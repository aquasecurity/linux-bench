---
controls:
version: "Red Hat Enterprise Linux 9 v2.0.0"
id: 1
description: "Initial Setup"
type: "master"
groups:
  - id: 1.1
    description: "Filesystem Configuration"
    checks:
      - id: 1.1.1
        description: "Disable unused filesystems"
        type: "skip"
        checks:
      - id: 1.1.1.1
        description: "Ensure cramfs kernel module is not available (Automated)"
        audit: |
          m="cramfs"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "cramfs_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "cramfs_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cramfs_disabled_ok:module_absent"
              set: true
            - flag: "cramfs_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable cramfs if present:
          # 1) Prevent loading
          echo "install cramfs /bin/false" > /etc/modprobe.d/cramfs.conf
          # 2) Deny-list it
          echo "blacklist cramfs" >> /etc/modprobe.d/cramfs.conf
          # 3) Unload if currently loaded
          modprobe -r cramfs 2>/dev/null || true

          # Note: If cramfs is not available on the system or is pre-compiled into the kernel,
          # no additional configuration is required.
        scored: true

      - id: 1.1.1.2
        description: "Ensure freevxfs kernel module is not available(Automated)"
        audit: |
          m="freevxfs"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "freevxfs_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "freevxfs_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "freevxfs_disabled_ok:module_absent"
              set: true
            - flag: "freevxfs_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable freevxfs if present:
          # 1) Prevent loading
          echo "install freevxfs /bin/false" > /etc/modprobe.d/freevxfs.conf
          # 2) Deny-list it
          echo "blacklist freevxfs" >> /etc/modprobe.d/freevxfs.conf
          # 3) Unload if currently loaded
          modprobe -r freevxfs 2>/dev/null || true

          # Note: If freevxfs is not available on the system or is pre-compiled into the kernel,
          # no additional configuration is required.
        scored: true

      - id: 1.1.1.3
        description: "Ensure hfs kernel module is not available(Automated)"
        audit: |
          m="hfs"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "hfs_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "hfs_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "hfs_disabled_ok:module_absent"
              set: true
            - flag: "hfs_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable hfs if present:
          # 1) Prevent loading
          echo "install hfs /bin/false" > /etc/modprobe.d/hfs.conf
          # 2) Deny-list it
          echo "blacklist hfs" >> /etc/modprobe.d/hfs.conf
          # 3) Unload if currently loaded
          modprobe -r hfs 2>/dev/null || true

          # Note: If hfs is not available on the system or is pre-compiled into the kernel,
          # no additional configuration is required.
        scored: true

      - id: 1.1.1.4
        description: "Ensure hfsplus kernel module is not available(Automated)"
        audit: |
          m="hfsplus"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "hfsplus_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "hfsplus_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "hfsplus_disabled_ok:module_absent"
              set: true
            - flag: "hfsplus_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable hfsplus if present:
          # 1) Prevent loading
          echo "install hfsplus /bin/false" > /etc/modprobe.d/hfsplus.conf
          # 2) Deny-list it
          echo "blacklist hfsplus" >> /etc/modprobe.d/hfsplus.conf
          # 3) Unload if currently loaded
          modprobe -r hfsplus 2>/dev/null || true

          # Note: If hfs is not available on the system or is pre-compiled into the kernel,
          # no additional configuration is required.
        scored: true

      - id: 1.1.1.5
        description: "Ensure jffs2 kernel module is not available(Automated)"
        audit: |
          m="jffs2"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "jffs2_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "jffs2_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "jffs2_disabled_ok:module_absent"
              set: true
            - flag: "jffs2_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable jffs2 if present:
          # 1) Prevent loading
          echo "install jffs2 /bin/false" > /etc/modprobe.d/jffs2.conf
          # 2) Deny-list it
          echo "blacklist jffs2" >> /etc/modprobe.d/jffs2.conf
          # 3) Unload if currently loaded
          modprobe -r jffs2 2>/dev/null || true

          # Note: If hfs is not available on the system or is pre-compiled into the kernel,
          # no additional configuration is required.
        scored: true

      - id: 1.1.1.6
        description: "Ensure squashfs kernel module is not available (Automated)"
        audit: |
          m="squashfs"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "squashfs_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "squashfs_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "squashfs_disabled_ok:module_absent"
              set: true
            - flag: "squashfs_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable squashfs if present:
          # 1) Prevent loading
          echo "install squashfs /bin/false" > /etc/modprobe.d/squashfs.conf
          # 2) Deny-list it
          echo "blacklist squashfs" >> /etc/modprobe.d/squashfs.conf
          # 3) Unload if currently loaded
          modprobe -r squashfs 2>/dev/null || true

          # Note: Disabling squashfs will break Snap packages which rely on squashfs.
        scored: true

      - id: 1.1.1.7
        description: "Ensure mounting of udf filesystems is disabled (Automated)"
        audit: |
          m="udf"

          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "udf_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe act?
          loadable="$(modprobe -n -v "$m" 2>/dev/null)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b")"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          # Deny-list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi

          # Pass case 2: present but blocked and not loaded -> emit a single verdict flag
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "udf_disabled_ok:present_but_blocked"
          fi
        tests:
          test_items:
            - flag: "udf_disabled_ok:module_absent"
              set: true
            - flag: "udf_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # WARNING: Microsoft Azure requires UDF. Do not disable on Azure hosts.
          # If acceptable for your environment, disable UDF:

          # 1) Prevent loading via install rule
          echo "install udf /bin/false" > /etc/modprobe.d/udf.conf

          # 2) Deny-list it
          echo "blacklist udf" >> /etc/modprobe.d/udf.conf

          # 3) Unload if currently loaded
          modprobe -r udf 2>/dev/null || true
        scored: true

      - id: 1.1.1.8
        description: "Ensure usb-storage kernel module is not available (Automated)"
        audit: |
          m="usb-storage"
          mn="${m//-/_}"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+(${m}|$mn)\s+not\s+found\b"; then
            echo "usb_storage_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          # If multiple lines, keep only the relevant ones
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b($m|$mn))\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present? (accept hyphen or underscore form)
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+(usb[-_]storage)\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded? (lsmod shows with underscore)
          if ! lsmod | grep -q "^$mn\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "usb_storage_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "usb_storage_disabled_ok:module_absent"
              set: true
            - flag: "usb_storage_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable usb-storage if present:
          # 1) Prevent loading
          echo "install usb-storage /bin/false" > /etc/modprobe.d/usb-storage.conf
          # 2) Deny-list it
          echo "blacklist usb-storage" >> /etc/modprobe.d/usb-storage.conf
          # 3) Unload if currently loaded (hyphen/underscore both accepted)
          modprobe -r usb-storage 2>/dev/null || true

          # Note: Disabling usb-storage will prevent use of USB mass storage devices.
          # If organizational policy permits controlled use, consider solutions like USBGuard.
        scored: true

      - id: 1.1.1.9
        description: "Ensure unused filesystems kernel modules are not available (Automated)"
        type: manual
        remediation: |
          IF - the module is available in the running kernel:

          Unload the filesystem kernel module from the kernel
          Create a file ending in .conf with install filesystem kernel modules /bin/false in the /etc/modprobe.d/ directory
          Create a file ending in .conf with deny list filesystem kernel modules in the /etc/modprobe.d/ directory
          WARNING: unloading, disabling or denylisting filesystem modules that are in use on the system maybe FATAL. It is extremely important to thoroughly review the filesystems returned by the audit before following the remediation procedure.

          Example of unloading the gfs2kernel module:

          # modprobe -r gfs2 2>/dev/null
          # rmmod gfs2 2>/dev/null
          Example of fully disabling the gfs2 kernel module:

          # printf '%s\n' "blacklist gfs2" "install gfs2 /bin/false" >> /etc/modprobe.d/gfs2.conf
          Note:

          Disabling a kernel module by modifying the command above for each unused filesystem kernel module
          The example gfs2 must be updated with the appropriate module name for the command or example script bellow to run correctly.
        scored: false

      - id: 1.1.2
        description: "Configure Filesystem Partitions"
        type: "skip"
        checks:
      - id: 1.1.2.1
        description: "Configure /tmp"
        type: "skip"
        checks:
      - id: 1.1.2.1.1
        description: "Ensure /tmp is a separate partition (Automated)"
        audit: |
          # Verify if /tmp has a mount entry
          if findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_partition_ok:mounted"
          else
            echo "tmp_partition_bad:not_mounted"
          fi

          # Check if systemd is managing /tmp mount properly
          systemd_status="$(systemctl is-enabled tmp.mount 2>/dev/null || true)"
          case "$systemd_status" in
            enabled|generated)
              echo "systemd_tmp_ok:enabled"
              ;;
            masked|disabled)
              echo "systemd_tmp_bad:disabled"
              ;;
            *)
              echo "systemd_tmp_unknown:check_required"
              ;;
          esac
        tests:
          test_items:
            - flag: "tmp_partition_ok:mounted"
              set: true
            - flag: "systemd_tmp_ok:enabled"
              set: true
        remediation: |
          # Ensure systemd can mount /tmp at boot
          systemctl unmask tmp.mount

          # Choose ONE approach that fits your environment and update /etc/fstab.

          # Option A: tmpfs (RAM-backed /tmp)
          # Add a line like the following to /etc/fstab, then mount:
          # tmpfs  /tmp  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0
          # mount -o remount /tmp || mount /tmp

          # Option B: dedicated disk/volume for /tmp
          # <device>  /tmp  <fstype>  defaults,nodev,nosuid,noexec  0  0
          # mount /tmp
        scored: true

      - id: 1.1.2.1.2
        description: "Ensure nodev option set on /tmp partition (Automated)"
        audit: |
          findmnt -kn /tmp | grep -v nodev
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit `/etc/fstab` so that the `/tmp` entry includes the `nodev` option.

          Example entry:
            <device>  /tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Then remount /tmp to apply the change:
            mount -o remount /tmp
        scored: true

      - id: 1.1.2.1.3
        description: "Ensure nosuid option set on /tmp partition (Automated)"
        audit: |
          findmnt -kn /tmp | grep -v nosuid
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit `/etc/fstab` to ensure the `/tmp` entry includes the `nosuid` option.

          Example:
            <device>  /tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/tmp`:
            mount -o remount /tmp
        scored: true

      - id: 1.1.2.1.4
        description: "Ensure noexec option set on /tmp partition (Automated)"
        audit: |
          findmnt -kn /tmp | grep -v noexec
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit `/etc/fstab` so the `/tmp` entry includes `noexec` in the mount options.

          Example:
            <device>  /tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change:
            mount -o remount /tmp
        scored: true

      - id: 1.1.2.2
        description: "Configure /dev/shm"
        type: "skip"
        checks:
      - id: 1.1.2.2.1
        description: "Ensure /dev/shm is a separate partition (Automated)"
        audit: |
          findmnt -kn /dev/shm
        tests:
          test_items:
            - flag: "/dev/shm"
              set: true
        remediation: |
          For specific configuration requirements of the /dev/shm mount for your environment, modify /etc/fstab.

          Example:

          tmpfs	/dev/shm	tmpfs     defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0
        scored: true

      - id: 1.1.2.2.2
        description: "Ensure nodev option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /dev/shm | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/dev/shm` entry includes the `nodev` option.

          Example entry:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Apply the change by remounting `/dev/shm`:
            mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.3
        description: "Ensure nosuid option set on /dev/shm partition (Automated)"
        audit: |
          # Is /dev/shm mounted?
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Check for nosuid in mount options
            if findmnt -kn /dev/shm | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include `nosuid` for `/dev/shm`.

          Example:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Apply the change:
            mount -o remount /dev/shm

          Note: Some distros mount `/dev/shm` outside `/etc/fstab`. If so, add the entry above
          to `/etc/fstab` or adjust the distribution-specific unit/config so `nosuid` is enforced.
        scored: true

      - id: 1.1.2.2.4
        description: "Ensure noexec option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /dev/shm | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/dev/shm` entry includes the `noexec` option.

          Example entry:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Apply the change by remounting `/dev/shm`:
            mount -o remount /dev/shm

          NOTE: It is recommended to use `tmpfs` as the filesystem type for `/dev/shm`,
          as it provides shared memory space used by applications.
        scored: true

      - id: 1.1.2.3
        description: "Configure /home"
        type: "skip"
        checks:
      - id: 1.1.2.3.1
        description: "Ensure separate partition exists for /home (Automated)"
        audit: |
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_mounted"
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "home_mounted"
              set: true
        remediation: |
          For new installations, during installation create a custom partition setup and specify a separate partition for /home.

          For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.
        scored: true

      - id: 1.1.2.3.2
        description: "Ensure nodev option set on /home partition (Automated)"
        audit: |
          # Check if /home is mounted
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /home | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "home_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/home` entry includes the `nodev` option.

          Example entry:
            <device>  /home  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/home`:
            mount -o remount /home
        scored: true

      - id: 1.1.2.3.3
        description: "Ensure nosuid option set on /home partition (Automated)"
        audit: |
          # Check if /home is mounted
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /home | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "home_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/home` entry includes the `nosuid` option.

          Example entry:
            <device>  /home  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/home`:
            mount -o remount /home
        scored: true

      - id: 1.1.2.4
        description: "Configure /var"
        type: "skip"
        checks:
      - id: 1.1.2.4.1
        description: "Ensure separate partition exists for /var (Automated)"
        audit: |
          # Check if /var is mounted on a separate partition
          if findmnt -kn /var >/dev/null 2>&1; then
            echo "var_partition_ok"
          else
            echo "var_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_partition_ok"
              set: true
        remediation: |
          For new installations, during setup create a dedicated partition for `/var`.
          For existing systems, create or attach a new volume, format it, and mount it as `/var`.
          Example steps:
            1. Create filesystem on the new device:
               mkfs -t ext4 /dev/<device>
            2. Mount temporarily and copy existing data:
               mount /dev/<device> /mnt
               rsync -avx /var/ /mnt/
               mv /var /var.backup
               umount /mnt
            3. Update `/etc/fstab` with the new entry:
               /dev/<device>  /var  ext4  defaults  0  2
            4. Mount the new partition:
               mount /var
            5. Verify:
               findmnt --kernel /var
          Once confirmed, you can remove `/var.backup` after ensuring successful migration.
        scored: true


      - id: 1.1.2.4.2
        description: "Ensure nodev option set on /var partition (Automated)"
        audit: |
          # Check if /var is mounted
          if findmnt -kn /var >/dev/null 2>&1; then
            echo "var_mounted"
            # Verify nodev is set
            if findmnt -kn /var | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
            - flag: "var_mounted"
              set: true
        remediation: |
          Edit `/etc/fstab` so that the `/var` entry includes the `nodev` option.

          Example entry:
            <device>  /var  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change:
            mount -o remount /var
        scored: true


      - id: 1.1.2.4.3
        description: "Ensure nosuid option set on /var partition (Automated)"
        audit: |
          # Check if /var is mounted
          if findmnt -kn /var >/dev/null 2>&1; then
            echo "var_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var` entry includes the `nosuid` option.

          Example entry:
            <device>  /var  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var`:
            mount -o remount /var
        scored: true

      - id: 1.1.2.5
        description: "Configure /var/tmp"
        type: "skip"
        checks:
      - id: 1.1.2.5.1
        description: "Ensure separate partition exists for /var/tmp (Automated)"
        audit: |
          # Check if /var/tmp is mounted on a separate partition
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_partition_ok"
          else
            echo "var_tmp_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_tmp_partition_ok"
              set: true
        remediation: |
          For new installations, create a dedicated partition for `/var/tmp` during setup.

          For existing systems:
            1. Create or attach a new volume or logical partition:
               mkfs -t ext4 /dev/<device>

            2. Mount temporarily and copy data:
               mount /dev/<device> /mnt
               rsync -avx /var/tmp/ /mnt/
               mv /var/tmp /var/tmp.backup
               umount /mnt

            3. Update `/etc/fstab` to mount the new partition:
               /dev/<device>  /var/tmp  ext4  defaults,nodev,nosuid,noexec,relatime  0  2

            4. Mount the new partition:
               mount /var/tmp

            5. Verify:
               findmnt --kernel /var/tmp

          After confirming successful migration, remove `/var/tmp.backup`.
        scored: true

      - id: 1.1.2.5.2
        description: "Ensure nodev option set on /var/tmp partition (Automated)"
        audit: |
          # Check if /var/tmp is mounted
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /var/tmp | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/tmp` entry includes the `nodev` option.

          Example entry:
            <device>  /var/tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/tmp`:
            mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.5.3
        description: "Ensure nosuid option set on /var/tmp partition (Automated)"
        audit: |
          # Check if /var/tmp is mounted
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var/tmp | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/tmp` entry includes the `nosuid` option.

          Example entry:
            <device>  /var/tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/tmp`:
            mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.5.4
        description: "Ensure noexec option set on /var/tmp partition (Automated)"
        audit: |
          # Check if /var/tmp is mounted
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /var/tmp | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "var_tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/tmp` entry includes the `noexec` option.

          Example entry:
            <device>  /var/tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/tmp`:
            mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.6
        description: "Configure /var/log"
        type: "skip"
        checks:
      - id: 1.1.2.6.1
        description: "Ensure separate partition exists for /var/log (Automated)"
        audit: |
          # Check if /var/log is mounted on a separate partition
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_partition_ok"
          else
            echo "var_log_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_log_partition_ok"
              set: true
        remediation: |
          For new installations, create a dedicated partition for `/var/log` during setup.

          For existing systems:
            1. Create or attach a new volume:
               mkfs -t ext4 /dev/<device>

            2. Mount temporarily and copy existing logs:
               mount /dev/<device> /mnt
               rsync -avx /var/log/ /mnt/
               mv /var/log /var/log.backup
               umount /mnt

            3. Update `/etc/fstab` with the new entry:
               /dev/<device>  /var/log  ext4  defaults,nodev,nosuid,noexec,relatime  0  2

            4. Mount the new partition:
               mount /var/log

            5. Verify the mount:
               findmnt --kernel /var/log

          Once confirmed, you may remove `/var/log.backup`.

          ⚠️ Note:
          Before performing changes on `/var/log`, it is recommended to switch the system
          to **emergency mode** (so auditd and other logging daemons are stopped) to avoid
          data loss or corruption during migration.
        scored: true


      - id: 1.1.2.6.2
        description: "Ensure nodev option set on /var/log partition (Automated)"
        audit: |
          # Check if /var/log is mounted
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /var/log | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log` entry includes the `nodev` option.

          Example entry:
            <device>  /var/log  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log`:
            mount -o remount /var/log
        scored: true

      - id: 1.1.2.6.3
        description: "Ensure nosuid option set on /var/log partition (Automated)"
        audit: |
          # Check if /var/log is mounted
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var/log | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log` entry includes the `nosuid` option.

          Example entry:
            <device>  /var/log  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log`:
            mount -o remount /var/log
        scored: true

      - id: 1.1.2.6.4
        description: "Ensure noexec option set on /var/log partition (Automated)"
        audit: |
          # Check if /var/log is mounted
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /var/log | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "var_log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log` entry includes the `noexec` option.

          Example entry:
            <device>  /var/log  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log`:
            mount -o remount /var/log
        scored: true


      - id: 1.1.2.7
        description: "Configure /var/log/audit"
        type: "skip"
        checks:
      - id: 1.1.2.7.1
        description: "Ensure separate partition exists for /var/log/audit (Automated)"
        audit: |
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_partition_ok"
          else
            echo "var_log_audit_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_partition_ok"
              set: true
        remediation: |
          For new installations, create a dedicated partition for `/var/log/audit` during setup.
          For existing systems:
            1. Create or attach a new volume or partition:
               mkfs -t ext4 /dev/<device>
            2. Mount temporarily and copy existing audit logs:
               mount /dev/<device> /mnt
               rsync -avx /var/log/audit/ /mnt/
               mv /var/log/audit /var/log/audit.backup
               umount /mnt
            3. Update `/etc/fstab` with the new entry:
               /dev/<device>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec,relatime  0  2
            4. Mount the new partition:
               mount /var/log/audit
            5. Verify the mount:
               findmnt --kernel /var/log/audit
          Once confirmed, you may remove `/var/log/audit.backup` after verifying data integrity.
          ⚠️ Note:
          To avoid audit service issues during migration, perform these steps in **single-user** or **emergency mode**
          so `auditd` is stopped and log data is not being written during the copy process.
        scored: true

      - id: 1.1.2.7.2
        description: "Ensure nodev option set on /var/log/audit partition (Automated)"
        audit: |
          # Check if /var/log/audit is mounted
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /var/log/audit | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_log_audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log/audit` entry includes the `nodev` option.

          Example entry:
            <device>  /var/log/audit  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log/audit`:
            mount -o remount /var/log/audit
        scored: true

      - id: 1.1.2.7.3
        description: "Ensure nosuid option set on /var/log/audit partition (Automated)"
        audit: |
          # Check if /var/log/audit is mounted
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var/log/audit | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_log_audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log/audit` entry includes the `nosuid` option.

          Example entry:
            <device>  /var/log/audit  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log/audit`:
            mount -o remount /var/log/audit
        scored: true

      - id: 1.1.2.7.4
        description: "Ensure noexec option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /var/log/audit | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "var_log_audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log/audit` entry includes the `noexec` option.

          Example entry:
            <device>  /var/log/audit  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log/audit`:
            mount -o remount /var/log/audit
        scored: true

  - id: 1.2
    description: "Package Management"
    checks:
      - id: 1.2.1
        description: "Configure Package Repositories"
        type: "skip"
        checks:
      - id: 1.2.1.1
        description: "Ensure GPG keys are configured (Manual)"
        type: manual
        remediation: |
          Update your package manager GPG keys in accordance with site policy.
        scored: false

      - id: 1.2.1.2
        description: "Ensure gpgcheck is globally activated (Automated)"
        audit: |
          # Verify [main] in /etc/dnf/dnf.conf enables gpgcheck (accept 1/true/yes)
          if awk -v RS='' '/^\[main\]/{print}' /etc/dnf/dnf.conf 2>/dev/null \
             | grep -Piq '^\s*gpgcheck\s*=\s*(1|true|yes)\b'; then
            echo "main_ok"
          else
            echo "main_bad"
          fi

          # In repo files, ensure there are NO invalid overrides (0, 2+, false, no)
          if find /etc/yum.repos.d -type f -name '*.repo' 2>/dev/null \
             | xargs -r grep -PHin --color=never -i -P '^\s*(?![#;])\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|false|no)\b' \
             >/dev/null; then
            echo "repos_bad"
          else
            echo "repos_ok"
          fi
        tests:
          test_items:
            - flag: "main_ok"
              set: true
            - flag: "repos_ok"
              set: true
        remediation: |
          Edit /etc/dnf/dnf.conf and set gpgcheck=1:

          Example

          # sed -i 's/^gpgcheck\s*=\s*.*/gpgcheck=1/' /etc/dnf/dnf.conf
          Edit any failing files in /etc/yum.repos.d/* and set all instances starting with gpgcheck to 1.

          Example:

          # find /etc/yum.repos.d/ -name "*.repo" -exec echo "Checking:" {} \; -exec sed -i 's/^gpgcheck\s*=\s*.*/gpgcheck=1/' {} \;
        scored: true

      - id: 1.2.1.3
        description: "Ensure repo_gpgcheck is globally activated (Manual)"
        audit: |
          grep ^repo_gpgcheck /etc/dnf/dnf.conf
        tests:
          test_items:
            - flag: "repo_gpgcheck"
              compare:
                op: eq
                value: 1
        remediation: |
          Edit /etc/dnf/dnf.conf and set repo_gpgcheck=1 in the [main] section.

          Example:

          [main]
          repo_gpgcheck=1
          Per repository configuration

          First check that the particular repository support GPG checking on the repodata.

          Edit any failing files in /etc/yum.repos.d/* and set all instances starting with repo_gpgcheck to 1.
        scored: false

      - id: 1.2.1.4
        description: "Ensure package manager repositories are configured (Manual)"
        audit: "dnf repolist"
        type: "manual"
        remediation: |
          Configure your package manager repositories according to site policy.
          Note: The preferred way to manage the contents of /etc/yum.repos.d/redhat.repo is
          via the use of subscription-manager repos
        scored: false
      - id: 1.2.2
        description: "Configure Package Updates"
        type: "skip"
        checks:
      - id: 1.2.2.1
        description: "Ensure updates, patches, and additional security software are installed (Manual)"
        audit: "dnf check-update"
        type: "manual"
        remediation: |
          Use your package manager to update all packages on the system according to site policy.

          The following command will install all available updates:

          # dnf update
          Once the update process is complete, verify if reboot is required to load changes.

          dnf needs-restarting -r
        scored: false

  - id: 1.3
    description: "Mandatory Access Control"
    checks:
      - id: 1.3.1
        description: "Configure SELinux"
        type: "skip"
        check:
      - id: 1.3.1.1
        description: "Ensure SELinux is installed (Automated)"
        audit: "rpm -q libselinux"
        tests:
          test_items:
            - flag: "package libselinux is not installed"
              set: false
        remediation: |
          Run the following command to install SELinux:

          # dnf install libselinux
        scored: true

      - id: 1.3.1.2
        description: "Ensure SELinux is not disabled in bootloader configuration (Automated)"
        audit: |
          grubby --info=ALL | grep -Po '(selinux|enforcing)=0\b'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to remove the selinux=0 and enforcing=0 parameters:

          grubby --update-kernel ALL --remove-args "selinux=0 enforcing=0"
          Run the following command to remove the selinux=0 and enforcing=0 parameters if they were created by the deprecated grub2-mkconfig command:

          # grep -Prsq -- '\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi && grub2-mkconfig -o "$(grep -Prl -- '\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi)"
        scored: true

      - id: 1.3.1.3
        description: "Ensure SELinux policy is configured (Automated)"
        audit: |
          # Verify SELINUXTYPE in configuration file
          if grep -Eq '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config; then
            echo "selinuxtype_config_ok"
          else
            echo "selinuxtype_config_bad"
          fi

          # Verify loaded policy in current runtime status
          if sestatus 2>/dev/null | grep -Eq 'Loaded policy name:\s+(targeted|mls)\b'; then
            echo "selinuxtype_runtime_ok"
          else
            echo "selinuxtype_runtime_bad"
          fi
        tests:
          test_items:
            - flag: "selinuxtype_config_ok"
              set: true
            - flag: "selinuxtype_runtime_ok"
              set: true
        remediation: |
          Edit `/etc/selinux/config` and ensure the `SELINUXTYPE` parameter is set to one of:
            SELINUXTYPE=targeted
            # or, if required by your site policy:
            SELINUXTYPE=mls

          Apply changes immediately (requires reboot or relabeling):
            touch /.autorelabel
            reboot
        scored: true

      - id: 1.3.1.4
        description: "Ensure the SELinux mode is not disabled (Automated)"
        audit: |
          # Runtime mode must be Enforcing or Permissive (not Disabled)
          if getenforce 2>/dev/null | grep -Eq '^(Enforcing|Permissive)\b'; then
            echo "selinux_runtime_ok"
          else
            echo "selinux_runtime_bad"
          fi

          # Configured mode must be enforcing or permissive (not disabled)
          if grep -Eq '^\s*SELINUX=(enforcing|permissive)\b' /etc/selinux/config; then
            echo "selinux_config_ok"
          else
            echo "selinux_config_bad"
          fi
        tests:
          test_items:
            - flag: "selinux_runtime_ok"
              set: true
            - flag: "selinux_config_ok"
              set: true
        remediation: |
          Set SELinux to Enforcing (recommended) or Permissive (not Disabled).

          Temporarily set runtime mode:
            # Enforcing
            setenforce 1
            # OR Permissive
            setenforce 0

          Persist across reboots by editing /etc/selinux/config:
            # For Enforcing
            SELINUX=enforcing
            # OR for Permissive
            SELINUX=permissive

          If SELinux had been Disabled previously, enable labeling then reboot:
            touch /.autorelabel
            reboot
        scored: true

      - id: 1.3.1.5
        description: "Ensure the SELinux mode is enforcing (Automated)"
        audit: |
          # Runtime enforcement check
          if getenforce 2>/dev/null | grep -Eq '^Enforcing$'; then
            echo "selinux_runtime_enforcing"
          else
            echo "selinux_runtime_not_enforcing"
          fi

          # Config file enforcement check
          if grep -Eq '^\s*SELINUX=enforcing\b' /etc/selinux/config; then
            echo "selinux_config_enforcing"
          else
            echo "selinux_config_not_enforcing"
          fi
        tests:
          test_items:
            - flag: "selinux_runtime_enforcing"
              set: true
            - flag: "selinux_config_enforcing"
              set: true
        remediation: |
          Set SELinux to enforcing mode both at runtime and persistently:

          Temporarily set runtime mode:
            setenforce 1

          Make the change persistent by editing `/etc/selinux/config`:
            SELINUX=enforcing

          Reboot the system to ensure full enforcement takes effect.
        scored: true

      - id: 1.3.1.6
        description: "Ensure no unconfined services exist (Manual)"
        audit: "ps -eZ | grep unconfined_service_t"
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Investigate any unconfined processes found during the audit action. They may need to
          have an existing security context assigned to them or a policy built for them.
        scored: false

      - id: 1.3.1.7
        description: "Ensure the MCS Translation Service (mcstrans) is not installed (Automated)"
        audit: "rpm -q mcstrans"
        tests:
          test_items:
            - flag: "package mcstrans is not installed"
              set: true
        remediation: |
          Run the following command to uninstall mcstrans:
            # dnf remove mcstrans
        scored: true

      - id: 1.3.1.8
        description: "Ensure SETroubleshoot is not installed (Automated)"
        audit: "rpm -q setroubleshoot"
        tests:
          test_items:
            - flag: "package setroubleshoot is not installed"
              set: true
        remediation: |
          Run the following command to uninstall setroubleshoot:
            # dnf remove setroubleshoot
        scored: true


  - id: 1.4
    description: "Configure Bootloader"
    checks:
      - id: 1.4.1
        description: "Ensure bootloader password is set (Automated)"
        audit: |
          {
             l_grub_password_file="$(find /boot -type f -name 'user.cfg' ! -empty)"
             if [ -f "$l_grub_password_file" ]; then
                awk -F. '/^\s*GRUB2_PASSWORD=\S+/ {print $1"."$2"."$3}' "$l_grub_password_file"
             fi
          }
        tests:
          test_items:
            - flag: "GRUB2_PASSWORD"
              compare:
                op: eq
                value: "grub.pbkdf2.sha512"
        remediation: |
          Create an encrypted password with grub2-setpassword:
            # grub2-setpassword
          Enter password: <password>
          Confirm password: <password>
        scored: true

      - id: 1.4.2
        description: "Ensure access to bootloader config is configured (Automated)"
        audit: |
          #!/usr/bin/env bash
          # PASS if all GRUB files are root:root and perms are:
          #   - UEFI (/boot/efi/EFI/*): 0700 or more restrictive
          #   - BIOS (/boot/grub2/*):   0600 or more restrictive
          ok=1
          while read -r f m u g; do
            case "$f" in /boot/efi/EFI/*) pm=$((8#0077));; *) pm=$((8#0177));; esac
            # Fail if permissions exceed policy or owner/group not root
            if (( (8#$m & pm) != 0 )) || [[ "$u" != root || "$g" != root ]]; then ok=0; fi
          done < <(find /boot \( -path '/boot/efi/EFI/*' -o -path '/boot/grub2/*' \) -type f \
                    \( -name 'grub*.cfg' -o -name 'grubenv' -o -name 'user.cfg' \) -print0 \
                    | xargs -0 stat -Lc '%n %a %U %G' 2>/dev/null || true)
          [ $ok -eq 1 ] && echo "bootloader_files_ok" || echo "bootloader_files_bad"
        tests:
          test_items:
            - flag: "bootloader_files_ok"
              set: true
        remediation: |
          # UEFI systems (ESP is typically vfat at /boot/efi):
          # Set restrictive file ownership/masks via mount options in /etc/fstab, then remount.
          # Example:
          #   <device>  /boot/efi  vfat  defaults,uid=0,gid=0,fmask=0077,umask=0027  0  0
          #   mount -o remount /boot/efi

          # BIOS systems (/boot/grub2/* on POSIX FS):
          [ -f /boot/grub2/grub.cfg ]  && chown root:root /boot/grub2/grub.cfg  && chmod 600 /boot/grub2/grub.cfg
          [ -f /boot/grub2/grubenv ]   && chown root:root /boot/grub2/grubenv   && chmod 600 /boot/grub2/grubenv
          [ -f /boot/grub2/user.cfg ]  && chown root:root /boot/grub2/user.cfg  && chmod 600 /boot/grub2/user.cfg
        scored: true


  - id: 1.5
    description: "Additional Process Hardening"
    checks:
      - id: 1.5.1.1
        description: "Ensure address space layout randomization (ASLR) is enabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require: kernel.randomize_va_space == 2 in running config AND set to 2 in a loaded sysctl file
          set -euo pipefail

          # 1) Running value
          rv="$(sysctl -n kernel.randomize_va_space 2>/dev/null || echo '')"
          if [ "$rv" = "2" ]; then
            echo "aslr_run_ok"
          else
            echo "aslr_run_bad"
          fi

          # 2) Persistent config (respect systemd-sysctl precedence when available)
          if [ -x /usr/lib/systemd/systemd-sysctl ]; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Any bad / overriding values?
          if grep -Piq '^\s*kernel\.randomize_va_space\s*=\s*(0|1|[3-9]|[1-9][0-9]+)\b' <<< "$conf"; then
            echo "aslr_files_bad"
          else
            # Must be explicitly set to 2 somewhere
            if grep -Piq '^\s*kernel\.randomize_va_space\s*=\s*2\b' <<< "$conf"; then
              echo "aslr_files_ok"
            else
              echo "aslr_files_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "aslr_run_ok"
              set: true
            - flag: "aslr_files_ok"
              set: true
        remediation: |
          # Persistently enforce ASLR = 2 and activate immediately:

          # 1) Persist (create or update a sysctl.d file)
          printf '%s\n' 'kernel.randomize_va_space = 2' > /etc/sysctl.d/60-kernel_sysctl.conf

          # 2) Remove/neutralize any conflicting settings (0/1/other) in earlier files if present

          # 3) Apply now
          sysctl -w kernel.randomize_va_space=2

          # 4) Load all persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true

      - id: 1.5.2
        description: "Ensure ptrace_scope is restricted (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require: kernel.yama.ptrace_scope == 1 in running config AND set to 1 in a loaded sysctl file
          set -euo pipefail

          # 1) Running value
          rv="$(sysctl -n kernel.yama.ptrace_scope 2>/dev/null || echo '')"
          if [ "$rv" = "1" ]; then
            echo "ptrace_run_ok"
          else
            echo "ptrace_run_bad"
          fi

          # 2) Persistent config (respect systemd-sysctl precedence when available)
          if [ -x /usr/lib/systemd/systemd-sysctl ]; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Any bad / overriding values?
          if grep -Piq '^\s*kernel\.yama\.ptrace_scope\s*=\s*(0|[2-9]|[1-9][0-9]+)\b' <<< "$conf"; then
            echo "ptrace_files_bad"
          else
            # Must be explicitly set to 1 somewhere
            if grep -Piq '^\s*kernel\.yama\.ptrace_scope\s*=\s*1\b' <<< "$conf"; then
              echo "ptrace_files_ok"
            else
              echo "ptrace_files_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "ptrace_run_ok"
              set: true
            - flag: "ptrace_files_ok"
              set: true
        remediation: |
          # Persistently enforce ptrace restriction and activate immediately:

          # 1) Persist (create or update a sysctl.d file)
          printf '%s\n' 'kernel.yama.ptrace_scope = 1' > /etc/sysctl.d/60-kernel_sysctl.conf

          # 2) Remove/neutralize any conflicting settings (0 or >1) in other files if present

          # 3) Apply now
          sysctl -w kernel.yama.ptrace_scope=1

          # 4) Load all persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


      - id: 1.5.3
        description: "Ensure core dump backtraces are disabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # PASS if effective systemd coredump setting ProcessSizeMax == 0
          set -euo pipefail

          get_effective_val() {
            if command -v systemd-analyze >/dev/null 2>&1; then
              # Use systemd's own merge/precedence
              /usr/bin/systemd-analyze cat-config /etc/systemd/coredump.conf 2>/dev/null \
                | awk '
                    BEGIN{sec=""}
                    /^\s*\[.*\]\s*$/{
                      gsub(/^\s*|\s*$/,""); sec=$0
                    }
                    /^\s*ProcessSizeMax\s*=/{
                      val=$0; gsub(/.*=/,"",val); gsub(/^\s+|\s+$/,"",val)
                      if (sec=="[Coredump]") eff=val
                    }
                    END{print eff}
                  ' || true
            else
              # Fallback: consider last assignment found in standard paths
              grep -Hnri --exclude-dir={.backup,.bak,.rpmsave,.rpmnew} \
                -E '^\s*ProcessSizeMax\s*=' /etc/systemd/coredump.conf /etc/systemd/coredump.conf.d/*.conf 2>/dev/null \
                | sort -V | awk -F= '{v=$2} END{gsub(/^\s+|\s+$/,"",v); print v}'
            fi
          }

          val="$(get_effective_val || true)"
          if [[ "$val" == "0" ]]; then
            echo "coredump_psm_ok"
          else
            echo "coredump_psm_bad"
          fi
        tests:
          test_items:
            - flag: "coredump_psm_ok"
              set: true
        remediation: |
          # Disable core dump backtraces by setting ProcessSizeMax=0 in the Coredump section.

          install -d -m 0755 /etc/systemd/coredump.conf.d
          cat > /etc/systemd/coredump.conf.d/60-coredump.conf <<'EOF'
          [Coredump]
          ProcessSizeMax=0
          EOF

          # Reload config (takes effect for new crashes)
          systemctl daemon-reload 2>/dev/null || true
        scored: true

      - id: 1.5.4
        description: "Ensure core dump storage is disabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # PASS if effective systemd coredump setting Storage == none
          set -euo pipefail

          get_effective_storage() {
            if command -v systemd-analyze >/dev/null 2>&1; then
              /usr/bin/systemd-analyze cat-config /etc/systemd/coredump.conf 2>/dev/null \
                | awk '
                    BEGIN{sec=""; eff=""}
                    /^\s*\[.*\]\s*$/{
                      s=$0; gsub(/^\s*|\s*$/,"",s); sec=s
                    }
                    /^\s*Storage\s*=/{
                      if (sec=="[Coredump]") {
                        v=$0; sub(/^[^=]*=/,"",v); gsub(/^\s+|\s+$/,"",v); eff=v
                      }
                    }
                    END{print eff}
                  ' || true
            else
              # Fallback: last assignment found across standard paths (best effort)
              grep -Hnri --exclude-dir={.backup,.bak,.rpmsave,.rpmnew} \
                -E '^\s*Storage\s*=' /etc/systemd/coredump.conf /etc/systemd/coredump.conf.d/*.conf 2>/dev/null \
                | sort -V | awk -F= '{v=$2} END{gsub(/^\s+|\s+$/,"",v); print v}'
            fi
          }

          val="$(get_effective_storage || true)"
          if [[ "$val" == "none" ]]; then
            echo "coredump_storage_ok"
          else
            echo "coredump_storage_bad"
          fi
        tests:
          test_items:
            - flag: "coredump_storage_ok"
              set: true
        remediation: |
          # Disable persistent core dump storage by setting Storage=none in the Coredump section.

          install -d -m 0755 /etc/systemd/coredump.conf.d
          cat > /etc/systemd/coredump.conf.d/60-coredump.conf <<'EOF'
          [Coredump]
          Storage=none
          EOF

          # Reload systemd configuration (affects new crashes)
          systemctl daemon-reload 2>/dev/null || true
        scored: true

  - id: 1.6
    description: "Configure system wide crypto policy"
    checks:
      - id: 1.6.1
        description: "Ensure system wide crypto policy is not set to legacy (Automated)"
        audit: |
          grep -Pi '^\h*LEGACY\b' /etc/crypto-policies/config
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change the system-wide crypto policy

          # update-crypto-policies --set <CRYPTO POLICY>
          Example:

          # update-crypto-policies --set DEFAULT
          Run the following to make the updated system-wide crypto policy active

          # update-crypto-policies
        scored: true

      - id: 1.6.2
        description: "Ensure system wide crypto policy is not set in sshd configuration (Automated)"
        audit: |
          grep -Pi '^\h*CRYPTO_POLICY\h*=' /etc/sysconfig/sshd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following commands:

          # sed -ri "s/^\s*(CRYPTO_POLICY\s*=.*)$/# \1/" /etc/sysconfig/sshd

          # systemctl reload sshd
        scored: true

      - id: 1.6.3
        description: "Ensure system wide crypto policy disables SHA1 hash and signature support (Automated)"
        audit: |
          #!/usr/bin/env bash
          pol_file="/etc/crypto-policies/state/CURRENT.pol"

          # If policy file missing, fail both checks
          if [ ! -f "$pol_file" ]; then
            echo "sha1_hashsign_bad"
            echo "sha1_certs_bad"
            exit 0
          fi

          # 1) First command: should return NOTHING (no SHA1 in hash/sign unless explicitly negated)
          out1="$(awk -F= '($1~/(hash|sign)/ && $2~/SHA1/ && $2!~/^\s*\-\s*([^#\n\r]+)?SHA1/){print}' "$pol_file" || true)"
          if [ -z "$out1" ]; then
            echo "sha1_hashsign_ok"
          else
            echo "sha1_hashsign_bad"
          fi

          # 2) Second command: must contain "sha1_in_certs = 0"
          out2="$(grep -Psi -- '^\h*sha1_in_certs\h*=\h*0\b' "$pol_file" || true)"
          if [ -n "$out2" ]; then
            echo "sha1_certs_ok"
          else
            echo "sha1_certs_bad"
          fi
        tests:
          test_items:
            - flag: "sha1_hashsign_ok"
              set: true
            - flag: "sha1_certs_ok"
              set: true
        remediation: |
          install -d -m 0755 /etc/crypto-policies/policies/modules
          cat > /etc/crypto-policies/policies/modules/NO-SHA1.pmod <<'EOF'
          # Remove SHA1 hash and signature support; forbid SHA1 in certificates
          hash = -SHA1
          sign = -*-SHA1
          sha1_in_certs = 0
          EOF

          # Apply alongside your active policy (replace DEFAULT if your base policy differs)
          update-crypto-policies --set DEFAULT:NO-SHA1

          # Reboot so running services/applications adopt the new crypto settings
          reboot
        scored: true

      - id: 1.6.4
        description: "Ensure system wide crypto policy disables macs less than 128 bits (Automated)"
        audit: |
          grep -Pi -- '^\h*mac\h*=\h*([^#\n\r]+)?-64\b' /etc/crypto-policies/state/CURRENT.pol
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Note:

          The commands below are written for the included DEFAULT system-wide crypto policy. If another policy is in use and follows local site policy, replace DEFAULT with the name of your system-wide crypto policy.
          Multiple subpolicies may be assigned to a policy as a colon separated list. e.g. DEFAULT:NO-SHA1:NO-SSHCBC
          Subpolicies:
          Not included in the update-crypto-policies --set command will not be applied to the system wide crypto policy.
          must exist before they can be applied to the system wide crypto policy.
          .pmod file filenames must be in all upper case, upper case, e.g. NO-WEAKMAC.pmod, or they will not be read by the update-crypto-policies --set command.
          Create or edit a file in /etc/crypto-policies/policies/modules/ ending in .pmod and add or modify one of the following lines:

          mac = -*-64* # Disables weak macs
          Run the following command to update the system-wide cryptographic policy

          # update-crypto-policies --set <CRYPTO_POLICY>:<CRYPTO_SUBPOLICY1>:<CRYPTO_SUBPOLICY2>:<CRYPTO_SUBPOLICY3>
          Run the following command to reboot the system to make your cryptographic settings effective for already running services and applications:
          # reboot
        scored: true

      - id: 1.6.5
        description: "Ensure system wide crypto policy disables CBC for SSH (Automated)"
        audit: |
          {
             l_output="" l_output2=""
             if grep -Piq -- '^\h*cipher\h*=\h*([^#\n\r]+)?-CBC\b' /etc/crypto-policies/state/CURRENT.pol; then
                if grep -Piq -- '^\h*cipher@(lib|open)ssh(-server|-client)?\h*=\h*' /etc/crypto-policies/state/CURRENT.pol; then
                   if ! grep -Piq -- '^\h*cipher@(lib|open)ssh(-server|-client)?\h*=\h*([^#\n\r]+)?-CBC\b' /etc/crypto-policies/state/CURRENT.pol; then
                      l_output="$l_output\n - Cipher Block Chaining (CBC) is disabled for SSH"
                   else
                      l_output2="$l_output2\n - Cipher Block Chaining (CBC) is enabled for SSH"
                   fi
                else
                   l_output2="$l_output2\n - Cipher Block Chaining (CBC) is enabled for SSH"
                fi
             else
                l_output=" - Cipher Block Chaining (CBC) is disabled"
             fi
             if [ -z "$l_output2" ]; then # Provide output from checks
                echo -e "\n- Audit Result:\n  ** PASS **\n$l_output\n"
             else
                echo -e "\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n"
                [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          # Create a subpolicy to disable CBC mode ciphers for SSH
          install -d -m 0755 /etc/crypto-policies/policies/modules
          cat > /etc/crypto-policies/policies/modules/NO-SSHCBC.pmod <<'EOF'
          # Disable all CBC mode ciphers for SSH (libssh and OpenSSH)
          cipher@SSH = -*-CBC
          EOF

          # Apply alongside your active policy (replace DEFAULT if your base policy differs)
          # You can combine with other subpolicies, e.g., :NO-SHA1:NO-WEAKMAC:NO-SSHCBC
          update-crypto-policies --set DEFAULT:NO-SSHCBC

          # Reboot so running services/applications adopt the new crypto settings
          reboot
        scored: true

      - id: 1.6.6
        description: "Ensure system wide crypto policy disables chacha20-poly1305 for SSH (Manual)"
        audit: |
          {
             l_output="" l_output2=""
             if grep -Piq -- '^\h*cipher\h*=\h*([^#\n\r]+)?-CBC\b' /etc/crypto-policies/state/CURRENT.pol; then
                if grep -Piq -- '^\h*cipher@(lib|open)ssh(-server|-client)?\h*=\h*' /etc/crypto-policies/state/CURRENT.pol; then
                   if ! grep -Piq -- '^\h*cipher@(lib|open)ssh(-server|-client)?\h*=\h*([^#\n\r]+)?\bchacha20-poly1305\b' /etc/crypto-policies/state/CURRENT.pol; then
                      l_output="$l_output\n - chacha20-poly1305 is disabled for SSH"
                   else
                      l_output2="$l_output2\n - chacha20-poly1305 is enabled for SSH"
                   fi
                else
                   l_output2="$l_output2\n - chacha20-poly1305 is enabled for SSH"
                fi
             else
                l_output=" - chacha20-poly1305 is disabled"
             fi
             if [ -z "$l_output2" ]; then # Provide output from checks
                echo -e "\n- Audit Result:\n  ** PASS **\n$l_output\n"
             else
                echo -e "\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n"
                [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          # Create a subpolicy to disable chacha20-poly1305 for SSH
          install -d -m 0755 /etc/crypto-policies/policies/modules
          cat > /etc/crypto-policies/policies/modules/NO-SSHCHACHA20.pmod <<'EOF'
          # Disable the chacha20-poly1305 cipher for SSH (libssh and OpenSSH)
          cipher@SSH = -CHACHA20-POLY1305
          EOF

          # Apply alongside your active policy (replace DEFAULT if your base policy differs)
          # You can combine with other subpolicies, e.g., :NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20
          update-crypto-policies --set DEFAULT:NO-SSHCHACHA20

          # Reboot so running services/applications adopt the new crypto settings
          reboot
        scored: true

      - id: 1.6.7
        description: "Ensure system wide crypto policy disables EtM for SSH (Manual)"
        audit: |
          pol_file="/etc/crypto-policies/state/CURRENT.pol"

          # If policy file missing, fail both checks
          if [ ! -f "$pol_file" ]; then
            echo "ssh_etm_offending_bad"
            echo "ssh_etm_disable_line_bad"
            exit 0
          fi

          out1="$(grep -Psi -- '^\h*etm(@(lib|open)?ssh(-server|-client)?)?\h*=\h*(?!DISABLE_ETM\b)\H+' "$pol_file" || true)"
          if [ -z "$out1" ]; then
            echo "ssh_etm_offending_ok"     # nothing returned => OK
          else
            echo "ssh_etm_offending_bad"    # something returned => BAD
          fi

          out2="$(grep -Psi -- '^\h*etm(@(lib|open)?ssh(-server|-client)?)?\h*=\h*DISABLE_ETM\b' "$pol_file" || true)"
          if [ -n "$out2" ]; then
            echo "ssh_etm_disable_line_ok"  # explicit disable present => OK
          else
            echo "ssh_etm_disable_line_bad" # no explicit disable => BAD
          fi
        tests:
          test_items:
            - flag: "ssh_etm_offending_ok"
              set: true
            - flag: "ssh_etm_disable_line_ok"
              set: true
        remediation: |
          # Create a subpolicy to disable Encrypt-then-MAC (EtM) for SSH (libssh and OpenSSH)
          install -d -m 0755 /etc/crypto-policies/policies/modules
          cat > /etc/crypto-policies/policies/modules/NO-SSHETM.pmod <<'EOF'
          # Disable EtM for SSH (libssh and OpenSSH)
          etm@SSH = DISABLE_ETM
          EOF

          # Apply alongside your active policy (replace DEFAULT if your base policy differs)
          # You can combine with other subpolicies, e.g., :NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20:NO-SSHETM
          update-crypto-policies --set DEFAULT:NO-SSHETM

          # Reboot so running services/applications adopt the new crypto settings
          reboot
        scored: true


  - id: 1.7
    description: "Configure Command Line Warning Banners"
    checks:
      - id: 1.7.1
        description: "Ensure message of the day (MOTD) is configured properly (Automated)"
        audit: |
          os_id="$(grep -E '^ID=' /etc/os-release 2>/dev/null | cut -d= -f2 | tr -d '"' || true)"
          offending=""
          mapfile -t files < <(
            { [ -f /etc/motd ] && printf '%s\n' /etc/motd; } || true
            [ -d /etc/motd.d ] && find /etc/motd.d -type f -maxdepth 1 2>/dev/null || true
          )

          if [ "${#files[@]}" -eq 0 ]; then
            # No MOTD files present; treat as OK but note for human review if needed
            echo "motd_sysinfo_ok"
            exit 0
          fi

          pattern="(\\\v|\\\r|\\\m|\\\s"
          [ -n "$os_id" ] && pattern="$pattern|\b$os_id\b"
          pattern="$pattern)"

          for f in "${files[@]}"; do
            # Skip unreadable files gracefully
            [ -r "$f" ] || continue
            if grep -Psqi -- "$pattern" -- "$f"; then
              offending="yes"
              printf 'Offending MOTD file contains system info: %s\n' "$f" 1>&2
            fi
          done

          if [ -z "${offending:-}" ]; then
            echo "motd_sysinfo_ok"     # nothing returned by the grep checks => OK
          else
            echo "motd_sysinfo_bad"    # at least one offending file => BAD
          fi
        tests:
          test_items:
            - flag: "motd_sysinfo_ok"
              set: true
        remediation: |
          # Edit MOTD files to remove system information and align with site policy.
          # Remove any of the following tokens or OS references from /etc/motd and /etc/motd.d/*:
          #   \v  \r  \m  \s  and OS name from /etc/os-release (ID)
          #
          # Example helper (prints files needing edits):
          os_id="$(grep -E '^ID=' /etc/os-release 2>/dev/null | cut -d= -f2 | tr -d '"' || true)"
          pattern="(\\\v|\\\r|\\\m|\\\s"
          [ -n "$os_id" ] && pattern="$pattern|\b$os_id\b"
          pattern="$pattern)"
          for f in /etc/motd /etc/motd.d/*; do
            [ -f "$f" ] || continue
            if grep -Psqi -- "$pattern" -- "$f"; then
              echo "Please edit and remove system info from: $f"
            fi
          done

          # If your environment does not use MOTD at all, you may remove it:
          # rm -f /etc/motd
        scored: true


      - id: 1.7.2
        description: "Ensure local login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/issue file with the appropriate contents according to your site policy, remove any instances of \m , \r , \s , \v or references to the OS platform

          Example:

          # echo "Authorized users only. All activity may be monitored and reported." > /etc/issue
        scored: true

      - id: 1.7.3
        description: "Ensure remote login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue.net
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/issue.net file with the appropriate contents according to your site policy, remove any instances of \m , \r , \s , \v or references to the OS platform

          Example:

          # echo "Authorized users only. All activity may be monitored and reported." > /etc/issue.net
        scored: true


      - id: 1.7.4
        description: "Ensure access to /etc/motd is configured (Automated)"
        audit: |
          if [ -e /etc/motd ]; then
            perms=$(stat -Lc '%a' /etc/motd)
            owner=$(stat -Lc '%u' /etc/motd)
            group=$(stat -Lc '%g' /etc/motd)
            if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "motd_access_ok"
            else
              echo "motd_access_bad"
            fi
          else
            echo "motd_not_exist"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "motd_access_ok"
              set: true
            - flag: "motd_not_exist"
              set: true
        remediation: |
          # If /etc/motd exists, set owner and permissions
          if [ -e /etc/motd ]; then
            chown root:root /etc/motd
            chmod u-x,go-wx /etc/motd
          fi

          # Alternatively, remove /etc/motd if not required
          # rm /etc/motd
        scored: true

      - id: 1.7.5
        description: "Ensure access to /etc/issue is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue)
          owner=$(stat -Lc '%u' /etc/issue)
          group=$(stat -Lc '%g' /etc/issue)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_access_ok"
          else
            echo "issue_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue
          chown root:root /etc/issue
          chmod u-x,go-wx /etc/issue
        scored: true

      - id: 1.7.6
        description: "Ensure access to /etc/issue.net is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue.net)
          owner=$(stat -Lc '%u' /etc/issue.net)
          group=$(stat -Lc '%g' /etc/issue.net)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_net_access_ok"
          else
            echo "issue_net_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_net_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue.net
          chown root:root /etc/issue.net
          chmod u-x,go-wx /etc/issue.net
        scored: true

  - id: 1.8
    description: "GNOME Display Manager"
    checks:
      - id: 1.8.1
        description: "Ensure GNOME Display Manager is removed (Automated)"
        audit: "rpm -q gdm"
        tests:
          test_items:
            - flag: "package gdm is not installed"
              set: true
        remediation: |
          Run the following command to remove the gdm package
            # dnf remove gdm
        scored: true

      - id: 1.8.2
        description: "Ensure GDM login banner is configured (Automated)"
        audit: |
          #!/bin/sh
          if rpm -q gdm >/dev/null 2>&1; then
            if grep -Pirqs '^[[:space:]]*\[org/gnome/login-screen\]' /etc/dconf/db/*.d \
               && grep -Pirqs '^[[:space:]]*banner-message-enable[[:space:]]*=[[:space:]]*true\b' /etc/dconf/db/*.d \
               && grep -Pirqs '^[[:space:]]*banner-message-text[[:space:]]*=[[:space:]]*.+\S' /etc/dconf/db/*.d; then
              echo "gdm_banner_ok"
            else
              echo "gdm_banner_bad"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          test_items:
            - bin_op: "or"
              items:
                - flag: "gdm_banner_ok"
                  set: true
                - flag: "not_applicable"
                  set: true
        remediation: |
          If GDM is installed, ensure the banner is enabled and has text via dconf:

            # Choose a profile name (e.g., gdm)
            prof="gdm"
            msg="Authorized uses only. All activity may be monitored and reported."

            # Ensure dconf profile and directory exist
            [ -f "/etc/dconf/profile/$prof" ] || \
              printf "user-db:user\nsystem-db:%s\nfile-db:/usr/share/%s/greeter-dconf-defaults\n" "$prof" "$prof" > "/etc/dconf/profile/$prof"
            [ -d "/etc/dconf/db/$prof.d" ] || mkdir -p "/etc/dconf/db/$prof.d"

            # Configure banner keys
            keyfile="/etc/dconf/db/$prof.d/01-banner-message"
            grep -q '^\s*\[org/gnome/login-screen\]' "$keyfile" 2>/dev/null || echo "[org/gnome/login-screen]" >> "$keyfile"
            sed -ri '/^\s*banner-message-enable\s*=/d' "$keyfile" 2>/dev/null || true
            sed -ri '/^\s*banner-message-text\s*=/d' "$keyfile" 2>/dev/null || true
            echo "banner-message-enable=true" >> "$keyfile"
            printf "banner-message-text='%s'\n" "$msg" >> "$keyfile"

            # Apply settings
            dconf update

          If GDM is not used on this system, this control is Not Applicable.
        scored: true

      - id: 1.8.3
        description: "Ensure GDM disable-user-list option is enabled (Automated)"
        audit: |
          # If GDM isn't installed, this control is Not Applicable
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Require the key to be set to true under any dconf keyfile for the login screen
            if grep -Pirqs '^\s*\[org/gnome/login-screen\]' /etc/dconf/db/*.d \
               && grep -Pirqs '^\s*disable-user-list\s*=\s*true\b' /etc/dconf/db/*.d; then
              echo "gdm_disable_user_list_ok"
            else
              echo "gdm_disable_user_list_bad"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_disable_user_list_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, enable the “disable-user-list” option via system-wide dconf:

            prof="gdm"
            [ -f "/etc/dconf/profile/$prof" ] || \
              printf "user-db:user\nsystem-db:%s\nfile-db:/usr/share/%s/greeter-dconf-defaults\n" "$prof" "$prof" > "/etc/dconf/profile/$prof"
            [ -d "/etc/dconf/db/$prof.d" ] || mkdir -p "/etc/dconf/db/$prof.d"

            keyfile="/etc/dconf/db/$prof.d/00-login-screen"
            grep -q '^\s*\[org/gnome/login-screen\]' "$keyfile" 2>/dev/null || echo "[org/gnome/login-screen]" >> "$keyfile"
            sed -ri '/^\s*disable-user-list\s*=/d' "$keyfile" 2>/dev/null || true
            echo "disable-user-list=true" >> "$keyfile"

            dconf update

          If GNOME Display Manager is not used on this system, this control is Not Applicable.
        scored: true

      - id: 1.8.4
        description: "Ensure GDM screen locks when the user is idle (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            if grep -RPsq '^\s*idle-delay\s*=\s*uint32\s*(9[0-9]{2}|[1-8][0-9]{2}|[1-9][0-9]|[1-9])\b' /etc/dconf/db/*/*.d 2>/dev/null \
              && grep -RPsq '^\s*lock-delay\s*=\s*uint32\s*([0-5])\b' /etc/dconf/db/*/*.d 2>/dev/null; then
              echo "screenlock_ok"
            else
              echo "screenlock_bad"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "screenlock_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, configure automatic lock on idle:

            prof="local"
            mkdir -p /etc/dconf/db/${prof}.d
            cat > /etc/dconf/db/${prof}.d/00-screensaver << EOF
            [org/gnome/desktop/session]
            idle-delay=uint32 900

            [org/gnome/desktop/screensaver]
            lock-delay=uint32 5
            EOF

            echo -e "user-db:user\nsystem-db:${prof}" > /etc/dconf/profile/${prof}
            dconf update

          Users must log out and back in for settings to apply.
        scored: true

      - id: 1.8.5
        description: "Ensure GDM screen locks cannot be overridden (Automated)"
        audit: |
          # Skip check if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Verify locks exist for idle-delay and lock-delay in any dconf db locks directory
            if grep -Rqs '/org/gnome/desktop/session/idle-delay' /etc/dconf/db/*/locks 2>/dev/null \
              && grep -Rqs '/org/gnome/desktop/screensaver/lock-delay' /etc/dconf/db/*/locks 2>/dev/null; then
              echo "gdm_locks_ok"
            else
              echo "gdm_locks_missing"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_locks_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, ensure screen lock settings cannot be overridden:

            # Determine your dconf profile (example uses 'local')
            prof="local"
            lockdir="/etc/dconf/db/${prof}.d/locks"
            mkdir -p "$lockdir"

            cat > "${lockdir}/00-screensaver-locks" << 'EOF'
            # Lock desktop screensaver idle and lock delay settings
            /org/gnome/desktop/session/idle-delay
            /org/gnome/desktop/screensaver/lock-delay
            EOF

            # Apply changes
            dconf update

          Users must log out and back in for settings to apply.
          If GNOME Display Manager is not used, this recommendation is Not Applicable.
        scored: true

      - id: 1.8.6
        description: "Ensure GDM automatic mounting of removable media is disabled (Automated)"
        audit: |
          # If GNOME Display Manager isn't installed, mark Not Applicable
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Both settings must be set to false in any system dconf db
            if grep -Rqs '^\s*automount\s*=\s*false\b' /etc/dconf/db/*.d 2>/dev/null \
               && grep -Rqs '^\s*automount-open\s*=\s*false\b' /etc/dconf/db/*.d 2>/dev/null; then
              echo "gdm_automount_disabled"
            else
              echo "gdm_automount_enabled"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_automount_disabled"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, set these dconf keys system-wide (example uses profile 'local'):
            prof="local"
            kfile="/etc/dconf/db/${prof}.d/00-media-automount"
            mkdir -p "$(dirname "$kfile")"
            {
              echo '[org/gnome/desktop/media-handling]'
              echo 'automount=false'
              echo 'automount-open=false'
            } > "$kfile"
            dconf update
          Users must log out and back in for settings to apply. If GNOME is not used, this control is Not Applicable.
        scored: true

      - id: 1.8.7
        description: "Ensure GDM disabling automatic mounting of removable media is not overridden (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Both keys must be locked in any system dconf db "locks" file
            if grep -Rqs '^\s*/org/gnome/desktop/media-handling/automount\s*$' /etc/dconf/db/*/locks 2>/dev/null \
               && grep -Rqs '^\s*/org/gnome/desktop/media-handling/automount-open\s*$' /etc/dconf/db/*/locks 2>/dev/null; then
              echo "gdm_automount_locked"
            else
              echo "gdm_automount_not_locked"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_automount_locked"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Replace 'local' with your chosen dconf profile name if needed
          prof="local"
          lockdir="/etc/dconf/db/${prof}.d/locks"
          mkdir -p "$lockdir"
          {
            echo "# Lock automount settings"
            echo "/org/gnome/desktop/media-handling/automount"
            echo "/org/gnome/desktop/media-handling/automount-open"
          } > "${lockdir}/00-media-automount"
          dconf update
          # Users must log out/in for settings to take effect.
        scored: true

      - id: 1.8.8
        description: "Ensure GDM autorun-never is enabled (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # autorun-never must be set to true in any system dconf db keyfile
            if grep -Rqs '^\s*autorun-never\s*=\s*true\b' /etc/dconf/db/*.d 2>/dev/null; then
              echo "gdm_autorun_never_true"
            else
              echo "gdm_autorun_never_false"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_autorun_never_true"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Choose/confirm your dconf profile name (use 'local' or the one already in use)
          prof="local"
          keyfile="/etc/dconf/db/${prof}.d/00-media-autorun"
          mkdir -p "/etc/dconf/db/${prof}.d"

          # Ensure the section exists and autorun-never=true is set
          if ! grep -Pq '^\s*\[org/gnome/desktop/media-handling\]\s*$' "$keyfile" 2>/dev/null; then
            echo "[org/gnome/desktop/media-handling]" >> "$keyfile"
          fi
          if grep -Pq '^\s*autorun-never\s*=' "$keyfile" 2>/dev/null; then
            sed -ri 's/^\s*(autorun-never)\s*=.*/\1=true/' "$keyfile"
          else
            echo "autorun-never=true" >> "$keyfile"
          fi

          # Ensure a profile file points at this DB
          if ! grep -Pq "^\s*system-db:${prof}\b" /etc/dconf/profile/* 2>/dev/null; then
            printf "user-db:user\nsystem-db:%s\n" "$prof" >> /etc/dconf/profile/user
          fi

          # Apply
          dconf update
          # Users must log out/in for settings to take effect.
        scored: true

      - id: 1.8.9
        description: "Ensure GDM autorun-never is not overridden (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Pass when the autorun-never key is locked in any system dconf profile
            if grep -Rqs '^\s*/org/gnome/desktop/media-handling/autorun-never\s*$' /etc/dconf/db/*/locks 2>/dev/null; then
              echo "autorun_never_locked"
            else
              echo "autorun_never_not_locked"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "autorun_never_locked"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Find the dconf profile that defines autorun-never (from 1.8.8), default to 'local'
          prof="$(grep -Prsl '^\s*autorun-never\s*=' /etc/dconf/db/*.d 2>/dev/null | awk -F/ '{split($(NF-1),a,".");print a[1]}' | head -n1)"
          [ -n "$prof" ] || prof="local"

          # Ensure profile stanza exists
          [ -f /etc/dconf/profile/user ] || printf "user-db:user\nsystem-db:%s\n" "$prof" > /etc/dconf/profile/user
          grep -Pq "^\s*system-db:${prof}\b" /etc/dconf/profile/* || printf "system-db:%s\n" "$prof" >> /etc/dconf/profile/user

          # Lock the key
          mkdir -p "/etc/dconf/db/${prof}.d/locks"
          lockfile="/etc/dconf/db/${prof}.d/locks/00-media-autorun"
          grep -Pq '^\s*/org/gnome/desktop/media-handling/autorun-never\s*$' "$lockfile" 2>/dev/null || \
            echo "/org/gnome/desktop/media-handling/autorun-never" >> "$lockfile"

          # Apply changes (users must log out/in)
          dconf update
        scored: true

      - id: 1.8.10
        description: "Ensure XDCMP is not enabled (Automated)"
        audit: |
          grep -Eis '^\s*Enable\s*=\s*true' /etc/gdm/custom.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the file /etc/gdm/custom.conf and remove the line:
            Enable=true
        scored: true


  - id: 2
    description: "Services"
  - id: 2.1
    description: "Configure Server Service"
    checks:
      - id: 2.1.1
        description: "Ensure autofs services are not in use (Automated)"
        audit: |
          if ! rpm -q autofs >/dev/null 2>&1; then
            echo "autofs_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled autofs.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active autofs.service 2>/dev/null | grep -qx '^active'; then
            echo "autofs_enabled_active_bad"
          else
            echo "autofs_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "autofs_pkg_absent"
              set: true
            - flag: "autofs_disabled_or_inactive_ok"
        remediation: |
          # Preferred: remove autofs entirely if not required
          systemctl stop autofs.service 2>/dev/null || true
          dnf -y remove autofs || true

          # If autofs is required as a dependency, stop and mask the service instead:
          # systemctl stop autofs.service
          # systemctl mask autofs.service
        scored: true

      - id: 2.1.2
        description: "Ensure avahi daemon services are not in use (Automated)"
        audit: |
          if ! rpm -q avahi >/dev/null 2>&1; then
            echo "avahi_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled avahi-daemon.socket avahi-daemon.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active avahi-daemon.socket avahi-daemon.service 2>/dev/null | grep -qx '^active'; then
            echo "avahi_enabled_active_bad"
          else
            echo "avahi_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "avahi_pkg_absent"
              set: true
            - flag: "avahi_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop avahi-daemon.socket and avahi-daemon.service, and remove the avahi package:

          # systemctl stop avahi-daemon.socket avahi-daemon.service
          # dnf remove avahi
          - OR -

          - IF - the avahi package is required as a dependency:

          Run the following commands to stop and mask the avahi-daemon.socket and avahi-daemon.service:

          # systemctl stop avahi-daemon.socket avahi-daemon.service
          # systemctl mask avahi-daemon.socket avahi-daemon.service
        scored: true

      - id: 2.1.3
        description: "Ensure dhcp server services are not in use (Automated)"
        audit: |
          if ! rpm -q dhcp-server >/dev/null 2>&1; then
            echo "dhcp-server_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled dhcpd.service dhcpd6.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active dhcpd.service dhcpd6.service 2>/dev/null | grep -qx '^active'; then
            echo "dhcp-server_enabled_active_bad"
          else
            echo "dhcp-server_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "dhcp-server_pkg_absent"
              set: true
            - flag: "dhcp-server_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop dhcpd.service and dhcpd6.service and remove dhcp-server package:

          # systemctl stop dhcpd.service dhcpd6.service
          # dnf remove dhcp-server
          - OR -

          - IF - the dhcp-server package is required as a dependency:

          Run the following commands to stop and mask dhcpd.service and dhcpd6.service:

          # systemctl stop dhcpd.service dhcpd6.service
          # systemctl mask dhcpd.service dhcpd6.service
        scored: true

      - id: 2.1.4
        description: "Ensure dns server services are not in use (Automated)"
        audit: |
          if ! rpm -q bind >/dev/null 2>&1; then
            echo "dns_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled named.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active named.service 2>/dev/null | grep -qx '^active'; then
            echo "dns_enabled_active_bad"
          else
            echo "dns_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "dns_pkg_absent"
              set: true
            - flag: "dns_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop named.service and remove bind package:

          # systemctl stop named.service
          # dnf remove bind
          - OR -

          - IF - the bind package is required as a dependency:

          Run the following commands to stop and mask named.service:

          # systemctl stop named.service
          # systemctl mask named.service
        scored: true

      - id: 2.1.5
        description: "Ensure dnsmasq services are not in use (Automated)"
        audit: |
          if ! rpm -q dnsmasq >/dev/null 2>&1; then
            echo "dnsmasq_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled dnsmasq.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active dnsmasq.service 2>/dev/null | grep -qx '^active'; then
            echo "dnsmasq_enabled_active_bad"
          else
            echo "dnsmasq_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "dnsmasq_pkg_absent"
              set: true
            - flag: "dnsmasq_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop dnsmasq.service and remove dnsmasq package:

          # systemctl stop dnsmasq.service
          # dnf remove dnsmasq
          - OR -

          - IF - the dnsmasq package is required as a dependency:

          Run the following commands to stop and mask the dnsmasq.service:

          # systemctl stop dnsmasq.service
          # systemctl mask dnsmasq.service
        scored: true

      - id: 2.1.6
        description: "Ensure samba file server services are not in use (Automated)"
        audit: |
          if ! rpm -q samba >/dev/null 2>&1; then
            echo "samba_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled smb.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active smb.service 2>/dev/null | grep -qx '^active'; then
            echo "samba_enabled_active_bad"
          else
            echo "samba_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "samba_pkg_absent"
              set: true
            - flag: "samba_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop samba.service and remove samba package:

          # systemctl stop samba.service
          # dnf remove samba
          - OR -

          - IF - the samba package is required as a dependency:

          Run the following commands to stop and mask the samba.service:

          # systemctl stop samba.service
          # systemctl mask samba.service
        scored: true

      - id: 2.1.7
        description: "Ensure ftp server services are not in use (Automated)"
        audit: |
          if ! rpm -q vsftpd >/dev/null 2>&1; then
            echo "vsftpd_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled vsftpd.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active vsftpd.service 2>/dev/null | grep -qx '^active'; then
            echo "vsftpd_enabled_active_bad"
          else
            echo "vsftpd_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "vsftpd_pkg_absent"
              set: true
            - flag: "vsftpd_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop vsftpd.service and remove vsftpd package:

          # systemctl stop vsftpd.service
          # dnf remove vsftpd
          - OR -

          - IF - the vsftpd package is required as a dependency:

          Run the following commands to stop and mask the vsftpd.service:

          # systemctl stop vsftpd.service
          # systemctl mask vsftpd.service
        scored: true

      - id: 2.1.8
        description: "Ensure message access server services are not in use (Automated)"
        audit: |
          bad=0

          # If neither package is installed, PASS immediately
          if ! rpm -q dovecot >/dev/null 2>&1 && ! rpm -q cyrus-imapd >/dev/null 2>&1; then
            echo "imap_pop_ok"
            exit 0
          fi

          # Helper: returns 0 if unit file exists, 1 otherwise
          has_unit() {
            systemctl list-unit-files "$1" >/dev/null 2>&1
          }

          # Helper: mark bad if enabled/active
          check_unit() {
            u="$1"
            if has_unit "$u"; then
              systemctl is-enabled "$u" 2>/dev/null | grep -qx 'enabled' && bad=1
              systemctl is-active  "$u" 2>/dev/null | grep -qx 'active'  && bad=1
            fi
          }

          # Evaluate all related units (treat absent units as OK)
          check_unit "dovecot.socket"
          check_unit "dovecot.service"
          check_unit "cyrus-imapd.service"

          if [ "$bad" -eq 0 ]; then
            echo "imap_pop_ok"
          else
            echo "imap_pop_bad"
          fi
        tests:
          test_items:
            - flag: "imap_pop_ok"
              set: true
        remediation: |
          # Preferred: remove message access servers if not required
          systemctl stop dovecot.socket dovecot.service cyrus-imapd.service 2>/dev/null || true
          dnf -y remove dovecot cyrus-imapd || true

          # If required as dependencies, stop and mask the units instead of removing packages:
          # systemctl stop dovecot.socket dovecot.service cyrus-imapd.service
          # systemctl mask dovecot.socket dovecot.service cyrus-imapd.service
        scored: true

      - id: 2.1.9
        description: "Ensure network file system services are not in use (Automated)"
        audit: |
          if ! rpm -q nfs-utils >/dev/null 2>&1; then
            echo "nfs-utils_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled nfs-utils.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active nfs-utils.service 2>/dev/null | grep -qx '^active'; then
            echo "nfs-utils_enabled_active_bad"
          else
            echo "nfs-utils_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "nfs-utils_pkg_absent"
              set: true
            - flag: "nfs-utils_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop nfs-utils.service and remove nfs-utils package:

          # systemctl stop nfs-utils.service
          # dnf remove nfs-utils
          - OR -

          - IF - the nfs-utils package is required as a dependency:

          Run the following commands to stop and mask the nfs-utils.service:

          # systemctl stop nfs-utils.service
          # systemctl mask nfs-utils.service
        scored: true

      - id: 2.1.10
        description: "Ensure nis server services are not in use (Automated)"
        audit: |
          if ! rpm -q ypserv >/dev/null 2>&1; then
            echo "ypserv_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled ypserv.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active ypserv.service 2>/dev/null | grep -qx '^active'; then
            echo "ypserv_enabled_active_bad"
          else
            echo "ypserv_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "ypserv_pkg_absent"
              set: true
            - flag: "ypserv_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop ypserv.service and remove ypserv package:

          # systemctl stop ypserv.service
          # dnf remove ypserv
          - OR -

          - IF - the ypserv package is required as a dependency:

          Run the following commands to stop and mask the ypserv.service:

          # systemctl stop ypserv.service
          # systemctl mask ypserv.service
        scored: true

      - id: 2.1.11
        description: "Ensure print server services are not in use (Automated)"
        audit: |
          if ! rpm -q cups >/dev/null 2>&1; then
            echo "cups_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled cups.socket cups.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active cups.socket cups.service 2>/dev/null | grep -qx '^active'; then
            echo "cups_enabled_active_bad"
          else
            echo "cups_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "cups_pkg_absent"
              set: true
            - flag: "cups_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop cups.socket and cups.service, and remove the cups package:

          # systemctl stop cups.socket cups.service
          # dnf remove cups
          - OR -

          - IF - the cups package is required as a dependency:

          Run the following commands to stop and mask the cups.socket and cups.service:

          # systemctl stop cups.socket cups.service
          # systemctl mask cups.socket cups.service
        scored: true

      - id: 2.1.12
        description: "Ensure rpcbind services are not in use (Automated)"
        audit: |
          if ! rpm -q rpcbind >/dev/null 2>&1; then
            echo "rpcbind_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled rpcbind.socket rpcbind.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active rpcbind.socket rpcbind.service 2>/dev/null | grep -qx '^active'; then
            echo "rpcbind_enabled_active_bad"
          else
            echo "rpcbind_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "rpcbind_pkg_absent"
              set: true
            - flag: "rpcbind_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop rpcbind.socket and rpcbind.service, and remove the rpcbind package:

          # systemctl stop rpcbind.socket rpcbind.service
          # dnf remove rpcbind
          - OR -

          - IF - the rpcbind package is required as a dependency:

          Run the following commands to stop and mask the rpcbind.socket and rpcbind.service:

          # systemctl stop rpcbind.socket rpcbind.service
          # systemctl mask rpcbind.socket rpcbind.service
        scored: true

      - id: 2.1.13
        description: "Ensure rsync services are not in use (Automated)"
        audit: |
          if ! rpm -q rsync-daemon >/dev/null 2>&1; then
            echo "rpcbind_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled rpcbind.socket rpcbind.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active rpcbind.socket rpcbind.service 2>/dev/null | grep -qx '^active'; then
            echo "rpcbind_enabled_active_bad"
          else
            echo "rpcbind_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "rpcbind_pkg_absent"
              set: true
            - flag: "rpcbind_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop rpcbind.socket and rpcbind.service, and remove the rpcbind package:

          # systemctl stop rpcbind.socket rpcbind.service
          # dnf remove rpcbind
          - OR -

          - IF - the rpcbind package is required as a dependency:

          Run the following commands to stop and mask the rpcbind.socket and rpcbind.service:

          # systemctl stop rpcbind.socket rpcbind.service
          # systemctl mask rpcbind.socket rpcbind.service
        scored: true

      - id: 2.1.14
        description: "Ensure snmp services are not in use (Automated)"
        audit: |
          if ! rpm -q net-snmp >/dev/null 2>&1; then
            echo "snmpd_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled snmpd.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active snmpd.service 2>/dev/null | grep -qx '^active'; then
            echo "snmpd_enabled_active_bad"
          else
            echo "snmpd_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "snmpd_pkg_absent"
              set: true
            - flag: "snmpd_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop snmpd.service, and remove the snmpd package:

          # systemctl stop snmpd.service
          # dnf remove net-snmp
          - OR -

          - IF - the snmpd package is required as a dependency:

          Run the following commands to stop and mask the snmpd.service:

          # systemctl stop snmpd.service
          # systemctl mask snmpd.service
        scored: true

      - id: 2.1.15
        description: "Ensure telnet server services are not in use (Automated)"
        audit: |
          if ! rpm -q telnet-server >/dev/null 2>&1; then
            echo "telnet_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled telnet.socket 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active telnet.socket 2>/dev/null | grep -qx '^active'; then
            echo "telnet_enabled_active_bad"
          else
            echo "telnet_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "telnet_pkg_absent"
              set: true
            - flag: "telnet_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop telnet.socket, and remove the telnet package:

          # systemctl stop telnet.socket
          # dnf remove telnet-server
          - OR -

          - IF - the telnet package is required as a dependency:

          Run the following commands to stop and mask the telnet.socket:

          # systemctl stop telnet.socket
          # systemctl mask telnet.socket
        scored: true

      - id: 2.1.16
        description: "Ensure tftp server services are not in use (Automated)"
        audit: |
          if ! rpm -q tftp-server >/dev/null 2>&1; then
            echo "tftp_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled tftp.socket tftp.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active tftp.socket tftp.service 2>/dev/null | grep -qx '^active'; then
            echo "tftp_enabled_active_bad"
          else
            echo "tftp_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "tftp_pkg_absent"
              set: true
            - flag: "tftp_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop tftp.socket, and remove the tftp package:

          # systemctl stop tftp.socket tftp.service
          # dnf remove tftp-server
          - OR -

          - IF - the tftp package is required as a dependency:

          Run the following commands to stop and mask the tftp.socket:

          # systemctl stop tftp.socket tftp.service
          # systemctl mask tftp.socket tftp.service
        scored: true

      - id: 2.1.17
        description: "Ensure web proxy server services are not in use (Automated)"
        audit: |
          if ! rpm -q squid >/dev/null 2>&1; then
            echo "squid_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled squid.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active squid.service 2>/dev/null | grep -qx '^active'; then
            echo "squid_enabled_active_bad"
          else
            echo "squid_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "squid_pkg_absent"
              set: true
            - flag: "squid_disabled_or_inactive_ok"
        remediation: |
          Run the following commands to stop squid.service, and remove the squid package:

          # systemctl stop squid.service
          # dnf remove squid
          - OR -

          - IF - the squid package is required as a dependency:

          Run the following commands to stop and mask the squid.service:

          # systemctl stop squid.service
          # systemctl mask squid.service
        scored: true

      - id: 2.1.18
        description: "Ensure web server services are not in use (Automated)"
        audit: |
          #!/bin/sh
          # PASS if:
          #   - BOTH packages (httpd, nginx) are NOT installed
          #     OR
          #   - (one/both installed) AND ALL related units are NOT enabled AND NOT active
          # AND logic is enforced inside this audit; tests only check a single OK flag.

          bad=0

          # If neither package is installed, PASS immediately
          if ! rpm -q httpd >/dev/null 2>&1 && ! rpm -q nginx >/dev/null 2>&1; then
            echo "websrv_ok"
            exit 0
          fi

          # Helper: returns 0 if unit file exists, 1 otherwise
          has_unit() {
            systemctl list-unit-files "$1" >/dev/null 2>&1
          }

          # Helper: mark bad if enabled/active
          check_unit() {
            u="$1"
            if has_unit "$u"; then
              systemctl is-enabled "$u" 2>/dev/null | grep -qx 'enabled' && bad=1
              systemctl is-active  "$u" 2>/dev/null | grep -qx 'active'  && bad=1
            fi
          }

          # Evaluate all related units (treat absent units as OK)
          check_unit "httpd.socket"
          check_unit "httpd.service"
          check_unit "nginx.service"

          if [ "$bad" -eq 0 ]; then
            echo "websrv_ok"
          else
            echo "websrv_bad"
          fi
        tests:
          test_items:
            - flag: "websrv_ok"
              set: true
        remediation: |
          # Preferred: remove web servers if not required
          systemctl stop httpd.socket httpd.service nginx.service 2>/dev/null || true
          dnf -y remove httpd nginx || true

          # If required as dependencies, stop and mask the units instead of removing packages:
          # systemctl stop httpd.socket httpd.service nginx.service
          # systemctl mask httpd.socket httpd.service nginx.service
          #
          # Note: If other web server packages are present, audit them as well and
          # stop/mask/remove per local site policy.
        scored: true

      - id: 2.1.19
        description: "Ensure xinetd services are not in use (Automated)"
        audit: |
          if ! rpm -q xinetd >/dev/null 2>&1; then
            echo "xinetd_pkg_absent"
            exit 0
          fi

          if systemctl is-enabled xinetd.service 2>/dev/null | grep -qx 'enabled' && \
             systemctl is-active xinetd.service 2>/dev/null | grep -qx '^active'; then
            echo "xinetd_enabled_active_bad"
          else
            echo "xinetd_disabled_or_inactive_ok"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "xinetd_pkg_absent"
              set: true
            - flag: "xinetd_disabled_or_inactive_ok"
              set: true
        remediation: |
          Run the following commands to stop xinetd.service, and remove the xinetd package:

          # systemctl stop xinetd.service
          # dnf remove xinetd
          - OR -

          - IF - the xinetd package is required as a dependency:

          Run the following commands to stop and mask the xinetd.service:

          # systemctl stop xinetd.service
          # systemctl mask xinetd.service
        scored: true

      - id: 2.1.20
        description: "Ensure X window server services are not in use (Automated)"
        audit: |
          rpm -q xorg-x11-server-common
        tests:
          test_items:
            - flag: "package xorg-x11-server-common is not installed"
              set: true
        remediation: |
          - IF - a Graphical Desktop Manager or X-Windows server is not required and approved by local site policy:

          Run the following command to remove the X Windows Server packages:

          # dnf remove xorg-x11-server-common
        scored: true

      - id: 2.1.21
        description: "Ensure mail transfer agents are configured for local-only mode (Automated)"
        audit: |
          {
             l_output="" l_output2=""
             a_port_list=("25" "465" "587")
             if [ "$(postconf -n inet_interfaces)" != "inet_interfaces = all" ]; then
                for l_port_number in "${a_port_list[@]}"; do
                   if ss -plntu | grep -P -- ':'"$l_port_number"'\b' | grep -Pvq -- '\h+(127\.0\.0\.1|\[?::1\]?):'"$l_port_number"'\b'; then
                         l_output2="$l_output2\n - Port \"$l_port_number\" is listening on a non-loopback network interface"
                   else
                         l_output="$l_output\n - Port \"$l_port_number\" is not listening on a non-loopback network interface"
                   fi
                done
             else
                l_output2="$l_output2\n - Postfix is bound to all interfaces"
             fi
             unset a_port_list
             if [ -z "$l_output2" ]; then
                echo -e "\n- Audit Result:\n  ** PASS **\n$l_output\n"
             else
                echo -e "\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n"
                [ -n "$l_output" ] && echo -e "\n- Correctly set:\n$l_output\n"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          # Configure postfix to only listen on loopback interface
          if rpm -q postfix >/dev/null 2>&1; then
            # Update the configuration file
            if grep -q '^inet_interfaces' /etc/postfix/main.cf 2>/dev/null; then
              sed -ri 's/^inet_interfaces\s*=.*/inet_interfaces = loopback-only/' /etc/postfix/main.cf
            else
              echo "inet_interfaces = loopback-only" >> /etc/postfix/main.cf
            fi

            # Restart postfix for changes to take effect
            systemctl restart postfix
          fi

          # For other MTAs (like sendmail), configure local-only listening per vendor documentation
        scored: true

      - id: 2.1.22
        description: "Ensure only approved services are listening on a network interface (Manual)"
        type: "manual"
        remediation: |
          Run the following commands to stop the service and remove the package containing the service:

          # systemctl stop <service_name>.socket <service_name>.service
          # dnf remove <package_name>
          - OR - If required packages have a dependency:

          Run the following commands to stop and mask the service and socket:

          # systemctl stop <service_name>.socket <service_name>.service
          # systemctl mask <service_name>.socket <service_name>.service
          Note: replace <service_name> with the appropriate service name.
        scored: false

  - id: 2.2
    description: "Configure Client Services"
    checks:
      - id: 2.2.1
        description: "Ensure FTP client is not installed (Automated)"
        audit: "rpm -q ftp"
        tests:
          test_items:
            - flag: "package ftp is not installed"
              set: true
        remediation: |
          Run the following command to remove ftp:

          # dnf remove ftp
        scored: true

      - id: 2.2.2
        description: "Ensure LDAP client is not installed (Automated)"
        audit: "rpm -q openldap-clients"
        tests:
          test_items:
            - flag: "package openldap-clients is not installed"
              set: true
        remediation: |
          Run the following command to remove openldap-clients:

          # dnf remove openldap-clients
        scored: true

      - id: 2.2.3
        description: "Ensure nis client is not installed (Automated)"
        audit: "rpm -q ypbind"
        tests:
          test_items:
            - flag: "package ypbind is not installed"
              set: true
        remediation: |
          Run the following command to remove ypbind:

          # dnf remove ypbind
        scored: true

      - id: 2.2.4
        description: "Ensure telnet client is not installed (Automated)"
        audit: "rpm -q telnet"
        tests:
          test_items:
            - flag: "package telnet is not installed"
              set: true
        remediation: |
          Run the following command to remove telnet:

          # dnf remove telnet
        scored: true

      - id: 2.2.5
        description: "Ensure TFTP client is not installed (Automated)"
        audit: "rpm -q tftp"
        tests:
          test_items:
            - flag: "package tftp is not installed"
              set: true
        remediation: |
          Run the following command to remove tftp:

          # dnf remove tftp
        scored: true

  - id: 2.3
    description: "Configure Time Synchronization"
    checks:
      - id: 2.3.1
        description: "Ensure time synchronization is in use (Automated)"
        audit: "rpm -q chrony"
        tests:
          test_items:
            - flag: "package chrony is not installed"
              set: false
        remediation: |
          Run the following command to install chrony:

          # dnf install chrony
        scored: true

      - id: 2.3.2
        description: "Ensure chrony is configured (Automated)"
        audit: |
          #!/bin/sh
          # PASS if chrony is installed AND at least one non-comment 'server' or 'pool' line exists
          # Not Applicable if chrony is not installed.

          if ! rpm -q chrony >/dev/null 2>&1; then
            echo "not_applicable"
            exit 0
          fi

          if grep -Prqs -- '^[[:space:]]*(server|pool)[[:space:]]+[^#\r\n]+' /etc/chrony.conf /etc/chrony.d/ 2>/dev/null; then
            echo "chrony_servers_ok"
          else
            echo "chrony_servers_bad"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "chrony_servers_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Add one or more remote time sources to chrony configuration
          # Example (replace with approved NTP servers/pools):
          #   echo "server time1.example.com iburst" >> /etc/chrony.conf
          # or place files under /etc/chrony.d/ with 'server' or 'pool' lines.

          # After editing, restart or reload chrony:
          systemctl restart chronyd 2>/dev/null || systemctl try-restart chronyd 2>/dev/null || true
        scored: true

      - id: 2.3.3
        description: "Ensure chrony is not run as the root user (Automated)"
        audit: |
          grep -Psi -- '^\h*OPTIONS=\"?\h*([^#\n\r]+\h+)?-u\h+root\b' /etc/sysconfig/chronyd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the file /etc/sysconfig/chronyd and add or modify the following line to remove "-u root" from any OPTIONS= argument:

          Example:

          OPTIONS="-F 2"
          Run the following command to reload the chronyd.service configuration:

          # systemctl reload-or-restart chronyd.service
        scored: true

  - id: 2.4
    description: "Job schedulers"
    checks:
      - id: 2.4.1
        description: "Configure cron"
      - id: 2.4.1.1
        description: "Ensure cron daemon is enabled and active (Automated)"
        audit: |
          #!/bin/sh
          # PASS if (cron/crond service exists) AND (is-enabled == enabled) AND (is-active == active)
          # If no cron service exists, mark Not Applicable.

          units="$(systemctl list-unit-files | awk '$1~/^crond?\.service$/{print $1}')"

          if [ -z "$units" ]; then
            echo "not_applicable"
            exit 0
          fi

          bad=0
          for u in $units; do
            systemctl is-enabled "$u" 2>/dev/null | grep -qx 'enabled' || bad=1
            systemctl is-active  "$u" 2>/dev/null | grep -qx 'active'  || bad=1
          done

          if [ "$bad" -eq 0 ]; then
            echo "cron_enabled_active_ok"
          else
            echo "cron_enabled_active_bad"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "cron_enabled_active_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Unmask, enable, and start cron (supports cron.service or crond.service)
          unit_list="$(systemctl list-unit-files | awk '$1~/^crond?\.service$/{print $1}')"
          [ -n "$unit_list" ] && systemctl unmask $unit_list 2>/dev/null || true
          [ -n "$unit_list" ] && systemctl --now enable $unit_list 2>/dev/null || true
        scored: true


      - id: 2.4.1.2
        description: "Ensure permissions on /etc/crontab are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/crontab)
          owner=$(stat -Lc '%u' /etc/crontab)
          group=$(stat -Lc '%g' /etc/crontab)

          if [ "$perms" -le 600 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "crontab_perms_ok"
          else
            echo "crontab_perms_bad"
          fi
        tests:
          test_items:
            - flag: "crontab_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/crontab
          chown root:root /etc/crontab
          chmod og-rwx /etc/crontab
        scored: true

      - id: 2.4.1.3
        description: "Ensure permissions on /etc/cron.hourly are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.hourly)
          owner=$(stat -Lc '%u' /etc/cron.hourly)
          group=$(stat -Lc '%g' /etc/cron.hourly)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.hourly_perms_ok"
          else
            echo "cron.hourly_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.hourly_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.hourly
          chown root:root /etc/cron.hourly
          chmod og-rwx /etc/cron.hourly
        scored: true

      - id: 2.4.1.4
        description: "Ensure permissions on /etc/cron.daily are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.daily)
          owner=$(stat -Lc '%u' /etc/cron.daily)
          group=$(stat -Lc '%g' /etc/cron.daily)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.daily_perms_ok"
          else
            echo "cron.daily_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.daily_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.daily
          chown root:root /etc/cron.daily
          chmod og-rwx /etc/cron.daily
        scored: true

      - id: 2.4.1.5
        description: "Ensure permissions on /etc/cron.weekly are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.weekly)
          owner=$(stat -Lc '%u' /etc/cron.weekly)
          group=$(stat -Lc '%g' /etc/cron.weekly)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.weekly_perms_ok"
          else
            echo "cron.weekly_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.weekly_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.weekly
          chown root:root /etc/cron.weekly
          chmod og-rwx /etc/cron.weekly
        scored: true

      - id: 2.4.1.6
        description: "Ensure permissions on /etc/cron.monthly are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.monthly)
          owner=$(stat -Lc '%u' /etc/cron.monthly)
          group=$(stat -Lc '%g' /etc/cron.monthly)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.monthly_perms_ok"
          else
            echo "cron.monthly_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.monthly_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.monthly
          chown root:root /etc/cron.monthly
          chmod og-rwx /etc/cron.monthly
        scored: true

      - id: 2.4.1.7
        description: "Ensure permissions on /etc/cron.d are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.d)
          owner=$(stat -Lc '%u' /etc/cron.d)
          group=$(stat -Lc '%g' /etc/cron.d)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.d_perms_ok"
          else
            echo "cron.d_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.d_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.d
          chown root:root /etc/cron.d
          chmod og-rwx /etc/cron.d
        scored: true

      - id: 2.4.1.8
        description: "Ensure crontab is restricted to authorized users (Automated)"
        audit: |
          #!/usr/bin/env bash
          {
            # Helper to validate "0640 or more restrictive":
            # user ∈ {0,4,6}, group ∈ {0,4}, other = 0
            perm_ok() {
              local p="$1"
              # left-pad to 3 digits
              p=$(printf "%03d" "$p")
              local u="${p:0:1}" g="${p:1:1}" o="${p:2:1}"
              [[ "$o" == "0" ]] && [[ "$g" =~ ^(0|4)$ ]] && [[ "$u" =~ ^(0|4|6)$ ]]
            }

            if rpm -q cronie > /dev/null 2>&1; then
              fail=0

              # --- /etc/cron.allow must exist and be root:root with 0640 or more restrictive ---
              if [ ! -e /etc/cron.allow ]; then
                echo "Fail: cron.allow doesn't exist"
                fail=1
              else
                perm="$(stat -Lc '%a' /etc/cron.allow 2>/dev/null || echo '')"
                owner="$(stat -Lc '%u:%g' /etc/cron.allow 2>/dev/null || echo ':')"
                if ! perm_ok "$perm"; then
                  echo "Fail: cron.allow mode too permissive ($perm)"
                  fail=1
                fi
                if ! [[ "$owner" =~ ^0:0$ ]]; then
                  echo "Fail: cron.allow owner and/or group not root (got $owner)"
                  fail=1
                fi
              fi

              # --- /etc/cron.deny: either absent, or if present must be root:root with 0640 or tighter ---
              if [ -e /etc/cron.deny ]; then
                perm_d="$(stat -Lc '%a' /etc/cron.deny 2>/dev/null || echo '')"
                owner_d="$(stat -Lc '%u:%g' /etc/cron.deny 2>/dev/null || echo ':')"
                if ! perm_ok "$perm_d"; then
                  echo "Fail: cron.deny mode too permissive ($perm_d)"
                  fail=1
                fi
                if ! [[ "$owner_d" =~ ^0:0$ ]]; then
                  echo "Fail: cron.deny owner and/or group not root (got $owner_d)"
                  fail=1
                fi
              fi

              # Final verdict
              if [ "$fail" -eq 0 ]; then
                echo "Pass"
              fi
            else
              echo "Pass: cron is not installed on the system"
            fi
          }
        tests:
          test_items:
            - flag: "Pass"
            - flag: "Pass: cron is not installed on the system"
          bin_op: "or"
        remediation: |
          #!/usr/bin/env bash
          {
            if rpm -q cronie > /dev/null 2>&1; then
              # Ensure cron.allow exists and is restricted
              [ -e /etc/cron.allow ] || touch /etc/cron.allow
              chown root:root /etc/cron.allow
              chmod 0640 /etc/cron.allow

              # If cron.deny exists, restrict it (do not require removing it)
              if [ -e /etc/cron.deny ]; then
                chown root:root /etc/cron.deny
                chmod 0640 /etc/cron.deny
              fi
            else
              echo "cron is not installed on the system"
              # To remove cron if present:
              # dnf remove -y cronie
            fi
          }
        scored: true

      - id: 2.4.2.1
        description: "Configure at"
        type: "skip"
        checks:
      - id: 2.4.2.1.1
        description: "Ensure at is restricted to authorized users (Automated)"
        audit: |
          #!/usr/bin/env bash
          {
            # Helper to validate "0640 or more restrictive":
            # user ∈ {0,4,6}, group ∈ {0,4}, other = 0
            perm_ok() {
              local p="$1"
              p=$(printf "%03d" "$p")
              local u="${p:0:1}" g="${p:1:1}" o="${p:2:1}"
              [[ "$o" == "0" ]] && [[ "$g" =~ ^(0|4)$ ]] && [[ "$u" =~ ^(0|4|6)$ ]]
            }

            # Determine acceptable group: daemon (if present) or root
            daemon_gid="$(getent group daemon | awk -F: '{print $3}')"
            root_gid="0"

            if ! rpm -q at >/dev/null 2>&1; then
              echo "Pass: at is not installed on the system"
              exit 0
            fi

            fail=0

            # --- /etc/at.allow must exist and be root:daemon|root with 0640 or tighter ---
            if [ ! -e /etc/at.allow ]; then
              echo "Fail: at.allow doesn't exist"
              fail=1
            else
              perm_allow="$(stat -Lc '%a' /etc/at.allow 2>/dev/null || echo '')"
              own_allow="$(stat -Lc '%u:%g' /etc/at.allow 2>/dev/null || echo ':')"
              # perms
              if ! perm_ok "$perm_allow"; then
                echo "Fail: at.allow mode too permissive ($perm_allow)"
                fail=1
              fi
              # owner must be root and group must be root or daemon
              if [[ ! "$own_allow" =~ ^0:(0|${daemon_gid:-999999})$ ]]; then
                echo "Fail: at.allow owner/group not root:root or root:daemon (got $own_allow)"
                fail=1
              fi
            fi

            # --- /etc/at.deny: either absent, or if present must be restricted like above ---
            if [ -e /etc/at.deny ]; then
              perm_deny="$(stat -Lc '%a' /etc/at.deny 2>/dev/null || echo '')"
              own_deny="$(stat -Lc '%u:%g' /etc/at.deny 2>/dev/null || echo ':')"
              if ! perm_ok "$perm_deny"; then
                echo "Fail: at.deny mode too permissive ($perm_deny)"
                fail=1
              fi
              if [[ ! "$own_deny" =~ ^0:(0|${daemon_gid:-999999})$ ]]; then
                echo "Fail: at.deny owner/group not root:root or root:daemon (got $own_deny)"
                fail=1
              fi
            fi

            # Final verdict
            if [ "$fail" -eq 0 ]; then
              echo "Pass"
            fi
          }
        tests:
          test_items:
            - flag: "Pass"
        remediation: |
          #!/usr/bin/env bash
          {
            if rpm -q at >/dev/null 2>&1; then
              # Choose group: daemon if it exists, else root
              if getent group daemon >/dev/null 2>&1; then
                grp="daemon"
              else
                grp="root"
              fi

              # Ensure /etc/at.allow exists and is restricted
              [ -e /etc/at.allow ] || touch /etc/at.allow
              chown root:"$grp" /etc/at.allow
              chmod 0640 /etc/at.allow

              # If /etc/at.deny exists, restrict it (allowed to exist)
              if [ -e /etc/at.deny ]; then
                chown root:"$grp" /etc/at.deny
                chmod 0640 /etc/at.deny
              fi
            else
              echo "at is not installed on the system"
              # To remove if present under a different package manager context:
              # dnf remove -y at
            fi
          }
        scored: true


  - id: 3
    description: "Network"
  - id: 3.1
    description: "Configure Network Devices"
    checks:
      - id: 3.1.1
        description: "Ensure IPv6 status is identified (Manual)"
        audit: |
          {
             l_output=""
             ! grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable && l_output="- IPv6 is not enabled"
             if sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
                sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
                l_output="- IPv6 is not enabled"
             fi
             [ -z "$l_output" ] && l_output="- IPv6 is enabled"
             echo -e "\n$l_output\n"
          }
        tests:
          test_items:
            - flag: "- IPv6 is enabled"
        remediation: |
          Enable or disable IPv6 in accordance with system requirements and local site policy
        scored: false

      - id: 3.1.2
        description: "Ensure wireless interfaces are disabled (Automated)"
        audit: |
          # Detect wireless NIC driver modules and verify they are disabled
          any_bad=0
          found=0

          # Find wireless interfaces by presence of a 'wireless' directory under /sys/class/net/*/
          mapfile -t drivers < <(
            find /sys/class/net/*/ -maxdepth 1 -type d -name wireless 2>/dev/null \
              -printf '%h\n' | xargs -r -I{} readlink -f "{}/device/driver/module" \
              | xargs -r -n1 basename | sort -u
          )

          if [ ${#drivers[@]} -eq 0 ]; then
            echo "no_wireless_nics"
            exit 0
          fi

          found=1
          for m in "${drivers[@]}"; do
            # 1) Not loadable via modprobe (install /bin/false or /bin/true)
            if modprobe -n -v "$m" 2>/dev/null | grep -Eq '^\s*install\s+/bin/(true|false)\b'; then
              echo "mod_${m}_not_loadable"
            else
              echo "mod_${m}_loadable"
              any_bad=1
            fi

            # 2) Not currently loaded
            if lsmod | awk '{print $1}' | grep -qx "$m"; then
              echo "mod_${m}_loaded"
              any_bad=1
            else
              echo "mod_${m}_not_loaded"
            fi

            # 3) Blacklisted (deny-listed)
            if modprobe --showconfig 2>/dev/null | grep -Eq "^\s*blacklist\s+${m}\b"; then
              echo "mod_${m}_blacklisted"
            else
              echo "mod_${m}_not_blacklisted"
              any_bad=1
            fi
          done

          if [ "$any_bad" -eq 0 ] && [ "$found" -eq 1 ]; then
            echo "all_wireless_modules_disabled"
          else
            echo "wireless_modules_not_fully_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "no_wireless_nics"
              set: true
            - flag: "all_wireless_modules_disabled"
              set: true
        remediation: |
          # Disable detected wireless NIC driver modules:
          #  - make them un-loadable via modprobe ("install <mod> /bin/false")
          #  - unload if currently loaded
          #  - blacklist them to prevent autoload
          mapfile -t drivers < <(
            find /sys/class/net/*/ -maxdepth 1 -type d -name wireless 2>/dev/null \
              -printf '%h\n' | xargs -r -I{} readlink -f "{}/device/driver/module" \
              | xargs -r -n1 basename | sort -u
          )

          for m in "${drivers[@]}"; do
            conf="/etc/modprobe.d/${m}.conf"

            # Ensure not loadable via modprobe
            if ! modprobe -n -v "$m" 2>/dev/null | grep -Eq '^\s*install\s+/bin/(true|false)\b'; then
              echo "install $m /bin/false" >> "$conf"
            fi

            # Unload if currently loaded
            if lsmod | awk '{print $1}' | grep -qx "$m"; then
              modprobe -r "$m" 2>/dev/null || true
            fi

            # Blacklist (deny-list) the module
            if ! grep -Eq "^\s*blacklist\s+${m}\b" /etc/modprobe.d/*.conf 2>/dev/null; then
              echo "blacklist $m" >> "$conf"
            fi
          done
        scored: true
      - id: 3.1.3
        description: "Ensure bluetooth services are not in use (Automated)"
        audit: |
          bad=0

          if ! rpm -q bluez >/dev/null 2>&1; then
            echo "bluetooth_ok"
            exit 0
          fi

          # If unit exists, it must be disabled and inactive.
          if systemctl list-unit-files bluetooth.service >/dev/null 2>&1; then
            systemctl is-enabled bluetooth.service 2>/dev/null | grep -qx 'enabled' && bad=1
            systemctl is-active  bluetooth.service 2>/dev/null | grep -qx 'active'  && bad=1
          fi

          if [ "$bad" -eq 0 ]; then
            echo "bluetooth_ok"
          else
            echo "bluetooth_bad"
          fi
        tests:
          test_items:
            - flag: "bluetooth_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          if rpm -q bluez >/dev/null 2>&1; then
            # Preferred: remove BlueZ if not required
            systemctl stop bluetooth.service 2>/dev/null || true
            dnf -y remove bluez || true

            # If bluez is required as a dependency, stop and mask the service instead:
            # systemctl stop bluetooth.service
            # systemctl mask bluetooth.service
          else
            echo "bluez package not installed"
          fi

          # Note: A reboot may be required for some environments.
        scored: true


  - id: 3.2
    description: "Configure Network Kernel Modules"
    checks:
      - id: 3.2.1
        description: "Ensure dccp kernel module is not available (Automated)"
        audit: |
          {
             l_output3="" l_dl="" # clear variables
             unset a_output; unset a_output2 # unset arrays
             l_mod_name="dccp" # set module name
             l_mod_type="net" # set module type
             l_mod_path="$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)"
             f_module_chk()
             {
                l_dl="y" # Set to ignore duplicate checks
                a_showconfig=() # Create array with modprobe output
                while IFS= read -r l_showconfig; do
                   a_showconfig+=("$l_showconfig")
                done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'"${l_mod_name//-/_}"'\b')
                if ! lsmod | grep "$l_mod_name" &> /dev/null; then # Check if the module is currently loaded
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loaded")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loaded")
                fi
                if grep -Pq -- '\binstall\h+'"${l_mod_name//-/_}"'\h+\/bin\/(true|false)\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loadable")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loadable")
                fi
                if grep -Pq -- '\bblacklist\h+'"${l_mod_name//-/_}"'\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is deny listed")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is not deny listed")
                fi
             }
             for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
                if [ -d "$l_mod_base_directory/${l_mod_name/-/\/}" ] && [ -n "$(ls -A $l_mod_base_directory/${l_mod_name/-/\/})" ]; then
                   l_output3="$l_output3\n  - \"$l_mod_base_directory\""
                   [[ "$l_mod_name" =~ overlay ]] && l_mod_name="${l_mod_name::-2}"
                   [ "$l_dl" != "y" ] && f_module_chk
                else
                   a_output+=(" - kernel module: \"$l_mod_name\" doesn't exist in \"$l_mod_base_directory\"")
                fi
             done
             [ -n "$l_output3" ] && echo -e "\n\n -- INFO --\n - module: \"$l_mod_name\" exists in:$l_output3"
             if [ "${#a_output2[@]}" -le 0 ]; then
                printf '%s\n' "" "- Audit Result:" "  ** PASS **" "${a_output[@]}"
             else
                printf '%s\n' "" "- Audit Result:" "  ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                [ "${#a_output[@]}" -gt 0 ] && printf '%s\n' "- Correctly set:" "${a_output[@]}"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          mod="dccp"
          conf="/etc/modprobe.d/${mod}.conf"

          # Prevent loading
          if ! modprobe -n -v "$mod" 2>/dev/null | grep -Pq '^\s*install\s+'${mod//-/_}'\s+\/bin\/(true|false)\b'; then
            printf 'install %s /bin/false\n' "$mod" >> "$conf"
          fi

          # Deny-list the module
          if ! grep -Psq '^\s*blacklist\s+'${mod//-/_}'\b' /etc/modprobe.d/*.conf 2>/dev/null; then
            printf 'blacklist %s\n' "${mod//-/_}" >> "$conf"
          fi

          # Unload if loaded
          if lsmod | grep -q "^${mod}\b"; then
            modprobe -r "$mod" 2>/dev/null || rmmod "$mod" 2>/dev/null || true
          fi
        scored: true


      - id: 3.2.2
        description: "Ensure tipc kernel module is not available (Automated)"
        audit: |
          {
             l_output3="" l_dl="" # clear variables
             unset a_output; unset a_output2 # unset arrays
             l_mod_name="tipc" # set module name
             l_mod_type="net" # set module type
             l_mod_path="$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)"
             f_module_chk()
             {
                l_dl="y" # Set to ignore duplicate checks
                a_showconfig=() # Create array with modprobe output
                while IFS= read -r l_showconfig; do
                   a_showconfig+=("$l_showconfig")
                done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'"${l_mod_name//-/_}"'\b')
                if ! lsmod | grep "$l_mod_name" &> /dev/null; then # Check if the module is currently loaded
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loaded")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loaded")
                fi
                if grep -Pq -- '\binstall\h+'"${l_mod_name//-/_}"'\h+\/bin\/(true|false)\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loadable")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loadable")
                fi
                if grep -Pq -- '\bblacklist\h+'"${l_mod_name//-/_}"'\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is deny listed")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is not deny listed")
                fi
             }
             for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
                if [ -d "$l_mod_base_directory/${l_mod_name/-/\/}" ] && [ -n "$(ls -A $l_mod_base_directory/${l_mod_name/-/\/})" ]; then
                   l_output3="$l_output3\n  - \"$l_mod_base_directory\""
                   [[ "$l_mod_name" =~ overlay ]] && l_mod_name="${l_mod_name::-2}"
                   [ "$l_dl" != "y" ] && f_module_chk
                else
                   a_output+=(" - kernel module: \"$l_mod_name\" doesn't exist in \"$l_mod_base_directory\"")
                fi
             done
             [ -n "$l_output3" ] && echo -e "\n\n -- INFO --\n - module: \"$l_mod_name\" exists in:$l_output3"
             if [ "${#a_output2[@]}" -le 0 ]; then
                printf '%s\n' "" "- Audit Result:" "  ** PASS **" "${a_output[@]}"
             else
                printf '%s\n' "" "- Audit Result:" "  ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                [ "${#a_output[@]}" -gt 0 ] && printf '%s\n' "- Correctly set:" "${a_output[@]}"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          mod="tipc"
          conf="/etc/modprobe.d/${mod}.conf"

          # Prevent loading (install rule)
          if ! modprobe -n -v "$mod" 2>/dev/null | grep -Pq '^\s*install\s+'${mod//-/_}'\s+\/bin\/(true|false)\b'; then
            printf 'install %s /bin/false\n' "$mod" >> "$conf"
          fi

          # Deny-list the module
          if ! grep -Psq '^\s*blacklist\s+'${mod//-/_}'\b' /etc/modprobe.d/*.conf 2>/dev/null; then
            printf 'blacklist %s\n' "${mod//-/_}" >> "$conf"
          fi

          # Unload if currently loaded
          if lsmod | grep -q "^${mod}\b"; then
            modprobe -r "$mod" 2>/dev/null || rmmod "$mod" 2>/dev/null || true
          fi
        scored: true

      - id: 3.2.3
        description: "Ensure rds kernel module is not available (Automated)"
        audit: |
          {
             l_output3="" l_dl="" # clear variables
             unset a_output; unset a_output2 # unset arrays
             l_mod_name="rds" # set module name
             l_mod_type="net" # set module type
             l_mod_path="$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)"
             f_module_chk()
             {
                l_dl="y" # Set to ignore duplicate checks
                a_showconfig=() # Create array with modprobe output
                while IFS= read -r l_showconfig; do
                   a_showconfig+=("$l_showconfig")
                done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'"${l_mod_name//-/_}"'\b')
                if ! lsmod | grep "$l_mod_name" &> /dev/null; then # Check if the module is currently loaded
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loaded")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loaded")
                fi
                if grep -Pq -- '\binstall\h+'"${l_mod_name//-/_}"'\h+\/bin\/(true|false)\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loadable")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loadable")
                fi
                if grep -Pq -- '\bblacklist\h+'"${l_mod_name//-/_}"'\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is deny listed")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is not deny listed")
                fi
             }
             for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
                if [ -d "$l_mod_base_directory/${l_mod_name/-/\/}" ] && [ -n "$(ls -A $l_mod_base_directory/${l_mod_name/-/\/})" ]; then
                   l_output3="$l_output3\n  - \"$l_mod_base_directory\""
                   [[ "$l_mod_name" =~ overlay ]] && l_mod_name="${l_mod_name::-2}"
                   [ "$l_dl" != "y" ] && f_module_chk
                else
                   a_output+=(" - kernel module: \"$l_mod_name\" doesn't exist in \"$l_mod_base_directory\"")
                fi
             done
             [ -n "$l_output3" ] && echo -e "\n\n -- INFO --\n - module: \"$l_mod_name\" exists in:$l_output3"
             if [ "${#a_output2[@]}" -le 0 ]; then
                printf '%s\n' "" "- Audit Result:" "  ** PASS **" "${a_output[@]}"
             else
                printf '%s\n' "" "- Audit Result:" "  ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                [ "${#a_output[@]}" -gt 0 ] && printf '%s\n' "- Correctly set:" "${a_output[@]}"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          mod="rds"
          conf="/etc/modprobe.d/${mod}.conf"

          # Prevent loading (install rule)
          if ! modprobe -n -v "$mod" 2>/dev/null | grep -Pq '^\s*install\s+'${mod//-/_}'\s+\/bin\/(true|false)\b'; then
            printf 'install %s /bin/false\n' "$mod" >> "$conf"
          fi

          # Deny-list the module
          if ! grep -Psq '^\s*blacklist\s+'${mod//-/_}'\b' /etc/modprobe.d/*.conf 2>/dev/null; then
            printf 'blacklist %s\n' "${mod//-/_}" >> "$conf"
          fi

          # Unload if currently loaded
          if lsmod | grep -q "^${mod}\b"; then
            modprobe -r "$mod" 2>/dev/null || rmmod "$mod" 2>/dev/null || true
          fi
        scored: true

      - id: 3.2.4
        description: "Ensure sctp kernel module is not available (Automated)"
        audit: |
          {
             l_output3="" l_dl="" # clear variables
             unset a_output; unset a_output2 # unset arrays
             l_mod_name="sctp" # set module name
             l_mod_type="net" # set module type
             l_mod_path="$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)"
             f_module_chk()
             {
                l_dl="y" # Set to ignore duplicate checks
                a_showconfig=() # Create array with modprobe output
                while IFS= read -r l_showconfig; do
                   a_showconfig+=("$l_showconfig")
                done < <(modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+'"${l_mod_name//-/_}"'\b')
                if ! lsmod | grep "$l_mod_name" &> /dev/null; then # Check if the module is currently loaded
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loaded")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loaded")
                fi
                if grep -Pq -- '\binstall\h+'"${l_mod_name//-/_}"'\h+\/bin\/(true|false)\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is not loadable")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is loadable")
                fi
                if grep -Pq -- '\bblacklist\h+'"${l_mod_name//-/_}"'\b' <<< "${a_showconfig[*]}"; then
                   a_output+=("  - kernel module: \"$l_mod_name\" is deny listed")
                else
                   a_output2+=("  - kernel module: \"$l_mod_name\" is not deny listed")
                fi
             }
             for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system
                if [ -d "$l_mod_base_directory/${l_mod_name/-/\/}" ] && [ -n "$(ls -A $l_mod_base_directory/${l_mod_name/-/\/})" ]; then
                   l_output3="$l_output3\n  - \"$l_mod_base_directory\""
                   [[ "$l_mod_name" =~ overlay ]] && l_mod_name="${l_mod_name::-2}"
                   [ "$l_dl" != "y" ] && f_module_chk
                else
                   a_output+=(" - kernel module: \"$l_mod_name\" doesn't exist in \"$l_mod_base_directory\"")
                fi
             done
             [ -n "$l_output3" ] && echo -e "\n\n -- INFO --\n - module: \"$l_mod_name\" exists in:$l_output3"
             if [ "${#a_output2[@]}" -le 0 ]; then
                printf '%s\n' "" "- Audit Result:" "  ** PASS **" "${a_output[@]}"
             else
                printf '%s\n' "" "- Audit Result:" "  ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                [ "${#a_output[@]}" -gt 0 ] && printf '%s\n' "- Correctly set:" "${a_output[@]}"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          mod="sctp"
          conf="/etc/modprobe.d/${mod}.conf"

          # Prevent loading (install rule)
          if ! modprobe -n -v "$mod" 2>/dev/null | grep -Pq '^\s*install\s+'${mod//-/_}'\s+\/bin\/(true|false)\b'; then
            printf 'install %s /bin/false\n' "$mod" >> "$conf"
          fi

          # Deny-list the module
          if ! grep -Psq '^\s*blacklist\s+'${mod//-/_}'\b' /etc/modprobe.d/*.conf 2>/dev/null; then
            printf 'blacklist %s\n' "${mod//-/_}" >> "$conf"
          fi

          # Unload if currently loaded
          if lsmod | grep -q "^${mod}\b"; then
            modprobe -r "$mod" 2>/dev/null || rmmod "$mod" 2>/dev/null || true
          fi
        scored: true


  - id: 3.3
    description: "Configure Network Kernel Parameters"
    checks:
      - id: 3.3.1
        description: "Ensure IP forwarding is disabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require BOTH:
          #  - net.ipv4.ip_forward == 0 in running config AND explicitly set to 0 in a loaded sysctl file
          #  - If IPv6 is enabled: net.ipv6.conf.all.forwarding == 0 in running config AND explicitly set to 0 in a loaded sysctl file
          # (If IPv6 is disabled, the IPv6 check is treated as Not Applicable/Pass.)
          set -euo pipefail

          ipv6_enabled() {
            # IPv6 considered enabled unless both "disable_ipv6" toggles are 1 OR kernel param disables module
            if grep -Pqs '^\s*0\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
              return 0
            fi
            if sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -qx '0' \
               || sysctl -n net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -qx '0'; then
              return 0
            fi
            return 1
          }

          # 1) Running values
          bad=0
          rv4="$(sysctl -n net.ipv4.ip_forward 2>/dev/null || echo '')"
          [ "$rv4" = "0" ] || { echo "Fail: net.ipv4.ip_forward running=$rv4 (expected 0)"; bad=1; }

          ipv6_needed=0
          if ipv6_enabled; then
            ipv6_needed=1
            rv6="$(sysctl -n net.ipv6.conf.all.forwarding 2>/dev/null || echo '')"
            [ "$rv6" = "0" ] || { echo "Fail: net.ipv6.conf.all.forwarding running=$rv6 (expected 0)"; bad=1; }
          fi

          # 2) Loaded config (respect systemd-sysctl precedence when available)
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Any bad / overriding values for IPv4?
          if grep -Piq '^\s*net\.ipv4\.ip_forward\s*=\s*(1|[2-9]|[1-9][0-9]+)\b' <<< "$conf"; then
            echo "Fail: persistent config sets net.ipv4.ip_forward to non-zero"
            bad=1
          fi
          # Must be explicitly set to 0 somewhere
          grep -Piq '^\s*net\.ipv4\.ip_forward\s*=\s*0\b' <<< "$conf" \
            || { echo "Fail: persistent config does not explicitly set net.ipv4.ip_forward = 0"; bad=1; }

          # IPv6 persistent checks only if IPv6 enabled
          if [ "$ipv6_needed" -eq 1 ]; then
            if grep -Piq '^\s*net\.ipv6\.conf\.all\.forwarding\s*=\s*(1|[2-9]|[1-9][0-9]+)\b' <<< "$conf"; then
              echo "Fail: persistent config sets net.ipv6.conf.all.forwarding to non-zero"
              bad=1
            fi
            grep -Piq '^\s*net\.ipv6\.conf\.all\.forwarding\s*=\s*0\b' <<< "$conf" \
              || { echo "Fail: persistent config does not explicitly set net.ipv6.conf.all.forwarding = 0"; bad=1; }
          fi

          if [ "$bad" -eq 0 ]; then
            echo "ip_forwarding_ok"
          else
            echo "ip_forwarding_bad"
          fi
        tests:
          test_items:
            - flag: "ip_forwarding_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persistently enforce forwarding disabled and apply immediately.
          # IPv4
          printf '%s\n' 'net.ipv4.ip_forward = 0' > /etc/sysctl.d/60-netipv4_sysctl.conf
          sysctl -w net.ipv4.ip_forward=0
          sysctl -w net.ipv4.route.flush=1

          # IPv6 (only if IPv6 is enabled in your environment)
          if grep -Pqs '^\s*0\b' /sys/module/ipv6/parameters/disable 2>/dev/null || \
             sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -qx '0' || \
             sysctl -n net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -qx '0'; then
            printf '%s\n' 'net.ipv6.conf.all.forwarding = 0' > /etc/sysctl.d/60-netipv6_sysctl.conf
            sysctl -w net.ipv6.conf.all.forwarding=0
            sysctl -w net.ipv6.route.flush=1
          fi

          # Reload all persisted settings (or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


      - id: 3.3.2
        description: "Ensure packet redirect sending is disabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require BOTH:
          #  - net.ipv4.conf.all.send_redirects == 0 and net.ipv4.conf.default.send_redirects == 0 in the running config
          #  - BOTH explicitly set to 0 in a loaded sysctl file, with no conflicting non-zero later entries
          set -euo pipefail

          bad=0

          # 1) Running values
          r_all="$(sysctl -n net.ipv4.conf.all.send_redirects 2>/dev/null || echo '')"
          r_def="$(sysctl -n net.ipv4.conf.default.send_redirects 2>/dev/null || echo '')"
          [ "$r_all" = "0" ] || { echo "Fail: net.ipv4.conf.all.send_redirects running=$r_all (expected 0)"; bad=1; }
          [ "$r_def" = "0" ] || { echo "Fail: net.ipv4.conf.default.send_redirects running=$r_def (expected 0)"; bad=1; }

          # 2) Loaded config (respect systemd-sysctl precedence when available)
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Any bad / overriding values?
          for key in net.ipv4.conf.all.send_redirects net.ipv4.conf.default.send_redirects; do
            if grep -Piq "^\s*${key//./\.}\s*=\s*(1|[2-9]|[1-9][0-9]+)\b" <<<"$conf"; then
              echo "Fail: persistent config sets $key to non-zero"
              bad=1
            fi
            # Must be explicitly set to 0 somewhere
            grep -Piq "^\s*${key//./\.}\s*=\s*0\b" <<<"$conf" \
              || { echo "Fail: persistent config does not explicitly set $key = 0"; bad=1; }
          done

          if [ "$bad" -eq 0 ]; then
            echo "send_redirects_ok"
          else
            echo "send_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "send_redirects_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          # Persist settings
          cat > /etc/sysctl.d/60-netipv4_send_redirects.conf <<'EOF'
          net.ipv4.conf.all.send_redirects = 0
          net.ipv4.conf.default.send_redirects = 0
          EOF

          # Apply immediately
          sysctl -w net.ipv4.conf.all.send_redirects=0
          sysctl -w net.ipv4.conf.default.send_redirects=0
          sysctl -w net.ipv4.route.flush=1

          # Reload all persisted settings (optional)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


      - id: 3.3.3
        description: "Ensure bogus ICMP responses are ignored (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require BOTH:
          #  - net.ipv4.icmp_ignore_bogus_error_responses == 1 in the running config
          #  - Explicitly set to 1 in a loaded sysctl file, with no conflicting non-1 entries
          set -euo pipefail

          bad=0
          key="net.ipv4.icmp_ignore_bogus_error_responses"

          # 1) Running value
          rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
          [ "$rv" = "1" ] || { echo "Fail: $key running=$rv (expected 1)"; bad=1; }

          # 2) Loaded config (respect systemd-sysctl precedence when available)
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Any bad / overriding values?
          if grep -Piq "^\s*${key//./\.}\s*=\s*(0|[2-9]|[1-9][0-9]+)\b" <<<"$conf"; then
            echo "Fail: persistent config sets $key to a non-1 value"
            bad=1
          fi
          # Must be explicitly set to 1 somewhere
          grep -Piq "^\s*${key//./\.}\s*=\s*1\b" <<<"$conf" \
            || { echo "Fail: persistent config does not explicitly set $key = 1"; bad=1; }

          if [ "$bad" -eq 0 ]; then
            echo "icmp_bogus_ok"
          else
            echo "icmp_bogus_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_bogus_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          # Persist setting
          cat > /etc/sysctl.d/60-netipv4_icmp_bogus.conf <<'EOF'
          net.ipv4.icmp_ignore_bogus_error_responses = 1
          EOF

          # Apply immediately
          sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
          sysctl -w net.ipv4.route.flush=1

          # Reload all persisted settings (optional)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true

      - id: 3.3.4
        description: "Ensure broadcast ICMP requests are ignored (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require BOTH:
          #  - net.ipv4.icmp_echo_ignore_broadcasts == 1 in the running config
          #  - Explicitly set to 1 in a loaded sysctl file, with no conflicting non-1 entries
          set -euo pipefail

          bad=0
          key="net.ipv4.icmp_echo_ignore_broadcasts"

          # 1) Running value
          rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
          [ "$rv" = "1" ] || { echo "Fail: $key running=$rv (expected 1)"; bad=1; }

          # 2) Loaded config (respect systemd-sysctl precedence when available)
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Any bad / overriding values?
          if grep -Piq "^\s*${key//./\.}\s*=\s*(0|[2-9]|[1-9][0-9]+)\b" <<<"$conf"; then
            echo "Fail: persistent config sets $key to a non-1 value"
            bad=1
          fi
          # Must be explicitly set to 1 somewhere
          grep -Piq "^\s*${key//./\.}\s*=\s*1\b" <<<"$conf" \
            || { echo "Fail: persistent config does not explicitly set $key = 1"; bad=1; }

          if [ "$bad" -eq 0 ]; then
            echo "icmp_bcast_ok"
          else
            echo "icmp_bcast_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_bcast_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          # Persist setting
          cat > /etc/sysctl.d/60-netipv4_icmp_broadcast.conf <<'EOF'
          net.ipv4.icmp_echo_ignore_broadcasts = 1
          EOF

          # Apply immediately
          sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
          sysctl -w net.ipv4.route.flush=1

          # Reload all persisted settings (optional)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true

      - id: 3.3.5
        description: "Ensure ICMP redirects are not accepted (Automated)"
        audit: |
          bad=0

          # Detect whether IPv6 is enabled (either the module is enabled or sysctl flags say enabled)
          ipv6_enabled="yes"
          if grep -Pqs '^\s*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_enabled="no"
          else
            # If both 'all' and 'default' are disabled via sysctl, treat as disabled
            if sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs '\b=\s*1\b' && \
               sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs '\b=\s*1\b'; then
              ipv6_enabled="no"
            fi
          fi

          # Collect effective config text in precedence order (systemd-sysctl if available)
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          check_key() {
            local key="$1" want="$2" apply="$3"  # apply=yes|no (for IPv6 NA handling)
            # Running value
            if [ "$apply" = "yes" ]; then
              rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
              if [ "$rv" = "$want" ]; then
                :
              else
                echo "Fail: $key running=$rv (expected $want)"
                bad=1
              fi
            fi
            # Persistent config (only if apply=yes)
            if [ "$apply" = "yes" ]; then
              # Any conflicting non-wanted value present?
              if grep -Piq "^\s*${key//./\.}\s*=\s*(?!$want\b)\d+\b" <<<"$conf"; then
                echo "Fail: persistent config sets $key to a non-$want value"
                bad=1
              fi
              # Must be explicitly set to wanted value somewhere
              grep -Piq "^\s*${key//./\.}\s*=\s*${want}\b" <<<"$conf" \
                || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }
            fi
          }

          # IPv4 (always applicable)
          check_key "net.ipv4.conf.all.accept_redirects" 0 "yes"
          check_key "net.ipv4.conf.default.accept_redirects" 0 "yes"

          # IPv6 (only when enabled)
          if [ "$ipv6_enabled" = "yes" ]; then
            check_key "net.ipv6.conf.all.accept_redirects" 0 "yes"
            check_key "net.ipv6.conf.default.accept_redirects" 0 "yes"
          else
            # When IPv6 disabled, we do not require these settings
            :
          fi

          if [ "$bad" -eq 0 ]; then
            echo "icmp_redirects_ok"
          else
            echo "icmp_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_redirects_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail
          # Persist IPv4 requirements
          cat > /etc/sysctl.d/60-netipv4_accept_redirects.conf <<'EOF'
          net.ipv4.conf.all.accept_redirects = 0
          net.ipv4.conf.default.accept_redirects = 0
          EOF

          # If IPv6 is enabled on this system, also persist IPv6 requirements
          ipv6_enabled="yes"
          if grep -Pqs '^\s*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_enabled="no"
          else
            if sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs '\b=\s*1\b' && \
               sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs '\b=\s*1\b'; then
              ipv6_enabled="no"
            fi
          fi
          if [ "$ipv6_enabled" = "yes" ]; then
            cat > /etc/sysctl.d/60-netipv6_accept_redirects.conf <<'EOF'
            net.ipv6.conf.all.accept_redirects = 0
            net.ipv6.conf.default.accept_redirects = 0
            EOF
          fi

          # Apply immediately
          sysctl -w net.ipv4.conf.all.accept_redirects=0
          sysctl -w net.ipv4.conf.default.accept_redirects=0
          [ "$ipv6_enabled" = "yes" ] && sysctl -w net.ipv6.conf.all.accept_redirects=0
          [ "$ipv6_enabled" = "yes" ] && sysctl -w net.ipv6.conf.default.accept_redirects=0

          # Flush routes and reload persisted settings
          sysctl -w net.ipv4.route.flush=1
          [ "$ipv6_enabled" = "yes" ] && sysctl -w net.ipv6.route.flush=1 || true
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


      - id: 3.3.6
        description: "Ensure secure ICMP redirects are not accepted (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require:
          #   net.ipv4.conf.all.secure_redirects == 0 (running) AND explicitly set to 0 in a loaded sysctl file (no conflicting values)
          #   net.ipv4.conf.default.secure_redirects == 0 (running) AND explicitly set to 0 in a loaded sysctl file (no conflicting values)
          set -euo pipefail

          bad=0

          # Gather persisted config honoring systemd-sysctl precedence if available
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          check_key() {
            local key="$1" want="$2"

            # Running value must match
            rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
            if [ "$rv" = "$want" ]; then
              :
            else
              echo "Fail: $key running=$rv (expected $want)"
              bad=1
            fi

            # No conflicting non-wanted values in persisted config
            if grep -Piq "^\s*${key//./\.}\s*=\s*(?!$want\b)\d+\b" <<<"$conf"; then
              echo "Fail: persistent config sets $key to a non-$want value"
              bad=1
            fi

            # Must be explicitly set to wanted value somewhere
            grep -Piq "^\s*${key//./\.}\s*=\s*${want}\b" <<<"$conf" \
              || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }
          }

          check_key "net.ipv4.conf.all.secure_redirects" 0
          check_key "net.ipv4.conf.default.secure_redirects" 0

          if [ "$bad" -eq 0 ]; then
            echo "secure_redirects_ok"
          else
            echo "secure_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "secure_redirects_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persist requirements
          cat > /etc/sysctl.d/60-netipv4_secure_redirects.conf <<'EOF'
          net.ipv4.conf.all.secure_redirects = 0
          net.ipv4.conf.default.secure_redirects = 0
          EOF

          # Apply immediately
          sysctl -w net.ipv4.conf.all.secure_redirects=0
          sysctl -w net.ipv4.conf.default.secure_redirects=0
          sysctl -w net.ipv4.route.flush=1

          # Reload persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true

      - id: 3.3.7
        description: "Ensure reverse path filtering is enabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require:
          #   net.ipv4.conf.all.rp_filter == 1 (running) AND explicitly set to 1 in a loaded sysctl file (no conflicting values)
          #   net.ipv4.conf.default.rp_filter == 1 (running) AND explicitly set to 1 in a loaded sysctl file (no conflicting values)
          set -euo pipefail

          bad=0

          # Gather persisted config honoring systemd-sysctl precedence if available
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          check_key() {
            local key="$1" want="$2"

            # Running value must match
            rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
            if [ "$rv" = "$want" ]; then
              :
            else
              echo "Fail: $key running=$rv (expected $want)"
              bad=1
            fi

            # No conflicting non-wanted values in persisted config
            if grep -Piq "^\s*${key//./\.}\s*=\s*(?!$want\b)\d+\b" <<<"$conf"; then
              echo "Fail: persistent config sets $key to a non-$want value"
              bad=1
            fi

            # Must be explicitly set to wanted value somewhere
            grep -Piq "^\s*${key//./\.}\s*=\s*${want}\b" <<<"$conf" \
              || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }
          }

          check_key "net.ipv4.conf.all.rp_filter" 1
          check_key "net.ipv4.conf.default.rp_filter" 1

          if [ "$bad" -eq 0 ]; then
            echo "rp_filter_ok"
          else
            echo "rp_filter_bad"
          fi
        tests:
          test_items:
            - flag: "rp_filter_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persist requirements
          cat > /etc/sysctl.d/60-netipv4_rp_filter.conf <<'EOF'
          net.ipv4.conf.all.rp_filter = 1
          net.ipv4.conf.default.rp_filter = 1
          EOF

          # Apply immediately
          sysctl -w net.ipv4.conf.all.rp_filter=1
          sysctl -w net.ipv4.conf.default.rp_filter=1
          sysctl -w net.ipv4.route.flush=1

          # Reload persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


      - id: 3.3.8
        description: "Ensure source routed packets are not accepted (Automated)"
        audit: |
          bad=0

          # Persisted config honoring systemd-sysctl precedence if available
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          ipv6_enabled() {
            # IPv6 considered enabled if kernel module not disabled and sysctl toggles not both 1
            if [ -r /sys/module/ipv6/parameters/disable ] && grep -Pqs '^\s*1\b' /sys/module/ipv6/parameters/disable; then
              return 1
            fi
            a="$(sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null || echo 0)"
            d="$(sysctl -n net.ipv6.conf.default.disable_ipv6 2>/dev/null || echo 0)"
            if [ "$a" = "1" ] && [ "$d" = "1" ]; then
              return 1
            fi
            return 0
          }

          check_key() {
            local key="$1" want="$2" family="$3"

            if [ "$family" = "ipv6" ] && ! ipv6_enabled; then
              echo "Note: $key not applicable (IPv6 disabled)"
              return 0
            fi

            # Running value
            rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
            if [ "$rv" = "$want" ]; then
              :
            else
              echo "Fail: $key running=$rv (expected $want)"
              bad=1
            fi

            # No conflicting persisted values
            if grep -Piq "^\s*${key//./\.}\s*=\s*(?!$want\b)\d+\b" <<<"$conf"; then
              echo "Fail: persistent config sets $key to a non-$want value"
              bad=1
            fi

            # Must be explicitly set to desired value somewhere
            grep -Piq "^\s*${key//./\.}\s*=\s*${want}\b" <<<"$conf" \
              || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }
          }

          check_key "net.ipv4.conf.all.accept_source_route" 0 "ipv4"
          check_key "net.ipv4.conf.default.accept_source_route" 0 "ipv4"
          check_key "net.ipv6.conf.all.accept_source_route" 0 "ipv6"
          check_key "net.ipv6.conf.default.accept_source_route" 0 "ipv6"

          if [ "$bad" -eq 0 ]; then
            echo "src_route_ok"
          else
            echo "src_route_bad"
          fi
        tests:
          test_items:
            - flag: "src_route_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persist IPv4 requirements
          cat > /etc/sysctl.d/60-netipv4_source_route.conf <<'EOF'
          net.ipv4.conf.all.accept_source_route = 0
          net.ipv4.conf.default.accept_source_route = 0
          EOF

          # If IPv6 is in use on this system, also persist IPv6 requirements
          if [ -d /proc/sys/net/ipv6 ]; then
            cat > /etc/sysctl.d/60-netipv6_source_route.conf <<'EOF'
            net.ipv6.conf.all.accept_source_route = 0
            net.ipv6.conf.default.accept_source_route = 0
            EOF
          fi

          # Apply immediately (IPv4)
          sysctl -w net.ipv4.conf.all.accept_source_route=0
          sysctl -w net.ipv4.conf.default.accept_source_route=0
          sysctl -w net.ipv4.route.flush=1

          # Apply immediately (IPv6) if available
          if [ -d /proc/sys/net/ipv6 ]; then
            sysctl -w net.ipv6.conf.all.accept_source_route=0 || true
            sysctl -w net.ipv6.conf.default.accept_source_route=0 || true
            sysctl -w net.ipv6.route.flush=1 || true
          fi

          # Reload persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


      - id: 3.3.9
        description: "Ensure suspicious packets are logged (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Verify:
          #  - net.ipv4.conf.all.log_martians == 1 (running) and explicitly set to 1 in a loaded sysctl file
          #  - net.ipv4.conf.default.log_martians == 1 (running) and explicitly set to 1 in a loaded sysctl file
          #  - No conflicting persisted values
          set -euo pipefail

          bad=0

          # Collect persisted config honoring systemd-sysctl precedence when available
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Also consider UFW's IPT_SYSCTL if present (not covered by systemd-sysctl)
          if [ -f /etc/default/ufw ]; then
            ipt_sysctl="$(awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw | xargs)"
            if [ -n "$ipt_sysctl" ] && [ -f "$ipt_sysctl" ]; then
              conf="$conf
          $(sed -n 'p' -- "$ipt_sysctl")"
            fi
          fi

          check_key() {
            local key="$1" want="$2"

            # Running value
            rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
            if [ "$rv" = "$want" ]; then
              :
            else
              echo "Fail: $key running=$rv (expected $want)"
              bad=1
            fi

            # No conflicting persisted values
            if grep -Piq "^\s*${key//./\.}\s*=\s*(?!$want\b)\d+\b" <<<"$conf"; then
              echo "Fail: persistent config sets $key to a non-$want value"
              bad=1
            fi

            # Must be explicitly set to desired value somewhere
            grep -Piq "^\s*${key//./\.}\s*=\s*${want}\b" <<<"$conf" \
              || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }
          }

          check_key "net.ipv4.conf.all.log_martians" 1
          check_key "net.ipv4.conf.default.log_martians" 1

          if [ "$bad" -eq 0 ]; then
            echo "log_martians_ok"
          else
            echo "log_martians_bad"
          fi
        tests:
          test_items:
            - flag: "log_martians_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persist IPv4 requirements
          cat > /etc/sysctl.d/60-netipv4_log_martians.conf <<'EOF'
          net.ipv4.conf.all.log_martians = 1
          net.ipv4.conf.default.log_martians = 1
          EOF

          # Apply immediately
          sysctl -w net.ipv4.conf.all.log_martians=1
          sysctl -w net.ipv4.conf.default.log_martians=1
          sysctl -w net.ipv4.route.flush=1

          # Reload persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true

      - id: 3.3.10
        description: "Ensure TCP SYN cookies is enabled (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require: net.ipv4.tcp_syncookies == 1 in running config AND explicitly set to 1 in a loaded sysctl file
          set -euo pipefail

          bad=0
          key="net.ipv4.tcp_syncookies"
          want="1"

          # Gather persisted config honoring systemd-sysctl precedence
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Also consider UFW IPT_SYSCTL if present
          if [ -f /etc/default/ufw ]; then
            ipt_sysctl="$(awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw | xargs)"
            if [ -n "$ipt_sysctl" ] && [ -f "$ipt_sysctl" ]; then
              conf="$conf
          $(sed -n 'p' -- "$ipt_sysctl")"
            fi
          fi

          # 1) Running value
          rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
          if [ "$rv" != "$want" ]; then
            echo "Fail: $key running=$rv (expected $want)"
            bad=1
          fi

          # 2) No conflicting persisted values
          if grep -Piq "^\s*${key//./\.}\s*=\s*(?!$want\b)\d+\b" <<<"$conf"; then
            echo "Fail: persistent config sets $key to a non-$want value"
            bad=1
          fi

          # 3) Must be explicitly set to desired value somewhere
          grep -Piq "^\s*${key//./\.}\s*=\s*${want}\b" <<<"$conf" \
            || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }

          if [ "$bad" -eq 0 ]; then
            echo "syncookies_ok"
          else
            echo "syncookies_bad"
          fi
        tests:
          test_items:
            - flag: "syncookies_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persist requirement
          mkdir -p /etc/sysctl.d
          if grep -Pq '^\s*net\.ipv4\.tcp_syncookies\b' /etc/sysctl.d/*.conf 2>/dev/null || grep -Pq '^\s*net\.ipv4\.tcp_syncookies\b' /etc/sysctl.conf 2>/dev/null; then
            # Remove conflicting lines first
            sed -i '/^\s*net\.ipv4\.tcp_syncookies\s*=/d' /etc/sysctl.conf 2>/dev/null || true
            for f in /etc/sysctl.d/*.conf; do
              [ -f "$f" ] && sed -i '/^\s*net\.ipv4\.tcp_syncookies\s*=/d' "$f" 2>/dev/null || true
            done
          fi
          echo "net.ipv4.tcp_syncookies = 1" > /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply immediately
          sysctl -w net.ipv4.tcp_syncookies=1
          sysctl -w net.ipv4.route.flush=1

          # Reload persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true

      - id: 3.3.11
        description: "Ensure IPv6 router advertisements are not accepted (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Require (when IPv6 is enabled): net.ipv6.conf.all.accept_ra == 0 AND net.ipv6.conf.default.accept_ra == 0
          # …and both are explicitly set to 0 in a loaded sysctl config, with no conflicting values.
          set -euo pipefail

          keys=("net.ipv6.conf.all.accept_ra" "net.ipv6.conf.default.accept_ra")
          want="0"
          bad=0

          # Detect if IPv6 is effectively disabled (any standard mechanism)
          ipv6_disabled="no"
          if [ -e /sys/module/ipv6/parameters/disable ] && grep -Pqs '^\s*1\b' /sys/module/ipv6/parameters/disable; then
            ipv6_disabled="yes"
          fi
          if sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs '=\s*1\b' && \
             sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs '=\s*1\b'; then
            ipv6_disabled="yes"
          fi

          # Gather persisted config honoring systemd-sysctl precedence
          if command -v /usr/lib/systemd/systemd-sysctl >/dev/null 2>&1; then
            conf="$(
              /usr/lib/systemd/systemd-sysctl --cat-config 2>/dev/null \
                | sed -e 's/^\s*#\s*\/.*\.conf$//'
            )"
          else
            conf="$(
              { [ -f /etc/sysctl.conf ] && cat /etc/sysctl.conf; } 2>/dev/null
              { cat /etc/sysctl.d/*.conf; } 2>/dev/null || true
            )"
          fi

          # Also consider UFW IPT_SYSCTL if present
          if [ -f /etc/default/ufw ]; then
            ipt_sysctl="$(awk -F= '/^\s*IPT_SYSCTL=/ {print $2}' /etc/default/ufw | xargs)"
            if [ -n "${ipt_sysctl:-}" ] && [ -f "$ipt_sysctl" ]; then
              conf="$conf
          $(sed -n 'p' -- "$ipt_sysctl")"
            fi
          fi

          if [ "$ipv6_disabled" = "yes" ]; then
            echo "ipv6_disabled_ok"
            exit 0
          fi

          # 1) Running values
          for key in "${keys[@]}"; do
            rv="$(sysctl -n "$key" 2>/dev/null || echo '')"
            if [ "$rv" != "$want" ]; then
              echo "Fail: $key running=$rv (expected $want)"
              bad=1
            fi
          done

          # 2) No conflicting persisted values & must be explicitly set to wanted value
          for key in "${keys[@]}"; do
            pat_key="${key//./\\.}"
            if grep -Piq "^\s*${pat_key}\s*=\s*(?!${want}\b)\S+" <<<"$conf"; then
              echo "Fail: persistent config sets $key to a non-$want value"
              bad=1
            fi
            grep -Piq "^\s*${pat_key}\s*=\s*${want}\b" <<<"$conf" \
              || { echo "Fail: persistent config does not explicitly set $key = $want"; bad=1; }
          done

          if [ "$bad" -eq 0 ]; then
            echo "ipv6_ra_ok"
          else
            echo "ipv6_ra_bad"
          fi
        tests:
          test_items:
            - flag: "ipv6_ra_ok"
              set: true
            - flag: "ipv6_disabled_ok"
              set: true
          bin_op: "or"
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          # Persist desired values
          mkdir -p /etc/sysctl.d

          # Remove any conflicting lines
          for f in /etc/sysctl.conf /etc/sysctl.d/*.conf; do
            [ -f "$f" ] || continue
            sed -i '/^\s*net\.ipv6\.conf\.all\.accept_ra\s*=/d' "$f" || true
            sed -i '/^\s*net\.ipv6\.conf\.default\.accept_ra\s*=/d' "$f" || true
          done

          # Write authoritative settings
          cat > /etc/sysctl.d/60-netipv6_sysctl.conf <<'EOF'
          net.ipv6.conf.all.accept_ra = 0
          net.ipv6.conf.default.accept_ra = 0
          EOF

          # Apply immediately (harmless if IPv6 is disabled)
          sysctl -w net.ipv6.conf.all.accept_ra=0 || true
          sysctl -w net.ipv6.conf.default.accept_ra=0 || true
          sysctl -w net.ipv6.route.flush=1 || true

          # Reload persisted settings (optional; or reboot)
          /usr/lib/systemd/systemd-sysctl 2>/dev/null || sysctl --system
        scored: true


  - id: 4
    description: "Host Based Firewall"
    checks:
  - id: 4.1
    description: "Configure a firewall utility"
    checks:
      - id: 4.1.1
        description: "Ensure nftables is installed (Automated)"
        audit: "rpm -q nftables"
        tests:
          test_items:
            - flag: "package nftables is not installed"
              set: false
        remediation: |
          Run the following command to install nftables

          # dnf install nftables
        scored: true

      - id: 4.1.2
        description: "Ensure a single firewall configuration utility is in use (Automated)"
        audit: |
          # Pass if EXACTLY ONE of these is true:
          #  - firewalld is enabled+active AND nftables is (masked|disabled|not installed) and inactive
          #  - nftables is enabled+active AND firewalld is (masked|disabled|not installed) and inactive
          set -euo pipefail

          # Package presence
          fwd_installed=$([ rpm -q firewalld >/dev/null 2>&1 ] && echo 1 || echo 0)
          nft_installed=$([ rpm -q nftables  >/dev/null 2>&1 ] && echo 1 || echo 0)

          # Unit states (fallback to 'na' when unit doesn't exist)
          fwd_enabled="$(systemctl is-enabled firewalld 2>/dev/null || echo na)"
          fwd_active="$(systemctl is-active  firewalld 2>/dev/null || echo na)"
          nft_enabled="$(systemctl is-enabled nftables  2>/dev/null || echo na)"
          nft_active="$(systemctl is-active  nftables  2>/dev/null || echo na)"

          # Helpers
          is_off_like() { case "$1" in disabled|masked|na) return 0;; *) return 1;; esac; }

          if [ "$fwd_enabled" = "enabled" ] && [ "$fwd_active" = "active" ] && \
             { [ "$nft_installed" -eq 0 ] || { is_off_like "$nft_enabled" && [ "$nft_active" = "inactive" ]; }; }; then
            echo "single_firewalld_in_use"
          elif [ "$nft_enabled" = "enabled" ] && [ "$nft_active" = "active" ] && \
               { [ "$fwd_installed" -eq 0 ] || { is_off_like "$fwd_enabled" && [ "$fwd_active" = "inactive" ]; }; }; then
            echo "single_nftables_in_use"
          else
            # Helpful fail classifications (not used in tests)
            if [ "$fwd_active" = "active" ] && [ "$nft_active" = "active" ]; then
              echo "both_active"
            elif [ "$fwd_installed" -eq 0 ] && [ "$nft_installed" -eq 0 ]; then
              echo "neither_installed"
            else
              echo "ambiguous_or_misconfigured"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "single_firewalld_in_use"
              set: true
            - flag: "single_nftables_in_use"
              set: true
        remediation: |
          # Choose ONE firewall utility and suppress the other.
          # Preference: nftables (modern) unless firewalld is already active.

          fwd_installed=$([ rpm -q firewalld >/dev/null 2>&1 ] && echo 1 || echo 0)
          nft_installed=$([ rpm -q nftables  >/dev/null 2>&1 ] && echo 1 || echo 0)

          fwd_enabled="$(systemctl is-enabled firewalld 2>/dev/null || echo na)"
          fwd_active="$(systemctl is-active  firewalld 2>/dev/null || echo na)"
          nft_enabled="$(systemctl is-enabled nftables  2>/dev/null || echo na)"
          nft_active="$(systemctl is-active  nftables  2>/dev/null || echo na)"

          if [ "$fwd_active" = "active" ] && [ "$nft_active" = "active" ]; then
            # Both active → keep the one already enabled and mask the other
            if [ "$fwd_enabled" = "enabled" ] && [ "$nft_enabled" != "enabled" ]; then
              systemctl stop nftables
              systemctl --now mask nftables
            elif [ "$nft_enabled" = "enabled" ] && [ "$fwd_enabled" != "enabled" ]; then
              systemctl stop firewalld
              systemctl --now mask firewalld
            else
              # Default: keep firewalld, mask nftables
              systemctl stop nftables
              systemctl --now mask nftables
            fi
          elif [ "$fwd_enabled" = "enabled" ] && [ "$fwd_active" = "active" ]; then
            # Firewalld already in use → ensure nftables is suppressed
            systemctl stop nftables 2>/dev/null || true
            systemctl --now mask nftables 2>/dev/null || true
          elif [ "$nft_enabled" = "enabled" ] && [ "$nft_active" = "active" ]; then
            # Nftables already in use → ensure firewalld is suppressed
            systemctl stop firewalld 2>/dev/null || true
            systemctl --now mask firewalld 2>/dev/null || true
          else
            # Neither in use or ambiguous → standardize on nftables
            if [ "$nft_installed" -eq 0 ]; then
              dnf -q -y install nftables
            fi
            systemctl unmask nftables 2>/dev/null || true
            systemctl enable --now nftables
            if [ "$fwd_installed" -eq 1 ]; then
              systemctl stop firewalld 2>/dev/null || true
              systemctl --now mask firewalld 2>/dev/null || true
            fi
          fi
        scored: true


  - id: 4.2
    description: "Configure FirewallID"
    checks:
      - id: 4.2.1
        description: "Ensure firewalld drops unnecessary services and ports (Manual)"
        audit: |
          systemctl is-enabled firewalld.service | grep -q 'enabled' && firewall-cmd --list-all --zone="$(firewall-cmd --list-all | awk '/\(active\)/ { print $1 }')" | grep -P -- '^\h*(services:|ports:)'
        type: manual
        remediation: |
          If Firewalld is in use on the system:

          Run the following command to remove an unnecessary service:

          # firewall-cmd --remove-service=<service>
          Example:

          # firewall-cmd --remove-service=cockpit
          Run the following command to remove an unnecessary port:

          # firewall-cmd --remove-port=<port-number>/<port-type>
          Example:

          # firewall-cmd --remove-port=25/tcp
          Run the following command to make new settings persistent:

          # firewall-cmd --runtime-to-permanent
        scored: false

      - id: 4.2.2
        description: "Ensure firewalld loopback traffic is configured (Automated)"
        audit: |
          {
             l_output="" l_output2="" l_hbfw=""
             if systemctl is-enabled firewalld.service | grep -q 'enabled'; then
                echo -e "\n - FirewallD is in use on the system" && l_hbfw="fwd"
             elif systemctl is-enabled nftables.service 2>/dev/null | grep -q 'enabled'; then
                echo -e "\n - nftables is in use on the system \n - Recommendation is NA" && l_hbfw="nft"
             else
                echo -e "\n - Error - Neither FirewallD or NFTables is enabled\n - Please follow recommendation: \"Ensure a single firewall configuration utility is in use\""
             fi
             if [ "$l_hbfw" = "fwd" ]; then
                if nft list ruleset | awk '/hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -Pq -- '\H+\h+"lo"\h+accept'; then
                   l_output="$l_output\n - Network traffic to the loopback address is correctly set to accept"
                else
                   l_output2="$l_output2\n - Network traffic to the loopback address is not set to accept"
                fi
                l_ipsaddr="$(nft list ruleset | awk '/filter_IN_public_deny|hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -P -- 'ip\h+saddr')"
                if grep -Pq -- 'ip\h+saddr\h+127\.0\.0\.0\/8\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' <<< "$l_ipsaddr" || grep -Pq -- 'ip\h+daddr\h+\!\=\h+127\.0\.0\.1\h+ip\h+saddr\h+127\.0\.0\.1\h+drop' <<< "$l_ipsaddr"; then
                   l_output="$l_output\n - IPv4 network traffic from loopback address correctly set to drop"
                else
                   l_output2="$l_output2\n - IPv4 network traffic from loopback address not set to drop"
                fi
                if grep -Pq -- '^\h*0\h*$' /sys/module/ipv6/parameters/disable; then
                   l_ip6saddr="$(nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep 'ip6 saddr')"
                   if grep -Pq 'ip6\h+saddr\h+::1\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' <<< "$l_ip6saddr" || grep -Pq -- 'ip6\h+daddr\h+\!=\h+::1\h+ip6\h+saddr\h+::1\h+drop' <<< "$l_ip6saddr"; then
                      l_output="$l_output\n - IPv6 network traffic from loopback address correctly set to drop"
                   else
                      l_output2="$l_output2\n - IPv6 network traffic from loopback address not set to drop"
                   fi
                fi
             fi
             if [ "$l_hbfw" = "nft" ] || [ -z "$l_output2" ]; then
                echo -e "\n- Audit Result:\n  *** PASS ***\n$l_output"
             else
                echo -e "\n- Audit Result:\n  *** FAIL ***\n$l_output2\n\n  - Correctly set:\n$l_output"
             fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          Configure firewalld to accept loopback input and drop loopback-source traffic on non-loopback interfaces.

          1. Ensure the loopback interface is trusted (accepted in INPUT):
             # firewall-cmd --permanent --zone=trusted --add-interface=lo
             # firewall-cmd --reload

          2. Add IPv4 anti-spoofing rich rule to drop traffic sourced from 127.0.0.1 that is destined anywhere except 127.0.0.1:
             # firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address="127.0.0.1" destination not address="127.0.0.1" drop'
             # firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv4 source address="127.0.0.1" destination not address="127.0.0.1" drop'
             # firewall-cmd --reload

          3. If IPv6 is enabled ( /sys/module/ipv6/parameters/disable == 0 ), add IPv6 anti-spoofing rich rule:
             # firewall-cmd --permanent --add-rich-rule='rule family=ipv6 source address="::1" destination not address="::1" drop'
             # firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv6 source address="::1" destination not address="::1" drop'
             # firewall-cmd --reload

          Note: If standalone nftables is the active firewall instead of firewalld, this recommendation is Not Applicable.
        scored: true

  - id: 4.3
    description: "Configure NFTables"
    checks:
      - id: 4.3.1
        description: "Ensure nftables base chains exist (Automated)"
        audit: |
          # Pass if the ruleset contains base chains with hooks for input, forward, and output.
          set -euo pipefail

          if ! command -v nft >/dev/null 2>&1; then
            echo "nft_unavailable"
            exit 0
          fi

          rs="$(nft list ruleset 2>/dev/null || true)"
          echo "$rs" | grep -qE '^\s*type\s+filter\s+hook\s+input?'   || { echo "nft_base_chains_missing"; exit 0; }
          echo "$rs" | grep -qE '^\s*type\s+filter\s+hook\s+forward?' || { echo "nft_base_chains_missing"; exit 0; }
          echo "$rs" | grep -qE '^\s*type\s+filter\s+hook\s+output?'  || { echo "nft_base_chains_missing"; exit 0; }

          echo "nft_base_chains_present"
        tests:
          test_items:
            - flag: "nft_base_chains_present"
              set: true
        remediation: |
          IF - NFTables utility is in use on your system:

          Run the following command to create the base chains:

          # nft create chain inet <table name> <base chain name> { type filter hook <(input|forward|output)> priority 0 \; }
          Example:

          # nft create chain inet filter input { type filter hook input priority 0 \; }
          # nft create chain inet filter forward { type filter hook forward priority 0 \; }
          # nft create chain inet filter output { type filter hook output priority 0 \; }
          Note: use the add command if the create command returns an error due to the chain already existing.
        scored: true

      - id: 4.3.2
        description: "Ensure nftables established connections are configured (Manual)"
        audit: |
          systemctl is-enabled nftables.service | grep -q 'enabled' && nft list ruleset | awk '/hook input/,/}/' | grep 'ct state'
        type: "manual"
        remediation: |
          If NFTables utility is in use on your system:
            Configure nftables in accordance with site policy. The following commands will
          implement a policy to allow all established connections:
          # systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule
            inet filter input ip protocol tcp ct state established accept
            # systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule
            inet filter input ip protocol udp ct state established accept
            # systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule
            inet filter input ip protocol icmp ct state established accept
        scored: false

      - id: 4.3.3
        description: "Ensure nftables default deny firewall policy (Automated)"
        audit: |
          # Pass when nftables is in use AND the base chains with hooks for input and forward have "policy drop".
          # (Control scope: only when nftables.service is enabled; firewalld-only hosts are not applicable here.)
          set -euo pipefail

          if ! systemctl --quiet is-enabled nftables.service 2>/dev/null; then
            echo "nft_not_in_use_not_applicable"
            exit 0
          fi

          rs="$(nft list ruleset 2>/dev/null || true)"
          [ -n "$rs" ] || { echo "nft_default_drop_noncompliant"; exit 0; }

          have_input_drop=$(awk '
            /hook[[:space:]]+input[[:space:]]+/ { inblk=1 }
            inblk && /policy[[:space:]]+drop/ { print "yes"; exit }
            inblk && /\}/ { inblk=0 }
          ' <<<"$rs")

          have_forward_drop=$(awk '
            /hook[[:space:]]+forward[[:space:]]+/ { inblk=1 }
            inblk && /policy[[:space:]]+drop/ { print "yes"; exit }
            inblk && /\}/ { inblk=0 }
          ' <<<"$rs")

          if [ "${have_input_drop:-}" = "yes" ] && [ "${have_forward_drop:-}" = "yes" ]; then
            echo "nft_default_drop_compliant"
          else
            echo "nft_default_drop_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nft_default_drop_compliant"
              set: true
            - flag: "nft_not_in_use_not_applicable"
              set: true
        remediation: |
          - IF - NFTables utility is in use on your system:

          Run the following command for the base chains with the input, forward, and output hooks to implement a default DROP policy:

          # nft chain <table family> <table name> <chain name> { policy drop \; }
          Example:

          # nft chain inet filter input { policy drop \; }
          # nft chain inet filter forward { policy drop \; }
        scored: true

      - id: 4.3.4
        description: "Ensure nftables loopback traffic is configured (Automated)"
        audit: |
          nft_flag="nft_loopback_bad"

          # Determine which firewall stack is enabled
          if systemctl is-enabled firewalld.service 2>/dev/null | grep -q 'enabled'; then
            # firewalld in use -> this nftables recommendation is Not Applicable
            echo "nft_loopback_ok"
            exit 0
          elif systemctl is-enabled nftables.service 2>/dev/null | grep -q 'enabled'; then
            hbfw="nft"
          else
            # Neither firewalld nor nftables enabled -> fail
            echo "$nft_flag"
            exit 0
          fi

          if [ "$hbfw" = "nft" ]; then
            ok=true

            # 1) Loopback interface must be accepted in input hook
            if nft list ruleset 2>/dev/null | awk '/hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -Pq -- '\H+\h+"lo"\h+accept'; then
              :
            else
              ok=false
            fi

            # 2) IPv4 anti-spoof for loopback (drop if 127.0.0.0/8 on non-lo)
            ipsaddr="$(nft list ruleset 2>/dev/null | awk '/filter_IN_public_deny|hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -P -- 'ip\h+saddr')"
            if echo "$ipsaddr" | grep -Pq -- 'ip\h+saddr\h+127\.0\.0\.0\/8\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' || \
               echo "$ipsaddr" | grep -Pq -- 'ip\h+daddr\h+\!\=\h+127\.0\.0\.1\h+ip\h+saddr\h+127\.0\.0\.1\h+drop'; then
              :
            else
              ok=false
            fi

            # 3) IPv6 anti-spoof for loopback (only when IPv6 enabled)
            if grep -Pq -- '^\h*0\h*$' /sys/module/ipv6/parameters/disable 2>/dev/null; then
              ip6saddr="$(nft list ruleset 2>/dev/null | awk '/filter_IN_public_deny|hook input/,/}/' | grep -P 'ip6\h+saddr')"
              if echo "$ip6saddr" | grep -Pq -- 'ip6\h+saddr\h+::1\h+(counter\h+packets\h+\d+\h+bytes\h+\d+\h+)?drop' || \
                 echo "$ip6saddr" | grep -Pq -- 'ip6\h+daddr\h+\!=\h+::1\h+ip6\h+saddr\h+::1\h+drop'; then
                :
              else
                ok=false
              fi
            fi

            if $ok; then
              nft_flag="nft_loopback_ok"
            fi
          fi

          echo "$nft_flag"
        tests:
          test_items:
            - flag: "nft_loopback_ok"
              set: true
        remediation: |
          Configure nftables to accept loopback input and drop loopback-source traffic on non-loopback interfaces.

          If firewalld is enabled, this recommendation is Not Applicable.

          1) Ensure loopback input is accepted:
           # nft add rule inet filter input iif lo accept

          2) Add IPv4 anti-spoofing rule to drop traffic sourced from 127.0.0.0/8 on non-loopback:
             # nft add rule inet filter input ip saddr 127.0.0.0/8 counter drop

          3) If IPv6 is enabled ( /sys/module/ipv6/parameters/disable == 0 ), add IPv6 anti-spoofing rule:
             # nft add rule inet filter input ip6 saddr ::1 counter drop
        scored: true


  - id: 5
    description: "Access Control"
    checks:
  - id: 5.1
    description: "Configure SSH Server"
    checks:
      - id: 5.1.1
        description: "Ensure permissions on /etc/ssh/sshd_config are configured (Automated)"
        audit: |
          sshd_cfgperm_flag="sshd_cfgperm_bad"

          # Must exist
          if [ ! -e /etc/ssh/sshd_config ]; then
            echo "$sshd_cfgperm_flag"
            exit 0
          fi

          # Check /etc/ssh/sshd_config: mode <= 0600, owner root, group root
          f_mode="$(stat -Lc '%a' /etc/ssh/sshd_config 2>/dev/null)"
          f_user="$(stat -Lc '%U' /etc/ssh/sshd_config 2>/dev/null)"
          f_group="$(stat -Lc '%G' /etc/ssh/sshd_config 2>/dev/null)"

          main_ok=true
          # 0600 or more restrictive == no group/other bits and no user execute (mask 0177)
          if [ $(( 8#$f_mode & 0177 )) -ne 0 ]; then main_ok=false; fi
          if [ "$f_user" != "root" ]; then main_ok=false; fi
          if [ "$f_group" != "root" ]; then main_ok=false; fi

          # Check *.conf under /etc/ssh/sshd_config.d for the same constraints
          # Any file violating: group/other perms, non-root owner, or non-root group => fail
          bad_conf=""
          if [ -d /etc/ssh/sshd_config.d ]; then
            bad_conf="$(find -L /etc/ssh/sshd_config.d -type f -name '*.conf' \( -perm /0177 -o ! -user root -o ! -group root \) -print -quit 2>/dev/null)"
          fi

          if $main_ok && [ -z "$bad_conf" ]; then
            sshd_cfgperm_flag="sshd_cfgperm_ok"
          fi

          echo "$sshd_cfgperm_flag"
        tests:
          test_items:
            - flag: "sshd_cfgperm_ok"
              set: true
        remediation: |
          Set restrictive permissions and ownership on the OpenSSH server configuration files.

          1) Base file:
             # chmod u-x,og-rwx /etc/ssh/sshd_config
             # chown root:root /etc/ssh/sshd_config

          2) Drop-in configuration (*.conf) under /etc/ssh/sshd_config.d:
             # find /etc/ssh/sshd_config.d -type f -name '*.conf' -exec chmod u-x,og-rwx {} \; -exec chown root:root {} \; 2>/dev/null

          Note:
          - If additional Include paths are used, apply the same ownership (root:root) and permissions (0600 or more restrictive) to *.conf in those locations as well.
        scored: true

      - id: 5.1.2
        description: "Ensure permissions on SSH private host key files are configured (Automated)"
        audit: |
          ssh_hostkey_privperm_flag="ssh_hostkey_privperm_bad"

          # Identify optional SSH private-key group (ssh_keys or _ssh)
          ssh_key_grp="$(awk -F: '($1 ~ /^(ssh_keys|_?ssh)$/){print $1; exit}' /etc/group)"

          # Scope: host private keys under /etc/ssh
          # If no host private keys are present, treat as pass (nothing to evaluate)
          if ! find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key' -print -quit 2>/dev/null | grep -q .; then
            echo "ssh_hostkey_privperm_ok"
            exit 0
          fi

          # Owner must be root
          bad_owner="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key' ! -user root -print -quit 2>/dev/null)"

          # Group must be root or the designated SSH key group (if it exists)
          if [ -n "$ssh_key_grp" ]; then
            bad_group="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key' ! -group root ! -group "$ssh_key_grp" -print -quit 2>/dev/null)"
          else
            bad_group="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key' ! -group root -print -quit 2>/dev/null)"
          fi

          # Permissions:
          # - If group=root -> mode 0600 or more restrictive (no u+x, no g/o perms): mask 0177 must NOT be set
          bad_perm_root="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key' -group root -perm /0177 -print -quit 2>/dev/null)"

          # - If group=${ssh_key_grp} -> mode 0640 or more restrictive (no u+x, no g+wx, no o+rwx): mask 0137 must NOT be set
          if [ -n "$ssh_key_grp" ]; then
            bad_perm_ssh="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key' -group "$ssh_key_grp" -perm /0137 -print -quit 2>/dev/null)"
          else
            bad_perm_ssh=""
          fi

          if [ -z "$bad_owner" ] && [ -z "$bad_group" ] && [ -z "$bad_perm_root" ] && [ -z "$bad_perm_ssh" ]; then
            ssh_hostkey_privperm_flag="ssh_hostkey_privperm_ok"
          fi

          echo "$ssh_hostkey_privperm_flag"
        tests:
          test_items:
            - flag: "ssh_hostkey_privperm_ok"
              set: true
        remediation: |
          Set correct ownership and permissions on SSH private host key files (e.g., /etc/ssh/ssh_host_*_key).

          1) Default (root-only access: 0600):
             # chown root:root /etc/ssh/ssh_host_*_key 2>/dev/null
             # chmod 0600 /etc/ssh/ssh_host_*_key 2>/dev/null

          2) If your organization uses a dedicated group for OpenSSH private keys (e.g., ssh_keys or _ssh) to allow controlled group read (0640):
             # getent group ssh_keys >/dev/null && chgrp ssh_keys /etc/ssh/ssh_host_*_key
             # getent group _ssh >/dev/null && chgrp _ssh /etc/ssh/ssh_host_*_key
             # chmod 0640 /etc/ssh/ssh_host_*_key

          Notes:
          - Owner must be root in all cases.
          - If using a designated SSH private-key group, that group must own the files; otherwise, group should be root.
          - Apply these settings to all SSH host private key files under /etc/ssh.
        scored: true

      - id: 5.1.3
        description: "Ensure permissions on SSH public host key files are configured (Automated)"
        audit: |
          ssh_hostkey_pubperm_flag="ssh_hostkey_pubperm_bad"

          # Locate SSH public host key files
          if ! find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -print -quit 2>/dev/null | grep -q .; then
            # No public host keys found -> nothing to evaluate
            echo "ssh_hostkey_pubperm_ok"
            exit 0
          fi

          # Must be owned by root:root
          bad_owner="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' ! -user root -print -quit 2>/dev/null)"
          bad_group="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' ! -group root -print -quit 2>/dev/null)"

          # Mode must be 0644 or more restrictive:
          #   - no user execute
          #   - no group write/execute
          #   - no other write/execute
          # find -perm /0133 flags any file with these disallowed bits set
          bad_perm="$(find -L /etc/ssh -xdev -type f -name 'ssh_host_*_key.pub' -perm /0133 -print -quit 2>/dev/null)"

          if [ -z "$bad_owner" ] && [ -z "$bad_group" ] && [ -z "$bad_perm" ]; then
            ssh_hostkey_pubperm_flag="ssh_hostkey_pubperm_ok"
          fi

          echo "$ssh_hostkey_pubperm_flag"
        tests:
          test_items:
            - flag: "ssh_hostkey_pubperm_ok"
              set: true
        remediation: |
          Set ownership and permissions on SSH public host key files (e.g., /etc/ssh/ssh_host_*_key.pub):

          # Ensure root ownership and 0644-or-more-restrictive permissions
          # (no user execute; no group/other write or execute)
          # These commands are idempotent and safe if rerun.
          chown root:root /etc/ssh/ssh_host_*_key.pub 2>/dev/null
          chmod u-x,go-wx /etc/ssh/ssh_host_*_key.pub 2>/dev/null

          Notes:
          - Required state: owner=root, group=root, and mode 0644 or more restrictive.
          - Apply to all SSH public host key files in /etc/ssh.
        scored: true

      - id: 5.1.4
        description: "Ensure sshd Ciphers are configured (Automated)"
        audit: |
          sshd_ciphers_flag="sshd_ciphers_bad"

          # Get active sshd ciphers configuration
          weak_pattern='(^|\s)(3des-cbc|aes128-cbc|aes192-cbc|aes256-cbc|blowfish-cbc|cast128-cbc|arcfour(128|256)?|rijndael-cbc@lysator\.liu\.se)\b'
          chacha_pattern='chacha20-poly1305@openssh\.com'

          # Run sshd -T to list effective settings
          ciphers_line="$(sshd -T 2>/dev/null | grep -Pi '^ciphers\s+')"

          if [ -z "$ciphers_line" ]; then
            # No explicit cipher list -> system crypto policy likely applied
            echo "sshd_ciphers_ok"
            exit 0
          fi

          # If weak ciphers found, flag fail (CVE-reviewed chacha exempt if patched)
          if echo "$ciphers_line" | grep -Piq "$weak_pattern"; then
            sshd_ciphers_flag="sshd_ciphers_bad"
          else
            sshd_ciphers_flag="sshd_ciphers_ok"
          fi

          echo "$sshd_ciphers_flag"
        tests:
          test_items:
            - flag: "sshd_ciphers_ok"
              set: true
        remediation: |
          Configure the OpenSSH server to use only strong, approved ciphers.

          **Recommended method (system-wide crypto policy):**
          1) Ensure the following defaults exist:
             - /etc/ssh/sshd_config contains:
               Include /etc/ssh/sshd_config.d/*.conf
             - /etc/ssh/sshd_config.d/50-redhat.conf includes:
               Include /etc/crypto-policies/back-ends/opensshserver.config

          2) Create a subpolicy module to disable weak ciphers:
             # printf '%s\n' \
               "# Disable weak SSH ciphers" \
               "cipher@SSH = -3DES-CBC -AES-128-CBC -AES-192-CBC -AES-256-CBC -CHACHA20-POLY1305" \
               > /etc/crypto-policies/policies/modules/NO-SSHWEAKCIPHERS.pmod

          3) Apply the updated crypto policy:
             # update-crypto-policies --set DEFAULT:NO-SSHWEAKCIPHERS
             # systemctl reload-or-restart sshd

          **Alternate method (direct sshd_config, not recommended):**
          Edit `/etc/ssh/sshd_config` and place this line *above any Include entries*:
          Ciphers -3des-cbc,aes128-cbc,aes192-cbc,aes256-cbc,chacha20-poly1305@openssh.com

          Then reload SSH:
          # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.5
        description: "Ensure sshd KexAlgorithms is configured (Automated)"
        audit: |
          # Fail if any weak KEX appears in the effective sshd configuration
          if ! sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Pi -- '^\s*kexalgorithms\h+([^#\n\r]+,)?(diffie-hellman-group1-sha1|diffie-hellman-group14-sha1|diffie-hellman-group-exchange-sha1)\b' >/dev/null; then
            echo "sshd_kex_ok"
          else
            echo "sshd_kex_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_kex_ok"
              set: true
        remediation: |
          Prefer configuring allowed key exchange (KEX) via system-wide crypto policy and ensure SHA1-based KEX is disabled.

          Recommended (system-wide crypto policy):
          1) Ensure OpenSSH includes the crypto-policy backend:
             - /etc/ssh/sshd_config contains (above any KexAlgorithms lines):
               Include /etc/ssh/sshd_config.d/*.conf
             - /etc/ssh/sshd_config.d/50-redhat.conf contains:
               Include /etc/crypto-policies/back-ends/opensshserver.config

          2) Create a subpolicy module to drop SHA1 hash/signature support (which removes SHA1-based KEX):
             # printf '%s\n' \
               "# Drop SHA1 hash and signature support for system crypto policy" \
               "hash = -SHA1" \
               "sign = -*-SHA1" \
               "sha1_in_certs = 0" \
               > /etc/crypto-policies/policies/modules/NO-SHA1.pmod

          3) Apply crypto policy and reload sshd (adjust policy/subpolicies to your site standard):
             # update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20:NO-SSHETM:NO-SSHWEAKCIPHERS
             # systemctl reload-or-restart sshd

          Alternate (direct sshd_config — not recommended):
          - Place the exclusion *before* any Include lines; first occurrence wins.
            In /etc/ssh/sshd_config:
              KexAlgorithms -diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1
          - Then reload SSH:
              # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.6
        description: "Ensure sshd MACs are configured (Automated)"
        audit: |
          # Pass when NO weak MACs are present in the effective sshd configuration
          if ! sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Pi -- '^\s*macs\h+([^#\n\r]+,)?(hmac-md5|hmac-md5-96|hmac-ripemd160|hmac-sha1-96|umac-64@openssh\.com|hmac-md5-etm@openssh\.com|hmac-md5-96-etm@openssh\.com|hmac-ripemd160-etm@openssh\.com|hmac-sha1-96-etm@openssh\.com|umac-64-etm@openssh\.com|umac-128-etm@openssh\.com)\b' >/dev/null; then
            echo "sshd_macs_ok"
          else
            echo "sshd_macs_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_macs_ok"
              set: true
        remediation: |
          Configure OpenSSH to allow only strong MACs and exclude weak/96-bit/MD5/UMAC-64/UMAC-128 MACs. Prefer system-wide crypto policy.

          Recommended (system-wide crypto policy):
          1) Ensure OpenSSH includes the crypto policy backend (before any MACs lines):
             - In /etc/ssh/sshd_config:
                 Include /etc/ssh/sshd_config.d/*.conf
             - In /etc/ssh/sshd_config.d/50-redhat.conf:
                 Include /etc/crypto-policies/back-ends/opensshserver.config

          2) Create a subpolicy module to disable weak MACs:
             # printf '%s\n' \
               "# Disable weak SSH MACs (libssh/OpenSSH)" \
               "mac@SSH = -HMAC-MD5* -UMAC-64* -UMAC-128*" \
               > /etc/crypto-policies/policies/modules/NO-SSHWEAKMACS.pmod

          3) Apply the updated crypto policy and reload sshd (adjust policy set to your standard):
             # update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20:NO-SSHETM:NO-SSHWEAKCIPHERS:NO-SSHWEAKMACS
             # systemctl reload-or-restart sshd

          Note:
          - Review CVE-2023-48795 (SSH prefix truncation). If not addressed, also disable Encrypt-then-MAC variants for SSH (EtM) via NO-SSHETM, or explicitly exclude them below.

          Alternate (direct sshd_config — not recommended):
          - Place this line ABOVE any Include entries in /etc/ssh/sshd_config:
              MACs -hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-sha1-96,umac-64@openssh.com,hmac-md5-etm@openssh.com,hmac-md5-96-etm@openssh.com,hmac-ripemd160-etm@openssh.com,hmac-sha1-96-etm@openssh.com,umac-64-etm@openssh.com,umac-128-etm@openssh.com
            If CVE-2023-48795 is not remediated, also exclude: hmac-sha1-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com
          - Reload SSH:
              # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.7
        description: "Ensure sshd access is configured (Automated)"
        audit: |
          # Pass if at least one of allowusers/allowgroups/denyusers/denygroups is set (non-empty) in effective config
          line="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
                  | grep -Pi '^\s*(allow|deny)(users|groups)\s+\S' || true)"
          if [ -n "$line" ]; then
            echo "sshd_access_ok"
          else
            echo "sshd_access_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_access_ok"
              set: true
        remediation: |
          Configure OpenSSH server to explicitly control who may log in via SSH. Set one (recommended) or more of the following
          in /etc/ssh/sshd_config *above any Include and Match statements*:

            AllowUsers <user1> [user2 ...]
            # OR
            AllowGroups <group1> [group2 ...]

          Guidance:
          - Prefer an allow list over a deny list for clarity and tighter control.
          - Avoid configuring both AllowUsers and AllowGroups unless required (they are ANDed together).
          - If Include directories are used and precedence is well understood, you may place the directive in an appropriate
            *.conf drop-in that is processed before any Match blocks.

          Apply changes:
            # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.8
        description: "Ensure sshd Banner is configured (Automated)"
        audit: |
          sshd_banner_flag="sshd_banner_bad"

          # Resolve effective sshd banner setting
          banner_line="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | grep -Pi '^\s*banner\s+')"
          banner_path="$(printf '%s\n' "$banner_line" | awk '$1=="banner"{print $2}')"

          ok=true
          # 1) Banner must be set to a real file path (not "none")
          if printf '%s\n' "$banner_line" | grep -Piq '^\s*banner\s+/(.+)'; then
            :
          else
            ok=false
          fi

          # 2) Banner file must exist
          if [ -n "$banner_path" ] && [ -f "$banner_path" ]; then
            :
          else
            ok=false
          fi

          # 3) Banner content must not contain prohibited escape sequences or OS name token
          #    Disallowed: \v \r \m \s and the current OS ID token from /etc/os-release
          os_id="$(
            if [ -r /etc/os-release ]; then
              . /etc/os-release 2>/dev/null
              printf '%s' "${ID:-}"
            fi
          )"
          pat='(\\v|\\r|\\m|\\s'
          if [ -n "$os_id" ]; then
            pat="$pat|\b${os_id}\b"
          fi
          pat="$pat)"

          if [ -n "$banner_path" ] && [ -f "$banner_path" ]; then
            if grep -Psi -- "$pat" "$banner_path" >/dev/null; then
              ok=false
            fi
          fi

          if $ok; then
            sshd_banner_flag="sshd_banner_ok"
          fi

          echo "$sshd_banner_flag"
        tests:
          test_items:
            - flag: "sshd_banner_ok"
              set: true
        remediation: |
          Configure a login banner and ensure its content meets site policy.

          1) Set the Banner directive *above any Include and Match entries* in /etc/ssh/sshd_config:
             Banner /etc/issue.net

          2) Create/edit the banner file with an approved legal notice and without prohibited tokens (\m, \r, \s, \v) or OS name:
             # printf '%s\n' "Authorized users only. All activity may be monitored and reported." > /etc/issue.net

          3) Apply the change:
             # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.9
        description: "Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured (Automated)"
        audit: |
          sshd_alive_flag="sshd_alive_bad"

          # Collect effective values from sshd runtime configuration
          interval="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^clientaliveinterval/ {print $2}')"
          countmax="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^clientalivecountmax/ {print $2}')"

          # Default empty to zero if not found
          interval="${interval:-0}"
          countmax="${countmax:-0}"

          # Both must be greater than 0
          if [ "$interval" -gt 0 ] && [ "$countmax" -gt 0 ]; then
            sshd_alive_flag="sshd_alive_ok"
          fi

          echo "$sshd_alive_flag"
        tests:
          test_items:
            - flag: "sshd_alive_ok"
              set: true
        remediation: |
          Configure SSH server to disconnect unresponsive sessions after a defined timeout.

          Edit /etc/ssh/sshd_config and add the following settings *above any Include or Match blocks*:

          ClientAliveInterval 15
          ClientAliveCountMax 3

          Notes:
          - Both values must be greater than zero.
          - These control only idle network connections (not idle user activity).
          - Adjust per site security and network policy (e.g., longer intervals for unstable links).

          Apply the change:
            # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.10
        description: "Ensure sshd DisableForwarding is enabled (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^disableforwarding/ {print $2}')"
            if [ "$val" = "yes" ]; then
              echo "sshd_disableforwarding_ok"
            else
              echo "sshd_disableforwarding_bad"
            fi
        tests:
          test_items:
            - flag: "sshd_disableforwarding_ok"
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the DisableForwarding parameter to yes above any Include entry as follows:

            DisableForwarding yes
          Note: First occurrence of a option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.
        scored: true

      - id: 5.1.11
        description: "Ensure sshd GSSAPIAuthentication is disabled (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^gssapiauthentication/ {print $2}')"
            if [ "$val" = "no" ]; then
              echo "sshd_gssapiauthentication_ok"
            else
              echo "sshd_gssapiauthentication_bad"
            fi
        tests:
          test_items:
            - flag: "sshd_gssapiauthentication_ok"
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the GSSAPIAuthentication parameter to no above any Include and Match entries as follows:

          GSSAPIAuthentication no
          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.
        scored: true

      - id: 5.1.12
        description: "Ensure sshd HostbasedAuthentication is disabled (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^hostbasedauthentication/ {print $2}')"
          if [ "$val" = "no" ]; then
            echo "sshd_hostbasedauthentication_ok"
          else
            echo "sshd_hostbasedauthentication_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_hostbasedauthentication_ok"
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the HostbasedAuthentication parameter to no above any Include and Match entries as follows:

          HostbasedAuthentication no
          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.
        scored: true

      - id: 5.1.13
        description: "Ensure sshd IgnoreRhosts is enabled (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^ignorerhosts/ {print $2}')"
          if [ "$val" = "yes" ]; then
            echo "sshd_ignorerhosts_ok"
          else
            echo "sshd_ignorerhosts_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_ignorerhosts_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the IgnoreRhosts parameter to no above any Include and Match entries as follows:

          IgnoreRhosts yes
          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.
        scored: true

      - id: 5.1.14
        description: "Ensure sshd LoginGraceTime is configured (Automated)"
        audit: |
          lg_time=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | grep -i '^logingracetime' | awk '{print $2}')
          if [ -n "$lg_time" ] && [ "$lg_time" -ge 1 ] && [ "$lg_time" -le 60 ]; then
            echo "sshd_logingracetime_ok"
          else
            echo "sshd_logingracetime_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_logingracetime_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the LoginGraceTime parameter to a value between 1 and 60 seconds, based on site policy:
            LoginGraceTime 60

          Then reload the SSH daemon:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.15
        description: "Ensure sshd LogLevel is configured (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^loglevel/ {print tolower($2)}')"
          if [ "$val" = "info" ] || [ "$val" = "verbose" ]; then
            echo "sshd_loglevel_ok"
          else
            echo "sshd_loglevel_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_loglevel_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and ensure the LogLevel directive is set *above any Include and Match entries* to one of the following:

            LogLevel VERBOSE
              - OR -
            LogLevel INFO

          These levels record login activity and SSH key fingerprints while avoiding excessive debug output.

          Apply the configuration:
            # systemctl reload-or-restart sshd
        scored: true

      - id: 5.1.16
        description: "Ensure SSH MaxAuthTries is is set to 4 or less (Automated)"
        audit: |
          mat_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxauthtries\>/ {print $2}')"
          if [ -n "$mat_val" ] && [ "$mat_val" -le 4 ] && \
             ! grep -Pis '^\h*MaxAuthTries\h+"?([5-9]|[1-9][0-9]+)\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_maxauthtries_ok"
          else
            echo "sshd_maxauthtries_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxauthtries_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
            MaxAuthTries 4
        scored: true

      - id: 5.1.17
        description: "Ensure sshd MaxStartups is configured (Automated)"
        audit: |
          msu_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxstartups\>/ {print $2}')"
          if [ -n "$msu_val" ]; then
            # Extract values in the format "start:rate:full"
            start=$(echo "$msu_val" | cut -d: -f1)
            rate=$(echo "$msu_val" | cut -d: -f2)
            full=$(echo "$msu_val" | cut -d: -f3)

            if [ "$start" -le 10 ] && [ "$rate" -le 30 ] && [ "$full" -le 60 ]; then
              echo "sshd_maxstartups_ok"
            else
              echo "sshd_maxstartups_bad"
            fi
          else
            echo "sshd_maxstartups_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxstartups_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          MaxStartups 10:30:60
        scored: true

      - id: 5.1.18
        description: "Ensure sshd MaxSessions is set to 10 or less  (Automated)"
        audit: |
          ms_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxsessions\>/ {print $2}')"
          if [ -n "$ms_val" ] && [ "$ms_val" -le 10 ] && \
             ! grep -Pis '^\h*MaxSessions\h+"?(1[1-9]|[2-9][0-9]|[1-9][0-9]{2,})\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_maxsessions_ok"
          else
            echo "sshd_maxsessions_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxsessions_ok"
              set: true
        remediation: |
          Set MaxSessions to 10 or fewer (place above any Match blocks) in /etc/ssh/sshd_config, e.g.:
            MaxSessions 10
        scored: true

      - id: 5.1.19
        description: "Ensure SSH PermitEmptyPasswords is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*PermitEmptyPasswords\s+no$'; then
            echo "sshd_permitemptypassword_disabled_ok"
          else
            echo "sshd_permitemptypassword_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permitemptypassword_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          PermitEmptyPasswords no
        scored: true

      - id: 5.1.20
        description: "Ensure SSH root login is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*permitrootlogin\s+no$'; then
            echo "ssh_rootlogin_disabled"
          else
            echo "ssh_rootlogin_not_disabled"
          fi
        tests:
          test_items:
            - flag: "ssh_rootlogin_disabled"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          permitrootlogin no
        scored: true

      - id: 5.1.21
        description: "Ensure SSH PermitUserEnvironment is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*PermitUserEnvironment\s+no$'; then
            echo "sshd_userenv_disabled_ok"
          else
            echo "sshd_userenv_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_userenv_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          PermitUserEnvironment no
        scored: true

      - id: 5.1.22
        description: "Ensure SSH UsePAM is enabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*usepam\s+yes$'; then
            echo "ssh_usepam_ok"
          else
            echo "ssh_usepam_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_usepam_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the UsePAM parameter to yes above any Include entries as follows:

          UsePAM yes
          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.
        scored: true

  - id: 5.2
    description: "Configure privilege escalation"
    checks:
      - id: 5.2.1
        description: "Ensure sudo is installed (Automated)"
        audit: "rpm -q sudo"
        tests:
          test_items:
            - flag: "package sudo is not installed"
              set: false
        remediation: |
          Run the following command to install sudo

          # dnf install sudo
        scored: true

      - id: 5.2.2
        description: "Ensure sudo commands use pty (Automated)"
        audit: |
          grep -rPi '^\h*Defaults\h+([^#\n\r]+,)?use_pty(,\h*\h+\h*)*\h*(#.*)?$' /etc/sudoers*
        tests:
          test_items:
            - flag: "use_pty"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f <PATH TO FILE> and add the following line:

          Defaults use_pty
          Edit the file /etc/sudoers with visudo and any files in /etc/sudoers.d/ with visudo -f <PATH TO FILE> and remove any occurrence of !use_pty

          Note:

          sudo will read each file in /etc/sudoers.d, skipping file names that end in ~ or contain a . character to avoid causing problems with package manager or editor temporary/backup files.
          Files are parsed in sorted lexical order. That is, /etc/sudoers.d/01_first will be parsed before /etc/sudoers.d/10_second.
          Be aware that because the sorting is lexical, not numeric, /etc/sudoers.d/1_whoops would be loaded after /etc/sudoers.d/10_second.
          Using a consistent number of leading zeroes in the file names can be used to avoid such problems.

        scored: true

      - id: 5.2.3
        description: "Ensure sudo log file exists (Automated)"
        audit: |
          grep -rPsi "^\h*Defaults\h+([^#]+,\h*)?logfile\h*=\h*(\"|\')?\H+(\"|\')?(,\h*\H+\h*)*\h*(#.*)?$" /etc/sudoers*
        tests:
          test_items:
            - flag: "logfile"
              set: true
        remediation: |
          Edit the file /etc/sudoers or a file in /etc/sudoers.d/ with visudo or visudo -f <PATH
          TO FILE> and add the following line:
          Defaults logfile="<PATH TO CUSTOM LOG FILE>"
          Example
          Defaults logfile="/var/log/sudo.log"
        scored: true

      - id: 5.2.4
        description: "Ensure users must provide password for escalation (Automated)"
        audit: |
          if grep -r "^[^#].*NOPASSWD" /etc/sudoers* 2>/dev/null | grep -vE '^\s*#' >/dev/null; then
            echo "sudo_nopasswd_bad"
          else
            echo "sudo_nopasswd_ok"
          fi
        tests:
          test_items:
            - flag: "sudo_nopasswd_ok"
              set: true
        remediation: |
          Based on the outcome of the audit procedure, use visudo -f <PATH TO FILE> to edit
          the relevant sudoers file.
          Remove any line with occurrences of NOPASSWD tags in the file.
        scored: true

      - id: 5.2.5
        description: "Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
        audit: |
          grep -r "^[^#].*\!authenticate" /etc/sudoers /etc/sudoers.d 2>/dev/null
        tests:
          test_items:
            - flag: "!authenticate"
              set: false
        remediation: |
          Configure the operating system to require users to reauthenticate for privilege
          escalation.
          Based on the outcome of the audit procedure, use visudo -f <PATH TO FILE> to edit
          the relevant sudoers file.
          Remove any occurrences of !authenticate tags in the file(s).
        scored: true

      - id: 5.2.6
        description: "Ensure sudo authentication timeout is configured correctly (Automated)"
        audit: |
          timeout=$(grep -roP "timestamp_timeout=\K-?[0-9]+" /etc/sudoers* 2>/dev/null | head -n 1)

          if [ -z "$timeout" ]; then
            timeout=$(sudo -V | grep -i "Authentication timestamp timeout:" | awk -F ':' '{print $2}' | awk '{print int($1)}')
          fi

          if [ -z "$timeout" ]; then
            echo "timestamp timeout: not set"
          elif [ "$timeout" -le 15 ] && [ "$timeout" -ge 0 ]; then
            echo "timestamp timeout: ok"
          else
            echo "timestamp timeout: bad"
          fi
        tests:
          test_items:
            - flag: "timestamp timeout: ok"
              set: true
        remediation: |
          If the currently configured timeout is larger than 15 minutes, edit the file listed in the
          audit section with visudo -f <PATH TO FILE> and modify the entry timestamp_timeout=
          to 15 minutes or less as per your site policy. The value is in minutes. This particular
          entry may appear on its own, or on the same line as env_reset. See the following two
          examples:
          Defaults env_reset, timestamp_timeout=15
          Defaults timestamp_timeout=15
          Defaults env_reset
        scored: true


      - id: 5.2.7
        description: "Ensure access to the su command is restricted (Automated)"
        audit: |
          su_line="$(grep -Pi '^\h*auth\h+[^#\n\r]+\h+pam_wheel\.so\h+([^#\n\r]+\h+)?(use_uid|group=\H+)\h+([^#\n\r]+\h+)?(use_uid|group=\H+)\b' /etc/pam.d/su 2>/dev/null)"
          if [ -n "$su_line" ]; then
            su_group="$(echo "$su_line" | grep -oP 'group=\K\S+')"
            if [ -n "$su_group" ]; then
              group_users="$(getent group "$su_group" | awk -F: '{print $4}')"
              if [ -z "$group_users" ]; then
                echo "su_restricted_ok"
              else
                echo "su_group_not_empty"
              fi
            else
              echo "su_group_missing"
            fi
          else
            echo "su_not_restricted"
          fi
        tests:
          test_items:
            - flag: "su_restricted_ok"
              set: true
        remediation: |
          Create an empty group that will be specified for use of the su command. The group
          should be named according to site policy.
          Example:
          # groupadd sugroup
          Add the following line to the /etc/pam.d/su file, specifying the empty group:
          auth required pam_wheel.so use_uid group=sugroup
        scored: true


  - id: 5.3
    description: "Pluggable Authentication Modules"
    checks:
      - id: 5.3.1
        description: "Configure PAM software packages"
        type: "skip"
        checks:
      - id: 5.3.1.1
        description: "Ensure latest version of pam is installed (Automated)"
        audit: |
          pam_version="$(rpm -q --qf '%{VERSION}-%{RELEASE}\n' pam 2>/dev/null | head -n 1)"
          if rpm -q pam >/dev/null 2>&1; then
            # Extract numeric components for comparison
            if rpmdev-vercmp "$pam_version" "1.5.1-19" | grep -qE '^<' ; then
              echo "pam_version_bad"
            else
              echo "pam_version_ok"
            fi
          else
            echo "pam_not_installed"
          fi
        tests:
          test_items:
            - flag: "pam_version_ok"
              set: true
        remediation: |
          Update the PAM package to the latest available version to ensure compatibility with benchmark features.

          To upgrade:
            # dnf upgrade pam

          Verify the installed version:
            # rpm -q pam

          Ensure the version is pam-1.5.1-19 or newer.
        scored: true

      - id: 5.3.1.2
        description: "Ensure latest version of authselect is installed (Automated)"
        audit: |
          authselect_flag="authselect_version_bad"

          if rpm -q authselect >/dev/null 2>&1; then
            cur="$(rpm -q --qf '%{VERSION}-%{RELEASE}\n' authselect 2>/dev/null | head -n1)"
            base="1.2.6-2"
            # Pass if current version is >= 1.2.6-2 (version sort)
            if [ "$(printf '%s\n' "$base" "$cur" | sort -V | head -n1)" = "$base" ]; then
              authselect_flag="authselect_version_ok"
            fi
          else
            authselect_flag="authselect_not_installed"
          fi

          echo "$authselect_flag"
        tests:
          test_items:
            - flag: "authselect_version_ok"
              set: true
        remediation: |
          Install or upgrade authselect to ensure version 1.2.6-2 or newer is present.

          - If not installed:
              # dnf install authselect

          - If installed but older than 1.2.6-2:
              # dnf upgrade authselect

          Verify:
              # rpm -q authselect
          Ensure the reported version is authselect-1.2.6-2 or later.
        scored: true

      - id: 5.3.1.3
        description: "Ensure latest version of libpwquality is installed (Automated)"
        audit: |
          libpwq_flag="libpwq_version_bad"

          if rpm -q libpwquality >/dev/null 2>&1; then
            cur="$(rpm -q --qf '%{VERSION}-%{RELEASE}\n' libpwquality 2>/dev/null | head -n1)"
            base="1.4.4-8"
            # Pass if current version is >= base
            if [ "$(printf '%s\n' "$base" "$cur" | sort -V | head -n1)" = "$base" ]; then
              libpwq_flag="libpwq_version_ok"
            fi
          else
            libpwq_flag="libpwq_not_installed"
          fi

          echo "$libpwq_flag"
        tests:
          test_items:
            - flag: "libpwq_version_ok"
              set: true
        remediation: |
          Install or upgrade libpwquality to ensure version 1.4.4-8 or newer is present.

          - If not installed:
              # dnf install libpwquality

          - If installed but older than 1.4.4-8:
              # dnf upgrade libpwquality

          Verify:
              # rpm -q libpwquality
          Ensure the reported version is libpwquality-1.4.4-8 or later.
        scored: true

      - id: 5.3.2
        description: "Configure PAM software packages"
        type: "skip"
        checks:
      - id: 5.3.2.1
        description: "Ensure active authselect profile includes pam modules (Automated)"
        audit: |
          authselect_flag="authselect_pam_bad"

          # Determine active authselect profile
          active_profile="$(awk 'NR==1{print $1}' /etc/authselect/authselect.conf 2>/dev/null)"
          profile_path="/etc/authselect/${active_profile}"

          # Ensure profile path exists and required PAM modules are present
          if [ -d "$profile_path" ]; then
            if grep -qP -- '\b(pam_pwquality\.so|pam_pwhistory\.so|pam_faillock\.so|pam_unix\.so)\b' "$profile_path"/{system,password}-auth 2>/dev/null; then
              authselect_flag="authselect_pam_ok"
            fi
          fi

          echo "$authselect_flag"
        tests:
          test_items:
            - flag: "authselect_pam_ok"
              set: true
        remediation: |
          Create and apply a custom authselect profile that includes the required PAM modules.

          1) Create a custom profile based on an existing template (e.g., sssd):
             # authselect create-profile custom-profile -b sssd

          2) Modify the custom profile templates under:
             /etc/authselect/custom/custom-profile/system-auth
             /etc/authselect/custom/custom-profile/password-auth

             Ensure they include the following PAM modules:
               pam_pwquality.so
               pam_pwhistory.so
               pam_faillock.so
               pam_unix.so

          3) Activate the new custom profile:
             # authselect select custom/custom-profile --backup=PAM_CONFIG_BACKUP --force

          4) Apply changes:
             # authselect apply-changes

          Notes:
          - Ensure PAM ≥ 1.3.1-25 and authselect ≥ 1.2.6-1 are installed.
          - Avoid using symlink options to prevent overwrites during updates.
          - The --backup option creates a backup under /var/lib/authselect/backups/.
        scored: true

      - id: 5.3.2.2
        description: "Ensure pam_faillock module is enabled (Automated)"
        audit: |
          set -euo pipefail
          pwd_auth="/etc/pam.d/password-auth"
          sys_auth="/etc/pam.d/system-auth"
          if [ ! -f "$pwd_auth" ] || [ ! -f "$sys_auth" ]; then
            echo "pam_faillock_bad"
            exit 0
          fi
          pw_auth_ok=1
          grep -Pq '^\s*auth\s+required\s+pam_faillock\.so\b.*\bpreauth\b' "$pwd_auth"    || pw_auth_ok=0
          grep -Pq '^\s*auth\s+required\s+pam_faillock\.so\b.*\bauthfail\b' "$pwd_auth"  || pw_auth_ok=0
          grep -Pq '^\s*account\s+required\s+pam_faillock\.so\b'            "$pwd_auth"  || pw_auth_ok=0
          sys_auth_ok=1
          grep -Pq '^\s*auth\s+required\s+pam_faillock\.so\b.*\bpreauth\b' "$sys_auth"   || sys_auth_ok=0
          grep -Pq '^\s*auth\s+required\s+pam_faillock\.so\b.*\bauthfail\b' "$sys_auth"  || sys_auth_ok=0
          grep -Pq '^\s*account\s+required\s+pam_faillock\.so\b'            "$sys_auth"  || sys_auth_ok=0

          if [ "$pw_auth_ok" -eq 1 ] && [ "$sys_auth_ok" -eq 1 ]; then
            echo "pam_faillock_ok"
          else
            echo "pam_faillock_bad"
          fi
        tests:
          test_items:
            - flag: "pam_faillock_ok"
              set: true
        remediation: |
          Ensure pam_faillock is enabled in the active authselect profile to enforce account lockout after failed logins.

          1) Verify that pam_faillock.so entries exist in the profile template files:
             # grep -P -- '\bpam_faillock.so\b' /etc/authselect/$(head -1 /etc/authselect/authselect.conf)/{password,system}-auth

             Expected lines:
               auth     required    pam_faillock.so preauth silent
               auth     required    pam_faillock.so authfail
               account  required    pam_faillock.so

          2) If pam_faillock entries are missing, refer to control **5.3.2.1** and add the module to your custom authselect profile.

          3) If pam_faillock entries contain `{include if "with-faillock"}`, enable the faillock feature:
             # authselect enable-feature with-faillock

          4) If pam_faillock entries are defined directly, apply changes:
             # authselect apply-changes

          Notes:
          - Ensure the active profile is custom if modifications are needed (avoid altering default profiles).
          - The with-faillock feature will automatically include the correct pam_faillock.so directives in /etc/pam.d/.
        scored: true

      - id: 5.3.2.3
        description: "Ensure pam_pwquality module is enabled (Automated)"
        audit: |
          pwd_auth="/etc/pam.d/password-auth"
          sys_auth="/etc/pam.d/system-auth"

          if [ ! -f "$pwd_auth" ] || [ ! -f "$sys_auth" ]; then
            echo "pam_pwquality_bad"
            exit 0
          fi

          pw_auth_ok=1
          sys_auth_ok=1

          grep -Pq '^\s*password\s+requisite\s+pam_pwquality\.so\b' "$pwd_auth" || pw_auth_ok=0
          grep -Pq '^\s*password\s+requisite\s+pam_pwquality\.so\b' "$sys_auth" || sys_auth_ok=0

          if [ "$pw_auth_ok" -eq 1 ] && [ "$sys_auth_ok" -eq 1 ]; then
            echo "pam_pwquality_ok"
          else
            echo "pam_pwquality_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwquality_ok"
              set: true
        remediation: |
          Ensure the active authselect profile enables pam_pwquality to enforce password quality checks.

          1) Verify pam_pwquality references exist in the active profile templates:
             # prof="$(head -1 /etc/authselect/authselect.conf)"
             # path="/etc/authselect/${prof}"
             # [[ "$prof" =~ ^custom/ ]] || path="/usr/share/authselect/default/${prof}"
             # grep -P -- '\bpam_pwquality\.so\b' "$path"/{password,system}-auth

             Expected examples:
               /.../password-auth:password   requisite   pam_pwquality.so local_users_only {include if "with-pwquality"}
               /.../system-auth:password     requisite   pam_pwquality.so local_users_only {include if "with-pwquality"}

          2) If lines are missing, update your custom authselect profile (see control 5.3.2.1) to include pam_pwquality in both
             password-auth and system-auth templates.

          3) If lines include `{include if "with-pwquality"}`, enable the feature and update /etc/pam.d:
             # authselect enable-feature with-pwquality
             # authselect apply-changes

          4) If lines exist without the conditional include, just apply changes:
             # authselect apply-changes
        scored: true

      - id: 5.3.2.4
        description: "Ensure pam_pwhistory module is enabled (Automated)"
        audit: |
          pwd_auth="/etc/pam.d/password-auth"
          sys_auth="/etc/pam.d/system-auth"

          if [ ! -f "$pwd_auth" ] || [ ! -f "$sys_auth" ]; then
            echo "pam_pwhistory_bad"
            exit 0
          fi

          pw_auth_ok=1
          sys_auth_ok=1

          grep -Pq '^\s*password\s+requisite\s+bpam_pwhistory\.so\b' "$pwd_auth" || pw_auth_ok=0
          grep -Pq '^\s*password\s+requisite\s+bpam_pwhistory\.so\b' "$sys_auth" || sys_auth_ok=0

          if [ "$pw_auth_ok" -eq 1 ] && [ "$sys_auth_ok" -eq 1 ]; then
            echo "pam_pwhistory_ok"
          else
            echo "pam_pwhistory_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwhistory_ok"
              set: true
        remediation: |
          Ensure pam_pwhistory is enabled in the active authselect profile to enforce password history checks.

          1) Verify pam_pwhistory entries exist in the active profile templates:
             # prof="$(head -1 /etc/authselect/authselect.conf)"
             # path="/etc/authselect/${prof}"
             # [[ "$prof" =~ ^custom/ ]] || path="/usr/share/authselect/default/${prof}"
             # grep -P -- '\bpam_pwhistory\.so\b' "$path"/{password,system}-auth

             Expected examples:
               /.../password-auth:password   required   pam_pwhistory.so use_authtok {include if "with-pwhistory"}
               /.../system-auth:password     required   pam_pwhistory.so use_authtok {include if "with-pwhistory"}

          2) If lines are missing, update your custom authselect profile (see control 5.3.2.1) to include pam_pwhistory in both
             password-auth and system-auth templates.

          3) If lines include `{include if "with-pwhistory"}`, enable the feature and apply changes:
             # authselect enable-feature with-pwhistory
             # authselect apply-changes

          4) If lines exist without the conditional include, just apply changes:
             # authselect apply-changes

          Notes:
          - The pam_pwhistory module prevents users from reusing recent passwords.
          - Ensure the active authselect profile is a custom one before making changes.
        scored: true

      - id: 5.3.2.5
        description: "Ensure pam_unix module is enabled (Automated)"
        audit: |
          pwd_auth="/etc/pam.d/password-auth"
          sys_auth="/etc/pam.d/system-auth"

          # Required PAM files must exist
          if [ ! -f "$pwd_auth" ] || [ ! -f "$sys_auth" ]; then
            echo "pam_unix_bad"
            exit 0
          fi

          pwd_ok=1
          sys_ok=1

          # password-auth required pam_unix lines
          grep -Pq '^\s*auth\s+(sufficient|required)\s+pam_unix\.so\b' "$pwd_auth" || pwd_ok=0
          grep -Pq '^\s*account\s+(required|sufficient)\s+pam_unix\.so\b' "$pwd_auth" || pwd_ok=0
          grep -Pq '^\s*password\s+(sufficient|required)\s+pam_unix\.so\b' "$pwd_auth" || pwd_ok=0
          grep -Pq '^\s*session\s+(required|sufficient)\s+pam_unix\.so\b' "$pwd_auth" || pwd_ok=0

          # system-auth required pam_unix lines
          grep -Pq '^\s*auth\s+(sufficient|required)\s+pam_unix\.so\b' "$sys_auth" || sys_ok=0
          grep -Pq '^\s*account\s+(required|sufficient)\s+pam_unix\.so\b' "$sys_auth" || sys_ok=0
          grep -Pq '^\s*password\s+(sufficient|required)\s+pam_unix\.so\b' "$sys_auth" || sys_ok=0
          grep -Pq '^\s*session\s+(required|sufficient)\s+pam_unix\.so\b' "$sys_auth" || sys_ok=0

          if [ "$pwd_ok" -eq 1 ] && [ "$sys_ok" -eq 1 ]; then
            echo "pam_unix_ok"
          else
            echo "pam_unix_bad"
          fi
        tests:
          test_items:
            - flag: "pam_unix_ok"
              set: true
        remediation: |
          Ensure the active authselect profile enables pam_unix across authentication stacks.

          1) Check the active profile templates for pam_unix:
             # prof="$(head -1 /etc/authselect/authselect.conf)"
             # path="/etc/authselect/${prof}"; [[ "$prof" =~ ^custom/ ]] || path="/usr/share/authselect/default/${prof}"
             # grep -P -- '\bpam_unix\.so\b' "$path"/{password,system}-auth

             Example expected entries:
               # password-auth
               auth     sufficient  pam_unix.so
               account  required    pam_unix.so
               password sufficient  pam_unix.so sha512 shadow use_authtok
               session  required    pam_unix.so

               # system-auth
               auth     sufficient  pam_unix.so
               account  required    pam_unix.so
               password sufficient  pam_unix.so sha512 shadow use_authtok
               session  required    pam_unix.so

          2) If missing, update your custom authselect profile (see control 5.3.2.1) to include pam_unix in both
             password-auth and system-auth templates, then apply changes:
             # authselect apply-changes

          Notes:
          - Arguments after pam_unix.so may vary per site policy (e.g., sha512, shadow, use_authtok).
          - Prefer modifying a custom profile rather than vendor defaults.
        scored: true

      - id: 5.3.3
        description: "Configure PAM Arguments"
        type: "skip"
        checks:
      - id: 5.3.3.1
        description: "Configure pam_faillock module"
        type: "skip"
        checks:
      - id: 5.3.3.1.1
        description: "Ensure password failed attempts lockout is configured (Automated)"
        audit: |
          faillock_lockout_flag="faillock_lockout_bad"

          # Check that deny <= 5 in faillock.conf
          if grep -Pi -- '^\s*deny\s*=\s*[1-5]\b' /etc/security/faillock.conf >/dev/null 2>&1; then
            # Ensure no PAM files override deny with higher value
            if ! grep -Pi -- '^\s*auth\s+(requisite|required|sufficient)\s+pam_faillock\.so\s+([^#\n\r]+\s+)?deny\s*=\s*(0|[6-9]|[1-9][0-9]+)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth >/dev/null 2>&1; then
              faillock_lockout_flag="faillock_lockout_ok"
            fi
          fi

          echo "$faillock_lockout_flag"
        tests:
          test_items:
            - flag: "faillock_lockout_ok"
              set: true
        remediation: |
          Configure account lockout after consecutive failed login attempts.

          1) Edit /etc/security/faillock.conf and set:
             deny = 5
             # Adjust to local site policy, but must not exceed 5.

          2) Ensure pam_faillock.so lines in /etc/pam.d/system-auth and /etc/pam.d/password-auth
             do NOT include a separate deny= argument (it should be managed in faillock.conf):
             # sed -ri 's/(^\s*auth\s+(requisite|required|sufficient)\s+pam_faillock\.so.*)(\s+deny\s*=\s*\S+)(.*$)/\1\4/' /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/{system,password}-auth
             # authselect apply-changes

          3) Apply changes:
             # authselect apply-changes

          Notes:
          - The deny option defines the number of failed authentication attempts before the account is locked.
          - It should be set to 5 or fewer.
        scored: true

      - id: 5.3.3.1.2
        description: "Ensure password unlock time is configured (Automated)"
        audit: |
          faillock_unlock_flag="faillock_unlock_bad"

          # Verify unlock_time in faillock.conf is either 0 or >=900
          if grep -Pi -- '^\s*unlock_time\s*=\s*(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/security/faillock.conf >/dev/null 2>&1; then
            # Ensure no weak unlock_time values are hardcoded in PAM configuration
            if ! grep -Pi -- '^\s*auth\s+(requisite|required|sufficient)\s+pam_faillock\.so\s+([^#\n\r]+\s+)?unlock_time\s*=\s*([1-9]|[1-9][0-9]|[1-8][0-9][0-9])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth >/dev/null 2>&1; then
              faillock_unlock_flag="faillock_unlock_ok"
            fi
          fi

          echo "$faillock_unlock_flag"
        tests:
          test_items:
            - flag: "faillock_unlock_ok"
              set: true
        remediation: |
          Configure the password unlock time to meet site policy.

          1) Edit /etc/security/faillock.conf and set the unlock_time parameter:
             unlock_time = 900
             # Value must be either 0 (never) or ≥900 (15 minutes or more) per site security policy.

          2) Remove any unlock_time arguments from pam_faillock.so lines in system-auth and password-auth to avoid overrides:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*auth\s+(requisite|required|sufficient)\s+pam_faillock\.so.*)(\s+unlock_time\s*=\s*\S+)(.*$)/\1\4/' \
                 /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$f
               done
             # authselect apply-changes

          3) Apply configuration:
             # authselect apply-changes

          Notes:
          - unlock_time defines how long (in seconds) a locked account remains inaccessible.
          - A value of 0 means the account remains locked until manually reset.
          - Recommended: unlock_time = 900 (15 minutes) or as per organization policy.
        scored: true

      - id: 5.3.3.1.3
        description: "Ensure password failed attempts lockout includes root account (Automated)"
        audit: |
          rootlock_flag="faillock_rootlock_bad"
          conf="/etc/security/faillock.conf"

          ok=true

          # 1) Require either even_deny_root or root_unlock_time to be present in faillock.conf
          if grep -Piq '^\s*(even_deny_root\b|root_unlock_time\s*=\s*\d+)\b' "$conf"; then
            :
          else
            ok=false
          fi

          # 2) If root_unlock_time is present in faillock.conf, it must be >= 60 (1 minute)
          if grep -Piq '^\s*root_unlock_time\s*=\s*\d+\b' "$conf"; then
            rut_val="$(awk -F= '/^[[:space:]]*root_unlock_time[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);print $2}' "$conf" | head -n1)"
            # Fail if 1..59
            if [ -n "$rut_val" ] && [ "$rut_val" -ge 1 ] && [ "$rut_val" -le 59 ]; then
              ok=false
            fi
          fi

          # 3) Ensure PAM does NOT set a weak root_unlock_time (1..59) in system-auth/password-auth
          if grep -Pi -- '^\s*auth\s+([^#\n\r]+\s+)?pam_faillock\.so\s+([^#\n\r]+\s+)?root_unlock_time\s*=\s*([1-9]|[1-5][0-9])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth >/dev/null 2>&1; then
            ok=false
          fi

          if $ok; then
            rootlock_flag="faillock_rootlock_ok"
          fi
          echo "$rootlock_flag"
        tests:
          test_items:
            - flag: "faillock_rootlock_ok"
              set: true
        remediation: |
          Configure account lockout to include the root account and ensure safe unlock timing.

          1) Edit /etc/security/faillock.conf:
             - Ensure one of the following is present (both are acceptable):
                 even_deny_root
                 # and/or
                 root_unlock_time = 60     # or a higher value per site policy
             - If a root_unlock_time line exists with a value less than 60, raise it to ≥60 or remove it.

          2) Remove any inline overrides in PAM files:
             - From /etc/authselect/<active-profile>/{system,password}-auth (or corresponding custom profile templates),
               remove these arguments from pam_faillock.so lines if present:
                 even_deny_root
                 root_unlock_time=...
             - Apply changes via authselect:
                 # authselect apply-changes

          3) No service restart is required for faillock.conf changes; PAM template updates via authselect update /etc/pam.d/.
        scored: true

      - id: 5.3.3.2
        description: "Configure pam_pwquality module"
        type: "skip"
        checks:
      - id: 5.3.3.2.1
        description: "Ensure password number of changed characters is configured (Automated)"
        audit: |
          pwq_difok_flag="pwq_difok_bad"

          # 1) Require difok to be set to >= 2 in pwquality config (conf or conf.d/*.conf)
          if grep -Psi -- '^\s*difok\s*=\s*([2-9]|[1-9][0-9]+)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null | grep -q .; then
            has_good_cfg=true
          else
            has_good_cfg=false
          fi

          # 2) Ensure no pam_pwquality module argument overrides difok to 0 or 1 in PAM stacks
          if grep -Psi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\s+([^#\n\r]+\s+)?difok\s*=\s*([0-1])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null | grep -q .; then
            pam_override_bad=true
          else
            pam_override_bad=false
          fi

          if $has_good_cfg && ! $pam_override_bad; then
            pwq_difok_flag="pwq_difok_ok"
          fi

          echo "$pwq_difok_flag"
        tests:
          test_items:
            - flag: "pwq_difok_ok"
              set: true
        remediation: |
          Configure pwquality to require at least 2 characters differ from the old password, and ensure PAM does not weaken it.

          1) Set difok in pwquality configuration (preferred: conf.d):
             # sed -ri 's/^\s*difok\s*=/# &/' /etc/security/pwquality.conf
             # printf '\n%s\n' 'difok = 2' > /etc/security/pwquality.conf.d/50-pwdifok.conf
             # (Adjust to site policy, but must be ≥ 2.)

          2) Remove any PAM module overrides that set difok to 0 or 1:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so)([^#\n\r]*\s)difok\s*=\s*[01]([^#\n\r]*$)/\1\3/' /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$f 2>/dev/null || true
               done
             # authselect apply-changes

          Notes:
          - PAM module arguments override pwquality.conf; keep the policy centralized in pwquality.conf(.d).
          - Files in /etc/security/pwquality.conf.d are processed in canonical order; later files take precedence.
        scored: true

      - id: 5.3.3.2.2
        description: "Ensure password length is configured (Automated)"
        audit: |
          pwq_minlen_flag="pwq_minlen_bad"

          # 1) Require minlen >= 14 in pwquality config (conf or conf.d/*.conf)
          if grep -Psi -- '^\s*minlen\s*=\s*(1[4-9]|[2-9][0-9]|[1-9][0-9]{2,})\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null | grep -q .; then
            good_cfg=true
          else
            good_cfg=false
          fi

          # 2) Ensure no PAM override sets minlen <= 13 in system-auth/password-auth
          if grep -Psi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\s+([^#\n\r]+\s+)?minlen\s*=\s*([0-9]|1[0-3])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null | grep -q .; then
            bad_override=true
          else
            bad_override=false
          fi

          if $good_cfg && ! $bad_override; then
            pwq_minlen_flag="pwq_minlen_ok"
          fi

          echo "$pwq_minlen_flag"
        tests:
          test_items:
            - flag: "pwq_minlen_ok"
              set: true
        remediation: |
          Configure pwquality to enforce a minimum password length of at least 14 characters and ensure PAM does not weaken it.

          1) Set minlen in pwquality configuration (prefer conf.d for durability):
             # sed -ri 's/^\s*minlen\s*=/# &/' /etc/security/pwquality.conf
             # printf '\n%s\n' 'minlen = 14' > /etc/security/pwquality.conf.d/50-pwlength.conf
             # (Adjust upward per site policy, but not below 14.)

          2) Remove any PAM module overrides that set minlen below 14:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so)([^#\n\r]*\s)minlen\s*=\s*([0-9]|1[0-3])([^#\n\r]*$)/\1\4/' \
                   /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$f 2>/dev/null || true
               done
             # authselect apply-changes

          Notes:
          - PAM arguments override pwquality.conf; centralize policy in pwquality.conf(.d).
          - Files in /etc/security/pwquality.conf.d are applied in canonical order; later files take precedence.
        scored: true

      - id: 5.3.3.2.3
        description: "Ensure password complexity is configured (Manual)"
        audit: |
          # Verify complexity is defined in pwquality configuration (meets site policy):
          grep -Psi -- '^\s*(minclass|[dulo]credit)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf

          # Verify settings are not weakened in PAM module arguments:
          # - minclass must not be < 4
          # - dcredit/ucredit/lcredit/ocredit must not be 0 or greater (i.e., should be negative to require chars)
          grep -Psi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\s+([^#\n\r]+\s+)?(minclass=[0-3]|[dulo]credit=[^-]\d*)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth
        type: "manual"
        remediation: |
          Configure password complexity via pwquality and ensure PAM does not override it.

          1) Define complexity in pwquality (prefer conf.d for durability):
             # sed -ri 's/^\s*minclass\s*=/# &/' /etc/security/pwquality.conf
             # sed -ri 's/^\s*[dulo]credit\s*=/# &/' /etc/security/pwquality.conf
             # printf '%s\n' "minclass = 4" > /etc/security/pwquality.conf.d/50-pwcomplexity.conf
             # printf '%s\n' "dcredit = -1" "ucredit = -1" "ocredit = -1" "lcredit = -1" >> /etc/security/pwquality.conf.d/50-pwcomplexity.conf
             # (Adjust -N values to meet site policy; minclass should be 4 or higher.)

          2) Remove any conflicting PAM module arguments so pwquality.conf governs:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)(\s+minclass\s*=\s*\S+)(.*$)/\1\3/' /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)(\s+dcredit\s*=\s*\S+)(.*$)/\1\3/'  /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)(\s+ucredit\s*=\s*\S+)(.*$)/\1\3/'  /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)(\s+lcredit\s*=\s*\S+)(.*$)/\1\3/'  /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)(\s+ocredit\s*=\s*\S+)(.*$)/\1\3/'  /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f
               done
             # authselect apply-changes

          Notes:
          - Configure these settings in only one place for clarity; pwquality.conf(.d) is preferred.
          - Precedence: PAM module args > /etc/security/pwquality.conf > /etc/security/pwquality.conf.d/*.conf (last file wins).
        scored: false

      - id: 5.3.3.2.4
        description: "Ensure password same consecutive characters is configured (Automated)"
        audit: |
          pwq_repeat_flag="pwq_repeat_bad"

          # 1) Require maxrepeat between 1 and 3 (inclusive) in pwquality configuration
          if grep -Psi -- '^\s*maxrepeat\s*=\s*[1-3]\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null | grep -q .; then
            good_cfg=true
          else
            good_cfg=false
          fi

          # 2) Ensure no PAM override sets maxrepeat = 0 or >3
          if grep -Psi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\s+([^#\n\r]+\s+)?maxrepeat\s*=\s*(0|[4-9]|[1-9][0-9]+)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null | grep -q .; then
            bad_override=true
          else
            bad_override=false
          fi

          if $good_cfg && ! $bad_override; then
            pwq_repeat_flag="pwq_repeat_ok"
          fi

          echo "$pwq_repeat_flag"
        tests:
          test_items:
            - flag: "pwq_repeat_ok"
              set: true
        remediation: |
          Configure pwquality to limit consecutive identical characters in passwords to 3 or fewer.

          1) Set maxrepeat in pwquality configuration (prefer conf.d for durability):
             # sed -ri 's/^\s*maxrepeat\s*=/# &/' /etc/security/pwquality.conf
             # printf '\n%s\n' 'maxrepeat = 3' > /etc/security/pwquality.conf.d/50-pwrepeat.conf
             # (Set according to site policy, must be between 1 and 3 and not 0.)

          2) Remove any PAM module overrides that set maxrepeat = 0 or greater than 3:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so)([^#\n\r]*\s)maxrepeat\s*=\s*(0|[4-9]|[1-9][0-9]+)([^#\n\r]*$)/\1\5/' \
                   /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$f 2>/dev/null || true
               done
             # authselect apply-changes

          Notes:
          - The maxrepeat option limits how many identical consecutive characters a password may contain.
          - Recommended value: 3 or less.
          - PAM module arguments override pwquality.conf; centralize the policy in pwquality.conf(.d).
        scored: true

      - id: 5.3.3.2.5
        description: "Ensure password maximum sequential characters is configured (Automated)"
        audit: |
          pwq_seq_flag="pwq_seq_bad"

          # 1) Require maxsequence between 1 and 3 (inclusive) in pwquality configuration
          if grep -Psi -- '^\s*maxsequence\s*=\s*[1-3]\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null | grep -q .; then
            good_cfg=true
          else
            good_cfg=false
          fi

          # 2) Ensure no PAM override sets maxsequence = 0 or >3
          if grep -Psi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\s+([^#\n\r]+\s+)?maxsequence\s*=\s*(0|[4-9]|[1-9][0-9]+)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null | grep -q .; then
            bad_override=true
          else
            bad_override=false
          fi

          if $good_cfg && ! $bad_override; then
            pwq_seq_flag="pwq_seq_ok"
          fi

          echo "$pwq_seq_flag"
        tests:
          test_items:
            - flag: "pwq_seq_ok"
              set: true
        remediation: |
          Configure pwquality to restrict sequential character repetition in passwords.

          1) Set maxsequence in pwquality configuration (prefer conf.d for durability):
             # sed -ri 's/^\s*maxsequence\s*=/# &/' /etc/security/pwquality.conf
             # printf '\n%s\n' 'maxsequence = 3' > /etc/security/pwquality.conf.d/50-pwmaxsequence.conf
             # (Adjust per site policy; must be between 1 and 3, and not 0.)

          2) Remove any PAM module overrides that set maxsequence = 0 or greater than 3:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so)([^#\n\r]*\s)maxsequence\s*=\s*(0|[4-9]|[1-9][0-9]+)([^#\n\r]*$)/\1\5/' \
                   /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$f 2>/dev/null || true
               done
             # authselect apply-changes

          Notes:
          - The maxsequence option limits the number of sequential characters (e.g., “12345” or “abcd”) in passwords.
          - Recommended value: 3 or less.
          - Centralize the setting in pwquality.conf(.d) to ensure clarity and persistence across updates.
        scored: true

      - id: 5.3.3.2.6
        description: "Ensure password dictionary check is enabled (Automated)"
        audit: |
          pwq_dictcheck_flag="pwq_dictcheck_bad"

          # Fail if dictcheck=0 appears in pwquality configuration
          if ! grep -Psi -- '^\s*dictcheck\s*=\s*0\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null | grep -q .; then
            cfg_ok=true
          else
            cfg_ok=false
          fi

          # Fail if dictcheck=0 appears as a pam_pwquality module argument
          if ! grep -Psi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\s+([^#\n\r]+\s+)?dictcheck\s*=\s*0\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null | grep -q .; then
            pam_ok=true
          else
            pam_ok=false
          fi

          if $cfg_ok && $pam_ok; then
            pwq_dictcheck_flag="pwq_dictcheck_ok"
          fi

          echo "$pwq_dictcheck_flag"
        tests:
          test_items:
            - flag: "pwq_dictcheck_ok"
              set: true
        remediation: |
          Ensure the pwquality dictionary check remains enabled.

          1) Remove or comment any dictcheck=0 from pwquality configuration:
             # sed -ri 's/^\s*dictcheck\s*=/# &/' /etc/security/pwquality.conf
             # sed -ri 's/^\s*dictcheck\s*=/# &/' /etc/security/pwquality.conf.d/*.conf 2>/dev/null || true
             # (Default is dictcheck = 1; no explicit setting is typically required.)

          2) Remove dictcheck module arguments from pam_pwquality so pwquality.conf governs:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)(\s+dictcheck\s*=\s*\S+)(.*$)/\1\3/' \
                   /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f 2>/dev/null || true
               done
             # authselect apply-changes

          Notes:
          - PAM arguments override pwquality.conf; keep dictcheck control in pwquality.conf(.d).
          - Files in /etc/security/pwquality.conf.d are applied in canonical order; last file wins.
        scored: true

      - id: 5.3.3.2.7
        description: "Ensure password quality is enforced for the root user (Automated)"
        audit: |
          pwq_root_flag="pwq_root_bad"

          # Pass if enforce_for_root appears (enabled) in pwquality configuration
          if grep -Psi -- '^\s*enforce_for_root\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null | grep -q .; then
            pwq_root_flag="pwq_root_ok"
          fi

          echo "$pwq_root_flag"
        tests:
          test_items:
            - flag: "pwq_root_ok"
              set: true
        remediation: |
          Enable password quality enforcement for the root user.

          1) Add the enforce_for_root directive in pwquality configuration:
             # printf '\n%s\n' "enforce_for_root" > /etc/security/pwquality.conf.d/50-pwroot.conf

          2) Verify the configuration:
             # grep -Psi -- '^\s*enforce_for_root\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf

          Notes:
          - This setting ensures root is subject to the same password quality checks as regular users.
          - It is recommended to configure this directive in /etc/security/pwquality.conf.d for persistence and clarity.
        scored: true

      - id: 5.3.3.3
        description: "Configure pam_pwhistory module"
        type: "skip"
        checks:
      - id: 5.3.3.3.1
        description: "Ensure password history remember is configured (Automated)"
        audit: |
          pwhist_remember_flag="pwhist_remember_bad"

          # 1) Ensure remember is set to 24 or more in /etc/security/pwhistory.conf
          if grep -Pi -- '^\s*remember\s*=\s*(2[4-9]|[3-9][0-9]|[1-9][0-9]{2,})\b' /etc/security/pwhistory.conf >/dev/null 2>&1; then
            good_cfg=true
          else
            good_cfg=false
          fi

          # 2) Ensure no PAM overrides set remember < 24 in password-auth/system-auth
          if grep -Pi -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so\s+([^#\n\r]+\s+)?remember=(2[0-3]|1[0-9]|[0-9])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth >/dev/null 2>&1; then
            bad_override=true
          else
            bad_override=false
          fi

          if $good_cfg && ! $bad_override; then
            pwhist_remember_flag="pwhist_remember_ok"
          fi

          echo "$pwhist_remember_flag"
        tests:
          test_items:
            - flag: "pwhist_remember_ok"
              set: true
        remediation: |
          Configure password history to prevent password reuse for at least the last 24 passwords.

          1) Set the remember value in /etc/security/pwhistory.conf:
             # printf '\n%s\n' "remember = 24" > /etc/security/pwhistory.conf
             # (Increase the value if required by site policy.)

          2) Remove any pam_pwhistory.so module arguments overriding remember with a lower value:
             # for f in system-auth password-auth; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so.*)(\s+remember\s*=\s*\S+)(.*$)/\1\4/' \
                   /etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep "custom/")/$f 2>/dev/null || true
               done
             # authselect apply-changes

          Notes:
          - The remember parameter defines how many previous passwords a user cannot reuse.
          - Minimum required: 24 previous passwords.
          - PAM arguments override /etc/security/pwhistory.conf; keep configuration centralized there.
        scored: true

      - id: 5.3.3.3.2
        description: "Ensure password history is enforced for the root user (Automated)"
        audit: |
          grep -Pi -- '^\h*enforce_for_root\b' /etc/security/pwhistory.conf
        tests:
          test_items:
            - flag: "enforce_for_root"
        remediation: |
          Edit or add the following line in /etc/security/pwhistory.conf:

            enforce_for_root
        scored: true

      - id: 5.3.3.3.3
        description: "Ensure pam_pwhistory includes use_authtok (Automated)"
        audit: |
          pwhist_useauthtok_flag="pwhistory_use_authtok_bad"

          if grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so(\s+[^#\n\r]+)?\suse_authtok\b' /etc/pam.d/password-auth 2>/dev/null && \
             grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so(\s+[^#\n\r]+)?\suse_authtok\b' /etc/pam.d/system-auth 2>/dev/null; then
            pwhist_useauthtok_flag="pwhistory_use_authtok_ok"
          fi

          echo "$pwhist_useauthtok_flag"
        tests:
          test_items:
            - flag: "pwhistory_use_authtok_ok"
              set: true
        remediation: |
          Ensure the pam_pwhistory.so lines in the password stack include use_authtok so that stacked PAM modules enforce the
          previously accepted new password.

          1) Identify active authselect profile templates:
             prof="$(head -1 /etc/authselect/authselect.conf)"
             case "$prof" in
               custom/*) path="/etc/authselect/$prof" ;;
               *)        path="/usr/share/authselect/default/$prof" ;;
             esac

          2) Add use_authtok to pam_pwhistory.so in the templates (password-auth and system-auth):
             # for f in "$path/password-auth" "$path/system-auth"; do
                 if ! grep -Pq '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so(\s+[^#\n\r]+)?\suse_authtok\b' "$f"; then
                   sed -ri 's/^\s*(password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so)(\s+.*)?$/\1\3 use_authtok/' "$f"
                 fi
               done

          3) Apply the changes to /etc/pam.d:
             # authselect apply-changes

          4) Verify:
             # grep -P -- '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so(\s+[^#\n\r]+)?\suse_authtok\b' /etc/pam.d/{password,system}-auth
        scored: true

      - id: 5.3.3.4
        description: "Configure pam_unix module"
        type: "skip"
        checks:
      - id: 5.3.3.4.1
        description: "Ensure pam_unix does not include nullok (Automated)"
        audit: |
          pam_unix_nullok_flag="pam_unix_nullok_bad"

          # Gather pam_unix lines from the active PAM stacks
          lines="$(grep -PH -- '^\s*(auth|account|password|session)\s+(requisite|required|sufficient)\s+pam_unix\.so\b' /etc/pam.d/{password,system}-auth 2>/dev/null)"

          if [ -n "$lines" ] && ! echo "$lines" | grep -Pi '\bnullok\b' >/dev/null 2>&1; then
            pam_unix_nullok_flag="pam_unix_nullok_ok"
          fi

          echo "$pam_unix_nullok_flag"
        tests:
          test_items:
            - flag: "pam_unix_nullok_ok"
              set: true
        remediation: |
          Remove the "nullok" option from pam_unix.so so accounts with empty passwords cannot authenticate.

          Preferred (authselect-based) approach:
          1) Check the active authselect profile templates:
               prof="$(head -1 /etc/authselect/authselect.conf)"
               case "$prof" in
                 custom/*) path="/etc/authselect/$prof" ;;
                 *)        path="/usr/share/authselect/default/$prof" ;;
               esac
               grep -P -- '\bpam_unix\.so\b' "$path"/{password,system}-auth

          2) If templates contain the conditional include token `{if not "without-nullok":nullok}`, enable the feature:
               # authselect enable-feature without-nullok

          3) If any pam_unix.so line contains an explicit "nullok", remove it from the templates:
               # for f in "$path/password-auth" "$path/system-auth"; do
                   sed -ri 's/\bnullok\b//g' "$f"
                 done

          4) Apply changes to /etc/pam.d:
               # authselect apply-changes

          Verification:
            # grep -PH -- '^\s*(auth|account|password|session)\s+(requisite|required|sufficient)\s+pam_unix\.so\b' /etc/pam.d/{password,system}-auth | grep -Pi '\bnullok\b' || echo "pam_unix nullok not present"
        scored: true

      - id: 5.3.3.4.2
        description: "Ensure pam_unix does not include remember (Automated)"
        audit: |
          pam_unix_remember_flag="pam_unix_remember_bad"

          # Fail if any pam_unix.so password stack line includes remember=<N>
          if ! grep -PHq -- '^\s*password\s+([^#\n\r]+\s+)?pam_unix\.so\b.*\bremember=[1-9][0-9]*\b' /etc/pam.d/{password,system}-auth 2>/dev/null; then
            pam_unix_remember_flag="pam_unix_remember_ok"
          fi

          echo "$pam_unix_remember_flag"
        tests:
          test_items:
            - flag: "pam_unix_remember_ok"
              set: true
        remediation: |
          Remove the remember= argument from pam_unix.so and rely on pam_pwhistory for password history.

          1) Identify active authselect profile templates:
             prof="$(head -1 /etc/authselect/authselect.conf)"
             case "$prof" in
               custom/*) path="/etc/authselect/$prof" ;;
               *)        path="/usr/share/authselect/default/$prof" ;;
             esac

          2) Strip remember=<N> from pam_unix.so lines in the templates:
             # for f in "$path/password-auth" "$path/system-auth"; do
                 sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)\bremember=[1-9][0-9]*\b(.*$)/\1\2/' "$f"
               done

          3) Apply changes to /etc/pam.d:
             # authselect apply-changes

          4) (Recommended) Configure password history via pam_pwhistory (see control 5.3.3.3.1) instead of pam_unix remember.
        scored: true

      - id: 5.3.3.4.3
        description: "Ensure pam_unix includes a strong password hashing algorithm (Automated)"
        audit: |
          pam_unix_hash_flag="pam_unix_hash_bad"

          if grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+([^#\n\r]+\s+)?(sha512|yescrypt)\b' /etc/pam.d/password-auth 2>/dev/null && \
             grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+([^#\n\r]+\s+)?(sha512|yescrypt)\b' /etc/pam.d/system-auth 2>/dev/null; then
            pam_unix_hash_flag="pam_unix_hash_ok"
          fi

          echo "$pam_unix_hash_flag"
        tests:
          test_items:
            - flag: "pam_unix_hash_ok"
              set: true
        remediation: |
          Configure pam_unix to use a strong password hashing algorithm (sha512 or yescrypt).

          1) Identify the active authselect profile templates:
             prof="$(head -1 /etc/authselect/authselect.conf)"
             case "$prof" in
               custom/*) path="/etc/authselect/$prof" ;;
               *)        path="/usr/share/authselect/default/$prof" ;;
             esac

          2) Ensure a strong hash is specified on the pam_unix.so password lines in both templates:
             # If a weak or missing algorithm is present, replace or append with sha512 (or yescrypt if preferred).

             # password-auth:
             sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)\b(md5|bigcrypt|sha256|blowfish)\b(.*$)/\1\3 sha512/' "$path/password-auth" 2>/dev/null || true
             grep -Pq '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+([^#\n\r]+\s+)?(sha512|yescrypt)\b' "$path/password-auth" || \
               sed -ri 's/^\s*(password\s+(requisite|required|sufficient)\s+pam_unix\.so)(\s+.*)?$/\1\3 sha512/' "$path/password-auth"

             # system-auth:
             sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)\b(md5|bigcrypt|sha256|blowfish)\b(.*$)/\1\3 sha512/' "$path/system-auth" 2>/dev/null || true
             grep -Pq '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+([^#\n\r]+\s+)?(sha512|yescrypt)\b' "$path/system-auth" || \
               sed -ri 's/^\s*(password\s+(requisite|required|sufficient)\s+pam_unix\.so)(\s+.*)?$/\1\3 sha512/' "$path/system-auth"

          3) Apply the changes to /etc/pam.d:
             # authselect apply-changes

          4) (Recommended) Keep the chosen algorithm consistent across:
             - /etc/pam.d/password-auth and /etc/pam.d/system-auth
             - /etc/login.defs and /etc/libuser.conf (if used)

          5) After changing the algorithm, consider expiring local accounts so users update passwords to the stronger hash:
             # chage -d 0 <username>
        scored: true

      - id: 5.3.3.4.4
        description: "Ensure pam_unix includes use_authtok (Automated)"
        audit: |
          pam_unix_useauthtok_flag="pam_unix_useauthtok_bad"

          if grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so(\s+[^#\n\r]+)?\suse_authtok\b' /etc/pam.d/password-auth 2>/dev/null && \
             grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so(\s+[^#\n\r]+)?\suse_authtok\b' /etc/pam.d/system-auth 2>/dev/null; then
            pam_unix_useauthtok_flag="pam_unix_useauthtok_ok"
          fi

          echo "$pam_unix_useauthtok_flag"
        tests:
          test_items:
            - flag: "pam_unix_useauthtok_ok"
              set: true
        remediation: |
          Ensure the pam_unix.so lines in the password stack include use_authtok so stacked PAM modules enforce the accepted new password.

          1) Identify the active authselect profile templates:
             prof="$(head -1 /etc/authselect/authselect.conf)"
             case "$prof" in
               custom/*) path="/etc/authselect/$prof" ;;
               *)        path="/usr/share/authselect/default/$prof" ;;
             esac

          2) Add use_authtok to pam_unix.so in both templates (password-auth and system-auth):
             # for f in "$path/password-auth" "$path/system-auth"; do
                 if ! grep -Pq '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so(\s+[^#\n\r]+)?\suse_authtok\b' "$f"; then
                   sed -ri 's/^\s*(password\s+(requisite|required|sufficient)\s+pam_unix\.so)(\s+.*)?$/\1\3 use_authtok/' "$f"
                 fi
               done

          3) Apply the changes to /etc/pam.d:
             # authselect apply-changes

          4) Verify:
             # grep -P -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so(\s+[^#\n\r]+)?\suse_authtok\b' /etc/pam.d/{password,system}-auth
        scored: true

  - id: 5.4
    description: "User Accounts and Environment"
    checks:
      - id: 5.4.1
        description: "Set shadow password suite parameters"
        type: "skip"
        checks:
      - id: 5.4.1.1
        description: "Ensure password expiration is configured (Automated)"
        audit: |
          pass_maxdays_flag="pass_maxdays_bad"

          # 1) Read effective PASS_MAX_DAYS from /etc/login.defs (last non-comment wins)
          max_from_defs="$(awk '
            /^[[:space:]]*#/ {next}
            /^[[:space:]]*PASS_MAX_DAYS[[:space:]]+[0-9]+/ {v=$2}
            END {if (v!="") print v}
          ' /etc/login.defs 2>/dev/null)"

          defs_ok=false
          if [ -n "$max_from_defs" ] && [ "$max_from_defs" -ge 1 ] && [ "$max_from_defs" -le 365 ]; then
            defs_ok=true
          fi

          # 2) Verify each local account with a password hash has PASS_MAX_DAYS between 1 and 365
          offenders="$(awk -F: '
            $2 ~ /^\$.+\$/ {                     # has a password hash
              max=$5
              if (max == "" || max < 1 || max > 365) {
                printf("User: %s PASS_MAX_DAYS: %s\n", $1, max)
              }
            }
          ' /etc/shadow 2>/dev/null)"

          if $defs_ok && [ -z "$offenders" ]; then
            pass_maxdays_flag="pass_maxdays_ok"
          fi

          echo "$pass_maxdays_flag"
        tests:
          test_items:
            - flag: "pass_maxdays_ok"
              set: true
        remediation: |
          Configure system-wide password maximum age and align existing accounts to meet policy (≤ 365 days, and > 0).

          1) Set PASS_MAX_DAYS in /etc/login.defs (example: 365 days):
             # sed -ri 's/^\s*PASS_MAX_DAYS\s+.*/PASS_MAX_DAYS 365/; t; $aPASS_MAX_DAYS 365' /etc/login.defs

          2) Update existing local accounts whose MAX_DAYS are out of range:
             # awk -F: '($2~/^\$.+\$/) {if($5 > 365 || $5 < 1 || $5 == "") system("chage --maxdays 365 " $1)}' /etc/shadow

          3) (If initial install set no last-change date, setting PASS_MAX_DAYS may immediately expire passwords.)
             Optionally set the last change date to today to avoid immediate expiry where appropriate:
             # chage -d "$(date +%Y-%m-%d)" <user>

          Notes:
          - Ensure PASS_MAX_DAYS is greater than PASS_MIN_DAYS to allow users to change passwords.
          - Choose the exact value per site policy (must be 1–365 to pass this control).
        scored: true

      - id: 5.4.1.2
        description: "Ensure minimum password days is configured (Manual)"
        audit: |
          grep -Pi -- '^\h*PASS_MIN_DAYS\h+\d+\b' /etc/login.defs
        tests:
          test_items:
            - flag: "PASS_MIN_DAYS"
              compare:
                op: gte
                value: 1
        remediation: |
          Edit /etc/login.defs and set PASS_MIN_DAYS to a value greater than 0 that follows local site policy:

          Example:

          PASS_MIN_DAYS 1
          Run the following command to modify user parameters for all users with a password set to a minimum days greater than zero that follows local site policy:

          # chage --mindays <N> <user>
          Example:

          # awk -F: '($2~/^\$.+\$/) {if($4 < 1)system ("chage --mindays 1 " $1)}' /etc/shadow
        scored: false

      - id: 5.4.1.3
        description: "Ensure password expiration warning days is configured (Automated)"
        audit: |
          grep -Pi -- '^\h*PASS_WARN_AGE\h+\d+\b' /etc/login.defs
        tests:
          test_items:
            - flag: "PASS_WARN_AGE"
              compare:
                op: gte
                value: 7
        remediation: |
          1. Set global warning age in `/etc/login.defs`:
             ```
             PASS_WARN_AGE 7
             ```

          2. Fix user-specific values:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $6 < 7) { print $1 }' /etc/shadow); do
               chage --warndays 7 "$user"
             done
             ```
        scored: true

      - id: 5.4.1.4
        description: "Ensure strong password hashing algorithm is configured (Automated)"
        audit: |
          encrypt_method_flag="encrypt_method_bad"

          # Extract ENCRYPT_METHOD from /etc/login.defs (last non-commented occurrence)
          method="$(awk '
            /^[[:space:]]*#/ {next}
            /^[[:space:]]*ENCRYPT_METHOD[[:space:]]+[A-Za-z0-9_]+/ {m=$2}
            END {if (m!="") print toupper(m)}
          ' /etc/login.defs 2>/dev/null)"

          if [ "$method" = "SHA512" ] || [ "$method" = "YESCRYPT" ]; then
            encrypt_method_flag="encrypt_method_ok"
          fi

          echo "$encrypt_method_flag"
        tests:
          test_items:
            - flag: "encrypt_method_ok"
              set: true
        remediation: |
          Configure the system to use a strong password hashing algorithm for local group passwords.

          1) Edit /etc/login.defs and set ENCRYPT_METHOD to SHA512 or YESCRYPT:
             ENCRYPT_METHOD YESCRYPT
               - OR -
             ENCRYPT_METHOD SHA512

          2) Ensure consistency with PAM configuration (e.g., pam_unix.so uses sha512 or yescrypt).

          3) Optionally, re-encrypt existing group passwords by resetting them after the change.

          Notes:
          - This setting affects only new or modified local group passwords.
          - Recommended algorithms: YESCRYPT (preferred) or SHA512.
        scored: true


      - id: 5.6.1.5
        description: "Ensure inactive password lock is configured (Automated)"
        audit: |
          useradd -D | grep INACTIVE
        tests:
          test_items:
            - flag: "INACTIVE"
              compare:
                op: lte
                value: 45
            - flag: "INACTIVE"
              compare:
                op: gte
                value: 0
        remediation: |
          Run the following command to set the default password inactivity period to 45 days or less that meets local site policy:

          # useradd -D -f <N>
          Example:

          # useradd -D -f 45
          Run the following command to modify user parameters for all users with a password set to a inactive age of 45 days or less that follows local site policy:

          # chage --inactive <N> <user>
          Example:

          # awk -F: '($2~/^\$.+\$/) {if($7 > 45 || $7 < 0)system ("chage --inactive 45 " $1)}' /etc/shadow
        scored: true

      - id: 5.4.1.6
        description: "Ensure all users last password change date is in the past (Automated)"
        audit: |
          lastchg_flag="users_lastchange_bad"
          offenders=0
          now_ts="$(date +%s)"

          while IFS= read -r u; do
            # Get human date (skip "never")
            hdate="$(chage --list "$u" | awk -F': ' '/^Last password change/{print $2}' | grep -vE '^\s*never\s*$')"
            [ -z "$hdate" ] && continue
            ts="$(date -d "$hdate" +%s 2>/dev/null || echo)"
            [ -z "$ts" ] && continue
            if [ "$ts" -gt "$now_ts" ]; then
              offenders=$((offenders+1))
            fi
          done < <(awk -F: '$2~/^\$.+\$/{print $1}' /etc/shadow)

          if [ "$offenders" -eq 0 ]; then
            lastchg_flag="users_lastchange_ok"
          fi

          echo "$lastchg_flag"
        tests:
          test_items:
            - flag: "users_lastchange_ok"
              set: true
        remediation: |
          Investigate any account whose "Last password change" is set in the future and correct it.

          Suggested approaches:
          - Set the last change date to today (or an appropriate past date):
              # chage -d "$(date +%Y-%m-%d)" <user>
          - Expire the password to force a reset on next login:
              # chage -d 0 <user>
          - If the account should be disabled, lock it:
              # usermod -L <user>

          After correction, re-run the audit to confirm no users report a future last-change date.
        scored: true

      - id: 5.4.2
        description: "Configure root and system accounts and environment"
        type: "skip"
        checks:
      - id: 5.4.2.1
        description: "Ensure root is the only UID 0 account (Automated)"
        audit: "awk -F: '($3 == 0) { print $1 }' /etc/passwd"
        tests:
          test_items:
            - flag: "root"
        remediation: |
          Run the following command to change the root account UID to 0:

          # usermod -u 0 root
          Modify any users other than root with UID 0 and assign them a new UID.
        scored: true

      - id: 5.4.2.2
        description: "Ensure root is the only GID 0 account (Automated)"
        audit: |
          awk -F: '($1 !~ /^(sync|shutdown|halt|operator)/ && $4=="0") {print $1":"$4}' /etc/passwd
        tests:
          test_items:
            - flag: "root:0"
        remediation: |
          Run the following command to set the root user's GID to 0:

          # usermod -g 0 root
          Run the following command to set the root group's GID to 0:

          # groupmod -g 0 root
          Remove any users other than the root user with GID 0 or assign them a new GID if appropriate.
        scored: true

      - id: 5.4.2.3
        description: "Ensure group root is the only GID 0 group (Automated)"
        audit: |
          awk -F: '$3=="0"{print $1":"$3}' /etc/group
        tests:
          test_items:
            - flag: "root:0"
        remediation: |
          Run the following command to set the root group's GID to 0:

          # groupmod -g 0 root
          Remove any groups other than the root group with GID 0 or assign them a new GID if appropriate.
        scored: true

      - id: 5.4.2.4
        description: "Ensure root account access is controlled (Automated)"
        audit: |
          root_access_flag="root_access_bad"

          # Check root account status
          status="$(passwd -S root 2>/dev/null | awk '{print $2}')"

          if [ "$status" = "P" ] || [ "$status" = "L" ]; then
            root_access_flag="root_access_ok"
          fi

          echo "$root_access_flag"
        tests:
          test_items:
            - flag: "root_access_ok"
              set: true
        remediation: |
          Ensure the root account is protected by a password or locked.

          To set a strong password for the root user:
            # passwd root

          OR to lock the root account (if direct login should be disabled):
            # usermod -L root

          Notes:
          - Root must either have a valid password (status "P") or be locked (status "L").
          - Verify with:
              # passwd -S root
        scored: true

      - id: 5.4.2.5
        description: "Ensure root path integrity (Automated)"
        audit: |
          root_path_flag="root_path_bad"
          l_output2=""
          l_pmask="0022"
          l_maxperm="$(printf '%o' $((0777 & ~$l_pmask)))"

          # Get root's PATH from a login shell; fall back to current env if unavailable
          l_root_path="$(sudo -Hiu root env 2>/dev/null | awk -F= '$1=="PATH"{print $2}')"
          [ -z "$l_root_path" ] && l_root_path="$(env | awk -F= '$1=="PATH"{print $2}')"

          # Basic string sanity checks
          grep -q "::" <<< "$l_root_path" && l_output2="$l_output2\n - root's PATH contains an empty directory (::)"
          grep -Pq ":\s*$" <<< "$l_root_path" && l_output2="$l_output2\n - root's PATH contains a trailing (:)"
          grep -Pq '(^|:)\.(?=:$|:|\s*$)' <<< "$l_root_path" && l_output2="$l_output2\n - root's PATH contains current working directory (.)"

          # Per-entry checks
          IFS=":" read -r -a a_path_loc <<< "$l_root_path"
          for l_path in "${a_path_loc[@]}"; do
            [ -z "$l_path" ] && continue
            if [ -d "$l_path" ]; then
              read -r l_fmode l_fown <<< "$(stat -Lc '%#a %U' "$l_path" 2>/dev/null || echo "")"
              if [ -z "$l_fmode" ]; then
                l_output2="$l_output2\n - Unable to stat \"$l_path\""
                continue
              fi
              [ "$l_fown" != "root" ] && l_output2="$l_output2\n - Directory: \"$l_path\" is owned by: \"$l_fown\" (should be root)"
              # Fail if group/other write bits present (mask 0022)
              [ $(( l_fmode & l_pmask )) -gt 0 ] && l_output2="$l_output2\n - Directory: \"$l_path\" has mode \"$l_fmode\" (should be $l_maxperm or more restrictive)"
            else
              l_output2="$l_output2\n - \"$l_path\" is not a directory"
            fi
          done

          if [ -z "$l_output2" ]; then
            echo "root_path_ok"
          else
            echo "root_path_bad"
          fi
        tests:
          test_items:
            - flag: "root_path_ok"
              set: true
        remediation: |
          Correct any issues in root's PATH:

          - Remove non-directory entries from PATH.
          - Eliminate empty elements (::), trailing colons (:), and the current directory (.) from PATH.
          - Ensure each PATH directory:
              * is owned by root:
                # chown root <dir>
              * has permissions 0755 or more restrictive (no group/other write):
                # chmod 0755 <dir>

          Recommended steps:
          1) Inspect root's PATH:
             # sudo -Hiu root env | grep '^PATH='

          2) Fix shell init files that set PATH (e.g., /root/.bash_profile, /root/.bashrc, /etc/profile, /etc/profile.d/*.sh) to remove '.', empty entries, and trailing ':'.

          3) Correct ownership and permissions of each PATH directory:
             # chown root:root /path/to/dir
             # chmod 0755 /path/to/dir

          4) Re-log as root and re-run the audit to confirm compliance.
        scored: true

      - id: 5.4.2.6
        description: "Ensure root user umask is configured (Automated)"
        audit: |
          grep -Psi -- '^\h*umask\h+(([0-7][0-7][01][0-7]\b|[0-7][0-7][0-7][0-6]\b)|([0-7][01][0-7]\b|[0-7][0-7][0-6]\b)|(u=[rwx]{1,3},)?(((g=[rx]?[rx]?w[rx]?[rx]?\b)(,o=[rwx]{1,3})?)|((g=[wrx]{1,3},)?o=[wrx]{1,3}\b)))' /root/.bash_profile /root/.bashrc
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /root/.bash_profile and /root/.bashrc and remove, comment out, or update any line with umask to be 0027 or more restrictive.
        scored: true

      - id: 5.4.2.7
        description: "Ensure system accounts do not have a valid login shell (Automated)"
        audit: |
          {
             l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
             awk -v pat="$l_valid_shells" -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $(NF) ~ pat) {print "Service account: \"" $1 "\" has a valid shell: " $7}' /etc/passwd
          }
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set the shell for any service accounts returned by the audit to nologin:

          # usermod -s $(command -v nologin) <user>
          Example script:

          #!/usr/bin/env bash

          {
             l_valid_shells="^($( awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
             awk -v pat="$l_valid_shells" -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $(NF) ~ pat) {system ("usermod -s '"$(command -v nologin)"' " $1)}' /etc/passwd
          }
        scored: true

      - id: 5.4.2.8
        description: "Ensure accounts without a valid login shell are locked (Automated)"
        audit: |
          {
             l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
             while IFS= read -r l_user; do
                passwd -S "$l_user" | awk '$2 !~ /^L/ {print "Account: \"" $1 "\" does not have a valid login shell and is not locked"}'
             done < <(awk -v pat="$l_valid_shells" -F: '($1 != "root" && $(NF) !~ pat) {print $1}' /etc/passwd)
          }
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to lock any non-root accounts without a valid login shell returned by the audit:

          # usermod -L <user>
          Example script::

          #!/usr/bin/env bash

          {
             l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
             while IFS= read -r l_user; do
                passwd -S "$l_user" | awk '$2 !~ /^L/ {system ("usermod -L " $1)}'
             done < <(awk -v pat="$l_valid_shells" -F: '($1 != "root" && $(NF) !~ pat) {print $1}' /etc/passwd)
          }
        scored: true

      - id: 5.4.3
        description: "Configure user default environment"
        type: "skip"
        checks:
      - id: 5.4.3.1
        description: "Ensure nologin is not listed in /etc/shells (Automated)"
        audit: |
          grep -Ps '^\h*([^#\n\r]+)?\/nologin\b' /etc/shells
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/shells and remove any lines that include nologin
        scored: true
      - id: 5.4.3.2
        description: "Ensure default user shell timeout is configured (Automated)"
        audit: |
          tmout_flag="tmout_bad"
          files="$(ls -1 /etc/*bashrc /etc/profile /etc/profile.d/*.sh 2>/dev/null | tr '\n' ' ')"

          # Allowed TMOUT values: 1..900
          _ALLOWED_RGX='(?:[1-9]|[1-9][0-9]|[1-8][0-9]{2}|900)'
          _BAD_RGX='(0|90[1-9]|9[1-9][0-9]|[1-9][0-9]{3,})'

          # 1) Ensure TMOUT is set (readonly+export), via either:
          #    a) single-line typeset -xr TMOUT=<1..900>, OR
          #    b) TMOUT=<1..900> plus readonly TMOUT and export TMOUT present somewhere in the same config set
          ok_a=false
          ok_b=false

          # a) typeset -xr TMOUT=<allowed>
          if grep -Pqs -- "^\s*typeset\s+-xr\s+TMOUT=${_ALLOWED_RGX}\b" $files; then
            ok_a=true
          fi

          # b) TMOUT=<allowed> exists AND readonly TMOUT exists AND export TMOUT exists
          if grep -Pqs -- "^\s*TMOUT=${_ALLOWED_RGX}\b" $files && \
             grep -Pqs -- "^\s*(readonly\s+TMOUT|typeset\s+-r\s+TMOUT\b)" $files && \
             grep -Pqs -- "^\s*(export(\s+[^#\r\n]+)?TMOUT\b|typeset\s+-x(r)?\s*TMOUT=)" $files; then
            ok_b=true
          fi

          # 2) Ensure there are NO bad TMOUT assignments (0 or >900) anywhere
          bad_set=false
          if grep -Pqs -- "^\s*TMOUT\s*=\s*${_BAD_RGX}\b" $files; then
            bad_set=true
          fi

          # 3) Declare PASS only if (a OR b) and no bad assignments
          if { $ok_a || $ok_b; } && ! $bad_set; then
            tmout_flag="tmout_ok"
          fi

          echo "$tmout_flag"
        tests:
          test_items:
            - flag: "tmout_ok"
              set: true
        remediation: |
          Configure a single, system-wide shell timeout that is ≤ 900 seconds, exported, and readonly. Recommended approach:

          1) Create a dedicated profile script:
             # printf '%s\n' "# Set TMOUT to 900 seconds" "typeset -xr TMOUT=900" > /etc/profile.d/50-tmout.sh

          2) Remove or comment out conflicting TMOUT settings in:
             - /etc/profile
             - /etc/bashrc
             - /etc/profile.d/*.sh
             Ensure there are no entries setting TMOUT to 0 or > 900.

          3) Re-log or source the profile to apply:
             # . /etc/profile

          Notes:
          - Set TMOUT only once to avoid readonly redefinition errors.
          - Acceptable configuration (single line):  typeset -xr TMOUT=900
          - Deprecated alternatives (not recommended): separate TMOUT=..., readonly TMOUT, export TMOUT lines.
        scored: true

      - id: 5.4.3.3
        description: "Ensure default user umask is configured (Automated)"
        audit: |
          umask_flag="umask_bad"
          umask_ok=false

          # Check umask setting in /etc/profile.d, /etc/profile, /etc/bashrc, and PAM/postlogin
          files=$(find /etc/profile.d/ -type f -name '*.sh' 2>/dev/null; echo /etc/profile /etc/bashrc /etc/pam.d/postlogin /etc/login.defs /etc/default/login)

          for f in $files; do
            if grep -Psiq -- '^\s*umask\s+(0?[0-7]27|0?[0-7]77|u=rwx,g=rx,o=)\b' "$f" 2>/dev/null; then
              umask_ok=true
              break
            fi
            if grep -Psiq -- '^\s*session\s+[^#\n\r]+\s+pam_umask\.so\s+([^#\n\r]+\s+)?umask=(0?[0-7]27|0?[0-7]77)\b' "$f" 2>/dev/null; then
              umask_ok=true
              break
            fi
          done

          if $umask_ok; then
            umask_flag="umask_ok"
          fi

          echo "$umask_flag"
        tests:
          test_items:
            - flag: "umask_ok"
              set: true
        remediation: |
          Set the system-wide default umask to 027 (octal) or more restrictive.

          1) Preferred method — create a profile script:
             # printf '%s\n' "umask 027" > /etc/profile.d/50-systemwide_umask.sh

          2) Alternatively, configure in one of these files if not already set:
             - /etc/profile
             - /etc/bashrc
             - /etc/login.defs (using pam_umask)
             - /etc/pam.d/postlogin (if using pam_umask.so)

             Example for PAM:
               session optional pam_umask.so umask=027

          3) Remove or comment out weaker umask values (e.g., 022, 002) found in:
             /etc/profile, /etc/bashrc, /etc/profile.d/*.sh, /etc/login.defs, /etc/default/login

          Notes:
          - A default umask of 027 results in new files with permissions 640 and directories with 750.
          - This setting ensures that group and world access is restricted by default.
        scored: true

  - id: 6
    description: "Logging and Auditing"
    checks:
  - id: 6.1
    description: "Configure Integrity Checking"
    checks:
      - id: 6.1.1
        description: "Ensure AIDE is installed (Automated)"
        audit: "rpm -q aide"
        tests:
          test_items:
            - flag: "package aide is not installed"
              set: false
        remediation: |
          Run the following command to install aide:

          # dnf install aide
          Configure aide as appropriate for your environment. Consult the aide documentation for options.

          Initialize aide:

          Run the following commands:

          # aide --init
          # mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
        scored: true

      - id: 6.1.2
        description: "Ensure filesystem integrity is regularly checked (Automated)"
        audit: |
          # Pass if AIDE check is scheduled via cron OR systemd timer
          flag="AIDE_SCHEDULED_BAD"

          # 1) Look for cron entries that run 'aide' (or aide.wrapper) with --check/--update or $AIDEARGS
          if grep -Ersq '^([^#]+\s+)?(\/usr\/s?bin\/|^\s*)aide(\.wrapper)?\s(--?\S+\s)*(--(check|update)|\$AIDEARGS)\b' \
              /etc/cron.* /etc/crontab /var/spool/cron/ 2>/dev/null; then
            flag="AIDE_SCHEDULED_OK(CRON)"
          else
            # 2) Otherwise, look for a systemd timer setup (aidecheck.{service,timer})
            svc_enabled="$(systemctl is-enabled aidecheck.service 2>/dev/null || true)"
            tmr_enabled="$(systemctl is-enabled aidecheck.timer 2>/dev/null || true)"
            tmr_active="$(systemctl is-active aidecheck.timer 2>/dev/null || true)"
            if [ "$svc_enabled" = "enabled" ] && [ "$tmr_enabled" = "enabled" ] && [ "$tmr_active" = "active" ]; then
              flag="AIDE_SCHEDULED_OK(SYSTEMD)"
            fi
          fi

          echo "$flag"
        tests:
          test_items:
            - flag: "AIDE_SCHEDULED_OK"
              set: true
        remediation: |
          Configure AIDE to run daily at 05:00 using ONE of the following methods:

          Option A — Cron (simple):
            # crontab -u root -e
            Add:
              0 5 * * * /usr/sbin/aide --check

          Option B — systemd timer (recommended on systemd-based hosts):
            Create /etc/systemd/system/aidecheck.service with:
              [Unit]
              Description=Aide Check

              [Service]
              Type=simple
              ExecStart=/usr/sbin/aide --check

            Create /etc/systemd/system/aidecheck.timer with:
              [Unit]
              Description=Aide check every day at 5AM

              [Timer]
              OnCalendar=*-*-* 05:00:00
              Unit=aidecheck.service

              [Install]
              WantedBy=multi-user.target

            Then:
              # chown root:root /etc/systemd/system/aidecheck.*
              # chmod 0644 /etc/systemd/system/aidecheck.*
              # systemctl daemon-reload
              # systemctl enable aidecheck.service
              # systemctl --now enable aidecheck.timer
        scored: true

      - id: 6.1.3
        description: "Ensure cryptographic mechanisms are used to protect the integrity of audit tools (Automated)"
        audit: |
          aide_audit_flag="aide_audit_bad"

          # Verify AIDE is installed and configuration exists
          aide_conf="$(whereis aide.conf | awk '{print $2}')"
          [ ! -f "$aide_conf" ] && { echo "aide_audit_bad (AIDE not installed or aide.conf missing)"; exit 0; }

          # List of audit tools to verify
          audit_tools=(auditctl auditd ausearch aureport autrace augenrules)
          ok=true

          for tool in "${audit_tools[@]}"; do
            path="$(readlink -f "/sbin/$tool" 2>/dev/null || readlink -f "/usr/sbin/$tool" 2>/dev/null)"
            [ -z "$path" ] && continue
            if ! grep -Pq -- "^\s*${path}\s+.*\b(p|i|n|u|g|s|b|acl|xattrs|sha512)\b.*\bsha512\b" "$aide_conf" /etc/aide.conf.d/*.conf 2>/dev/null; then
              ok=false
              echo "Missing or incomplete AIDE configuration for $path"
            fi
          done

          if $ok; then
            aide_audit_flag="aide_audit_ok"
          fi

          echo "$aide_audit_flag"
        tests:
          test_items:
            - flag: "aide_audit_ok"
              set: true
        remediation: |
          Configure AIDE to verify the integrity of audit tools using cryptographic mechanisms.

          1) Determine the absolute path for each audit binary:
             # readlink -f /sbin/auditctl
             (Repeat for auditd, ausearch, aureport, autrace, augenrules.)

          2) Edit /etc/aide.conf (or the included AIDE configuration file) and add the following entries,
             replacing <PATH> with the correct absolute path returned by the above commands:

             # Audit Tools
             <PATH>/auditctl  p+i+n+u+g+s+b+acl+xattrs+sha512
             <PATH>/auditd    p+i+n+u+g+s+b+acl+xattrs+sha512
             <PATH>/ausearch  p+i+n+u+g+s+b+acl+xattrs+sha512
             <PATH>/aureport  p+i+n+u+g+s+b+acl+xattrs+sha512
             <PATH>/autrace   p+i+n+u+g+s+b+acl+xattrs+sha512
             <PATH>/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512

          3) If /etc/aide.conf uses @@x_include directives to include other config files,
             ensure these entries are placed in the included configuration directory.

          4) Save changes and update the AIDE database:
             # aide --init
             # mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz

          Notes:
          - Ensure sha512 is included for strong cryptographic integrity.
          - All audit tool entries should include: p+i+n+u+g+s+b+acl+xattrs+sha512
          - Protect AIDE configuration files from unauthorized modification (owned by root, 0600).
        scored: true

  - id: 6.2
    description: "System Logging"
    checks:
      - id: 6.2.1
        description: "Configure systemd-journald service"
        type: "skip"
        checks:
      - id: 6.2.1.1
        description: "Ensure journald service is enabled and active (Automated)"
        audit: |
          journald_flag="journald_bad"

          # Check if systemd-journald is enabled (expected: static)
          enabled_state="$(systemctl is-enabled systemd-journald.service 2>/dev/null || echo "unknown")"
          active_state="$(systemctl is-active systemd-journald.service 2>/dev/null || echo "inactive")"

          if [ "$enabled_state" = "static" ] && [ "$active_state" = "active" ]; then
            journald_flag="journald_ok"
          fi

          echo "$journald_flag"
        tests:
          test_items:
            - flag: "journald_ok"
              set: true
        remediation: |
          Ensure the systemd-journald service is unmasked and active to collect system logs.

          1) Unmask and start the service:
             # systemctl unmask systemd-journald.service
             # systemctl start systemd-journald.service

          2) Verify the service state:
             # systemctl is-enabled systemd-journald.service
               Expected output: static
             # systemctl is-active systemd-journald.service
               Expected output: active

          Notes:
          - The "static" enabled state is expected and normal for journald.
          - If the service is masked or inactive, logging will not function correctly.
        scored: true

      - id: 6.2.1.2
        description: "Ensure journald log file access is configured (Manual)"
        audit: |
          #!/usr/bin/env bash
          # PASS if journald tmpfiles configuration applies 0640 or more restrictive permissions.
          set -euo pipefail

          file_path=""
          if [ -f /etc/tmpfiles.d/systemd.conf ]; then
            file_path="/etc/tmpfiles.d/systemd.conf"
          elif [ -f /usr/lib/tmpfiles.d/systemd.conf ]; then
            file_path="/usr/lib/tmpfiles.d/systemd.conf"
          fi

          if [ -z "$file_path" ]; then
            echo "Fail: no systemd.conf found under /etc/tmpfiles.d or /usr/lib/tmpfiles.d"
            exit 0
          fi

          # Check for any lines that set perms weaker than 0640 (e.g. world/group writeable or readable)
          if grep -Piq '^\s*[a-z]+\s+[^\s]+\s+0*([6-7][4-7][1-7]|7[0-7][0-7])\s+' "$file_path"; then
            echo "JOURNALD_PERMS_BAD:$file_path"
          else
            echo "JOURNALD_PERMS_OK:$file_path"
          fi
        tests:
          test_items:
            - flag: "JOURNALD_PERMS_OK"
              set: true
        remediation: |
          # If the default configuration does not meet site requirements, copy and adjust it:
          #
          # cp /usr/lib/tmpfiles.d/systemd.conf /etc/tmpfiles.d/systemd.conf
          #
          # Edit /etc/tmpfiles.d/systemd.conf to ensure journald log files have permissions
          # mode 0640 or more restrictive (or per local site policy).
          #
          # Example (within /etc/tmpfiles.d/systemd.conf):
          #   z /var/log/journal 0640 root systemd-journal - -
          #
          # Then reload tmpfiles configuration:
          #   systemd-tmpfiles --create
        scored: true

      - id: 6.2.1.3
        description: "Ensure journald log file rotation is configured (Manual)"
        audit: |
          # Review journald configuration for rotation settings.
          # These parameters control log size limits and rotation policy.
          systemd-analyze cat-config systemd/journald.conf | grep -E '(SystemMaxUse|SystemKeepFree|RuntimeMaxUse|RuntimeKeepFree|MaxFileSec)'
        type: "manual"
        remediation: |
          Configure journald log file rotation settings to manage log size and retention.

          1) Edit /etc/systemd/journald.conf or create a configuration file in /etc/systemd/journald.conf.d/
             (e.g., /etc/systemd/journald.conf.d/50-logrotation.conf).

          2) In the [Journal] section, define log rotation parameters that meet site policy, for example:

             [Journal]
             SystemMaxUse=1G
             SystemKeepFree=500M
             RuntimeMaxUse=200M
             RuntimeKeepFree=50M
             MaxFileSec=1month

          3) Reload the journald service to apply changes:
             # systemctl restart systemd-journald

          Notes:
          - Values should be adjusted to meet organizational policy and available disk space.
          - Parameters appearing later in the configuration (or in later-loaded files) override earlier ones.
          - SystemMaxUse and RuntimeMaxUse define the maximum disk space journald can use for persistent and runtime storage, respectively.
        scored: false

      - id: 6.2.1.4
        description: "Ensure only one logging system is in use (Automated)"
        audit: |
          {
              l_output="" l_output2="" # Check the status of rsyslog and journald
              if systemctl is-active --quiet rsyslog; then
                  l_output="$l_output\n - rsyslog is in use\n- follow the recommendations in Configure rsyslog subsection only"
              elif systemctl is-active --quiet systemd-journald; then
                  l_output="$l_output\n - journald is in use\n- follow the recommendations in Configure journald subsection only"
              else
                  echo -e “unable to determine system logging”
                  l_output2="$l_output2\n - unable to determine system logging\n- Configure only ONE system logging: rsyslog OR journald"
              fi
              if [ -z "$l_output2" ]; then  # Provide audit results
                  echo -e "\n- Audit Result:\n  ** PASS **\n$l_output\n"
              else
                  echo -e "\n- Audit Result:\n  ** FAIL **\n - Reason(s) for audit failure:\n$l_output2"
              fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          Ensure that only one logging system—either rsyslog or journald—is in active use.

          1) Check current logging services:
             # systemctl is-active rsyslog
             # systemctl is-active systemd-journald

          2) Choose one logging system per organizational policy:
             - **Option A: journald only**
               # systemctl stop rsyslog
               # systemctl disable rsyslog
               journald remains active by default.

             - **Option B: rsyslog only**
               # systemctl enable --now rsyslog
               # systemctl stop systemd-jjournald.socket
               # systemctl mask systemd-journald.socket
               (Note: journald cannot be fully disabled but should not be forwarding or duplicating logs.)

          3) Verify that only the chosen service is active:
             # systemctl is-active rsyslog
             # systemctl is-active systemd-journald

          Notes:
          - Running both services can cause duplicate logs and wasted resources.
          - After making changes, test log generation and confirm logs are being properly captured.
        scored: true
      - id: 6.2.2
        description: "Configure journald"
        type: "skip"
        checks:
      - id: 6.2.2.1
        description: "Configure systemd-journal-remote"
        type: "skip"
        checks:
      - id: 6.2.2.1.1
        description: "Ensure systemd-journal-remote is installed (Automated)"
        audit: "rpm -q systemd-journal-remote"
        tests:
          test_items:
            - flag: "package systemd-journal-remote is not installed"
              set: false
        remediation: |
          Run the following command to install systemd-journal-remote:
            # dnf install systemd-journal-remote
        scored: true

      - id: 6.2.2.1.2
        description: "Ensure systemd-journal-upload authentication is configured (Manual)"
        audit: |
          grep -P "^ *URL=|^ *ServerKeyFile=|^ *ServerCertificateFile=|^ *TrustedCertificateFile=" /etc/systemd/journal-upload.conf
        type: "manual"
        remediation: |
          Edit the /etc/systemd/journal-upload.conf file or a file in /etc/systemd/journal-upload.conf.d ending in .conf and ensure the following lines are set in the [Upload] section per your environment:

          [Upload]
          URL=192.168.50.42
          ServerKeyFile=/etc/ssl/private/journal-upload.pem
          ServerCertificateFile=/etc/ssl/certs/journal-upload.pem
          TrustedCertificateFile=/etc/ssl/ca/trusted.pem
          Restart the service:

          # systemctl restart systemd-journal-upload
        scored: false
      - id: 6.2.2.1.3
        description: "Ensure systemd-journal-upload is enabled and active (Automated)"
        audit: |
          journald_flag="journald_bad"

          enabled_state="$(systemctl is-enabled systemd-journal-upload.service 2>/dev/null || echo "unknown")"
          active_state="$(systemctl is-active systemd-journal-upload.service 2>/dev/null || echo "inactive")"

          if [ "$enabled_state" = "enabled" ] && [ "$active_state" = "active" ]; then
            journald_flag="journald_ok"
          fi

          echo "$journald_flag"
        tests:
          test_items:
            - flag: "journald_ok"
        remediation: |
          Run the following commands to unmask, enable and start systemd-journal-upload:

          # systemctl unmask systemd-journal-upload.service
          # systemctl --now enable systemd-journal-upload.service
        scored: true

      - id: 6.2.2.1.4
        description: "Ensure systemd-journal-remote service is not in use (Automated)"
        audit: |
          journal_remote_flag="journal_remote_bad"

          enabled_chk="$(systemctl is-enabled systemd-journal-remote.socket systemd-journal-remote.service 2>/dev/null | grep -P '^enabled' || true)"
          active_chk="$(systemctl is-active systemd-journal-remote.socket systemd-journal-remote.service 2>/dev/null | grep -P '^active' || true)"

          if [ -z "$enabled_chk" ] && [ -z "$active_chk" ]; then
            journal_remote_flag="journal_remote_ok"
          fi

          echo "$journal_remote_flag"
        tests:
          test_items:
            - flag: "journal_remote_ok"
              set: true
        remediation: |
          Disable and stop systemd-journal-remote services to prevent this system from acting as a log server.

          1) Stop both the socket and service if running:
             # systemctl stop systemd-journal-remote.socket systemd-journal-remote.service

          2) Mask both to prevent future activation:
             # systemctl mask systemd-journal-remote.socket systemd-journal-remote.service

          3) Verify that both are inactive and disabled:
             # systemctl is-active systemd-journal-remote.socket systemd-journal-remote.service
               (No "active" output expected)
             # systemctl is-enabled systemd-journal-remote.socket systemd-journal-remote.service
               (No "enabled" output expected)

          Note:
          - Applies only if journald is used for local logging.
          - Do not apply if rsyslog is configured for remote log collection.
        scored: true

      - id: 6.2.2.2
        description: "Ensure journald ForwardToSyslog is disabled (Automated)"
        audit: |
          systemd-analyze cat-config systemd/journald.conf systemd/journald.conf.d/* | grep -E "^ForwardToSyslog=no"
        tests:
          test_items:
            - flag: "ForwardToSyslog=no"
        remediation: |
          - IF - rsyslog is the preferred method for capturing logs, this section and Recommendation should be skipped and the "Configure rsyslog" section followed.
          - IF - journald is the preferred method for capturing logs:
          Set the following parameter in the [Journal] section in /etc/systemd/journald.conf or a file in /etc/systemd/journald.conf.d/ ending in .conf:
          ForwardToSyslog=no
          Example:
          #!/usr/bin/env bash
          {
             [ ! -d /etc/systemd/journald.conf.d/ ] && mkdir /etc/systemd/journald.conf.d/
             if grep -Psq -- '^\h*\[Journal\]' /etc/systemd/journald.conf.d/60-journald.conf; then
                printf '%s\n' "ForwardToSyslog=no" >> /etc/systemd/journald.conf.d/60-journald.conf
             else
                printf '%s\n' "[Journal]" "ForwardToSyslog=no" >> /etc/systemd/journald.conf.d/60-journald.conf
             fi
          }
          Note: If this setting appears in a canonically later file, or later in the same file, the setting will be overwritten
          Run to following command to update the parameters in the service:
          # systemctl reload-or-restart systemd-journald
        scored: true

      - id: 6.2.2.3
        description: "Ensure journald Compress is configured (Automated)"
        audit: |
          systemd-analyze cat-config systemd/journald.conf systemd/journald.conf.d/* | grep -E "^Compress=yes"
        tests:
          test_items:
            - flag: "Compress=yes"
        remediation: |
          Set the following parameter in the [Journal] section in /etc/systemd/journald.conf or a file in /etc/systemd/journald.conf.d/ ending in .conf:
          Compress=yes
          Example:
          #!/usr/bin/env bash
          {
             [ ! -d /etc/systemd/journald.conf.d/ ] && mkdir /etc/systemd/journald.conf.d/
             if grep -Psq -- '^\h*\[Journal\]' /etc/systemd/journald.conf.d/60-journald.conf; then
                printf '%s\n' "Compress=yes" >> /etc/systemd/journald.conf.d/60-journald.conf
             else
                printf '%s\n' "[Journal]" "Compress=yes" >> /etc/systemd/journald.conf.d/60-journald.conf
             fi
          }
          Note: If this setting appears in a canonically later file, or later in the same file, the setting will be overwritten
          Run to following command to update the parameters in the service:
          # systemctl reload-or-restart systemd-journald
        scored: true

      - id: 6.2.2.4
        description: "Ensure journald Storage is configured (Automated)"
        audit: |
          systemd-analyze cat-config systemd/journald.conf systemd/journald.conf.d/* | grep -E "^Storage=persistent"
        tests:
          test_items:
            - flag: "Storage=persistent"
        remediation: |
          Set the following parameter in the [Journal] section in /etc/systemd/journald.conf or a file in /etc/systemd/journald.conf.d/ ending in .conf:
          Storage=persistent
          Example:
          #!/usr/bin/env bash
          {
             [ ! -d /etc/systemd/journald.conf.d/ ] && mkdir /etc/systemd/journald.conf.d/
             if grep -Psq -- '^\h*\[Journal\]' /etc/systemd/journald.conf.d/60-journald.conf; then
                printf '%s\n' "Storage=persistent" >> /etc/systemd/journald.conf.d/60-journald.conf
             else
                printf '%s\n' "[Journal]" "Storage=persistent" >> /etc/systemd/journald.conf.d/60-journald.conf
             fi
          }
          Note: If this setting appears in a canonically later file, or later in the same file, the setting will be overwritten
          Run to following command to update the parameters in the service:
          # systemctl reload-or-restart systemd-journald
        scored: true


      - id: 6.2.3
        description: "Configure rsyslog"
        type: "skip"
        checks:
      - id: 6.2.3.1
        description: "Ensure rsyslog is installed (Automated)"
        audit: "rpm -q rsyslog"
        tests:
          test_items:
            - flag: "package rsyslog is not installed"
              set: false
        remediation: |
          Run the following command to install rsyslog:
            # dnf install rsyslog
        scored: true

      - id: 6.2.3.2
        description: "Ensure rsyslog service is enabled and active (Automated)"
        audit: |
          rsyslog_flag="rsyslog_bad"

          enabled_state="$(systemctl is-enabled rsyslog 2>/dev/null || echo "unknown")"
          active_state="$(systemctl is-active rsyslog 2>/dev/null || echo "inactive")"

          if [ "$enabled_state" = "enabled" ] && [ "$active_state" = "active" ]; then
            rsyslog_flag="rsyslog_ok"
          fi

          echo "$rsyslog_flag"
        tests:
          test_items:
            - flag: "rsyslog_ok"
        remediation: |
          -IF - rsyslog is being used for logging on the system:

          Run the following commands to unmask, enable, and start rsyslog.service:

          # systemctl unmask rsyslog.service
          # systemctl enable rsyslog.service
          # systemctl start rsyslog.service
        scored: true

      - id: 6.2.3.3
        description: "Ensure journald is configured to send logs to rsyslog (Manual)"
        audit: |
          systemd-analyze cat-config systemd/journald.conf systemd/journald.conf.d/* | grep -E "^ForwardToSyslog=yes"
        tests:
          test_items:
            - flag: "ForwardToSyslog=yes"
        remediation: |
          - IF - rsyslog is the preferred method for capturing logs:
          Set the following parameter in the [Journal] section in /etc/systemd/journald.conf or a file in /etc/systemd/journald.conf.d/ ending in .conf:
          ForwardToSyslog=yes
          Example:
          #!/usr/bin/env bash
          {
             [ ! -d /etc/systemd/journald.conf.d/ ] && mkdir /etc/systemd/journald.conf.d/
             if grep -Psq -- '^\h*\[Journal\]' /etc/systemd/journald.conf.d/60-journald.conf; then
                printf '%s\n' "ForwardToSyslog=yes" >> /etc/systemd/journald.conf.d/60-journald.conf
             else
                printf '%s\n' "[Journal]" "ForwardToSyslog=yes" >> /etc/systemd/journald.conf.d/60-journald.conf
             fi
          }
          Note: If this setting appears in a canonically later file, or later in the same file, the setting will be overwritten
          Run to following command to update the parameters in the service:
          Restart systemd-journald.service:
          # systemctl reload-or-restart systemd-journald.service
        scored: true

      - id: 6.2.3.4
        description: "Ensure rsyslog log file creation mode is configured (Automated)"
        audit: |
          # Verify rsyslog is configured to create new log files with permissions 0640 or stricter.
          if ! rpm -q rsyslog >/dev/null 2>&1; then
            echo "rsyslog_not_installed"
            exit 0
          fi

          if ! systemctl is-enabled rsyslog 2>/dev/null | grep -qE 'enabled|static'; then
            echo "rsyslog_not_enabled"
            exit 0
          fi

          grep -Ps '^\h*\$FileCreateMode\h+0[0,2,4,6][0,2,4]0\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null | grep -q '0640'
          if [ $? -eq 0 ]; then
            echo "rsyslog_filecreatemode_ok"
          else
            echo "rsyslog_filecreatemode_not_ok"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rsyslog_filecreatemode_ok"
              set: true
            - flag: "rsyslog_not_installed"
              set: true
            - flag: "rsyslog_not_enabled"
              set: true
        remediation: |
          # Configure rsyslog to create log files with permissions 0640 or more restrictive
          if [ -f /etc/rsyslog.conf ]; then
            if grep -q '^\s*\$FileCreateMode' /etc/rsyslog.conf; then
              sed -i 's/^\s*\$FileCreateMode.*/$FileCreateMode 0640/' /etc/rsyslog.conf
            else
              echo '$FileCreateMode 0640' >> /etc/rsyslog.conf
            fi
          else
            echo '$FileCreateMode 0640' > /etc/rsyslog.conf
          fi

          # Restart rsyslog to apply changes
          systemctl restart rsyslog
        scored: true

      - id: 6.2.3.5
        description: "Ensure rsyslog logging is configured (Manual)"
        audit: "ls -l /var/log/maillog"
        type: "manual"
        remediation: |
          Edit the following lines in the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files as appropriate for your environment.

          Note: The below configuration is shown for example purposes only. Due care should be given to how the organization wishes to store log data.

          *.emerg                                  :omusrmsg:*
          auth,authpriv.*                          /var/log/secure
          mail.*                                  -/var/log/mail
          mail.info                               -/var/log/mail.info
          mail.warning                            -/var/log/mail.warn
          mail.err                                 /var/log/mail.err
          cron.*                                   /var/log/cron
          *.=warning;*.=err                       -/var/log/warn
          *.crit                                   /var/log/warn
          *.*;mail.none;news.none                 -/var/log/messages
          local0,local1.*                         -/var/log/localmessages
          local2,local3.*                         -/var/log/localmessages
          local4,local5.*                         -/var/log/localmessages
          local6,local7.*                         -/var/log/localmessages
          Run the following command to reload the rsyslogd configuration:

          # systemctl restart rsyslog
        scored: false

      - id: 6.2.3.6
        description: "Ensure rsyslog is configured to send logs to a remote log host (Manual)"
        audit: |
          grep "^*.*[^I][^I]*@" /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        type: "manual"
        remediation: |
          Edit the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files and add the following line
            (where loghost.example.com is the name of your central log host). The target directive
            may either be a fully qualified domain name or an IP address.
            *.* action(type="omfwd" target="192.168.2.100" port="514" protocol="tcp"
            action.resumeRetryCount="100"
            queue.type="LinkedList" queue.size="1000")
          Run the following command to reload the rsyslogd configuration:
            # systemctl restart rsyslog
        scored: false

      - id: 6.2.3.7
        description: "Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
        audit: |
          #!/usr/bin/env bash
          set -euo pipefail

          rsyslog_flag="rsyslog_not_server_ok"

          # If rsyslog config files don't exist, treat as not_applicable (no rsyslog)
          if ! ls /etc/rsyslog.conf /etc/rsyslog.d/*.conf >/dev/null 2>&1; then
            echo "rsyslog_not_server_not_applicable"
            exit 0
          fi

          # Advanced format: imtcp as module and input()
          adv_load="$(grep -Psi -- '^\h*module\(load=\"?imtcp\"?\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null || true)"
          adv_input="$(grep -Psi -- '^\h*input\(type=\"?imtcp\"?\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null || true)"

          if [ -n "$adv_load$adv_input" ]; then
            rsyslog_flag="rsyslog_not_server_bad"
          fi

          echo "$rsyslog_flag"
        tests:
          test_items:
            - flag: "rsyslog_not_server_ok"
              set: true
        remediation: |
          # Edit /etc/rsyslog.conf and any /etc/rsyslog.d/*.conf files that contain
          # TCP server / imtcp receiver configuration and remove or comment out the
          # lines that cause rsyslog to listen for remote logs.

          # Remove **advanced** imtcp server configuration such as:
          #   module(load="imtcp")
          #   input(type="imtcp" port="514")

          # Remove **legacy / obsolete** imtcp server configuration such as:
          #   $ModLoad imtcp
          #   $InputTCPServerRun 514

          # After cleaning up the configuration, restart rsyslog:
          #   systemctl restart rsyslog

          # Re-run the audit to confirm that no imtcp load/input or legacy
          # $ModLoad imtcp / $InputTCPServerRun directives remain.
        scored: true


      - id: 6.2.3.8
        description: "Ensure rsyslog logrotate is configured (Manual)"
        type: "manual"
        remediation: |
          Edit /etc/logrotate.conf and /etc/logrotate.d/* to ensure logs are rotated according to site policy.

          Example logrotate configuration that specifies log files be rotated weekly, keep 4 backlogs, compress old log files, ignores missing and empty log files, postrotate to reload rsyslog service after logs are rotated

          /var/log/rsyslog/*.log {
              weekly
              rotate 4
              compress
              missingok
              notifempty
              postrotate
                      /usr/bin/systemctl reload rsyslog.service >/dev/null || true
              endscript
          }
        scored: false
      - id: 6.2.4
        description: "Configure Logfiles"
        type: "skip"
        checks:
      - id: 6.2.4.1
        description: "Ensure access to all logfiles has been configured (Automated)"
        audit: |
          #!/usr/bin/env bash
          set -euo pipefail

          l_output2=""
          l_uidmin="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"

          file_test_chk() {
            local l_op2=""
            # permissions mask already set by caller
            if [ $(( l_mode & perm_mask )) -gt 0 ]; then
              l_op2="$l_op2\n  - Mode: \"$l_mode\" should be \"$maxperm\" or more restrictive"
            fi
            if [[ ! "$l_user" =~ $l_auser ]]; then
              l_op2="$l_op2\n  - Owned by: \"$l_user\" and should be owned by \"${l_auser//|/ or }\""
            fi
            if [[ ! "$l_group" =~ $l_agroup ]]; then
              l_op2="$l_op2\n  - Group owned by: \"$l_group\" and should be group owned by \"${l_agroup//|/ or }\""
            fi
            [ -n "$l_op2" ] && l_output2="$l_output2\n - File: \"$l_fname\" is:$l_op2\n"
          }

          # Collect candidate files under /var/log that might violate perms/ownership
          mapfile -d '' A_FILES < <(find -L /var/log -type f \( -perm /0137 -o ! -user root -o ! -group root \) -print0 2>/dev/null)

          for f in "${A_FILES[@]:-}"; do
            [ -e "$f" ] || continue
            IFS="^" read -r l_fname l_mode l_user l_uid l_group l_gid < <(stat -Lc '%n^%#a^%U^%u^%G^%g' "$f")
            l_bname="$(basename "$l_fname")"

            case "$l_bname" in
              lastlog|lastlog.*|wtmp|wtmp.*|wtmp-*|btmp|btmp.*|btmp-*|README)
                perm_mask=$((8#0113)); maxperm="$(printf '%o' $(( 0777 & ~perm_mask )))"
                l_auser="root"; l_agroup="(root|utmp)";;
              secure|auth.log|syslog|messages)
                perm_mask=$((8#0137)); maxperm="$(printf '%o' $(( 0777 & ~perm_mask )))"
                l_auser="(root|syslog)"; l_agroup="(root|adm)";;
              SSSD|sssd)
                perm_mask=$((8#0117)); maxperm="$(printf '%o' $(( 0777 & ~perm_mask )))"
                l_auser="(root|SSSD)"; l_agroup="(root|SSSD)";;
              gdm|gdm3)
                perm_mask=$((8#0117)); maxperm="$(printf '%o' $(( 0777 & ~perm_mask )))"
                l_auser="root"; l_agroup="(root|gdm|gdm3)";;
              *.journal|*.journal~)
                perm_mask=$((8#0137)); maxperm="$(printf '%o' $(( 0777 & ~perm_mask )))"
                l_auser="root"; l_agroup="(root|systemd-journal)";;
              *)
                perm_mask=$((8#0137)); maxperm="$(printf '%o' $(( 0777 & ~perm_mask )))"
                l_auser="(root|syslog)"; l_agroup="(root|adm)"
                # Allow service-specific user/group if it is a true system account/group
                if [ "$l_uid" -lt "${l_uidmin:-1000}" ] && [ -z "$(awk -v grp="$l_group" -F: '$1==grp {print $4}' /etc/group)" ]; then
                  [[ ! "$l_user" =~ $l_auser ]] && l_auser="(root|syslog|$l_user)"
                  if [[ ! "$l_group" =~ $l_agroup ]]; then
                    l_tst=""
                    while read -r l_duid; do
                      [ "$l_duid" -ge "$l_uidmin" ] && l_tst=failed
                    done < <(awk -F: '$4=='"$l_gid"' {print $3}' /etc/passwd)
                    [ "$l_tst" != "failed" ] && l_agroup="(root|adm|$l_group)"
                  fi
                fi
                ;;
            esac

            file_test_chk
          done

          if [ -z "${l_output2}" ]; then
            echo "LOGFILES_OK"
          else
            echo "LOGFILES_BAD"
            printf "%b\n" "$l_output2"
          fi
        tests:
          test_items:
            - flag: "LOGFILES_OK"
              set: true
        remediation: |
          #!/usr/bin/env bash
          set -euo pipefail

          echo "- Adjusting ownership and permissions for /var/log where required…"

          l_uidmin="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"

          fix_file() {
            local l_fname="$1" l_mode="$2" l_user="$3" l_group="$4"
            local l_target_user="root" l_target_group="root" l_rperms="u-x,g-wx,o-rwx"

            case "$(basename "$l_fname")" in
              lastlog|lastlog.*|wtmp|wtmp.*|wtmp-*|btmp|btmp.*|btmp-*|README)
                l_rperms="ug-x,o-wx"; l_target_user="root"; l_target_group="root";;
              secure|auth.log|syslog|messages|*.journal|*.journal~)
                l_rperms="u-x,g-wx,o-rwx"; l_target_user="root"; l_target_group="root";;
              SSSD|sssd)
                l_rperms="ug-x,o-rwx"; l_target_user="root"; l_target_group="root";;
              gdm|gdm3)
                l_rperms="ug-x,o-rwx"; l_target_user="root"; l_target_group="root";;
              *)
                l_rperms="u-x,g-wx,o-rwx"; l_target_user="root"; l_target_group="root";;
            esac

            # tighten perms
            chmod "$l_rperms" "$l_fname" || true
            # enforce root:root unless explicitly allowed otherwise by policy
            chown "$l_target_user":"$l_target_group" "$l_fname" || true
          }

          # Identify candidates that violate perms/ownership and remediate
          while IFS="^" read -r f m u g; do
            fix_file "$f" "$m" "$u" "$g"
          done < <(find -L /var/log -type f \( -perm /0137 -o ! -user root -o ! -group root \) -printf '%p^%m^%u^%g\n' 2>/dev/null)

          echo "- Remediation complete. Re-run the audit to confirm LOGFILES_OK."
        scored: true

  - id: 6.3
    description: "System Auditing"
    checks:
      - id: 6.3.1
        description: "Configure auditd Service"
        type: "skip"
        checks:
      - id: 6.3.1.1
        description: "Ensure auditd packages are installed (Automated)"
        audit: |
          audit_pkg_flag="audit_pkg_bad"

          # Verify both audit and audit-libs packages are installed
          if rpm -q audit >/dev/null 2>&1 && rpm -q audit-libs >/dev/null 2>&1; then
            audit_pkg_flag="audit_pkg_ok"
          fi

          echo "$audit_pkg_flag"
        tests:
          test_items:
            - flag: "audit_pkg_ok"
              set: true
        remediation: |
          Install the auditd and audit-libs packages to enable the Linux Auditing System.

          Run:
            # dnf install audit audit-libs

          Verify installation:
            # rpm -q audit audit-libs
            Expected output:
              audit-<version>
              audit-libs-<version>

          Notes:
          - auditd provides the userspace service for recording audit logs.
          - audit-libs provides the libraries required by auditd and related tools.
        scored: true

      - id: 6.3.1.2
        description: "Ensure auditing for processes that start prior to auditd is enabled (Automated)"
        audit: |
          audit_early_flag="audit_early_bad"

          # Check if audit=1 is configured in all kernel entries
          if grubby --info=ALL 2>/dev/null | grep -Pq '\baudit=1\b' && \
             grep -Psoi -- '^\s*GRUB_CMDLINE_LINUX="([^#\n\r]+\s+)?audit=1\b' /etc/default/grub >/dev/null 2>&1; then
            audit_early_flag="audit_early_ok"
          fi

          echo "$audit_early_flag"
        tests:
          test_items:
            - flag: "audit_early_ok"
              set: true
        remediation: |
          Enable auditing for processes that start prior to auditd.

          1) Add the audit=1 kernel parameter to enable early boot auditing:
             # grubby --update-kernel ALL --args 'audit=1'

          2) Edit /etc/default/grub and ensure the GRUB_CMDLINE_LINUX line includes audit=1:
             GRUB_CMDLINE_LINUX="quiet audit=1"

          3) Rebuild the GRUB configuration if necessary (for EFI or legacy systems):
             # grub2-mkconfig -o /boot/grub2/grub.cfg
             # grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg

          4) Reboot the system to apply changes:
             # reboot

          Notes:
          - This ensures that all processes, including those starting before auditd, are captured by the kernel audit subsystem.
          - Verify post-boot:
              # grep 'command line' /proc/cmdline | grep audit=1
        scored: true

      - id: 6.3.1.3
        description: "Ensure audit_backlog_limit is sufficient (Automated)"
        audit: |
          backlog_flag="audit_backlog_bad"

          # Check if audit_backlog_limit is set in kernel parameters (recommend ≥8192)
          if grubby --info=ALL 2>/dev/null | grep -Pq '\baudit_backlog_limit=(8[1-9][0-9]{2,}|[9-9][0-9]{3,})\b'; then
            if grep -Psoi -- '^\s*GRUB_CMDLINE_LINUX="([^#\n\r]+\s+)?audit_backlog_limit=(8[1-9][0-9]{2,}|[9-9][0-9]{3,})\b' /etc/default/grub >/dev/null 2>&1; then
              backlog_flag="audit_backlog_ok"
            fi
          fi

          echo "$backlog_flag"
        tests:
          test_items:
            - flag: "audit_backlog_ok"
              set: true
        remediation: |
          Configure an appropriate audit_backlog_limit in GRUB to ensure no audit records are lost during early boot.

          1) Add the parameter to all kernel entries (recommended: 8192 or greater):
             # grubby --update-kernel ALL --args 'audit_backlog_limit=8192'

          2) Edit /etc/default/grub and verify the GRUB_CMDLINE_LINUX line includes the parameter:
             GRUB_CMDLINE_LINUX="quiet audit_backlog_limit=8192"

          3) Rebuild the GRUB configuration:
             # grub2-mkconfig -o /boot/grub2/grub.cfg
             # grub2-mkconfig -o /boot/efi/EFI/fedora/grub.cfg

          4) Reboot the system to apply the change:
             # reboot

          Notes:
          - This setting defines the kernel’s in-memory audit buffer size during early boot.
          - Recommended minimum: audit_backlog_limit=8192
          - Adjust higher if your system generates heavy early boot activity.
        scored: true

      - id: 6.3.1.4
        description: "Ensure auditd service is enabled and active (Automated)"
        audit: |
          auditd_flag="auditd_bad"

          enabled_state="$(systemctl is-enabled auditd 2>/dev/null || echo "disabled")"
          active_state="$(systemctl is-active auditd 2>/dev/null || echo "inactive")"

          if [ "$enabled_state" = "enabled" ] && [ "$active_state" = "active" ]; then
            auditd_flag="auditd_ok"
          fi

          echo "$auditd_flag"
        tests:
          test_items:
            - flag: "auditd_ok"
              set: true
        remediation: |
          Ensure the auditd service is enabled and active to record system audit events.

          1) Unmask the service (if previously masked):
             # systemctl unmask auditd

          2) Enable auditd to start automatically at boot:
             # systemctl enable auditd

          3) Start the auditd service immediately:
             # systemctl start auditd

          4) Verify auditd status:
             # systemctl is-enabled auditd
               Expected: enabled
             # systemctl is-active auditd
               Expected: active

          Notes:
          - auditd is responsible for capturing system-level audit logs.
          - Keeping it active ensures full coverage of security-relevant events.
        scored: true


      - id: 6.3.2
        description: "Configure Data Retention"
        type: "skip"
        checks:
      - id: 6.3.2.1
        description: "Ensure audit log storage size is configured (Automated)"
        audit: |
          audit_logsize_flag="audit_logsize_bad"

          # Extract configured max_log_file value
          max_size="$(grep -Po -- '^\s*max_log_file\s*=\s*\d+\b' /etc/audit/auditd.conf 2>/dev/null | awk -F= '{print $2}' | xargs)"

          if [ -n "$max_size" ] && [ "$max_size" -ge 8 ]; then
            audit_logsize_flag="audit_logsize_ok"
          fi

          echo "$audit_logsize_flag"
        tests:
          test_items:
            - flag: "audit_logsize_ok"
              set: true
        remediation: |
          Configure the maximum size of audit log files in accordance with site policy.

          1) Edit /etc/audit/auditd.conf and set an appropriate value for max_log_file (in megabytes):
             Example:
               max_log_file = 100

          2) Restart the auditd service to apply the change:
             # systemctl restart auditd

          Notes:
          - The default value is 8 MB, which may be insufficient for systems generating large amounts of audit data.
          - Adjust this value based on disk space and audit retention requirements.
          - When the limit is reached, auditd will rotate the log file as defined by the log rotation settings.
        scored: true

      - id: 6.3.2.2
        description: "Ensure audit logs are not automatically deleted (Automated)"
        audit: "grep max_log_file_action /etc/audit/auditd.conf"
        tests:
          test_items:
            - flag: "max_log_file_action"
              compare:
                op: eq
                value: "keep_logs"
        remediation: |
          Set the following parameter in /etc/audit/auditd.conf:
            # max_log_file_action = keep_logs
        scored: true

      - id: 6.3.2.3
        description: "Ensure system is disabled when audit logs are full (Automated)"
        audit: |
          audit_full_flag="audit_full_bad"

          # Validate disk_full_action (must be halt or single)
          disk_full_ok=false
          if grep -Pq '^\s*disk_full_action\s*=\s*(halt|single)\b' /etc/audit/auditd.conf 2>/dev/null; then
            disk_full_ok=true
          fi

          # Validate disk_error_action (must be syslog, single, or halt)
          disk_error_ok=false
          if grep -Pq '^\s*disk_error_action\s*=\s*(syslog|single|halt)\b' /etc/audit/auditd.conf 2>/dev/null; then
            disk_error_ok=true
          fi

          if $disk_full_ok && $disk_error_ok; then
            audit_full_flag="audit_full_ok"
          fi

          echo "$audit_full_flag"
        tests:
          test_items:
            - flag: "audit_full_ok"
              set: true
        remediation: |
          Configure auditd to halt or enter single-user mode when audit logs are full or when an error is detected.

          1) Edit /etc/audit/auditd.conf and set the following parameters based on organizational policy:

             disk_full_action = halt
             disk_error_action = halt

             (Alternatives: disk_full_action = single, disk_error_action = single or syslog)

          2) Restart the auditd service to apply the changes:
             # systemctl restart auditd

          Notes:
          - "halt" provides maximum security by stopping the system if audit storage is unavailable.
          - "single" places the system in single-user mode to prevent further logins.
          - "syslog" may be used for disk_error_action to record the event while maintaining limited functionality.
          - These settings ensure that no further system activity occurs without proper audit logging.
        scored: true

      - id: 6.3.2.4
        description: "Ensure system warns when audit logs are low on space (Automated)"
        audit: |
          result_flag="audit_lowspace_bad"

          # space_left_action must be one of: email | exec | single | halt
          space_left_ok=false
          if grep -Pqi '^\s*space_left_action\s*=\s*(email|exec|single|halt)\b' /etc/audit/auditd.conf 2>/dev/null; then
            space_left_ok=true
          fi

          # admin_space_left_action must be one of: single | halt
          admin_space_left_ok=false
          if grep -Pqi '^\s*admin_space_left_action\s*=\s*(single|halt)\b' /etc/audit/auditd.conf 2>/dev/null; then
            admin_space_left_ok=true
          fi

          if $space_left_ok && $admin_space_left_ok; then
            result_flag="audit_lowspace_ok"
          fi

          echo "$result_flag"
        tests:
          test_items:
            - flag: "audit_lowspace_ok"
              set: true
        remediation: |
          Configure auditd to warn or take protective action when audit log storage is getting low.

          1) Edit /etc/audit/auditd.conf and set:
             # Choose one appropriate for your policy:
             space_left_action = email        # or: exec | single | halt
             # And require a protective action when critically low:
             admin_space_left_action = single # or: halt

          2) (Optional, required if using email) Ensure an MTA is installed and configured
             so auditd can send notifications when space is low.

          3) Restart auditd to apply changes:
             # systemctl restart auditd

          Notes:
          - "email" sends warnings (requires a working MTA and configured action_mail_acct).
          - "exec" runs a custom script you provide; that script must signal auditd to resume when done.
          - "single" or "halt" provide stronger protection by limiting or stopping the system
            to avoid running without auditable logging.
        scored: true


      - id: 6.3.3
        description: "Configure auditd rules"
        type: "skip"
        checks:
      - id: 6.3.3.1
        description: "Ensure changes to system administration scope (sudoers) is collected (Automated)"
        audit: |
          # Verify audit rules exist (on disk and running) for monitoring /etc/sudoers and /etc/sudoers.d changes.
          set -euo pipefail

          check_rules() {
            awk '/^ *-w/ && /\/etc\/sudoers/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' "$@" 2>/dev/null || true
          }

          # Check on-disk rules
          ondisk="$(check_rules /etc/audit/rules.d/*.rules)"
          # Check loaded rules
          loaded="$(auditctl -l 2>/dev/null | awk '/^ *-w/ && /\/etc\/sudoers/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)')"

          if grep -q '/etc/sudoers' <<<"$ondisk" && grep -q '/etc/sudoers.d' <<<"$ondisk" && \
             grep -q '/etc/sudoers' <<<"$loaded" && grep -q '/etc/sudoers.d' <<<"$loaded"; then
            echo "audit_sudoers_scope_rules_present"
          else
            echo "audit_sudoers_scope_rules_missing"
          fi
        tests:
          test_items:
            - flag: "audit_sudoers_scope_rules_present"
              set: true
        remediation: |
          # Create audit rules to collect modifications to /etc/sudoers and /etc/sudoers.d
          # These rules tag events with key "scope".
          cat << 'EOF' > /etc/audit/rules.d/50-scope.rules
          -w /etc/sudoers   -p wa -k scope
          -w /etc/sudoers.d -p wa -k scope
          EOF

          # Load new audit rules
          if command -v augenrules >/dev/null 2>&1; then
            augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
            auditctl -w /etc/sudoers   -p wa -k scope
            auditctl -w /etc/sudoers.d -p wa -k scope
          fi

          # Check if reboot is required (e.g., auditing locked with -e 2)
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
            echo "Reboot required to apply new audit rules."
          fi
        scored: true

      - id: 6.3.3.2
        description: "Ensure actions as another user are always logged (Automated)"
        audit: |
          sudo_user_flag="sudo_user_bad"

          # Check on-disk audit rules
          disk_rules=$(awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b(32|64)/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ -C *euid!=uid/||/ -C *uid!=euid/) \
          &&/ -S *execve/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules 2>/dev/null)

          # Check loaded audit rules
          loaded_rules=$(auditctl -l 2>/dev/null | awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b(32|64)/ \
          &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \
          &&(/ -C *euid!=uid/||/ -C *uid!=euid/) \
          &&/ -S *execve/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)')

          if echo "$disk_rules" | grep -q "user_emulation" && echo "$loaded_rules" | grep -q "user_emulation"; then
            sudo_user_flag="sudo_user_ok"
          fi

          echo "$sudo_user_flag"
        tests:
          test_items:
            - flag: "sudo_user_ok"
              set: true
        remediation: |
          Ensure audit rules are in place to log all actions executed as another user.

          1) Create or edit an audit rules file, for example:
             /etc/audit/rules.d/50-user_emulation.rules

             Add the following lines:
             - For 64-bit systems:
               -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
             - For 32-bit compatibility:
               -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation

          2) Merge and load the rules into the active configuration:
             # augenrules --load

          3) Check if a reboot is required to load persistent audit rules:
             # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
                 echo "Reboot required to load rules"
               fi

          Notes:
          - These rules ensure that all commands executed with elevated privileges (e.g., via sudo) are logged.
          - The key "user_emulation" makes it easier to filter these events from the audit logs.
        scored: true

      - id: 6.3.3.3
        description: "Ensure events that modify the sudo log file are collected (Automated)"
        audit: |
          SUDO_LOG_AUDIT_FLAG="SUDO_LOG_AUDIT_BAD"

          # Discover sudo log file (expects 'Defaults logfile="/var/log/sudo.log"' or similar)
          SUDO_LOG_FILE_RAW="$(grep -Rsi 'logfile=' /etc/sudoers /etc/sudoers.d 2>/dev/null \
            | sed -e 's/.*logfile=//;s/,.*$//' -e 's/"//g' -e "s/'//g" | head -n1)"

          if [ -n "$SUDO_LOG_FILE_RAW" ] && [ -e "$SUDO_LOG_FILE_RAW" ]; then
            # Escape slashes for awk regex
            SUDO_LOG_FILE_ESCAPED="$(printf '%s' "$SUDO_LOG_FILE_RAW" | sed 's|/|\\/|g')"

            # On-disk rules check
            disk_rules="$(awk "/^ *-w/ && /${SUDO_LOG_FILE_ESCAPED}/ && / +-p *wa/ && (/ key= *[!-~]* *$|/ -k *[!-~]* *$)/" \
              /etc/audit/rules.d/*.rules 2>/dev/null)"

            # Loaded rules check
            loaded_rules="$(auditctl -l 2>/dev/null | awk "/^ *-w/ && /${SUDO_LOG_FILE_ESCAPED}/ && / +-p *wa/ && (/ key= *[!-~]* *$|/ -k *[!-~]* *$)/")"

            if echo "$disk_rules"   | grep -qE '^-w '; then has_disk_rule=true; else has_disk_rule=false; fi
            if echo "$loaded_rules" | grep -qE '^-w '; then has_loaded_rule=true; else has_loaded_rule=false; fi

            if $has_disk_rule && $has_loaded_rule; then
              SUDO_LOG_AUDIT_FLAG="SUDO_LOG_AUDIT_OK:$SUDO_LOG_FILE_RAW"
            fi
          else
            echo "SUDO_LOG_FILE_UNSET_OR_MISSING"
          fi

          echo "$SUDO_LOG_AUDIT_FLAG"
        tests:
          test_items:
            - flag: "SUDO_LOG_AUDIT_OK"
              set: true
        remediation: |
          NOTE: This control requires sudo to log to a dedicated file (e.g., /var/log/sudo.log).

          1) Ensure sudo logging is enabled (if not already):
             - Add to /etc/sudoers (use visudo) or an included file in /etc/sudoers.d:
               Defaults logfile="/var/log/sudo.log"
             - Create the log file and secure it:
               # install -o root -g root -m 0640 /dev/null /var/log/sudo.log

          2) Add audit rules to watch the sudo log for writes/attribute changes:
             # SUDO_LOG_FILE=$(grep -Rsi 'logfile=' /etc/sudoers /etc/sudoers.d \
                 | sed -e 's/.*logfile=//;s/,.*$//' -e 's/"//g' -e "s/'//g" | head -n1)
             # if [ -n "$SUDO_LOG_FILE" ]; then
                 printf "\n-w %s -p wa -k sudo_log_file\n" "$SUDO_LOG_FILE" \
                   > /etc/audit/rules.d/50-sudo-log.rules
               else
                 echo "ERROR: sudo logfile not configured; set Defaults logfile= in sudoers."
               fi

          3) Load the rules into the active audit configuration:
             # augenrules --load

          4) Check if a reboot is required for immutable mode:
             # if [[ $(auditctl -s | grep enabled) =~ "2" ]]; then
                 echo "Reboot required to load persistent audit rules";
               fi

          After remediation, you should see lines like:
            -w /var/log/sudo.log -p wa -k sudo_log_file
        scored: true

      - id: 6.3.3.4
        description: "Ensure events that modify date and time information are collected (Automated)"
        audit: |
          timechange_flag="timechange_bad"

          # Check on-disk audit rules
          disk_rules="$(awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b(32|64)/ \
          &&/ -S/ \
          &&(/adjtimex/ || /settimeofday/ || /clock_settime/ ) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules 2>/dev/null)"

          disk_watch="$(awk '/^ *-w/ && /\/etc\/localtime/ && / +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules 2>/dev/null)"

          # Check loaded audit rules
          loaded_rules="$(auditctl -l 2>/dev/null | awk '/^ *-a *always,exit/ \
          &&/ -F *arch=b(32|64)/ && / -S/ \
          &&(/adjtimex/ || /settimeofday/ || /clock_settime/ ) \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)')"

          loaded_watch="$(auditctl -l 2>/dev/null | awk '/^ *-w/ && /\/etc\/localtime/ && / +-p *wa/ \
          &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)')"

          if echo "$disk_rules" | grep -q "time-change" && \
             echo "$disk_watch" | grep -q "time-change" && \
             echo "$loaded_rules" | grep -q "time-change" && \
             echo "$loaded_watch" | grep -q "time-change"; then
            timechange_flag="timechange_ok"
          fi

          echo "$timechange_flag"
        tests:
          test_items:
            - flag: "timechange_ok"
              set: true
        remediation: |
          Ensure auditd collects events related to changes in date and time configuration.

          1) Create or edit an audit rules file:
             /etc/audit/rules.d/50-time-change.rules

             Add the following lines:
               -a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change
               -a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change
               -a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change
               -a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change
               -w /etc/localtime -p wa -k time-change

          2) Merge and load the new rules:
             # augenrules --load

          3) Check if a reboot is required to apply immutable rules:
             # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
                 echo "Reboot required to load rules";
               fi

          Notes:
          - These rules track system time changes via adjtimex, settimeofday, and clock_settime syscalls.
          - They also monitor modifications to /etc/localtime, ensuring time zone or clock settings changes are logged.
          - The key "time-change" allows easy filtering from audit logs.
        scored: true

      - id: 6.3.3.5
        description: "Ensure events that modify the system's network environment are collected (Automated)"
        audit: |
          status_flag="netenv_bad"

          # ---- On-disk rules checks ----
          disk_syscalls="$(awk '/^ *-a *always,exit/ \
            && /-F *arch=b(32|64)/ \
            && /-S/ && (/sethostname/ || /setdomainname/) \
            && (/ key= *[!-~]* *$/ || /-k *[!-~]* *$/)' /etc/audit/rules.d/*.rules 2>/dev/null)"

          disk_watches="$(awk '/^ *-w/ \
            && (/etc\/issue(\.net)?/ || /etc\/hosts/ || /etc\/hostname/ || /etc\/sysconfig\/network(\-scripts\/)?/ || /etc\/NetworkManager/) \
            && / +-p *wa/ \
            && (/ key= *[!-~]* *$/ || /-k *[!-~]* *$/)' /etc/audit/rules.d/*.rules 2>/dev/null)"

          # ---- Loaded rules checks ----
          loaded_syscalls="$(auditctl -l 2>/dev/null | awk '/^ *-a *always,exit/ \
            && /-F *arch=b(32|64)/ \
            && /-S/ && (/sethostname/ || /setdomainname/) \
            && (/ key= *[!-~]* *$/ || /-k *[!-~]* *$/)')"

          loaded_watches="$(auditctl -l 2>/dev/null | awk '/^ *-w/ \
            && (/etc\/issue(\.net)?/ || /etc\/hosts/ || /etc\/hostname/ || /etc\/sysconfig\/network(\-scripts)?/ || /etc\/NetworkManager/) \
            && / +-p *wa/ \
            && (/ key= *[!-~]* *$/ || /-k *[!-~]* *$/)')"

          # Require the canonical key 'system-locale' to be present on all expected items
          # Check syscall rules (both arches may be merged in some installs; key must be present)
          syscalls_ok=false
          if echo "$disk_syscalls" | grep -q "system-locale" && echo "$loaded_syscalls" | grep -q "system-locale"; then
            # also ensure both sethostname and setdomainname appear across rules
            if echo "$disk_syscalls" | grep -q "sethostname" && echo "$disk_syscalls" | grep -q "setdomainname" && \
               echo "$loaded_syscalls" | grep -q "sethostname" && echo "$loaded_syscalls" | grep -q "setdomainname"; then
              syscalls_ok=true
            fi
          fi

          # Expected watch paths
          need_paths="/etc/issue
          /etc/issue.net
          /etc/hosts
          /etc/hostname
          /etc/sysconfig/network
          /etc/sysconfig/network-scripts
          /etc/NetworkManager"

          watches_ok=true
          while IFS= read -r p; do
            [ -z "$p" ] && continue
            # treat non-existent legacy dirs as still requiring a rule per CIS text
            if ! echo "$disk_watches" | grep -qE "^-w[[:space:]]+$p([/[:space:]]|$).*system-locale"; then
              watches_ok=false
            fi
            if ! echo "$loaded_watches" | grep -qE "^-w[[:space:]]+$p([/[:space:]]|$).*system-locale"; then
              watches_ok=false
            fi
          done <<< "$need_paths"

          if [ "$syscalls_ok" = true ] && [ "$watches_ok" = true ]; then
            status_flag="netenv_ok"
          fi

          echo "$status_flag"
        tests:
          test_items:
            - flag: "netenv_ok"
              set: true
        remediation: |
          Create audit rules to record changes to the network environment and to hostname/domainname syscalls.

          1) Add the following to /etc/audit/rules.d/50-system_locale.rules
             (create the file if it does not exist):

               -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
               -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale

               -w /etc/issue -p wa -k system-locale
               -w /etc/issue.net -p wa -k system-locale
               -w /etc/hosts -p wa -k system-locale
               -w /etc/hostname -p wa -k system-locale
               -w /etc/sysconfig/network -p wa -k system-locale
               -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
               -w /etc/NetworkManager -p wa -k system-locale

          2) Merge and load the rules:

               # augenrules --load

          3) If immutable mode is enabled, a reboot is required to apply new rules:

               # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
                     echo "Reboot required to load rules";
                 fi

          Notes:
          - The key "system-locale" enables easy filtering (e.g., ausearch -k system-locale).
          - Some systems may not use legacy paths (e.g., /etc/sysconfig/network-scripts), but CIS requires watches be present.
        scored: true

      - id: 6.3.3.6
        description: "Ensure use of privileged commands are collected (Automated)"
        audit: |
          # This audit verifies BOTH on-disk rules and the running configuration
          # cover every setuid/setgid ("privileged") file on executable/suid-capable mounts.

          status="privileged_bad"
          tmp_dir="$(mktemp -d)"
          trap 'rm -rf "$tmp_dir"' EXIT

          # Identify target mountpoints: all non-nodev filesystems that are NOT mounted with noexec or nosuid
          mapfile -t PARTS < <(findmnt -n -l -k -it "$(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,)" \
                              | grep -Pv "noexec|nosuid" | awk '{print $1}')

          # Find all privileged binaries within each target mountpoint
          : > "$tmp_dir/priv.list"
          for p in "${PARTS[@]}"; do
            find "$p" -xdev -perm /6000 -type f -print 2>/dev/null
          done | sort -u > "$tmp_dir/priv.list"

          # Quick exit if nothing to check
          if [ ! -s "$tmp_dir/priv.list" ]; then
            echo "PRIV_RULES_OK:empty"
            exit 0
          fi

          # Collect on-disk rules
          ONDISK="$(cat /etc/audit/rules.d/*.rules 2>/dev/null || true)"
          # Collect running rules
          RUNNING="$(auditctl -l 2>/dev/null || true)"

          miss_disk=0
          miss_run=0

          while IFS= read -r f; do
            # Expect a watch/exec rule with -F path=<file> and -F perm=x
            echo "$ONDISK" | grep -qE -- "\-a +always,exit .* -F +path=${f}(\s|$).* -F +perm=x" || miss_disk=$((miss_disk+1))
            echo "$RUNNING" | grep -qE -- "\-a +always,exit .* -F +path=${f}(\s|$).* -F +perm=x" || miss_run=$((miss_run+1))
          done < "$tmp_dir/priv.list"

          if [ "$miss_disk" -eq 0 ] && [ "$miss_run" -eq 0 ]; then
            echo "PRIV_RULES_OK:all"
          else
            echo "PRIV_RULES_BAD:missing_on_disk=$miss_disk,missing_running=$miss_run"
          fi
        tests:
          test_items:
            - flag: "PRIV_RULES_OK"
              set: true
        remediation: |
          # Generate per-binary audit rules for every setuid/setgid file on executable/suid-capable mounts,
          # keyed as "privileged". Rules restrict to real users (auid>=UID_MIN and auid!=unset).

          # Review the mounts that will be scanned (exclude very large mounts by adding an extra grep -Pv clause if needed):
          #   findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid"

          # Create / update rules file:
          cat >/usr/local/sbin/gen-privileged-audit-rules.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          OUT="/etc/audit/rules.d/50-privileged.rules"
          TMP="$(mktemp)"
          trap 'rm -f "$TMP"' EXIT

          # Enumerate eligible mountpoints
          mapfile -t PARTS < <(findmnt -n -l -k -it "$(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,)" \
                               | grep -Pv "noexec|nosuid" | awk '{print $1}')

          # Build rules
          : > "$TMP"
          for p in "${PARTS[@]}"; do
            # Find setuid/setgid regular files
            while IFS= read -r bin; do
              printf -- "-a always,exit -F path=%s -F perm=x -F auid>=%s -F auid!=unset -k privileged\n" "$bin" "$UID_MIN"
            done < <(find "$p" -xdev -perm /6000 -type f -print 2>/dev/null)
          done

          # Merge with existing (if any) and de-duplicate
          if [ -f "$OUT" ]; then
            cat "$OUT" "$TMP" | sort -u > "${OUT}.new"
            mv "${OUT}.new" "$OUT"
          else
            sort -u "$TMP" > "$OUT"
          fi
          EOF

          chmod 0755 /usr/local/sbin/gen-privileged-audit-rules.sh

          # Run the generator and load rules:
          /usr/local/sbin/gen-privileged-audit-rules.sh
          augenrules --load

          # If the audit rules are immutable (enabled=2), a reboot is required to apply new/changed rules:
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi

          # Notes:
          # - To exclude specific mounts for performance, add an additional grep -Pv filter to the PARTS pipeline.
          # - Re-run the generator after OS updates that add or remove setuid/setgid binaries.
        scored: true

      - id: 6.3.3.7
        description: "Ensure unsuccessful file access attempts are collected (Automated)"
        audit: |
          # Verify the RUNNING audit rules include unsuccessful file access attempts
          # for both 64-bit and 32-bit syscalls, for real users (auid>=UID_MIN and !=unset),
          # and for both denials: EACCES and EPERM.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          req_ok=0

          # helper: awk filter template
          f_base='
            /^ *-a *always,exit/ &&
            / -F *arch=bARCH/ &&
            (/ -F *auid!=unset/ || / -F *auid!=-1/ || / -F *auid!=4294967295/) &&
            / -F *auid>='${UID_MIN}'/ &&
            / -S/ &&
            /creat/ && /open/ && /truncate/ &&
            / -F *exit=-EXIT/
          '

          # b64 / EACCES
          echo "$RULES" | awk "$f_base" ARCH=64 EXIT=EACCES | grep -q . && req_ok=$((req_ok+1))
          # b64 / EPERM
          echo "$RULES" | awk "$f_base" ARCH=64 EXIT=EPERM  | grep -q . && req_ok=$((req_ok+1))
          # b32 / EACCES
          echo "$RULES" | awk "$f_base" ARCH=32 EXIT=EACCES | grep -q . && req_ok=$((req_ok+1))
          # b32 / EPERM
          echo "$RULES" | awk "$f_base" ARCH=32 EXIT=EPERM  | grep -q . && req_ok=$((req_ok+1))

          if [ -n "$UID_MIN" ] && [ "$req_ok" -eq 4 ]; then
            echo "ACCESS_RULES_OK:$req_ok"
          else
            echo "ACCESS_RULES_BAD:matched=$req_ok UID_MIN=${UID_MIN:-unset}"
          fi
        tests:
          test_items:
            - flag: "ACCESS_RULES_OK"
              set: true
        remediation: |
          # Create on-disk audit rules to capture unsuccessful open/create/truncate attempts
          # for both architectures and for both exit codes (EACCES, EPERM), limited to real users.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          if [ -z "$UID_MIN" ]; then
            echo "ERROR: Could not determine UID_MIN from /etc/login.defs"; exit 1
          fi

          cat > /etc/audit/rules.d/50-access.rules <<EOF
          -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$UID_MIN -F auid!=unset -k access
          -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=$UID_MIN -F auid!=unset -k access
          -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$UID_MIN -F auid!=unset -k access
          -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=$UID_MIN -F auid!=unset -k access
          EOF

          # Load rules
          augenrules --load

          # If the audit rules are immutable (enabled=2), a reboot is required to apply new rules:
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.8
        description: "Ensure events that modify user/group information are collected (Automated)"
        audit: |
          # Validate RUNNING audit rules watch the required identity files/dirs with -p wa and key 'identity'
          required=(/etc/group /etc/passwd /etc/gshadow /etc/shadow /etc/security/opasswd /etc/nsswitch.conf /etc/pam.conf /etc/pam.d)
          RULES="$(auditctl -l 2>/dev/null || true)"
          ok=0

          have_watch() {
            local path="$1"
            # Match a line like: -w <path> -p wa ... -k identity   (accept -F key=identity too)
            echo "$RULES" | grep -P -- "^-w\s+${path//\//\\/}\b" | \
              awk '
                {
                  has_p=0; has_w=0; has_a=0; has_key=0;
                  for (i=1;i<=NF;i++) {
                    if ($i=="-p" && (i+1)<=NF) {
                      p=$(i+1)
                      if (p ~ /w/) has_w=1
                      if (p ~ /a/) has_a=1
                    }
                    if ($i=="-k" && (i+1)<=NF && $(i+1)=="identity") has_key=1
                    if ($i ~ /^-F$/ && (i+1)<=NF && $(i+1) ~ /^key=identity$/) has_key=1
                  }
                  if (has_w && has_a && has_key) { print "match"; exit }
                }
              ' | grep -q match
          }

          for p in "${required[@]}"; do
            if have_watch "$p"; then ok=$((ok+1)); fi
          done

          if [ "$ok" -eq "${#required[@]}" ]; then
            echo "IDENTITY_RULES_OK:$ok"
          else
            echo "IDENTITY_RULES_BAD:matched=$ok expected=${#required[@]}"
          fi
        tests:
          test_items:
            - flag: "IDENTITY_RULES_OK"
              set: true
        remediation: |
          # Create persistent rules to watch identity-related files and directories with -p wa and key 'identity'
          cat > /etc/audit/rules.d/50-identity.rules <<'EOF'
          -w /etc/group -p wa -k identity
          -w /etc/passwd -p wa -k identity
          -w /etc/gshadow -p wa -k identity
          -w /etc/shadow -p wa -k identity
          -w /etc/security/opasswd -p wa -k identity
          -w /etc/nsswitch.conf -p wa -k identity
          -w /etc/pam.conf -p wa -k identity
          -w /etc/pam.d -p wa -k identity
          EOF

          # Load the rules into the running configuration
          augenrules --load

          # If audit is immutable (enabled=2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.9
        description: "Ensure discretionary access control permission modification events are collected (Automated)"
        audit: |
          # Confirm running audit rules record DAC permission/ownership/attribute changes for non-system users
          RULES="$(auditctl -l 2>/dev/null || true)"
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"

          have_group_rule() {
            # $1 = arch (b32|b64)
            # $2 = comma-separated syscalls list that must all be present on a single -a always,exit rule
            arch="$1"; syscalls_csv="$2"
            # Build grep for all -S items
            ok=1
            # Limit to always,exit + arch + auid filters (+ key present)
            cand="$(printf '%s\n' "$RULES" | \
              grep -P "^-a\s+always,exit\b" | \
              grep -P "\b-F\s+arch=${arch}\b" | \
              grep -P "\b-F\s+auid>=${UID_MIN}\b" | \
              grep -P "\b-F\s+auid!=(unset|-1|4294967295)\b" | \
              grep -P "\b(-k\s+\S+|-F\s+key=\S+)\b")"
            [ -z "$cand" ] && return 1
            IFS=',' read -r -a need <<< "$syscalls_csv"
            while IFS= read -r line; do
              has_all=1
              for s in "${need[@]}"; do
                printf '%s' "$line" | grep -P "\b-S\b.*\b${s}\b|\b-S\s*${s}\b" -q || { has_all=0; break; }
              done
              [ "$has_all" -eq 1 ] && { printf '%s\n' "$line"; return 0; }
            done <<< "$cand"
            return 1
          }

          ok=0
          # syscall groups as per CIS control
          chmod_grp="chmod,fchmod,fchmodat"
          chown_grp="chown,fchown,lchown,fchownat"
          xattr_grp="setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr"

          for arch in b64 b32; do
            have_group_rule "$arch" "$chmod_grp" && ok=$((ok+1))
            have_group_rule "$arch" "$chown_grp" && ok=$((ok+1))
            have_group_rule "$arch" "$xattr_grp" && ok=$((ok+1))
          done

          if [ "$ok" -eq 6 ]; then
            echo "PERM_MOD_OK:$ok"
          else
            echo "PERM_MOD_BAD:matched=$ok expected=6"
          fi
        tests:
          test_items:
            - flag: "PERM_MOD_OK"
              set: true
        remediation: |
          # Create persistent audit rules for DAC permission/ownership/attribute changes (tagged key=perm_mod)
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          cat > /etc/audit/rules.d/50-perm_mod.rules <<EOF
          -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -k perm_mod
          -a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -k perm_mod
          -a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -k perm_mod
          EOF

          # Load rules into the running configuration
          augenrules --load

          # If audit is immutable (enabled=2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.10
        description: "Ensure successful file system mounts are collected (Automated)"
        audit: |
          # Verify running audit rules collect successful mount() calls for non-system users
          RULES="$(auditctl -l 2>/dev/null || true)"
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"

          have_mount_rule() {
            # $1 = arch (b32|b64)
            arch="$1"
            printf '%s\n' "$RULES" \
              | grep -P "^-a\s+always,exit\b" \
              | grep -P "\b-F\s+arch=${arch}\b" \
              | grep -P "\b-S\s+.*\bmount\b" \
              | grep -P "\b-F\s+auid>=${UID_MIN}\b" \
              | grep -P "\b-F\s+auid!=(unset|-1|4294967295)\b" \
              | grep -P "\b(-k\s+\S+|-F\s+key=\S+)\b" \
              >/dev/null
          }

          ok=0
          have_mount_rule b64 && ok=$((ok+1))
          have_mount_rule b32 && ok=$((ok+1))

          if [ "$ok" -eq 2 ]; then
            echo "MOUNTS_OK:$ok"
          else
            echo "MOUNTS_BAD:matched=$ok expected=2"
          fi
        tests:
          test_items:
            - flag: "MOUNTS_OK"
              set: true
        remediation: |
          # Persist audit rules to log successful mount() by non-system users
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          cat > /etc/audit/rules.d/50-mounts.rules <<EOF
          -a always,exit -F arch=b32 -S mount -F auid>=${UID_MIN} -F auid!=unset -k mounts
          -a always,exit -F arch=b64 -S mount -F auid>=${UID_MIN} -F auid!=unset -k mounts
          EOF

          # Load rules now
          augenrules --load

          # If audit is immutable (enabled=2), a reboot will be required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.11
        description: "Ensure session initiation information is collected (Automated)"
        audit: |
          # Verify running audit rules watch utmp/wtmp/btmp with -p wa and key 'session'
          RULES="$(auditctl -l 2>/dev/null || true)"

          have_watch() {
            # $1 = absolute path to watch
            printf '%s\n' "$RULES" \
              | grep -P "^-w\s+$1\b" \
              | grep -P "\b-p\s+wa\b" \
              | grep -P "(\b-k\s+session\b|\b-F\s+key=session\b)" \
              >/dev/null
          }

          ok=0
          have_watch /var/run/utmp  && ok=$((ok+1))
          have_watch /var/log/wtmp  && ok=$((ok+1))
          have_watch /var/log/btmp  && ok=$((ok+1))

          if [ "$ok" -eq 3 ]; then
            echo "SESSION_OK:$ok"
          else
            echo "SESSION_BAD:matched=$ok expected=3"
          fi
        tests:
          test_items:
            - flag: "SESSION_OK"
              set: true
        remediation: |
          # Persist audit watches for session initiation files and load them
          cat > /etc/audit/rules.d/50-session.rules <<'EOF'
          -w /var/run/utmp -p wa -k session
          -w /var/log/wtmp -p wa -k session
          -w /var/log/btmp -p wa -k session
          EOF

          # Merge and load rules into the running configuration
          augenrules --load

          # If the ruleset is immutable (enabled=2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.12
        description: "Ensure login and logout events are collected (Automated)"
        audit: |
          # Verify running audit rules watch lastlog and faillock with -p wa and key 'logins'
          RULES="$(auditctl -l 2>/dev/null || true)"

          have_watch() {
            # $1 = absolute path to watch
            printf '%s\n' "$RULES" \
              | grep -P "^-w\s+$1\b" \
              | grep -P "\b-p\s+wa\b" \
              | grep -P "(\b-k\s+logins\b|\b-F\s+key=logins\b)" \
              >/dev/null
          }

          ok=0
          have_watch /var/log/lastlog   && ok=$((ok+1))
          have_watch /var/run/faillock  && ok=$((ok+1))

          if [ "$ok" -eq 2 ]; then
            echo "LOGIN_LOGOUT_OK:$ok"
          else
            echo "LOGIN_LOGOUT_BAD:matched=$ok expected=2"
          fi
        tests:
          test_items:
            - flag: "LOGIN_LOGOUT_OK"
              set: true
        remediation: |
          # Persist audit watches for login/logout files and load them
          cat > /etc/audit/rules.d/50-login.rules <<'EOF'
          -w /var/log/lastlog -p wa -k logins
          -w /var/run/faillock -p wa -k logins
          EOF

          # Merge and load rules into the running configuration
          augenrules --load

          # If the ruleset is immutable (enabled=2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.13
        description: "Ensure file deletion events by users are collected (Automated)"
        audit: |
          # Verify running audit rules include delete-related syscalls for both arches,
          # filtered to non-daemon users (auid>=UID_MIN and auid!=unset) with key 'delete'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs 2>/dev/null)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          have_delete_rule() {
            # $1 = arch (b32 or b64)
            # Accept either -k delete or -F key=delete and require the full syscall set is present.
            printf '%s\n' "$RULES" \
              | awk -v ARCH="$1" -v UMIN="${UID_MIN:-1000}" '
                  /^ *-a *always,exit/ &&
                  / -F *arch=ARCH/ &&
                  / -S / &&
                  /unlink/ && /unlinkat/ && /rename/ && /renameat/ &&
                  ( / -F *auid>=/ ? $0 ~ ("-F *auid>=" UMIN) : 0 ) &&
                  ( /-F *auid!=unset/ || /-F *auid!=-1/ || /-F *auid!=4294967295/ ) &&
                  ( / key= *delete *$/ || / -k *delete *$/ )
                ' >/dev/null
          }

          if [ -z "$UID_MIN" ] || [ -z "$RULES" ]; then
            echo "DELETE_RULES_BAD:env_incomplete"
          else
            ok=0
            have_delete_rule b64 && ok=$((ok+1))
            have_delete_rule b32 && ok=$((ok+1))
            if [ "$ok" -eq 2 ]; then
              echo "DELETE_RULES_OK:$ok"
            else
              echo "DELETE_RULES_BAD:matched=$ok expected=2"
            fi
          fi
        tests:
          test_items:
            - flag: "DELETE_RULES_OK"
              set: true
        remediation: |
          # Persist audit rules to collect file deletion syscalls by non-privileged users
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          : "${UID_MIN:=1000}"

          cat > /etc/audit/rules.d/50-delete.rules <<EOF
          -a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -k delete
          -a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -k delete
          EOF

          # Load the rules into the running configuration
          augenrules --load

          # If auditing is immutable (enabled=2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.14
        description: "Ensure events that modify the system's Mandatory Access Controls are collected (Automated)"
        audit: |
          # Verify running audit rules watch SELinux policy dirs with write+attr (-p wa)
          # and a MAC-policy key (accepts either `-k MAC-policy` or `-F key=MAC-policy`).
          RULES="$(auditctl -l 2>/dev/null || true)"

          have_watch() {
            # $1 = directory path (e.g., /etc/selinux or /usr/share/selinux)
            printf '%s\n' "$RULES" \
              | awk -v D="$1" '
                BEGIN{found=0}
                /^ *-w/ &&
                $0 ~ "(^|[[:space:]])-w[[:space:]]*" D "(/|[[:space:]]|$)" &&
                $0 ~ /[[:space:]]-p[[:space:]]*[rwxaduct]+/ &&
                $0 ~ /-p[[:space:]]*[^[:space:]]*w/ &&
                $0 ~ /-p[[:space:]]*[^[:space:]]*a/ &&
                ( $0 ~ /(^|[[:space:]])-k[[:space:]]*MAC-policy([[:space:]]|$) \
                  || $0 ~ /(^|[[:space:]])-F[[:space:]]*key=MAC-policy([[:space:]]|$) ) { found=1 }
                END{ exit(found?0:1) }
              '
          }

          ok=0
          have_watch "/etc/selinux" && ok=$((ok+1))
          have_watch "/usr/share/selinux" && ok=$((ok+1))

          if [ "$ok" -eq 2 ]; then
            echo "MAC_POLICY_OK:$ok"
          else
            echo "MAC_POLICY_BAD:matched=$ok expected=2"
          fi
        tests:
          test_items:
            - flag: "MAC_POLICY_OK"
              set: true
        remediation: |
          # Persist audit rules to watch SELinux policy directories for write & attribute changes
          cat > /etc/audit/rules.d/50-MAC-policy.rules <<'EOF'
          -w /etc/selinux -p wa -k MAC-policy
          -w /usr/share/selinux -p wa -k MAC-policy
          EOF

          # Load the rules into the running configuration
          augenrules --load

          # If auditing is immutable (enabled=2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.15
        description: "Ensure successful and unsuccessful attempts to use the chcon command are collected (Automated)"
        audit: |
          # Pass if a running audit rule exists to watch execution of /usr/bin/chcon
          # for non-daemon, non-system users (auid>=UID_MIN and auid!=unset) with key 'perm_chng'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs 2>/dev/null)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          chcon_rule_ok() {
            # Accept either `-k perm_chng` or `-F key=perm_chng`,
            # and tolerate presence/absence of `-S all` (implementation detail).
            printf '%s\n' "$RULES" | awk -v U="$UID_MIN" '
              /^ *-a *always,exit/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*path=\/usr\/bin\/chcon([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*perm=x([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*auid>=/ &&
              $0 ~ "auid>=" U &&
              ($0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=unset([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=-1([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=4294967295([[:space:]]|$)) &&
              ($0 ~ /(^|[[:space:]])-k[[:space:]]*perm_chng([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*key=perm_chng([[:space:]]|$)) { found=1 }
              END { exit(found?0:1) }
            '
          }

          if [ -n "$UID_MIN" ] && chcon_rule_ok; then
            echo "CHCON_AUDIT_OK"
          else
            echo "CHCON_AUDIT_BAD"
          fi
        tests:
          test_items:
            - flag: "CHCON_AUDIT_OK"
              set: true
        remediation: |
          # Persist an audit rule to record all executions of /usr/bin/chcon by non-daemon users
          # and tag with key 'perm_chng'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          cat > /etc/audit/rules.d/50-perm_chng.rules <<EOF
          -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
          EOF

          # Load rules into running configuration
          augenrules --load

          # If auditing is immutable (enabled = 2), a reboot is required for rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.16
        description: "Ensure successful and unsuccessful attempts to use the setfacl command are collected (Automated)"
        audit: |
          # Pass if a running audit rule exists to watch execution of /usr/bin/setfacl
          # for non-daemon, non-system users (auid>=UID_MIN and auid!=unset) with key 'perm_chng'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs 2>/dev/null)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          setfacl_rule_ok() {
            # Accept either `-k perm_chng` or `-F key=perm_chng`,
            # and tolerate presence/absence of `-S all`.
            printf '%s\n' "$RULES" | awk -v U="$UID_MIN" '
              /^ *-a *always,exit/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*path=\/usr\/bin\/setfacl([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*perm=x([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*auid>=/ &&
              $0 ~ "auid>=" U &&
              ($0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=unset([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=-1([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=4294967295([[:space:]]|$)) &&
              ($0 ~ /(^|[[:space:]])-k[[:space:]]*perm_chng([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*key=perm_chng([[:space:]]|$)) { found=1 }
              END { exit(found?0:1) }
            '
          }

          if [ -n "$UID_MIN" ] && setfacl_rule_ok; then
            echo "SETFACL_AUDIT_OK"
          else
            echo "SETFACL_AUDIT_BAD"
          fi
        tests:
          test_items:
            - flag: "SETFACL_AUDIT_OK"
              set: true
        remediation: |
          # Persist an audit rule to record all executions of /usr/bin/setfacl by non-daemon users
          # and tag with key 'perm_chng'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          cat > /etc/audit/rules.d/50-perm_chng.rules <<EOF
          -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
          EOF

          # Load rules into running configuration
          augenrules --load

          # If auditing is immutable (enabled = 2), a reboot is required for rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true
      - id: 6.3.3.17
        description: "Ensure successful and unsuccessful attempts to use the chacl command are collected (Automated)"
        audit: |
          # Pass if a running audit rule exists to watch execution of /usr/bin/chacl
          # for non-daemon users (auid>=UID_MIN and auid!=unset) with key 'perm_chng'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs 2>/dev/null)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          chacl_rule_ok() {
            # Accept either `-k perm_chng` or `-F key=perm_chng`,
            # and tolerate presence/absence of `-S all`.
            printf '%s\n' "$RULES" | awk -v U="$UID_MIN" '
              /^ *-a *always,exit/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*path=\/usr\/bin\/chacl([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*perm=x([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*auid>=/ &&
              $0 ~ "auid>=" U &&
              ($0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=unset([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=-1([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=4294967295([[:space:]]|$)) &&
              ($0 ~ /(^|[[:space:]])-k[[:space:]]*perm_chng([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*key=perm_chng([[:space:]]|$)) { found=1 }
              END { exit(found?0:1) }
            '
          }

          if [ -n "$UID_MIN" ] && chacl_rule_ok; then
            echo "CHACL_AUDIT_OK"
          else
            echo "CHACL_AUDIT_BAD"
          fi
        tests:
          test_items:
            - flag: "CHACL_AUDIT_OK"
              set: true
        remediation: |
          # Persist an audit rule to record all executions of /usr/bin/chacl by non-daemon users
          # and tag with key 'perm_chng'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          cat > /etc/audit/rules.d/50-perm_chng.rules <<EOF
          -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng
          EOF

          # Load rules into the running configuration
          augenrules --load

          # If auditing is immutable (enabled = 2), a reboot is required for rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.18
        description: "Ensure successful and unsuccessful attempts to use the usermod command are collected (Automated)"
        audit: |
          # Pass if a running audit rule watches execution of /usr/sbin/usermod
          # for non-daemon users (auid>=UID_MIN and auid!=unset) and is tagged 'usermod'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs 2>/dev/null)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          usermod_rule_ok() {
            printf '%s\n' "$RULES" | awk -v U="$UID_MIN" '
              BEGIN{ok=0}
              /^ *-a *always,exit/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*path=\/usr\/sbin\/usermod([[:space:]]|$)/ &&
              $0 ~ /(^|[[:space:]])-F[[:space:]]*perm=x([[:space:]]|$)/ &&
              $0 ~ "auid>=" U &&
              ($0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=unset([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=-1([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*auid!=4294967295([[:space:]]|$)) &&
              ($0 ~ /(^|[[:space:]])-k[[:space:]]*usermod([[:space:]]|$) \
               || $0 ~ /(^|[[:space:]])-F[[:space:]]*key=usermod([[:space:]]|$)) { ok=1 }
              END{ exit(ok?0:1) }
            '
          }

          if [ -n "$UID_MIN" ] && usermod_rule_ok; then
            echo "USERMOD_AUDIT_OK"
          else
            echo "USERMOD_AUDIT_BAD"
          fi
        tests:
          test_items:
            - flag: "USERMOD_AUDIT_OK"
              set: true
        remediation: |
          # Persist an audit rule to record all executions of /usr/sbin/usermod by non-daemon users
          # and tag with key 'usermod'.
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          cat > /etc/audit/rules.d/50-usermod.rules <<EOF
          -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k usermod
          EOF

          # Load rules into the running configuration
          augenrules --load

          # If auditing is immutable (enabled = 2), a reboot is required for rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.19
        description: "Ensure kernel module loading, unloading, and modification is collected (Automated)"
        audit: |
          # Pass if running audit rules:
          #  - watch the module syscalls (init_module, finit_module, delete_module, create_module, query_module)
          #    for non-daemon users, on either b32 or b64 arch
          #  - and watch execution of /usr/bin/kmod with perm=x, auid>=UID_MIN, auid!=unset
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs 2>/dev/null)"
          RULES="$(auditctl -l 2>/dev/null || true)"

          have_syscalls() {
            printf '%s\n' "$RULES" | awk '
              /^ *-a *always,exit/ &&
              /-F[[:space:]]*arch=b(32|64)/ &&
              /-S/ &&
              (/init_module/ || /finit_module/ || /delete_module/ || /create_module/ || /query_module/) &&
              ( /-F[[:space:]]*auid!=unset/ || /-F[[:space:]]*auid!=-1/ || /-F[[:space:]]*auid!=4294967295/ ) &&
              ( /-k[[:space:]]*kernel_modules/ || /-F[[:space:]]*key=kernel_modules/ ) { ok=1 }
              END { exit(ok?0:1) }
            '
          }

          have_kmod_path() {
            printf '%s\n' "$RULES" | awk -v U="$UID_MIN" '
              /^ *-a *always,exit/ &&
              /-F[[:space:]]*path=\/usr\/bin\/kmod/ &&
              /-F[[:space:]]*perm=x/ &&
              $0 ~ "auid>=" U &&
              ( /-F[[:space:]]*auid!=unset/ || /-F[[:space:]]*auid!=-1/ || /-F[[:space:]]*auid!=4294967295/ ) &&
              ( /-k[[:space:]]*kernel_modules/ || /-F[[:space:]]*key=kernel_modules/ ) { ok=1 }
              END { exit(ok?0:1) }
            '
          }

          if [ -n "$UID_MIN" ] && have_syscalls && have_kmod_path; then
            echo "KERNEL_MODULES_AUDIT_OK"
          else
            echo "KERNEL_MODULES_AUDIT_BAD"
          fi
        tests:
          test_items:
            - flag: "KERNEL_MODULES_AUDIT_OK"
              set: true
        remediation: |
          # Persist audit rules to collect kernel module load/unload and kmod executions
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"

          cat > /etc/audit/rules.d/50-kernel_modules.rules <<'EOF'
          # Kernel module syscalls (both arches where applicable)
          -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=UID_MIN_PLACEHOLDER -F auid!=unset -k kernel_modules
          -a always,exit -F arch=b32 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=UID_MIN_PLACEHOLDER -F auid!=unset -k kernel_modules
          # kmod frontend (covers modprobe/insmod/rmmod/etc symlinks)
          -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=UID_MIN_PLACEHOLDER -F auid!=unset -k kernel_modules
          EOF

          # Replace placeholders with actual UID_MIN
          sed -ri "s/UID_MIN_PLACEHOLDER/${UID_MIN}/g" /etc/audit/rules.d/50-kernel_modules.rules

          # Load rules into the running configuration
          augenrules --load

          # If auditing is immutable (enabled = 2), a reboot is required for rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.20
        description: "Ensure the audit configuration is immutable (Automated)"
        audit: |
          # Pass if the *last* immutable directive in /etc/audit/rules.d ends with "-e 2"
          last_e="$(grep -Ph '^\s*-e\s+[0-2]\b' /etc/audit/rules.d/*.rules 2>/dev/null \
                    | awk '{print $2}' | tail -n1)"
          if [ "$last_e" = "2" ]; then
            echo "AUDIT_IMMUTABLE_OK:-e 2"
          else
            echo "AUDIT_IMMUTABLE_BAD:${last_e:-not_set}"
          fi
        tests:
          test_items:
            - flag: "AUDIT_IMMUTABLE_OK"
              set: true
        remediation: |
          # Ensure the immutable flag is set in the final rules file so it wins after merges.
          install -m 0640 -o root -g root /dev/null /etc/audit/rules.d/99-finalize.rules
          printf '%s\n' '-e 2' > /etc/audit/rules.d/99-finalize.rules

          # Load the rules into the running configuration (may not take effect if already immutable)
          augenrules --load

          # If auditing is already immutable (enabled = 2), a reboot is required for changes to apply
          if auditctl -s 2>/dev/null | grep -q 'enabled[[:space:]]*2'; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.3.3.21
        description: "Ensure the running and on-disk audit configuration is the same (Manual)"
        audit: |
          # Verify that all rules from /etc/audit/rules.d/ have been merged into /etc/audit/audit.rules
          augenrules --check
        type: "manual"
        remediation: |
          If the on-disk and running configurations are not aligned, reload and merge the rule sets:

          1) Merge and load all rules from /etc/audit/rules.d:
             # augenrules --load

          2) Verify consistency:
             # augenrules --check
               Expected output: /usr/sbin/augenrules: No change

          3) If audit is immutable (enabled = 2), a reboot is required to apply new rules:
             # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
                 echo "Reboot required to load rules";
               fi

          Notes:
          - This control ensures parity between the rules stored on disk and those active in memory.
          - Drift between configurations may lead to incorrect compliance or incomplete auditing.
        scored: false

      - id: 6.3.4
        description: "Configure auditd file access"
        type: "skip"
        checks:
      - id: 6.3.4.1
        description: "Ensure the audit log file directory mode is configured (Automated)"
        audit: |
          audit_dir_flag="audit_logdir_bad"
          perm_mask=$((8#0027))
          conf="/etc/audit/auditd.conf"

          if [ -f "$conf" ]; then
            logdir="$(dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' "$conf" | xargs)")"
            if [ -d "$logdir" ]; then
              dir_mode=$(stat -Lc '%#a' "$logdir")
              maxperm=$(printf '%o' $(( 0777 & ~perm_mask )) )
              if [ $(( dir_mode & perm_mask )) -eq 0 ]; then
                audit_dir_flag="audit_logdir_ok"
              else
                echo "Directory $logdir permissions $dir_mode should be $maxperm or more restrictive"
              fi
            fi
          fi

          echo "$audit_dir_flag"
        tests:
          test_items:
            - flag: "audit_logdir_ok"
              set: true
        remediation: |
          Restrict the permissions on the audit log directory to mode 0750 or more restrictive.

          1) Determine the audit log directory:
             # dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' /etc/audit/auditd.conf | xargs)"

          2) Apply secure permissions:
             # chmod g-w,o-rwx "$(dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' /etc/audit/auditd.conf | xargs)")"

          3) Verify the directory permissions:
             # stat -Lc '%n %a' "$(dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' /etc/audit/auditd.conf | xargs)")"
             Expected mode: 750 or more restrictive

          Notes:
          - The audit log directory should not allow write access by group or any access by others.
          - Ensures that only the audit subsystem and administrators can access audit logs.
        scored: true

      - id: 6.3.4.2
        description: "Ensure audit log files mode is configured (Automated)"
        audit: |
          audit_logs_flag="audit_logs_bad"
          perm_mask=$((8#0177))
          conf="/etc/audit/auditd.conf"

          if [ -f "$conf" ]; then
            logdir="$(dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' "$conf" | xargs)")"
            if [ -d "$logdir" ]; then
              maxperm=$(printf '%o' $(( 0777 & ~perm_mask )) )
              # Check if any files exceed 0640 permissions
              bad_files=$(find "$logdir" -maxdepth 1 -type f -perm /"$perm_mask" -print 2>/dev/null)
              if [ -z "$bad_files" ]; then
                audit_logs_flag="audit_logs_ok"
              else
                echo "Files in $logdir with permissions less restrictive than $maxperm:"
                echo "$bad_files"
              fi
            fi
          fi

          echo "$audit_logs_flag"
        tests:
          test_items:
            - flag: "audit_logs_ok"
              set: true
        remediation: |
          Restrict the permissions of audit log files to mode 0640 or more restrictive.

          1) Determine the audit log directory:
             # dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' /etc/audit/auditd.conf | xargs)"

          2) Apply secure permissions:
             # [ -f /etc/audit/auditd.conf ] && \
               find "$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" \
               -type f -perm /0137 -exec chmod u-x,g-wx,o-rwx {} +

          3) Verify that all log files are mode 0640 or more restrictive:
             # find "$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" -type f -exec stat -Lc '%n %a' {} +

          Notes:
          - Ensures that only root and members of the owning group (typically root or audit) can read audit logs.
          - Prevents unauthorized modification or viewing of audit records.
        scored: true


      - id: 6.3.4.3
        description: "Ensure audit log files owner is configured (Automated)"
        audit: |
          owner_flag="AUDIT_LOGS_OWNER_BAD"
          conf="/etc/audit/auditd.conf"

          if [ -f "$conf" ]; then
            logdir="$(dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' "$conf" | xargs)")"
            if [ -d "$logdir" ]; then
              not_root=$(find "$logdir" -maxdepth 1 -type f ! -user root -print 2>/dev/null)
              if [ -z "$not_root" ]; then
                owner_flag="AUDIT_LOGS_OWNER_OK"
              else
                echo "Non-root owned audit log files found in $logdir:"
                echo "$not_root"
              fi
            else
              echo "Audit log directory not found or not set (derived from $conf)."
            fi
          else
            echo "$conf not found. Verify auditd is installed."
          fi

          echo "$owner_flag"
        tests:
          test_items:
            - flag: "AUDIT_LOGS_OWNER_OK"
              set: true
        remediation: |
          Ensure audit log files are owned by root.

          Command (safe, targeted to audit log directory from auditd.conf):
          # [ -f /etc/audit/auditd.conf ] && \
            find "$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" \
            -maxdepth 1 -type f ! -user root -exec chown root {} +

          After remediation, re-run the audit to confirm:
          # chown --version >/dev/null 2>&1 && echo "Ownership updated where needed"
        scored: true


      - id: 6.3.4.4
        description: "Ensure audit log files group owner is configured (Automated)"
        audit: |
          audit_group_flag="AUDIT_LOG_GROUP_BAD"
          conf="/etc/audit/auditd.conf"

          if [ -f "$conf" ]; then
            logdir="$(dirname "$(awk -F= '/^\s*log_file\s*/{print $2}' "$conf" | xargs)")"
            log_group="$(awk -F= '/^\s*log_group\s*/{print $2}' "$conf" | xargs)"
            if echo "$log_group" | grep -Pq '^\s*(root|adm)\s*$'; then
              loggroup_ok=true
            else
              echo "log_group in $conf is '$log_group' — should be 'root' or 'adm'"
              loggroup_ok=false
            fi
            if [ -d "$logdir" ]; then
              bad_files=$(find "$logdir" -maxdepth 1 -type f ! -group root ! -group adm -print 2>/dev/null)
              if [ -z "$bad_files" ] && [ "$loggroup_ok" = true ]; then
                audit_group_flag="AUDIT_LOG_GROUP_OK"
              else
                [ -n "$bad_files" ] && echo "Files with incorrect group ownership in $logdir:" && echo "$bad_files"
              fi
            else
              echo "Audit log directory not found or not set in $conf."
            fi
          else
            echo "$conf not found. Verify auditd is installed."
          fi

          echo "$audit_group_flag"
        tests:
          test_items:
            - flag: "AUDIT_LOG_GROUP_OK"
              set: true
        remediation: |
          Ensure audit log files are group owned by 'adm' or 'root' and that auditd configuration reflects this.

          1) Set group ownership of audit log files:
             # find "$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" \
               -type f \( ! -group adm -a ! -group root \) -exec chgrp adm {} +

          2) Set the log group for the audit log directory:
             # chgrp adm /var/log/audit/

          3) Update /etc/audit/auditd.conf to ensure log_group is configured correctly:
             # sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?$/log_group = adm\1/' /etc/audit/auditd.conf

          4) Restart auditd to apply configuration changes:
             # systemctl restart auditd

          Notes:
          - Either 'root' or 'adm' group ownership is acceptable.
          - The adm group is commonly used to allow administrators read-only access to audit logs.
        scored: true


      - id: 6.3.4.5
        description: "Ensure audit configuration files mode is configured (Automated)"
        audit: |
          flag="AUDIT_CFG_MODE_BAD"
          perm_mask="0137"   # bits disallowed for files (should be <= 0640)
          maxperm="$(printf '%o' $(( 0777 & ~0$perm_mask )) )"
          bad_list=""

          while IFS= read -r -d '' f; do
            mode="$(stat -Lc '%#a' "$f" 2>/dev/null || echo "")"
            if [ -n "$mode" ] && [ $(( 0$mode & 0$perm_mask )) -gt 0 ]; then
              bad_list="${bad_list}\n - file: \"$f\" is mode: \"$mode\" (should be \"$maxperm\" or more restrictive)"
            fi
          done < <(find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -print0 2>/dev/null)

          if [ -z "$bad_list" ]; then
            echo "AUDIT_CFG_MODE_OK"
          else
            echo -e "$bad_list"
            echo "AUDIT_CFG_MODE_BAD"
          fi
        tests:
          test_items:
            - flag: "AUDIT_CFG_MODE_OK"
              set: true
        remediation: |
          Set audit configuration files to mode 0640 or more restrictive:

          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec chmod u-x,g-wx,o-rwx {} +

          Notes:
          - This enforces max permissions of 0640 (rw-r-----).
          - Re-run the audit to confirm no files exceed the allowed permissions.
        scored: true


      - id: 6.3.4.6
        description: "Ensure audit configuration files owner is configured (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change ownership to root user:
          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -exec chown root {} +
        scored: true

      - id: 6.3.4.7
        description: "Ensure audit configuration files group owner is configured (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change group to root:

          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root -exec chgrp root {} +
        scored: true

      - id: 6.3.4.8
        description: "Ensure audit tools mode is configured (Automated)"
        audit: |
          # Fail if any audit tool is more permissive than 0755 (i.e., group/other write set)
          perm_mask="0022"   # disallow g+w (0020) and o+w (0002)
          maxperm="$(printf '%o' $(( 0777 & ~0$perm_mask )) )"  # 0755
          bad=""
          ok=""

          # Primary paths from CIS text; also check common /usr/sbin locations
          declare -a tools=(/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules)

          resolve_tool() {
            t="$1"
            if [ -x "$t" ]; then
              printf '%s' "$t"
            elif [ -x "/usr$s1" ]; then
              printf '%s' "/usr$s1"
            else
              # try to find by basename in PATH
              bname="$(basename "$t")"
              path="$(command -v "$bname" 2>/dev/null || true)"
              printf '%s' "$path"
            fi
          }

          for t in "${tools[@]}"; do
            r="$(resolve_tool "$t")"
            if [ -n "$r" ] && [ -e "$r" ]; then
              mode="$(stat -Lc '%#a' "$r" 2>/dev/null || true)"
              if [ -n "$mode" ] && [ $(( 0$mode & 0$perm_mask )) -gt 0 ]; then
                bad="${bad}\n - Audit tool \"$r\" is mode: \"$mode\" (should be \"$maxperm\" or more restrictive)"
              else
                ok="${ok}\n - Audit tool \"${r:-$t}\" is correctly configured"
              fi
            else
              bad="${bad}\n - Audit tool \"$t\" not found (verify package installation and path)"
            fi
          done

          if [ -z "$bad" ]; then
            echo "AUDIT_TOOLS_MODE_OK"
          else
            echo -e "$bad"
            echo "AUDIT_TOOLS_MODE_BAD"
          fi
        tests:
          test_items:
            - flag: "AUDIT_TOOLS_MODE_OK"
              set: true
        remediation: |
          Set audit tools to be no more permissive than 0755 (remove group/other write):

          # Adjust paths if your distro installs tools under /usr/sbin
          chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules 2>/dev/null || true
          chmod go-w /usr/sbin/auditctl /usr/sbin/aureport /usr/sbin/ausearch /usr/sbin/autrace /usr/sbin/auditd /usr/sbin/augenrules 2>/dev/null || true

          You can also perform a generic fix by locating the binaries first:
          # for b in auditctl aureport ausearch autrace auditd augenrules; do
          #   p="$(command -v "$b" 2>/dev/null)" && [ -n "$p" ] && chmod go-w "$p"
          # done

          Re-run the audit to confirm all tools are at 0755 or more restrictive.
        scored: true


      - id: 6.3.4.9
        description: "Ensure audit tools owner is configured (Automated)"
        audit: |
          stat -Lc "%n %U" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | awk '$2 != "root" {print}'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change the owner of the audit tools to the root user:

          # chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
        scored: true

      - id: 6.3.4.10
        description: "Ensure audit tools group owner is configured (Automated)"
        audit: |
          stat -Lc "%n %G" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | awk '$2 != "root" {print}'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change group ownership to the groop root:

          # chgrp root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
        scored: true


  - id: 7
    description: "System Maintenance"
    checks:
  - id: 7.1
    description: "System File Permissions"
    checks:
      - id: 7.1.1
        description: "Ensure permissions on /etc/passwd are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/passwd:
          # chmod u-x,go-wx /etc/passwd
          # chown root:root /etc/passwd
        scored: true

      - id: 7.1.2
        description: "Ensure permissions on /etc/passwd- are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd- 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/passwd-:
          # chmod u-x,go-wx /etc/passwd-
          # chown root:root /etc/passwd-
        scored: true


      - id: 7.1.3
        description: "Ensure permissions on /etc/group are configured (Automated)"
        audit: |
          mode_str="$(stat -Lc '%a' /etc/group 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/group:
          # chmod u-x,go-wx /etc/group
          # chown root:root /etc/group
        scored: true


      - id: 7.1.4
        description: "Ensure permissions on /etc/group- are configured (Automated)"
        audit: |
          # Expect: group <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/group- 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group-:

          chmod u-x,go-wx /etc/group-
          chown root:root /etc/group-
        scored: true

      - id: 7.1.5
        description: "Ensure permissions on /etc/shadow are configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          # Correct ownership and permissions for /etc/shadow
          chown root:root /etc/shadow
          chmod 0000 /etc/shadow
        scored: true

      - id: 7.1.6
        description: "Ensure permissions on /etc/shadow- are configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow-:

          # chown root:root /etc/shadow-
          # chmod 0000 /etc/shadow-
        scored: true

      - id: 7.1.7
        description: "Ensure permissions on /etc/gshadow are configured (Automated)"
        audit: |
          # Expected: /etc/gshadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/gshadow ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow:

          # chown root:root /etc/gshadow
          # chmod 0000 /etc/gshadow
        scored: true

      - id: 7.1.8
        description: "Ensure permissions on /etc/gshadow- are configured (Automated)"
        audit: |
          # Expected: /etc/gshadow- owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/gshadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow-:

          # chown root:root /etc/gshadow-
          # chmod 0000 /etc/gshadow-
        scored: true
      - id: 7.1.9
        description: "Ensure permissions on /etc/shells are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/shells 2>/dev/null)" || { echo "shells_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/shells)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "shells_perms_ok"
          else
            echo "shells_perms_bad"
          fi
        tests:
          test_items:
            - flag: "shells_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/shells:
          # chmod u-x,go-wx /etc/shells
          # chown root:root /etc/shells
        scored: true

      - id: 7.1.10
        description: "Ensure permissions on /etc/security/opasswd are configured (Automated)"
        audit: |
          opasswd_flag="opasswd_bad"

          check_file() {
            local f="$1"
            [ ! -e "$f" ] && return 0
            mode=$(stat -Lc '%#a' "$f" 2>/dev/null)
            owner=$(stat -Lc '%U' "$f" 2>/dev/null)
            group=$(stat -Lc '%G' "$f" 2>/dev/null)
            if [ "$mode" = "0600" ] && [ "$owner" = "root" ] && [ "$group" = "root" ]; then
              return 0
            else
              echo "$f: mode=$mode owner=$owner group=$group (should be 0600, root:root)"
              return 1
            fi
          }

          if check_file /etc/security/opasswd && check_file /etc/security/opasswd.old; then
            opasswd_flag="opasswd_ok"
          fi

          echo "$opasswd_flag"
        tests:
          test_items:
            - flag: "opasswd_ok"
              set: true
        remediation: |
          Ensure /etc/security/opasswd and /etc/security/opasswd.old are owned by root:root
          and have mode 0600 or more restrictive.

          # [ -e /etc/security/opasswd ] && chmod u-x,go-rwx /etc/security/opasswd && chown root:root /etc/security/opasswd
          # [ -e /etc/security/opasswd.old ] && chmod u-x,go-rwx /etc/security/opasswd.old && chown root:root /etc/security/opasswd.old

          Notes:
          - These files store previous passwords and must be tightly restricted.
          - Absence of the files is acceptable and will pass this check.
        scored: true


      - id: 7.1.11
        description: "Ensure world writable files and directories are secured (Automated)"
        audit: |
          ww_flag="WW_SECURED_OK"
          sticky_mask=01000

          # Filesystems to scan: all local, skip well-known pseudo/virtual types
          # Keep /tmp and /var/tmp in scope to validate sticky bit there too.
          mapfile -t MOUNTS < <(findmnt -Dkerno fstype,target \
            | awk '$1 !~ /^(nfs|proc|smb|cifs|vfat|iso9660|efivarfs|selinuxfs|autofs|debugfs|devpts|devtmpfs|mqueue|hugetlbfs|rpc_pipefs|tmpfs)$/ {print $2}')

          WW_FILES=()
          WW_DIRS_NO_STICKY=()

          # Path patterns to exclude during traversal (containers, kernel pseudo-trees, etc.)
          FIND_PRUNE=( ! -path "/run/user/*" -a ! -path "/proc/*" -a ! -path "/sys/*" \
                       -a ! -path "*/containerd/*" -a ! -path "*/kubelet/pods/*" \
                       -a ! -path "*/kubelet/plugins/*" -a ! -path "/snap/*" )

          for mp in "${MOUNTS[@]}"; do
            while IFS= read -r -d '' p; do
              if [ -f "$p" ]; then
                WW_FILES+=("$p")
              elif [ -d "$p" ]; then
                # Check sticky bit on WW directories
                mode=$(stat -Lc '%#a' "$p" 2>/dev/null || echo "")
                if [ -n "$mode" ]; then
                  # shellcheck disable=SC2004
                  if ! [ $(( 0$mode & $sticky_mask )) -gt 0 ]; then
                    WW_DIRS_NO_STICKY+=("$p")
                  fi
                fi
              fi
            done < <(find "$mp" -xdev \( "${FIND_PRUNE[@]}" \) \( -type f -o -type d \) -perm -0002 -print0 2>/dev/null)
          done

          if (( ${#WW_FILES[@]} > 0 )) || (( ${#WW_DIRS_NO_STICKY[@]} > 0 )); then
            ww_flag="WW_SECURED_BAD"
            echo "$ww_flag"
            if (( ${#WW_FILES[@]} > 0 )); then
              echo "--- World-writable files (o+w) ---"
              printf '%s\n' "${WW_FILES[@]}"
            fi
            if (( ${#WW_DIRS_NO_STICKY[@]} > 0 )); then
              echo "--- World-writable directories missing sticky bit (a+t) ---"
              printf '%s\n' "${WW_DIRS_NO_STICKY[@]}"
            fi
          else
            echo "$ww_flag"
          fi
        tests:
          test_items:
            - flag: "WW_SECURED_OK"
              set: true
        remediation: |
          World-writable files should not allow write for "other", and world-writable directories
          must have the sticky bit set so users cannot delete/rename others’ files.

          **Recommended fixes**
          - For each listed *file*: remove other-write
              chmod o-w <file>
          - For each listed *directory*: add sticky bit
              chmod a+t <directory>

          **One-shot helper script (careful in prod; review before running)**
          #!/usr/bin/env bash
          set -u
          sticky_mask=01000
          mapfile -t MOUNTS < <(findmnt -Dkerno fstype,target \
            | awk '$1 !~ /^(nfs|proc|smb|cifs|vfat|iso9660|efivarfs|selinuxfs|autofs|debugfs|devpts|devtmpfs|mqueue|hugetlbfs|rpc_pipefs|tmpfs)$/ {print $2}')
          FIND_PRUNE=( ! -path "/run/user/*" -a ! -path "/proc/*" -a ! -path "/sys/*" \
                       -a ! -path "*/containerd/*" -a ! -path "*/kubelet/pods/*" \
                       -a ! -path "*/kubelet/plugins/*" -a ! -path "/snap/*" )
          for mp in "${MOUNTS[@]}"; do
            while IFS= read -r -d '' p; do
              if [ -f "$p" ]; then
                echo "Fixing file: $p (chmod o-w)"
                chmod o-w "$p"
              elif [ -d "$p" ]; then
                mode=$(stat -Lc '%#a' "$p" 2>/dev/null || echo "")
                if [ -n "$mode" ] && ! [ $(( 0$mode & $sticky_mask )) -gt 0 ]; then
                  echo "Fixing dir:  $p (chmod a+t)"
                  chmod a+t "$p"
                fi
              fi
            done < <(find "$mp" -xdev \( "${FIND_PRUNE[@]}" \) \( -type f -o -type d \) -perm -0002 -print0 2>/dev/null)
          done

          **Notes**
          - Always validate with application owners before changing permissions on app-managed files.
          - It’s normal for /tmp and /var/tmp to be world-writable, but they **must** have the sticky bit set (mode shows a leading “t”, e.g., 1777).
        scored: true

      - id: 7.1.12
        description: "Ensure no files or directories without an owner and a group exist (Automated)"
        audit: |
          flag="ORPHANED_OK"

          # Mounts to scan: local filesystems only; skip common virtual/pseudo FS
          mapfile -t MOUNTS < <(findmnt -Dkerno fstype,target \
            | awk '$1 !~ /^(nfs|proc|smb|cifs|vfat|iso9660|efivarfs|selinuxfs|autofs|debugfs|devpts|devtmpfs|mqueue|hugetlbfs|rpc_pipefs|tmpfs)$/ {print $2}')

          # Prune noisy/ephemeral paths
          PRUNE=( ! -path "/run/user/*" -a ! -path "/proc/*" -a ! -path "/sys/*"
                  -a ! -path "*/containerd/*" -a ! -path "*/kubelet/pods/*"
                  -a ! -path "*/kubelet/plugins/*" -a ! -path "/sys/fs/cgroup/memory/*"
                  -a ! -path "/var/*/private/*" )

          NOUSER=()
          NOGROUP=()

          for mp in "${MOUNTS[@]}"; do
            while IFS= read -r -d '' p; do
              # Double-check with stat to classify what is missing
              if [ -e "$p" ]; then
                ug="$(stat -Lc '%U:%G' "$p" 2>/dev/null || true)"
                u="${ug%%:*}"; g="${ug##*:}"
                [[ "$u" == "UNKNOWN" ]] && NOUSER+=("$p")
                [[ "$g" == "UNKNOWN" ]] && NOGROUP+=("$p")
              fi
            done < <(find "$mp" -xdev \( "${PRUNE[@]}" \) \( -type f -o -type d \) \( -nouser -o -nogroup \) -print0 2>/dev/null)
          done

          if (( ${#NOUSER[@]} > 0 )) || (( ${#NOGROUP[@]} > 0 )); then
            flag="ORPHANED_BAD"
          fi

          echo "$flag"
          if [ "$flag" = "ORPHANED_BAD" ]; then
            if (( ${#NOUSER[@]} > 0 )); then
              echo "--- Unowned paths (no matching UID) ---"
              printf '%s\n' "${NOUSER[@]}"
            fi
            if (( ${#NOGROUP[@]} > 0 )); then
              echo "--- Ungrouped paths (no matching GID) ---"
              printf '%s\n' "${NOGROUP[@]}"
            fi
          fi
        tests:
          test_items:
            - flag: "ORPHANED_OK"
              set: true
        remediation: |
          Identify each path and assign ownership to a valid local account/group or remove the path
          if it is not needed. **Do not** blindly chown system directories without validation.

          Examples:
            # Set owner/group to a valid account (replace with appropriate values)
            chown <user>:<group> <path>

            # Remove an abandoned path if confirmed safe to delete
            rm -rf <path>

          Helper script (prints actions; remove 'echo' to apply):
          #!/usr/bin/env bash
          set -u
          TARGET_USER="<valid_user>"
          TARGET_GROUP="<valid_group>"

          mapfile -t MOUNTS < <(findmnt -Dkerno fstype,target \
            | awk '$1 !~ /^(nfs|proc|smb|cifs|vfat|iso9660|efivarfs|selinuxfs|autofs|debugfs|devpts|devtmpfs|mqueue|hugetlbfs|rpc_pipefs|tmpfs)$/ {print $2}')
          PRUNE=( ! -path "/run/user/*" -a ! -path "/proc/*" -a ! -path "/sys/*"
                  -a ! -path "*/containerd/*" -a ! -path "*/kubelet/pods/*"
                  -a ! -path "*/kubelet/plugins/*" -a ! -path "/sys/fs/cgroup/memory/*"
                  -a ! -path "/var/*/private/*" )

          for mp in "${MOUNTS[@]}"; do
            while IFS= read -r -d '' p; do
              echo "Would set owner/group on: $p -> ${TARGET_USER}:${TARGET_GROUP}"
              # chown "${TARGET_USER}:${TARGET_GROUP}" "$p"
            done < <(find "$mp" -xdev \( "${PRUNE[@]}" \) \( -type f -o -type d \) \( -nouser -o -nogroup \) -print0 2>/dev/null)
          done

          Notes:
          - Pick an account/group that actually owns/should own the asset (e.g., service user).
          - Review application/vendor documentation before changes.
          - Consider scanning mounted network volumes separately with their native tools/policies.
        scored: true


      - id: 7.1.13
        description: "Ensure SUID and SGID files are reviewed (Manual)"
        audit: |
          # Collect local mounts that are NOT noexec and NOT nosuid, skip ephemeral/virtual FS
          mapfile -t MOUNTS < <(
            findmnt -Dkerno fstype,target,options \
            | awk '
              $1 !~ /^(nfs|smb|cifs|proc|sysfs|devtmpfs|devpts|tmpfs|mqueue|hugetlbfs|rpc_pipefs|autofs|iso9660|efivarfs|selinuxfs)$/ &&
              $2 !~ /^\/run\/user\// &&
              $3 !~ /(^|,)noexec(,|$)/ &&
              $3 !~ /(^|,)nosuid(,|$)/ {print $2}'
          )

          # Helper: safe stat fields
          f_stat() { stat -Lc '%#a %U:%G' "$1" 2>/dev/null || echo "0000 UNKNOWN:UNKNOWN"; }

          # Detect rpm availability
          HAVE_RPM=0; command -v rpm >/dev/null 2>&1 && HAVE_RPM=1

          SUID_LIST=()
          SGID_LIST=()

          # Find SUID/SGID files
          for mp in "${MOUNTS[@]}"; do
            while IFS= read -r -d '' p; do
              [ -e "$p" ] || continue
              mode_and_owner="$(f_stat "$p")"
              IFS=' ' read -r fmode fown <<<"$mode_and_owner"
              # Classify
              perm=$(( 8#${fmode} ))
              (( (perm & 04000) > 0 )) && SUID_LIST+=("$p|$fmode|$fown")
              (( (perm & 02000) > 0 )) && SGID_LIST+=("$p|$fmode|$fown")
            done < <(find "$mp" -xdev -type f \( -perm -4000 -o -perm -2000 \) -print0 2>/dev/null)
          done

          echo "SUID_SGID_REVIEW"
          echo
          printf '== Summary ==\n'
          printf 'Mount points scanned: %s\n' "${#MOUNTS[@]}"
          printf 'SUID files found: %s\n' "${#SUID_LIST[@]}"
          printf 'SGID files found: %s\n' "${#SGID_LIST[@]}"
          echo

          print_block () {
            local title="$1"; shift
            local -n arr_ref=$1
            echo "$title"
            echo "---------------------------------------------"
            if ((${#arr_ref[@]}==0)); then
              echo "(none)"
              echo
              return
            fi
            for entry in "${arr_ref[@]}"; do
              IFS='|' read -r path fmode fown <<<"$entry"
              pkg="(n/a)"; verify="(n/a)"
              if ((HAVE_RPM==1)); then
                if pkg_name=$(rpm -qf --qf '%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n' -- "$path" 2>/dev/null); then
                  pkg="$pkg_name"
                  # rpm -V returns nonzero on differences; we capture the report text if any
                  if out=$(rpm -V -- "$pkg_name" 2>/dev/null | awk -v p="$path" '$0 ~ p'); then
                    verify="MODIFIED: $out"
                  else
                    verify="ok"
                  fi
                else
                  pkg="(unowned-by-rpm)"
                fi
              fi
              printf '%s\n' "Path: $path"
              printf '  Mode/Owner : %s / %s\n' "$fmode" "$fown"
              printf '  Package    : %s\n' "$pkg"
              printf '  Integrity  : %s\n' "$verify"
              echo
            done
          }

          print_block "SUID files" SUID_LIST
          print_block "SGID files" SGID_LIST

        tests:
          test_items:
            - flag: "SUID_SGID_REVIEW"
              set: true
        remediation: |
          Review each SUID/SGID file to confirm it is expected for your system and installed package.
          Actions you may take for *unexpected* entries:
            - Remove the setuid/setgid bit:
                # chmod u-s <path>      # remove SUID
                # chmod g-s <path>      # remove SGID
            - Reinstall the owning package to restore a tampered binary:
                # dnf reinstall <package>
            - If the file is not owned by any package and not required, remove it:
                # rm -f <path>
            - For legitimate admin tools, restrict execution path (e.g., mount with noexec/nosuid where possible),
              and ensure only trusted users can access them (ownership/ACLs).

          Caution:
            - Changing bits on core system binaries (e.g., passwd, sudo) can break functionality.
              Validate with vendor documentation and test in staging first.
            - Prefer removing SUID/SGID on nonessential binaries rather than deleting the file.
        scored: true

  - id: 7.2
    description: "Local User and Group Settings"
    checks:
      - id: 7.2.1
        description: "Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
        audit: |
          awk -F: '($2 != "x" ) { print "User: \"" $1 "\" is not set to shadowed passwords "}' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set accounts to use shadowed passwords and migrate passwords in /etc/passwd to /etc/shadow:

          # pwconv
          Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off.
        scored: true
      - id: 7.2.2
        description: "Ensure /etc/shadow password fields are not empty (Automated)"
        audit: |
          awk -F: '($2 == "" ) { print $1 " does not have a password "}' /etc/shadow
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:

          # passwd -l <username>
          Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off.
        scored: true


      - id: 7.2.3
        description: "Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
        audit: |
          #!/bin/sh
          # Verify that every primary GID in /etc/passwd exists in /etc/group
          # Expect: No missing group IDs

          [ -f /etc/passwd ] && [ -f /etc/group ] || { echo "passwd_groups_bad"; exit 0; }

          findings="$(
            awk -F: '
              FNR==NR { g[$3]=1; next }                 # collect all GIDs from /etc/group
              { if ($4 != "" && !( $4 in g )) m[$4]=1 } # find GIDs in /etc/passwd missing in /etc/group
              END {
                for (k in m)
                  printf "User(s) in /etc/passwd reference GID %s, which does not exist in /etc/group\n", k
              }
            ' /etc/group /etc/passwd
          )"

          if [ -z "$findings" ]; then
            echo "passwd_groups_ok"
          else
            echo "passwd_groups_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "passwd_groups_ok"
              set: true
        remediation: |
          Examine the reported missing groups and resolve discrepancies.

          - To create a missing group with a specific GID:
            # groupadd -g <GID> <groupname>

          - To assign an existing valid group to a user:
            # usermod -g <existing_group> <username>

          - Optionally, automatically create placeholder groups for all missing GIDs:
            # awk -F: '
            #   FNR==NR { g[$3]=1; next }
            #   { if ($4 != "" && !( $4 in g )) m[$4]=1 }
            #   END { for (k in m) print k }
            # ' /etc/group /etc/passwd | while read -r gid; do
            #   groupadd -g "$gid" "gid$gid" 2>/dev/null || true
            # done

          Re-run this check after remediation to verify no missing groups remain.
        scored: true


      - id: 7.2.4
        description: "Ensure no duplicate UIDs exist (Automated)"
        audit: |
          {
            while read -r l_count l_uid; do
              if [ "$l_count" -gt 1 ]; then
                echo -e "Duplicate UID: \"$l_uid\" Users: \"$(awk -F: '($3 == n) { print $1 }' n=$l_uid /etc/passwd | xargs)\""
              fi
            done < <(cut -f3 -d":" /etc/passwd | sort -n | uniq -c)
          }
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique UIDs and review all files owned by the shared UIDs to determine which UID they are supposed to belong to
        scored: true

      - id: 7.2.5
        description: "Ensure no duplicate GIDs exist (Automated)"
        audit: |
          {
             while read -r l_count l_gid; do
                if [ "$l_count" -gt 1 ]; then
                echo -e "Duplicate GID: \"$l_gid\" Groups: \"$(awk -F: '($3 == n) { print $1 }' n=$l_gid /etc/group | xargs)\""
              fi
            done < <(cut -f3 -d":" /etc/group | sort -n | uniq -c)
          }
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to.
        scored: true


      - id: 7.2.6
        description: "Ensure no duplicate user names exist (Automated)"
        audit: |
          {
             while read -r l_count l_user; do
                if [ "$l_count" -gt 1 ]; then
                   echo -e "Duplicate User: \"$l_user\" Users: \"$(awk -F: '($1 == n) { print $1 }' n=$l_user /etc/passwd | xargs)\""
                fi
             done < <(cut -f1 -d":" /etc/group | sort -n | uniq -c)
          }
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs.
        scored: true


      - id: 7.2.7
        description: "Ensure no duplicate group names exist (Automated)"
        audit: |
          {
             while read -r l_count l_group; do
                if [ "$l_count" -gt 1 ]; then
                   echo -e "Duplicate Group: \"$l_group\" Groups: \"$(awk -F: '($1 == n) { print $1 }' n=$l_group /etc/group | xargs)\""
                fi
             done < <(cut -f1 -d":" /etc/group | sort -n | uniq -c)
          }
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.
        scored: true


      - id: 7.2.8
        description: "Ensure local interactive user home directories are configured (Automated)"
        audit: |
          #!/bin/sh
          # Expectations per CIS:
          # 1) Home directory exists
          # 2) Home directory is owned by the user
          # 3) Home directory permissions are <= 0750 (mask 027)

          [ -f /etc/passwd ] || { echo "homes_bad"; echo "/etc/passwd not found"; exit 0; }
          [ -f /etc/shells ] || { echo "homes_bad"; echo "/etc/shells not found"; exit 0; }

          # Build allowlist of interactive shells (exclude nologin/false)
          shells_re="$(
            awk '
              $0 ~ /^\// && $0 !~ /(\/nologin|\/false)$/ { gsub(/\//,"\\\/"); printf "%s%s", sep $0, ORS==""?"":"|"; sep=""
            ' /etc/shells
          )"
          [ -n "$shells_re" ] || shells_re="^$"  # fallback to match nothing

          findings=""
          mask=$(( 8#027 ))

          # Iterate local interactive users (based on shell allowlist)
          awk -F: -v re="$shells_re" '$(NF) ~ "(" re ")" { print $1, $(NF-1) }' /etc/passwd |
          while read -r user home; do
            [ -n "$home" ] || home="/"
            if [ ! -d "$home" ]; then
              findings="${findings}\nUser \"$user\": home \"$home\" is missing"
              continue
            fi

            # ownership
            owner="$(stat -Lc '%U' "$home" 2>/dev/null || echo unknown)"
            [ "$owner" = "$user" ] || findings="${findings}\nUser \"$user\": home \"$home\" owner is \"$owner\" (expected \"$user\")"

            # mode check (<= 0750 -> i.e., (mode & 027) == 0)
            mode_str="$(stat -Lc '%a' "$home" 2>/dev/null || echo 9999)"
            case "$mode_str" in
              ''|*[!0-7]*) mode=9999 ;;
              *) mode=$(( 8#${mode_str} )) ;;
            esac
            if [ $(( mode & mask )) -ne 0 ]; then
              findings="${findings}\nUser \"$user\": home \"$home\" mode ${mode_str} too permissive (must be <= 0750)"
            fi
          done

          if [ -z "$findings" ]; then
            echo "homes_ok"
          else
            echo "homes_bad"
            # Trim leading newline if present
            printf "%s\n" "$(printf "%b" "$findings" | sed '1{/^$/d;}')"
          fi
        tests:
          test_items:
            - flag: "homes_ok"
              set: true
        remediation: |
          For each reported user:

          - If the home directory is missing, create it with secure ownership and mode:
            # mkdir -p <HOME>
            # chown <USER>:<USER> <HOME>
            # chmod 750 <HOME>

          - If ownership is incorrect:
            # chown <USER>:<USER> <HOME>

          - If permissions are too permissive (more than 0750):
            # chmod 750 <HOME>

          Re-run the audit to confirm that all local interactive user home directories exist, are owned by their users, and are 0750 or more restrictive.
        scored: true

      - id: 7.2.9
        description: "Ensure local interactive user dot files access is configured (Automated)"
        audit: |
          #!/bin/sh
          # Checks for each local interactive user:
          # - No .forward, .rhost present
          # - .bash_history and (if present) .netrc are <= 0600
          # - All other dotfiles are <= 0644 (no exec, no group/other write)
          # - Dotfiles owned by the user and group-owned by user's primary group

          [ -f /etc/passwd ] && [ -f /etc/shells ] || { echo "dotfiles_bad"; echo "Required system files missing"; exit 0; }

          # Build regex of valid interactive shells (exclude nologin/false)
          shells_re="$(
            awk '/^\// && $0 !~ /(\/nologin|\/false)$/ { gsub(/\//,"\\\/"); print }' /etc/shells | paste -sd'|' -
          )"
          [ -n "$shells_re" ] || shells_re="^$"  # match nothing if empty

          findings=""

          # Enumerate local interactive users and homes
          awk -F: -v re="$shells_re" '$(NF) ~ "(" re ")" { print $1, $(NF-1) }' /etc/passwd |
          while read -r user home; do
            [ -n "$home" ] || home="/"
            [ -d "$home" ] || { findings="${findings}\nUser \"$user\": home \"$home\" missing"; continue; }

            # Primary group name for ownership checks
            pgroup="$(id -gn "$user" 2>/dev/null)"
            [ -n "$pgroup" ] || pgroup="$user"

            # Prohibited files
            for f in ".forward" ".rhost"; do
              if [ -e "$home/$f" ]; then
                findings="${findings}\nUser \"$user\": prohibited file \"$home/$f\" exists"
              fi
            done

            # Iterate all dotfiles (regular files starting with '.')
            # shellcheck disable=SC2039
            find "$home" -xdev -type f -name '.*' 2>/dev/null | while read -r path; do
              base="$(basename "$path")"
              mode_str="$(stat -Lc '%a' "$path" 2>/dev/null || echo 9999)"
              owner="$(stat -Lc '%U' "$path" 2>/dev/null || echo unknown)"
              gowner="$(stat -Lc '%G' "$path" 2>/dev/null || echo unknown)"

              # Convert octal string to numeric
              case "$mode_str" in
                ''|*[!0-7]*) mode=9999 ;;
                *) mode=$(( 8#${mode_str} )) ;;
              esac

              # Ownership checks
              [ "$owner" = "$user" ] || findings="${findings}\nUser \"$user\": $path owner is \"$owner\" (expected \"$user\")"
              [ "$gowner" = "$pgroup" ] || findings="${findings}\nUser \"$user\": $path group is \"$gowner\" (expected \"$pgroup\")"

              # Permission policy
              case "$base" in
                .bash_history|.netrc)
                  # must be <= 0600 --> (mode & 0177) == 0
                  [ $(( mode & 8#0177 )) -eq 0 ] || findings="${findings}\nUser \"$user\": $path mode $mode_str too permissive (must be <= 0600)"
                  ;;
                .forward|.rhost)
                  # already flagged above; skip perms test
                  ;;
                *)
                  # general dotfiles must be <= 0644 --> (mode & 0133) == 0
                  [ $(( mode & 8#0133 )) -eq 0 ] || findings="${findings}\nUser \"$user\": $path mode $mode_str too permissive (must be <= 0644)"
                  ;;
              esac
            done
          done

          if [ -z "$findings" ]; then
            echo "dotfiles_ok"
          else
            echo "dotfiles_bad"
            printf "%s\n" "$(printf "%b" "$findings" | sed '1{/^$/d;}')"
          fi
        tests:
          test_items:
            - flag: "dotfiles_ok"
              set: true
        remediation: |
          For each reported user/file:

          - Remove prohibited files:
            # rm -f <HOME>/.forward <HOME>/.rhost

          - Tighten permissions:
            # chmod 600 <HOME>/.bash_history
            # [ -f <HOME>/.netrc ] && chmod 600 <HOME>/.netrc
            # find <HOME> -xdev -type f -name '.*' ! -name '.bash_history' ! -name '.netrc' -exec chmod u=rw,go=r {} +

          - Fix ownership and group:
            # chown <USER>:<PRIMARY_GROUP> <HOME>/.[!.]* 2>/dev/null || true

          Re-run the audit to verify there are no findings. If a .netrc file is required by site policy, ensure it remains at mode 600 and is owned by the user with the correct primary group.
        scored: true
