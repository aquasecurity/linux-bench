---
controls:
version: "Red Hat Enterprise Linux 9 v1.0.0"
id: 1
description: "Initial Setup"
type: "master"
groups:
  - id: 1.1
    description: "Filesystem Configuration"
    checks:
      - id: 1.1.1
        description: "Disable unused filesystems"
        type: "skip"
        checks:

      - id: 1.1.1.1
        description: "Ensure mounting of squashfs filesystems is disabled (Automated)"
        audit: |
          m="squashfs"

          # Is the module absent from this kernel?
          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "squashfs_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe handle it?
          loadable="$(modprobe -n -v "$m" 2>/dev/null || true)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b" || true)"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            install_status="install_ok"
          else
            install_status="install_bad"
          fi
          echo "$install_status"

          # Deny list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            blacklist_status="blacklist_ok"
          else
            blacklist_status="blacklist_bad"
          fi
          echo "$blacklist_status"

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            load_status="not_loaded"
          else
            load_status="loaded"
          fi
          echo "$load_status"

          # Final one-line verdict flag (so tests can be simple)
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "squashfs_disabled_ok:present_but_blocked"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "squashfs_disabled_ok:module_absent"
              set: true
            - flag: "squashfs_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # Disable squashfs if present:
          # 1) Prevent loading
          echo "install squashfs /bin/false" > /etc/modprobe.d/squashfs.conf
          # 2) Deny-list it
          echo "blacklist squashfs" >> /etc/modprobe.d/squashfs.conf
          # 3) Unload if currently loaded
          modprobe -r squashfs 2>/dev/null || true

          # Note: Disabling squashfs will break Snap packages which rely on squashfs.
        scored: true

      - id: 1.1.1.2
        description: "Ensure mounting of udf filesystems is disabled (Automated)"
        audit: |
          m="udf"

          if modprobe -n -v "$m" 2>&1 | grep -Piq "\bFATAL:\s+Module\s+$m\s+not\s+found\b"; then
            echo "udf_disabled_ok:module_absent"
            exit 0
          fi

          # How would modprobe act?
          loadable="$(modprobe -n -v "$m" 2>/dev/null)"
          [ "$(printf '%s\n' "$loadable" | wc -l)" -gt 1 ] && loadable="$(printf '%s\n' "$loadable" | grep -P "(^\s*install|\b$m)\b")"

          if printf '%s' "$loadable" | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          # Deny-list present?
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+'"$m"'\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          # Currently loaded?
          if ! lsmod | grep -q "^$m\b"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi

          # Pass case 2: present but blocked and not loaded -> emit a single verdict flag
          if [ "$install_status" = "install_ok" ] \
             && [ "$blacklist_status" = "blacklist_ok" ] \
             && [ "$load_status" = "not_loaded" ]; then
            echo "udf_disabled_ok:present_but_blocked"
          fi
        tests:
          test_items:
            - flag: "udf_disabled_ok:module_absent"
              set: true
            - flag: "udf_disabled_ok:present_but_blocked"
              set: true
        remediation: |
          # WARNING: Microsoft Azure requires UDF. Do not disable on Azure hosts.
          # If acceptable for your environment, disable UDF:

          # 1) Prevent loading via install rule
          echo "install udf /bin/false" > /etc/modprobe.d/udf.conf

          # 2) Deny-list it
          echo "blacklist udf" >> /etc/modprobe.d/udf.conf

          # 3) Unload if currently loaded
          modprobe -r udf 2>/dev/null || true
        scored: true

      - id: 1.1.2
        description: "Configure /tmp"
        type: "skip"
        checks:
      - id: 1.1.2.1
        description: "Ensure /tmp is a separate partition (Automated)"
        audit: |
          # Is /tmp mounted right now?
          if findmnt --kernel -kn /tmp >/dev/null 2>&1; then
            echo "tmp_mounted"
          else
            echo "tmp_not_mounted"
          fi

          # Will systemd mount /tmp at boot?
          unit_state="$(systemctl is-enabled tmp.mount 2>/dev/null || true)"
          case "$unit_state" in
            enabled|static|generated|indirect)
              echo "tmp_unit_ok"
              ;;
            *)
              echo "tmp_unit_bad"
              ;;
          esac
        tests:
          test_items:
            - flag: "tmp_mounted"
              set: true
            - flag: "tmp_unit_ok"
              set: true
        remediation: |
          # Ensure systemd can mount /tmp at boot
          systemctl unmask tmp.mount

          # Choose ONE approach that fits your environment and update /etc/fstab.

          # Option A: tmpfs (RAM-backed /tmp)
          # Add a line like the following to /etc/fstab, then mount:
          # tmpfs  /tmp  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0
          # mount -o remount /tmp || mount /tmp

          # Option B: dedicated disk/volume for /tmp
          # <device>  /tmp  <fstype>  defaults,nodev,nosuid,noexec  0  0
          # mount /tmp
        scored: true

      - id: 1.1.2.2
        description: "Ensure nodev option set on /tmp partition (Automated)"
        audit: |
          # First confirm /tmp is mounted
          if findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_mounted"
            # Check that nodev appears in the options list
            if findmnt -kn /tmp | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "tmp_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` so that the `/tmp` entry includes the `nodev` option.

          Example entry:
            <device>  /tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Then remount /tmp to apply the change:
            mount -o remount /tmp
        scored: true

      - id: 1.1.2.3
        description: "Ensure noexec option set on /tmp partition (Automated)"
        audit: |
          # Check if /tmp is mounted
          if findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /tmp | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "tmp_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` so the `/tmp` entry includes `noexec` in the mount options.

          Example:
            <device>  /tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change:
            mount -o remount /tmp
        scored: true

      - id: 1.1.2.4
        description: "Ensure nosuid option set on /tmp partition (Automated)"
        audit: |
          # Check if /tmp is mounted
          if findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /tmp | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "tmp_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/tmp` entry includes the `nosuid` option.

          Example:
            <device>  /tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/tmp`:
            mount -o remount /tmp
        scored: true

      - id: 1.1.3
        description: "Configure /var"
        type: "skip"
        checks:
      - id: 1.1.3.1
        description: "Ensure separate partition exists for /var (Automated)"
        audit: |
          # Check if /var is mounted on a separate partition
          if findmnt -kn /var >/dev/null 2>&1; then
            echo "var_partition_ok"
          else
            echo "var_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_partition_ok"
              set: true
        remediation: |
          For new installations, during setup create a dedicated partition for `/var`.
          For existing systems, create or attach a new volume, format it, and mount it as `/var`.
          Example steps:
            1. Create filesystem on the new device:
               mkfs -t ext4 /dev/<device>
            2. Mount temporarily and copy existing data:
               mount /dev/<device> /mnt
               rsync -avx /var/ /mnt/
               mv /var /var.backup
               umount /mnt
            3. Update `/etc/fstab` with the new entry:
               /dev/<device>  /var  ext4  defaults  0  2
            4. Mount the new partition:
               mount /var
            5. Verify:
               findmnt --kernel /var
          Once confirmed, you can remove `/var.backup` after ensuring successful migration.
        scored: true


      - id: 1.1.3.2
        description: "Ensure nodev option set on /var partition (Automated)"
        audit: |
          # Check if /var is mounted
          if findmnt -kn /var >/dev/null 2>&1; then
            echo "var_mounted"
            # Verify nodev is set
            if findmnt -kn /var | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
            - flag: "var_mounted"
              set: true
        remediation: |
          Edit `/etc/fstab` so that the `/var` entry includes the `nodev` option.

          Example entry:
            <device>  /var  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change:
            mount -o remount /var
        scored: true


      - id: 1.1.3.3
        description: "Ensure nosuid option set on /var partition (Automated)"
        audit: |
          # Check if /var is mounted
          if findmnt -kn /var >/dev/null 2>&1; then
            echo "var_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var` entry includes the `nosuid` option.

          Example entry:
            <device>  /var  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var`:
            mount -o remount /var
        scored: true

      - id: 1.1.4
        description: "Configure /var/tmp"
        type: "skip"
        checks:
      - id: 1.1.4.1
        description: "Ensure separate partition exists for /var/tmp (Automated)"
        audit: |
          # Check if /var/tmp is mounted on a separate partition
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_partition_ok"
          else
            echo "var_tmp_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_tmp_partition_ok"
              set: true
        remediation: |
          For new installations, create a dedicated partition for `/var/tmp` during setup.

          For existing systems:
            1. Create or attach a new volume or logical partition:
               mkfs -t ext4 /dev/<device>

            2. Mount temporarily and copy data:
               mount /dev/<device> /mnt
               rsync -avx /var/tmp/ /mnt/
               mv /var/tmp /var/tmp.backup
               umount /mnt

            3. Update `/etc/fstab` to mount the new partition:
               /dev/<device>  /var/tmp  ext4  defaults,nodev,nosuid,noexec,relatime  0  2

            4. Mount the new partition:
               mount /var/tmp

            5. Verify:
               findmnt --kernel /var/tmp

          After confirming successful migration, remove `/var/tmp.backup`.
        scored: true

      - id: 1.1.4.2
        description: "Ensure noexec option set on /var/tmp partition (Automated)"
        audit: |
          # Check if /var/tmp is mounted
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /var/tmp | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "var_tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/tmp` entry includes the `noexec` option.

          Example entry:
            <device>  /var/tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/tmp`:
            mount -o remount /var/tmp
        scored: true

      - id: 1.1.4.3
        description: "Ensure nosuid option set on /var/tmp partition (Automated)"
        audit: |
          # Check if /var/tmp is mounted
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var/tmp | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/tmp` entry includes the `nosuid` option.

          Example entry:
            <device>  /var/tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/tmp`:
            mount -o remount /var/tmp
        scored: true

      - id: 1.1.4.4
        description: "Ensure nodev option set on /var/tmp partition (Automated)"
        audit: |
          # Check if /var/tmp is mounted
          if findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "var_tmp_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /var/tmp | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/tmp` entry includes the `nodev` option.

          Example entry:
            <device>  /var/tmp  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/tmp`:
            mount -o remount /var/tmp
        scored: true


      - id: 1.1.5
        description: "Configure /var/log"
        type: "skip"
        checks:
      - id: 1.1.5.1
        description: "Ensure separate partition exists for /var/log (Automated)"
        audit: |
          # Check if /var/log is mounted on a separate partition
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_partition_ok"
          else
            echo "var_log_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_log_partition_ok"
              set: true
        remediation: |
          For new installations, create a dedicated partition for `/var/log` during setup.

          For existing systems:
            1. Create or attach a new volume:
               mkfs -t ext4 /dev/<device>

            2. Mount temporarily and copy existing logs:
               mount /dev/<device> /mnt
               rsync -avx /var/log/ /mnt/
               mv /var/log /var/log.backup
               umount /mnt

            3. Update `/etc/fstab` with the new entry:
               /dev/<device>  /var/log  ext4  defaults,nodev,nosuid,noexec,relatime  0  2

            4. Mount the new partition:
               mount /var/log

            5. Verify the mount:
               findmnt --kernel /var/log

          Once confirmed, you may remove `/var/log.backup`.

          ⚠️ Note:
          Before performing changes on `/var/log`, it is recommended to switch the system
          to **emergency mode** (so auditd and other logging daemons are stopped) to avoid
          data loss or corruption during migration.
        scored: true


      - id: 1.1.5.2
        description: "Ensure nodev option set on /var/log partition (Automated)"
        audit: |
          # Check if /var/log is mounted
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /var/log | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log` entry includes the `nodev` option.

          Example entry:
            <device>  /var/log  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log`:
            mount -o remount /var/log
        scored: true


      - id: 1.1.5.3
        description: "Ensure noexec option set on /var/log partition (Automated)"
        audit: |
          # Check if /var/log is mounted
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /var/log | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "var_log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log` entry includes the `noexec` option.

          Example entry:
            <device>  /var/log  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log`:
            mount -o remount /var/log
        scored: true

      - id: 1.1.5.4
        description: "Ensure nosuid option set on /var/log partition (Automated)"
        audit: |
          # Check if /var/log is mounted
          if findmnt -kn /var/log >/dev/null 2>&1; then
            echo "var_log_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var/log | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log` entry includes the `nosuid` option.

          Example entry:
            <device>  /var/log  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log`:
            mount -o remount /var/log
        scored: true


      - id: 1.1.6
        description: "Configure /var/log/audit"
        type: "skip"
        checks:
      - id: 1.1.6.1
        description: "Ensure separate partition exists for /var/log/audit (Automated)"
        audit: |
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_partition_ok"
          else
            echo "var_log_audit_partition_missing"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_partition_ok"
              set: true
        remediation: |
          For new installations, create a dedicated partition for `/var/log/audit` during setup.
          For existing systems:
            1. Create or attach a new volume or partition:
               mkfs -t ext4 /dev/<device>
            2. Mount temporarily and copy existing audit logs:
               mount /dev/<device> /mnt
               rsync -avx /var/log/audit/ /mnt/
               mv /var/log/audit /var/log/audit.backup
               umount /mnt
            3. Update `/etc/fstab` with the new entry:
               /dev/<device>  /var/log/audit  ext4  defaults,nodev,nosuid,noexec,relatime  0  2
            4. Mount the new partition:
               mount /var/log/audit
            5. Verify the mount:
               findmnt --kernel /var/log/audit
          Once confirmed, you may remove `/var/log/audit.backup` after verifying data integrity.
          ⚠️ Note:
          To avoid audit service issues during migration, perform these steps in **single-user** or **emergency mode**
          so `auditd` is stopped and log data is not being written during the copy process.
        scored: true

      - id: 1.1.6.2
        description: "Ensure noexec option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /var/log/audit | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "var_log_audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log/audit` entry includes the `noexec` option.

          Example entry:
            <device>  /var/log/audit  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log/audit`:
            mount -o remount /var/log/audit
        scored: true

      - id: 1.1.6.3
        description: "Ensure nodev option set on /var/log/audit partition (Automated)"
        audit: |
          # Check if /var/log/audit is mounted
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /var/log/audit | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "var_log_audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log/audit` entry includes the `nodev` option.

          Example entry:
            <device>  /var/log/audit  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log/audit`:
            mount -o remount /var/log/audit
        scored: true

      - id: 1.1.6.4
        description: "Ensure nosuid option set on /var/log/audit partition (Automated)"
        audit: |
          # Check if /var/log/audit is mounted
          if findmnt -kn /var/log/audit >/dev/null 2>&1; then
            echo "var_log_audit_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /var/log/audit | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "var_log_audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "var_log_audit_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/var/log/audit` entry includes the `nosuid` option.

          Example entry:
            <device>  /var/log/audit  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/var/log/audit`:
            mount -o remount /var/log/audit
        scored: true

      - id: 1.1.7
        description: "Configure /home"
        type: "skip"
        checks:
      - id: 1.1.7.1
        description: "Ensure separate partition exists for /home (Automated)"
        audit: |
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_mounted"
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "home_mounted"
              set: true
        remediation: |
          Create a dedicated partition (or volume) for `/home` and add an entry in `/etc/fstab`.

          Example `/etc/fstab` entry:
            <device>  /home  <fstype>  defaults,rw,relatime  0  0

          Then mount it (or remount after editing fstab):
            mount /home
        scored: true

      - id: 1.1.7.2
        description: "Ensure nodev option set on /home partition (Automated)"
        audit: |
          # Check if /home is mounted
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /home | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "home_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/home` entry includes the `nodev` option.

          Example entry:
            <device>  /home  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/home`:
            mount -o remount /home
        scored: true

      - id: 1.1.7.3
        description: "Ensure nosuid option set on /home partition (Automated)"
        audit: |
          # Check if /home is mounted
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_mounted"
            # Verify nosuid is present in mount options
            if findmnt -kn /home | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "home_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/home` entry includes the `nosuid` option.

          Example entry:
            <device>  /home  <fstype>  defaults,rw,nosuid,nodev,noexec,relatime  0  0

          Apply the change by remounting `/home`:
            mount -o remount /home
        scored: true

      - id: 1.1.8
        description: "Configure /dev/shm"
        type: "skip"
        checks:
      - id: 1.1.8.1
        description: "Ensure /dev/shm is a separate partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Confirm it's a distinct tmpfs mount (separate partition in RAM)
            if [ "$(findmnt -kn -o FSTYPE /dev/shm)" = "tmpfs" ]; then
              echo "fstype_tmpfs"
            else
              echo "fstype_not_tmpfs"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "fstype_tmpfs"
              set: true
        remediation: |
          Add (or correct) an /etc/fstab entry so /dev/shm is a separate tmpfs mount with appropriate options.
          Example:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Then mount (or remount) it:
            mount /dev/shm || mount -o remount /dev/shm
        scored: true

      - id: 1.1.8.2
        description: "Ensure nodev option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Verify nodev is present in mount options
            if findmnt -kn /dev/shm | grep -qw nodev; then
              echo "nodev_ok"
            else
              echo "nodev_missing"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/dev/shm` entry includes the `nodev` option.

          Example entry:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Apply the change by remounting `/dev/shm`:
            mount -o remount /dev/shm
        scored: true

      - id: 1.1.8.3
        description: "Ensure noexec option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Verify noexec is present in mount options
            if findmnt -kn /dev/shm | grep -qw noexec; then
              echo "noexec_ok"
            else
              echo "noexec_missing"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to ensure the `/dev/shm` entry includes the `noexec` option.

          Example entry:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Apply the change by remounting `/dev/shm`:
            mount -o remount /dev/shm

          NOTE: It is recommended to use `tmpfs` as the filesystem type for `/dev/shm`,
          as it provides shared memory space used by applications.
        scored: true

      - id: 1.1.8.4
        description: "Ensure nosuid option set on /dev/shm partition (Automated)"
        audit: |
          # Is /dev/shm mounted?
          if findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "devshm_mounted"
            # Check for nosuid in mount options
            if findmnt -kn /dev/shm | grep -qw nosuid; then
              echo "nosuid_ok"
            else
              echo "nosuid_missing"
            fi
          else
            echo "devshm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "devshm_mounted"
              set: true
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include `nosuid` for `/dev/shm`.

          Example:
            tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0  0

          Apply the change:
            mount -o remount /dev/shm

          Note: Some distros mount `/dev/shm` outside `/etc/fstab`. If so, add the entry above
          to `/etc/fstab` or adjust the distribution-specific unit/config so `nosuid` is enforced.
        scored: true

      - id: 1.1.9
        description: "Disable USB Storage (Automated)"
        audit: |
          command -v modprobe >/dev/null 2>&1 || { echo "not_applicable"; exit 0; }
          m="usb-storage"
          if modprobe -n -v "$m" 2>&1 | grep -qi 'FATAL: Module .* not found'; then
            echo "usb_module_absent_ok"
            exit 0
          fi
          loadable_override=0
          if modprobe -n -v "$m" 2>/dev/null | grep -Eiq "^[[:space:]]*install[[:space:]]+$m[[:space:]]+/bin/(true|false)"; then
            loadable_override=1
          fi
          bl=0
          if modprobe --showconfig 2>/dev/null | grep -Eiq '^[[:space:]]*blacklist[[:space:]]+(usb-storage|usb_storage)\b'; then
            bl=1
          fi
          loaded=0
          lsmod 2>/dev/null | grep -q '^usb_storage[[:space:]]' && loaded=1

          if [ "$loadable_override" -eq 1 ] && [ "$bl" -eq 1 ] && [ "$loaded" -eq 0 ]; then
            echo "usb_storage_ok"
          else
            echo "usb_storage_bad"
          fi
        tests:
          test_items:
            - bin_op: "or"
              items:
                - flag: "usb_module_absent_ok"
                  set: true
                - flag: "usb_storage_ok"
                  set: true
        remediation: |
          #!/bin/sh
          # Disable usb-storage module: block loading, blacklist, and unload if present

          set -e
          m="usb-storage"
          conf="/etc/modprobe.d/${m}.conf"

          # 1) Prevent loading via install override
          if ! grep -Eiq "^[[:space:]]*install[[:space:]]+$m[[:space:]]+/bin/(true|false)" "$conf" 2>/dev/null; then
            printf '%s\n' "install $m /bin/false" >> "$conf"
          fi

          # 2) Blacklist module (accept runtime name with hyphen)
          if ! grep -Eiq '^[[:space:]]*blacklist[[:space:]]+(usb-storage|usb_storage)\b' "$conf" 2>/dev/null; then
            printf '%s\n' "blacklist $m" >> "$conf"
          fi

          # 3) Unload if currently loaded
          if lsmod 2>/dev/null | grep -q '^usb_storage[[:space:]]'; then
            modprobe -r "$m" || true
          fi

          # 4) (Optional) Regenerate initramfs so settings persist in early boot
          # On RHEL/Rocky/Alma:
          # dracut -f
        scored: true


  - id: 1.2
    description: "Configure Software Updated"
    checks:
      - id: 1.2.1
        description: "Ensure GPG keys are configured (Manual)"
        type: manual
        remediation: |
          Update your package manager GPG keys in accordance with site policy.
        scored: false

      - id: 1.2.2
        description: "Ensure gpgcheck is globally activated (Automated)"
        audit: |
          if awk -v RS='' '/^\[main\]/{print}' /etc/dnf/dnf.conf \
             | grep -Pq '^\s*gpgcheck\s*=\s*1\s*$'; then
            echo "main_ok"
          else
            echo "main_bad"
          fi
          if find /etc/yum.repos.d -type f -name '*.repo' 2>/dev/null \
             | xargs -r grep -PHn --color=never -P '^\s*(?![#;])gpgcheck\s*=\s*[^1]\b' \
             >/dev/null; then
            echo "repos_bad"
          else
            echo "repos_ok"
          fi
        tests:
          test_items:
            - flag: "main_ok"
              set: true
            - flag: "repos_ok"
              set: true
        remediation: |
          # Set global default in /etc/dnf/dnf.conf ([main] section)
          sed -i -r '/^\s*\[main\]\s*$/,/^\s*\[/{s/^\s*gpgcheck\s*=.*/gpgcheck=1/}' /etc/dnf/dnf.conf
          # If gpgcheck not present in [main], add it:
          awk -v RS='' '{
            if ($0 ~ /^\[main\]/ && $0 !~ /\ngpgcheck\s*=/) {
              sub(/\[main\][^\n]*/, "&\n gpgcheck=1")
            } print
          }' /etc/dnf/dnf.conf > /etc/dnf/dnf.conf.tmp && mv /etc/dnf/dnf.conf.tmp /etc/dnf/dnf.conf

          # Enforce gpgcheck=1 in all repo files (overrides global if present)
          find /etc/yum.repos.d -type f -name '*.repo' -print0 2>/dev/null \
            | xargs -0 -r sed -i -r 's/^\s*(gpgcheck)\s*=.*/\1=1/'
        scored: true

      - id: 1.2.3
        description: "Ensure package manager repositories are configured (Manual)"
        audit: "dnf repolist"
        type: "manual"
        remediation: |
          Configure your package manager repositories according to site policy.
          Note: The preferred way to manage the contents of /etc/yum.repos.d/redhat.repo is
          via the use of subscription-manager repos
        scored: false

      - id: 1.2.4
        description: "Ensure repo_gpgcheck is globally activated (Manual)"
        audit: |
          # Check global repo_gpgcheck setting
          grep -Pq '^\s*repo_gpgcheck\s*=\s*1\b' /etc/dnf/dnf.conf && echo "main_ok" || echo "main_bad"

          # Check that no repo file explicitly disables repo_gpgcheck
          if ! grep -Pqs '^\s*(?![#;])repo_gpgcheck\s*=\s*0\b' /etc/yum.repos.d/*.repo 2>/dev/null; then
            echo "repos_ok"
          else
            echo "repos_bad"
          fi
        tests:
          test_items:
            - flag: "main_ok"
              set: true
            - flag: "repos_ok"
              set: true
        remediation: |
          Edit `/etc/dnf/dnf.conf` and ensure the `[main]` section contains:
            repo_gpgcheck=1

          Also verify all files in `/etc/yum.repos.d/*.repo` have:
            repo_gpgcheck=1

          Example fix:
            sed -i 's/^repo_gpgcheck\s*=.*/repo_gpgcheck=1/' /etc/yum.repos.d/*.repo
        scored: false

  - id: 1.3
    description: "Filesystem Integrity Checking"
    checks:
      - id: 1.3.1
        description: "Ensure AIDE is installed (Automated)"
        audit: "rpm -q aide"
        tests:
          test_items:
            - flag: "package aide is not installed"
              set: false
        remediation: |
          Run the following command to install AIDE:
            # dnf install aide
          Configure AIDE as appropriate for your environment. Consult the AIDE documentation
          for options.
          Initialize AIDE:
          Run the following commands:
            # aide --init
            # mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
        scored: true

      - id: 1.3.2
        description: "Ensure filesystem integrity is regularly checked (Automated)"
        audit: |
          if grep -Ers '(^[^#].*\s)?(/usr/s?bin/|^\s*)aide(\.wrapper)?\s(--?\S+\s)*(--(check|update)|\$AIDEARGS)\b' /etc/cron.* /etc/crontab /var/spool/cron/ 2>/dev/null; then
            echo "aide_scheduled"
          elif systemctl is-enabled aidecheck.timer 2>/dev/null | grep -qx enabled \
            && systemctl is-active aidecheck.timer 2>/dev/null | grep -qx active \
            && systemctl is-enabled aidecheck.service 2>/dev/null | grep -Eq '^(enabled|static)$'; then
            echo "aide_scheduled"
          else
            echo "aide_not_scheduled"
          fi
        tests:
          test_items:
            - flag: "aide_not_scheduled"
              set: false
        remediation: |
          Schedule AIDE checks via one of the following:
          Option A — cron (example: daily at 05:00):
            # crontab -u root -e
            0 5 * * * /usr/sbin/aide --check

          Option B — systemd timer:
            # /etc/systemd/system/aidecheck.service
            [Unit]
            Description=Aide Check
            [Service]
            Type=simple
            ExecStart=/usr/sbin/aide --check

            # /etc/systemd/system/aidecheck.timer
            [Unit]
            Description=Aide check every day at 5AM
            [Timer]
            OnCalendar=*-*-* 05:00:00
            Unit=aidecheck.service
            [Install]
            WantedBy=multi-user.target

            chown root:root /etc/systemd/system/aidecheck.*
            chmod 0644 /etc/systemd/system/aidecheck.*
            systemctl daemon-reload
            systemctl enable aidecheck.service
            systemctl --now enable aidecheck.timer
        scored: true

      - id: 1.3.3
        description: "Ensure cryptographic mechanisms are used to protect the integrity of audit tools (Automated)"
        audit: |
          # Check that each audit tool path is listed in AIDE config with a cryptographic hash (sha512)
          CFGS="$(ls /etc/aide.conf.d/*.conf 2>/dev/null) /etc/aide.conf"

          for t in auditctl auditd ausearch aureport autrace augenrules; do
            if grep -H -Pqs "^\s*/(usr/)?sbin/${t}\b.*\bsha512\b" $CFGS; then
              echo "${t}_ok"
            else
              echo "${t}_bad"
            fi
          done
        tests:
          test_items:
            - flag: "auditctl_ok"
              set: true
            - flag: "auditd_ok"
              set: true
            - flag: "ausearch_ok"
              set: true
            - flag: "aureport_ok"
              set: true
            - flag: "autrace_ok"
              set: true
            - flag: "augenrules_ok"
              set: true
        remediation: |
          Add the following AIDE selections to a dedicated config file (e.g. /etc/aide.conf.d/99-audit-tools.conf)
          or directly in /etc/aide.conf to ensure the audit tools are protected with sha512:

            # Audit Tools
            /sbin/auditctl  p+i+n+u+g+s+b+acl+xattrs+sha512
            /sbin/auditd    p+i+n+u+g+s+b+acl+xattrs+sha512
            /sbin/ausearch  p+i+n+u+g+s+b+acl+xattrs+sha512
            /sbin/aureport  p+i+n+u+g+s+b+acl+xattrs+sha512
            /sbin/autrace   p+i+n+u+g+s+b+acl+xattrs+sha512
            /sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512

          Note: On some systems the tools reside under /usr/sbin. If so, use /usr/sbin/<tool> in the paths.

          After updating AIDE configuration, (re)initialize or update the database as per your site policy:
            # aide --init
            # mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
            # or, if appropriate:
            # aide --update
        scored: true


  - id: 1.4
    description: "Secure Boot Settings"
    checks:
      - id: 1.4.1
        description: "Ensure bootloader password is set (Automated)"
        audit: |
          awk -F. '/^\s*GRUB2_PASSWORD/ {print $1"."$2"."$3}' /boot/grub2/user.cfg
        tests:
          test_items:
            - flag: "GRUB2_PASSWORD"
              compare:
                op: eq
                value: "grub.pbkdf2.sha512"
        remediation: |
          Create an encrypted password with grub2-setpassword:
            # grub2-setpassword
          Enter password: <password>
          Confirm password: <password>
        scored: true

      - id: 1.4.2
        description: "Ensure permissions on bootloader config are configured (Automated)"
        audit: |
          # Check grub.cfg
          if [ -e /boot/grub2/grub.cfg ]; then
            if stat -Lc "%a %u %g" /boot/grub2/grub.cfg | grep -Eq '^0?700 0 0$'; then
              echo "grub_cfg_ok"
            else
              echo "grub_cfg_bad"
            fi
          fi

          # Check grubenv
          if [ -e /boot/grub2/grubenv ]; then
            if stat -Lc "%a %u %g" /boot/grub2/grubenv | grep -Eq '^0?600 0 0$'; then
              echo "grub_env_ok"
            else
              echo "grub_env_bad"
            fi
          fi

          # Check user.cfg
          if [ -e /boot/grub2/user.cfg ]; then
            if stat -Lc "%a %u %g" /boot/grub2/user.cfg | grep -Eq '^0?600 0 0$'; then
              echo "user_cfg_ok"
            else
              echo "user_cfg_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "grub_cfg_ok"
              set: true
            - flag: "grub_env_ok"
              set: true
            - flag: "user_cfg_ok"
              set: true
        remediation: |
          Set the correct ownership and permissions on GRUB2 configuration files:

          grub.cfg:
            chown root:root /boot/grub2/grub.cfg
            chmod 700 /boot/grub2/grub.cfg

          grubenv:
            chown root:root /boot/grub2/grubenv
            chmod 600 /boot/grub2/grubenv

          user.cfg:
            chown root:root /boot/grub2/user.cfg
            chmod 600 /boot/grub2/user.cfg

          Reboot the system if required to apply the updated GRUB permissions.
        scored: true


  - id: 1.5
    description: "Additional Process Hardening"
    checks:
      - id: 1.5.1.1
        description: "Ensure core dump storage is disabled (Automated)"
        audit: 'grep -Ei ''^[[:space:]]*Storage[[:space:]]*=[[:space:]]*none[[:space:]]*$'' /etc/systemd/coredump.conf'
        tests:
          test_items:
            - flag: "Storage"
              compare:
                op: eq
                value: "none"
        remediation: |
          Edit /etc/systemd/coredump.conf and edit or add the following line:
            Storage=none
        scored: true

      - id: 1.5.2
        description: "Ensure core dump backtraces are disabled (Automated)"
        audit: |
          # Check if ProcessSizeMax is explicitly set to 0 in /etc/systemd/coredump.conf
          if grep -Piq '^\s*ProcessSizeMax\s*=\s*0\b' /etc/systemd/coredump.conf; then
            echo "ProcessSizeMax_0_ok"
          else
            echo "ProcessSizeMax_not_0"
          fi
        tests:
          test_items:
            - flag: "ProcessSizeMax_0_ok"
              set: true
        remediation: |
          Edit `/etc/systemd/coredump.conf` and ensure the following line is present
          (create the file if it does not exist):

            ProcessSizeMax=0

          Then reload the systemd configuration to apply changes:
            systemctl daemon-reexec
            systemctl daemon-reload

          This prevents applications from generating core dumps, reducing the
          risk of exposing sensitive information.
        scored: true


      - id: 1.5.3
        description: "Ensure address space layout randomization (ASLR) is enabled (Automated)"
        audit: |
          if [ "$(sysctl -n kernel.randomize_va_space 2>/dev/null)" = "2" ]; then
            echo "runtime_ok"
          else
            echo "runtime_bad"
          fi
          CFGS="/etc/sysctl.conf /run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf"
          if grep -RPsq '^\s*kernel\.randomize_va_space\s*=\s*2\b' $CFGS 2>/dev/null; then
            echo "persistent_ok"
          else
            echo "persistent_bad"
          fi
          if grep -RPs '^\s*kernel\.randomize_va_space\s*=' $CFGS 2>/dev/null | grep -Pv '=\s*2\b' >/dev/null; then
            echo "conflicts_found"
          else
            echo "no_conflicts"
          fi
        tests:
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "persistent_ok"
              set: true
            - flag: "no_conflicts"
              set: true
        remediation: |
          Set ASLR to 2 and make it persistent:

            # echo 'kernel.randomize_va_space = 2' > /etc/sysctl.d/60-kernel_sysctl.conf
            # sysctl -w kernel.randomize_va_space=2
            # sysctl --system

          If any other config file sets a different value for kernel.randomize_va_space,
          comment or remove those lines so only "= 2" remains.
        scored: true


  - id: 1.6
    description: "Mandatory Access Control"
    checks:
      - id: 1.6.1
        description: "Configure SELinux"
        type: "skip"
        checks:
      - id: 1.6.1.1
        description: "Ensure SELinux is installed (Automated)"
        audit: "rpm -q libselinux"
        tests:
          test_items:
            - flag: "package libselinux is not installed"
              set: false
        remediation: |
          Run the following command to install SELinux:
            # dnf install libselinux
        scored: true

      - id: 1.6.1.2
        description: "Ensure SELinux is not disabled in bootloader configuration (Automated)"
        audit: "grubby --info=ALL | grep -Po '(selinux|enforcing)=0\b'"
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to remove the selinux=0 and enforcing=0 parameters:
            grubby --update-kernel ALL --remove-args "selinux=0 enforcing=0"
            Run the following command to remove the selinux=0 and enforcing=0 parameters if
          they were created by the deprecated grub2-mkconfig command:
          # grep -Prsq --
            '\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b'
            /boot/grub2 /boot/efi && grub2-mkconfig -o "$(grep -Prl --
            '\h*([^#\n\r]+\h+)?kerne
        scored: true

      - id: 1.6.1.3
        description: "Ensure SELinux policy is configured (Automated)"
        audit: |
          # Verify SELINUXTYPE in configuration file
          if grep -Eq '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config; then
            echo "selinuxtype_config_ok"
          else
            echo "selinuxtype_config_bad"
          fi

          # Verify loaded policy in current runtime status
          if sestatus 2>/dev/null | grep -Eq 'Loaded policy name:\s+(targeted|mls)\b'; then
            echo "selinuxtype_runtime_ok"
          else
            echo "selinuxtype_runtime_bad"
          fi
        tests:
          test_items:
            - flag: "selinuxtype_config_ok"
              set: true
            - flag: "selinuxtype_runtime_ok"
              set: true
        remediation: |
          Edit `/etc/selinux/config` and ensure the `SELINUXTYPE` parameter is set to one of:
            SELINUXTYPE=targeted
            # or, if required by your site policy:
            SELINUXTYPE=mls

          Apply changes immediately (requires reboot or relabeling):
            touch /.autorelabel
            reboot
        scored: true

      - id: 1.6.1.4
        description: "Ensure the SELinux mode is not disabled (Automated)"
        audit: |
          # Runtime mode must be Enforcing or Permissive (not Disabled)
          if getenforce 2>/dev/null | grep -Eq '^(Enforcing|Permissive)\b'; then
            echo "selinux_runtime_ok"
          else
            echo "selinux_runtime_bad"
          fi

          # Configured mode must be enforcing or permissive (not disabled)
          if grep -Eq '^\s*SELINUX=(enforcing|permissive)\b' /etc/selinux/config; then
            echo "selinux_config_ok"
          else
            echo "selinux_config_bad"
          fi
        tests:
          test_items:
            - flag: "selinux_runtime_ok"
              set: true
            - flag: "selinux_config_ok"
              set: true
        remediation: |
          Set SELinux to Enforcing (recommended) or Permissive (not Disabled).

          Temporarily set runtime mode:
            # Enforcing
            setenforce 1
            # OR Permissive
            setenforce 0

          Persist across reboots by editing /etc/selinux/config:
            # For Enforcing
            SELINUX=enforcing
            # OR for Permissive
            SELINUX=permissive

          If SELinux had been Disabled previously, enable labeling then reboot:
            touch /.autorelabel
            reboot
        scored: true

      - id: 1.6.1.5
        description: "Ensure the SELinux mode is enforcing (Automated)"
        audit: |
          # Runtime enforcement check
          if getenforce 2>/dev/null | grep -Eq '^Enforcing$'; then
            echo "selinux_runtime_enforcing"
          else
            echo "selinux_runtime_not_enforcing"
          fi

          # Config file enforcement check
          if grep -Eq '^\s*SELINUX=enforcing\b' /etc/selinux/config; then
            echo "selinux_config_enforcing"
          else
            echo "selinux_config_not_enforcing"
          fi
        tests:
          test_items:
            - flag: "selinux_runtime_enforcing"
              set: true
            - flag: "selinux_config_enforcing"
              set: true
        remediation: |
          Set SELinux to enforcing mode both at runtime and persistently:

          Temporarily set runtime mode:
            setenforce 1

          Make the change persistent by editing `/etc/selinux/config`:
            SELINUX=enforcing

          Reboot the system to ensure full enforcement takes effect.
        scored: true

      - id: 1.6.1.6
        description: "Ensure no unconfined services exist (Automated)"
        audit: "ps -eZ | grep unconfined_service_t"
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Investigate any unconfined processes found during the audit action. They may need to
          have an existing security context assigned to them or a policy built for them.
        scored: true

      - id: 1.6.1.7
        description: "Ensure SETroubleshoot is not installed (Automated)"
        audit: "rpm -q setroubleshoot"
        tests:
          test_items:
            - flag: "package setroubleshoot is not installed"
              set: true
        remediation: |
          Run the following command to uninstall setroubleshoot:
            # dnf remove setroubleshoot
        scored: true

      - id: 1.6.1.8
        description: "Ensure the MCS Translation Service (mcstrans) is not installed (Automated)"
        audit: "rpm -q mcstrans"
        tests:
          test_items:
            - flag: "package mcstrans is not installed"
              set: true
        remediation: |
          Run the following command to uninstall mcstrans:
            # dnf remove mcstrans
        scored: true

  - id: 1.7
    description: "Command Line Warning Banners"
    checks:
      - id: 1.7.1
        description: "Ensure message of the day is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/motd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/motd file with the appropriate contents according to your site policy,
          remove any instances of \m , \r , \s , \v or references to the OS platform
          OR
          If the motd is not used, this file can be removed.
          Run the following command to remove the motd file:
            # rm /etc/motd
        scored: true


      - id: 1.7.2
        description: "Ensure local login warning banner is configured properly (Automated)"
        audit: |
          # Display current banner content
          echo "Current /etc/issue contents:"
          cat /etc/issue 2>/dev/null || echo "/etc/issue not found"

          # Check that the banner does not disclose OS or kernel details
          if grep -E -i '(\\v|\\r|\\m|\\s|$(grep "^ID=" /etc/os-release | cut -d= -f2 | sed -e "s/\"//g"))' /etc/issue >/dev/null 2>&1; then
            echo "os_info_present"
          else
            echo "banner_ok"
          fi
        tests:
          test_items:
            - flag: "os_info_present"
              set: false
        remediation: |
          Edit `/etc/issue` to display an approved warning banner that does **not**
          contain system information such as OS name, version, or release identifiers.

          Example compliant banner:
            Authorized uses only. All activity may be monitored and reported.

          To set this banner:
            echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue
        scored: true

      - id: 1.7.3
        description: "Ensure remote login warning banner is configured properly (Automated)"
        audit: |
          # Display current remote login banner
          echo "Current /etc/issue.net contents:"
          cat /etc/issue.net 2>/dev/null || echo "/etc/issue.net not found"

          # Check that /etc/issue.net does not include OS or kernel details
          if grep -E -i '(\\v|\\r|\\m|\\s|$(grep "^ID=" /etc/os-release | cut -d= -f2 | sed -e "s/\"//g"))' /etc/issue.net >/dev/null 2>&1; then
            echo "os_info_present"
          else
            echo "banner_ok"
          fi
        tests:
          test_items:
            - flag: "os_info_present"
              set: false
        remediation: |
          Edit `/etc/issue.net` to display an approved remote login warning banner that does **not**
          contain system information such as OS name, version, or release identifiers.

          Example compliant banner:
            Authorized uses only. All activity may be monitored and reported.

          To set this banner:
            echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue.net
        scored: true


      - id: 1.7.4
        description: "Ensure access to /etc/motd is configured (Automated)"
        audit: |
          if [ -e /etc/motd ]; then
            perms=$(stat -Lc '%a' /etc/motd)
            owner=$(stat -Lc '%u' /etc/motd)
            group=$(stat -Lc '%g' /etc/motd)
            if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "motd_access_ok"
            else
              echo "motd_access_bad"
            fi
          else
            echo "motd_not_exist"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "motd_access_ok"
              set: true
            - flag: "motd_not_exist"
              set: true
        remediation: |
          # If /etc/motd exists, set owner and permissions
          if [ -e /etc/motd ]; then
            chown root:root /etc/motd
            chmod u-x,go-wx /etc/motd
          fi

          # Alternatively, remove /etc/motd if not required
          # rm /etc/motd
        scored: true

      - id: 1.7.5
        description: "Ensure access to /etc/issue is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue)
          owner=$(stat -Lc '%u' /etc/issue)
          group=$(stat -Lc '%g' /etc/issue)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_access_ok"
          else
            echo "issue_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue
          chown root:root /etc/issue
          chmod u-x,go-wx /etc/issue
        scored: true

      - id: 1.7.6
        description: "Ensure access to /etc/issue.net is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue.net)
          owner=$(stat -Lc '%u' /etc/issue.net)
          group=$(stat -Lc '%g' /etc/issue.net)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_net_access_ok"
          else
            echo "issue_net_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_net_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue.net
          chown root:root /etc/issue.net
          chmod u-x,go-wx /etc/issue.net
        scored: true

  - id: 1.8
    description: "GNOME Display Manager"
    checks:
      - id: 1.8.1
        description: "Ensure GNOME Display Manager is removed (Automated)"
        audit: "rpm -q gdm"
        tests:
          test_items:
            - flag: "package gdm is not installed"
              set: true
        remediation: |
          Run the following command to remove the gdm package
            # dnf remove gdm
        scored: true

      - id: 1.8.2
        description: "Ensure GDM login banner is configured (Automated)"
        audit: |
          #!/bin/sh
          if rpm -q gdm >/dev/null 2>&1; then
            if grep -Pirqs '^[[:space:]]*\[org/gnome/login-screen\]' /etc/dconf/db/*.d \
               && grep -Pirqs '^[[:space:]]*banner-message-enable[[:space:]]*=[[:space:]]*true\b' /etc/dconf/db/*.d \
               && grep -Pirqs '^[[:space:]]*banner-message-text[[:space:]]*=[[:space:]]*.+\S' /etc/dconf/db/*.d; then
              echo "gdm_banner_ok"
            else
              echo "gdm_banner_bad"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          test_items:
            - bin_op: "or"
              items:
                - flag: "gdm_banner_ok"
                  set: true
                - flag: "not_applicable"
                  set: true
        remediation: |
          If GDM is installed, ensure the banner is enabled and has text via dconf:

            # Choose a profile name (e.g., gdm)
            prof="gdm"
            msg="Authorized uses only. All activity may be monitored and reported."

            # Ensure dconf profile and directory exist
            [ -f "/etc/dconf/profile/$prof" ] || \
              printf "user-db:user\nsystem-db:%s\nfile-db:/usr/share/%s/greeter-dconf-defaults\n" "$prof" "$prof" > "/etc/dconf/profile/$prof"
            [ -d "/etc/dconf/db/$prof.d" ] || mkdir -p "/etc/dconf/db/$prof.d"

            # Configure banner keys
            keyfile="/etc/dconf/db/$prof.d/01-banner-message"
            grep -q '^\s*\[org/gnome/login-screen\]' "$keyfile" 2>/dev/null || echo "[org/gnome/login-screen]" >> "$keyfile"
            sed -ri '/^\s*banner-message-enable\s*=/d' "$keyfile" 2>/dev/null || true
            sed -ri '/^\s*banner-message-text\s*=/d' "$keyfile" 2>/dev/null || true
            echo "banner-message-enable=true" >> "$keyfile"
            printf "banner-message-text='%s'\n" "$msg" >> "$keyfile"

            # Apply settings
            dconf update

          If GDM is not used on this system, this control is Not Applicable.
        scored: true

      - id: 1.8.3
        description: "Ensure GDM disable-user-list option is enabled (Automated)"
        audit: |
          # If GDM isn't installed, this control is Not Applicable
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Require the key to be set to true under any dconf keyfile for the login screen
            if grep -Pirqs '^\s*\[org/gnome/login-screen\]' /etc/dconf/db/*.d \
               && grep -Pirqs '^\s*disable-user-list\s*=\s*true\b' /etc/dconf/db/*.d; then
              echo "gdm_disable_user_list_ok"
            else
              echo "gdm_disable_user_list_bad"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_disable_user_list_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, enable the “disable-user-list” option via system-wide dconf:

            prof="gdm"
            [ -f "/etc/dconf/profile/$prof" ] || \
              printf "user-db:user\nsystem-db:%s\nfile-db:/usr/share/%s/greeter-dconf-defaults\n" "$prof" "$prof" > "/etc/dconf/profile/$prof"
            [ -d "/etc/dconf/db/$prof.d" ] || mkdir -p "/etc/dconf/db/$prof.d"

            keyfile="/etc/dconf/db/$prof.d/00-login-screen"
            grep -q '^\s*\[org/gnome/login-screen\]' "$keyfile" 2>/dev/null || echo "[org/gnome/login-screen]" >> "$keyfile"
            sed -ri '/^\s*disable-user-list\s*=/d' "$keyfile" 2>/dev/null || true
            echo "disable-user-list=true" >> "$keyfile"

            dconf update

          If GNOME Display Manager is not used on this system, this control is Not Applicable.
        scored: true

      - id: 1.8.4
        description: "Ensure GDM screen locks when the user is idle (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            if grep -RPsq '^\s*idle-delay\s*=\s*uint32\s*(9[0-9]{2}|[1-8][0-9]{2}|[1-9][0-9]|[1-9])\b' /etc/dconf/db/*/*.d 2>/dev/null \
              && grep -RPsq '^\s*lock-delay\s*=\s*uint32\s*([0-5])\b' /etc/dconf/db/*/*.d 2>/dev/null; then
              echo "screenlock_ok"
            else
              echo "screenlock_bad"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "screenlock_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, configure automatic lock on idle:

            prof="local"
            mkdir -p /etc/dconf/db/${prof}.d
            cat > /etc/dconf/db/${prof}.d/00-screensaver << EOF
            [org/gnome/desktop/session]
            idle-delay=uint32 900

            [org/gnome/desktop/screensaver]
            lock-delay=uint32 5
            EOF

            echo -e "user-db:user\nsystem-db:${prof}" > /etc/dconf/profile/${prof}
            dconf update

          Users must log out and back in for settings to apply.
        scored: true

      - id: 1.8.5
        description: "Ensure GDM screen locks cannot be overridden (Automated)"
        audit: |
          # Skip check if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Verify locks exist for idle-delay and lock-delay in any dconf db locks directory
            if grep -Rqs '/org/gnome/desktop/session/idle-delay' /etc/dconf/db/*/locks 2>/dev/null \
              && grep -Rqs '/org/gnome/desktop/screensaver/lock-delay' /etc/dconf/db/*/locks 2>/dev/null; then
              echo "gdm_locks_ok"
            else
              echo "gdm_locks_missing"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_locks_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, ensure screen lock settings cannot be overridden:

            # Determine your dconf profile (example uses 'local')
            prof="local"
            lockdir="/etc/dconf/db/${prof}.d/locks"
            mkdir -p "$lockdir"

            cat > "${lockdir}/00-screensaver-locks" << 'EOF'
            # Lock desktop screensaver idle and lock delay settings
            /org/gnome/desktop/session/idle-delay
            /org/gnome/desktop/screensaver/lock-delay
            EOF

            # Apply changes
            dconf update

          Users must log out and back in for settings to apply.
          If GNOME Display Manager is not used, this recommendation is Not Applicable.
        scored: true

      - id: 1.8.6
        description: "Ensure GDM automatic mounting of removable media is disabled (Automated)"
        audit: |
          # If GNOME Display Manager isn't installed, mark Not Applicable
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Both settings must be set to false in any system dconf db
            if grep -Rqs '^\s*automount\s*=\s*false\b' /etc/dconf/db/*.d 2>/dev/null \
               && grep -Rqs '^\s*automount-open\s*=\s*false\b' /etc/dconf/db/*.d 2>/dev/null; then
              echo "gdm_automount_disabled"
            else
              echo "gdm_automount_enabled"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_automount_disabled"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          If GDM is installed, set these dconf keys system-wide (example uses profile 'local'):
            prof="local"
            kfile="/etc/dconf/db/${prof}.d/00-media-automount"
            mkdir -p "$(dirname "$kfile")"
            {
              echo '[org/gnome/desktop/media-handling]'
              echo 'automount=false'
              echo 'automount-open=false'
            } > "$kfile"
            dconf update
          Users must log out and back in for settings to apply. If GNOME is not used, this control is Not Applicable.
        scored: true

      - id: 1.8.7
        description: "Ensure GDM disabling automatic mounting of removable media is not overridden (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Both keys must be locked in any system dconf db "locks" file
            if grep -Rqs '^\s*/org/gnome/desktop/media-handling/automount\s*$' /etc/dconf/db/*/locks 2>/dev/null \
               && grep -Rqs '^\s*/org/gnome/desktop/media-handling/automount-open\s*$' /etc/dconf/db/*/locks 2>/dev/null; then
              echo "gdm_automount_locked"
            else
              echo "gdm_automount_not_locked"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_automount_locked"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Replace 'local' with your chosen dconf profile name if needed
          prof="local"
          lockdir="/etc/dconf/db/${prof}.d/locks"
          mkdir -p "$lockdir"
          {
            echo "# Lock automount settings"
            echo "/org/gnome/desktop/media-handling/automount"
            echo "/org/gnome/desktop/media-handling/automount-open"
          } > "${lockdir}/00-media-automount"
          dconf update
          # Users must log out/in for settings to take effect.
        scored: true

      - id: 1.8.8
        description: "Ensure GDM autorun-never is enabled (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # autorun-never must be set to true in any system dconf db keyfile
            if grep -Rqs '^\s*autorun-never\s*=\s*true\b' /etc/dconf/db/*.d 2>/dev/null; then
              echo "gdm_autorun_never_true"
            else
              echo "gdm_autorun_never_false"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "gdm_autorun_never_true"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Choose/confirm your dconf profile name (use 'local' or the one already in use)
          prof="local"
          keyfile="/etc/dconf/db/${prof}.d/00-media-autorun"
          mkdir -p "/etc/dconf/db/${prof}.d"

          # Ensure the section exists and autorun-never=true is set
          if ! grep -Pq '^\s*\[org/gnome/desktop/media-handling\]\s*$' "$keyfile" 2>/dev/null; then
            echo "[org/gnome/desktop/media-handling]" >> "$keyfile"
          fi
          if grep -Pq '^\s*autorun-never\s*=' "$keyfile" 2>/dev/null; then
            sed -ri 's/^\s*(autorun-never)\s*=.*/\1=true/' "$keyfile"
          else
            echo "autorun-never=true" >> "$keyfile"
          fi

          # Ensure a profile file points at this DB
          if ! grep -Pq "^\s*system-db:${prof}\b" /etc/dconf/profile/* 2>/dev/null; then
            printf "user-db:user\nsystem-db:%s\n" "$prof" >> /etc/dconf/profile/user
          fi

          # Apply
          dconf update
          # Users must log out/in for settings to take effect.
        scored: true

      - id: 1.8.9
        description: "Ensure GDM autorun-never is not overridden (Automated)"
        audit: |
          # Pass if GDM isn't installed
          if rpm -q gdm >/dev/null 2>&1 || rpm -q gdm3 >/dev/null 2>&1; then
            # Pass when the autorun-never key is locked in any system dconf profile
            if grep -Rqs '^\s*/org/gnome/desktop/media-handling/autorun-never\s*$' /etc/dconf/db/*/locks 2>/dev/null; then
              echo "autorun_never_locked"
            else
              echo "autorun_never_not_locked"
            fi
          else
            echo "not_applicable"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "autorun_never_locked"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          # Find the dconf profile that defines autorun-never (from 1.8.8), default to 'local'
          prof="$(grep -Prsl '^\s*autorun-never\s*=' /etc/dconf/db/*.d 2>/dev/null | awk -F/ '{split($(NF-1),a,".");print a[1]}' | head -n1)"
          [ -n "$prof" ] || prof="local"

          # Ensure profile stanza exists
          [ -f /etc/dconf/profile/user ] || printf "user-db:user\nsystem-db:%s\n" "$prof" > /etc/dconf/profile/user
          grep -Pq "^\s*system-db:${prof}\b" /etc/dconf/profile/* || printf "system-db:%s\n" "$prof" >> /etc/dconf/profile/user

          # Lock the key
          mkdir -p "/etc/dconf/db/${prof}.d/locks"
          lockfile="/etc/dconf/db/${prof}.d/locks/00-media-autorun"
          grep -Pq '^\s*/org/gnome/desktop/media-handling/autorun-never\s*$' "$lockfile" 2>/dev/null || \
            echo "/org/gnome/desktop/media-handling/autorun-never" >> "$lockfile"

          # Apply changes (users must log out/in)
          dconf update
        scored: true

      - id: 1.8.10
        description: "Ensure XDCMP is not enabled (Automated)"
        audit: |
          grep -Eis '^\s*Enable\s*=\s*true' /etc/gdm/custom.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the file /etc/gdm/custom.conf and remove the line:
            Enable=true
        scored: true

      - id: 1.9
        description: "Ensure updates, patches, and additional security software are installed (Manual)"
        type: "manual"
        remediation: |
          Use your package manager to update all packages on the system according to site
            policy.
          The following command will install all available updates:
          # dnf update
            Once the update process is complete, verify if reboot is required to load changes.
            dnf needs-restarting -r
        scored: false

      - id: 1.10
        description: "Ensure system-wide crypto policy is not legacy (Automated)"
        audit: |
          grep -E -i '^\s*LEGACY\s*(\s+#.*)?$' /etc/crypto-policies/config
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change the system-wide crypto policy
            # update-crypto-policies --set <CRYPTO POLICY>
            Example:
            # update-crypto-policies --set DEFAULT
              Run the following to make the updated system-wide crypto policy active
            # update-crypto-policies
        scored: true

  - id: 2
    description: "Services"
  - id: 2.1
    description: "Time Synchronization"
    checks:
      - id: 2.1.1
        description: "Ensure time synchronization is in use (Automated)"
        audit: "rpm -q chrony"
        tests:
          test_items:
            - flag: "package chrony is not installed"
              set: false
        remediation: |
          Run the following command to install chrony:

          # dnf install chrony
        scored: true

      - id: 2.1.2
        description: "Ensure chrony is configured (Automated)"
        audit: |
          #!/bin/sh
          # Pass if chrony is installed AND:
          #  (a) /etc/chrony.conf has at least one uncommented 'server' or 'pool' line
          #  (b) /etc/sysconfig/chronyd includes '-u chrony'
          # Otherwise, fail. If chrony not installed -> not_applicable.

          # Is chrony installed?
          if ! rpm -q chrony >/dev/null 2>&1; then
            echo "not_applicable"
            exit 0
          fi

          # Check time sources
          if grep -Eqs '^[[:space:]]*(server|pool)[[:space:]]+' /etc/chrony.conf 2>/dev/null; then
            src_ok=1
          else
            src_ok=0
          fi

          # Check daemon user option
          if [ -f /etc/sysconfig/chronyd ] && grep -Eq '^[[:space:]]*OPTIONS=.*-u[[:space:]]*chrony\b' /etc/sysconfig/chronyd; then
            user_ok=1
          else
            user_ok=0
          fi

          # Single combined success flag for tests
          if [ "$src_ok" -eq 1 ] && [ "$user_ok" -eq 1 ]; then
            echo "chrony_ok"
          else
            echo "chrony_bad"
          fi
        tests:
          bin_op: "or"
          test_items:
            - flag: "chrony_ok"
              set: true
            - flag: "not_applicable"
              set: true
        remediation: |
          #!/bin/sh
          # Install and configure chrony with sources and run as 'chrony' user

          # Install chrony if missing
          if ! rpm -q chrony >/dev/null 2>&1; then
            if command -v dnf >/dev/null 2>&1; then dnf -y install chrony; else yum -y install chrony; fi
          fi

          # Ensure at least one time source exists (replace with your own servers/pools)
          if ! grep -Eqs '^[[:space:]]*(server|pool)[[:space:]]+' /etc/chrony.conf 2>/dev/null; then
            printf '%s\n' 'pool pool.ntp.org iburst' >> /etc/chrony.conf
          fi

          # Ensure chronyd runs as the 'chrony' user
          if [ -f /etc/sysconfig/chronyd ]; then
            if grep -Eq '^[[:space:]]*OPTIONS=' /etc/sysconfig/chronyd; then
              sed -ri 's/^[[:space:]]*OPTIONS=.*/OPTIONS="-u chrony"/' /etc/sysconfig/chronyd
            else
              printf '%s\n' 'OPTIONS="-u chrony"' >> /etc/sysconfig/chronyd
            fi
          else
            printf '%s\n' 'OPTIONS="-u chrony"' > /etc/sysconfig/chronyd
          fi

          # Enable and restart service
          systemctl enable chronyd --now 2>/dev/null || true
          systemctl restart chronyd 2>/dev/null || true
        scored: true

  - id: 2.2
    description: "Special Purpose Services"
    checks:
      - id: 2.2.1
        description: "Ensure xorg-x11-server-common is not installed (Automated)"
        audit: |
          rpm -q xorg-x11-server-common
        tests:
          test_items:
            - flag: "package xorg-x11-server-common is not installed"
        remediation: |
          Run the following command to remove the X Windows Server packages:
          # dnf remove xorg-x11-server-common
        scored: true

      - id: 2.2.2
        description: "Ensure avahi daemon services is not installed (Automated)"
        audit: |
          rpm -q avahi
        tests:
          test_items:
            - flag: "package avahi is not installed"
              set: true
        remediation: |
          Run the following commands to stop, mask and remove avahi:
          # systemctl stop avahi-daemon.socket avahi-daemon.service
          # dnf remove avahi
        scored: true

      - id: 2.2.3
        description: "Ensure CUPS is not installed (Automated)"
        audit: |
          rpm -q cups
        tests:
          test_items:
            - flag: "package cups is not installed"
              set: true
        remediation: |
          Run the following command to remove cups:
            # dnf remove cups
        scored: true

      - id: 2.2.4
        description: "Ensure DHCP Server is not installed (Automated)"
        audit: |
          rpm -q dhcp-server
        tests:
          test_items:
            - flag: "package dhcp-server is not installed"
              set: true
        remediation: |
          Run the following command to remove dhcp:
          # dnf remove dhcp-server
        scored: true

      - id: 2.2.5
        description: "Ensure dns server is not installed (Automated)"
        audit: |
          rpm -q bind
        tests:
          test_items:
            - flag: "package bind is not installed"
              set: true
        remediation: |
          Run the following command to remove bind:
          # dnf remove bind
        scored: true

      - id: 2.2.6
        description: "Ensure VSFTP Server is not installed (Automated)"
        audit: |
          rpm -q vsftpd
        tests:
          test_items:
            - flag: "package vsftpd is not installed"
              set: true
        remediation: |
          Run the following command to remove vsftpd:
          # dnf remove vsftpd
        scored: true

      - id: 2.2.7
        description: "Ensure TFTP Server is not installed (Automated)"
        audit: |
          rpm -q tftp-server
        tests:
          test_items:
            - flag: "package tftp-server is not installed"
              set: true
        remediation: |
          Run the following command to remove tftp-server:
          # dnf remove tftp-server
        scored: true

      - id: 2.2.8
        description: "Ensure a web server is not installed  (Automated)"
        audit: |
          rpm -q httpd nginx
        tests:
          test_items:
            - flag: "package httpd is not installed"
              set: true
            - flag: "package nginx is not installed"
              set: true
        remediation: |
          Run the following command to remove httpd and nginx:
          # dnf remove httpd nginx
        scored: true

      - id: 2.2.9
        description: "Ensure IMAP and POP3 server is not installed (Automated)"
        audit: |
          rpm -q dovecot cyrus-imapd
        tests:
          test_items:
            - flag: "package dovecot is not installed"
              set: true
            - flag: "package cyrus-imapd is not installed"
              set: true
        remediation: |
          Run the following command to remove dovecot and cyrus-imapd:
          # dnf remove dovecot cyrus-imapd
        scored: true

      - id: 2.2.10
        description: "Ensure Samba is not installed (Automated)"
        audit: |
          rpm -q samba
        tests:
          test_items:
            - flag: "package samba is not installed"
              set: true
        remediation: |
          Run the following command to remove samba:
          # dnf remove samba
        scored: true

      - id: 2.2.11
        description: "Ensure HTTP Proxy Server is not installed (Automated)"
        audit: |
          rpm -q squid
        tests:
          test_items:
            - flag: "package squid is not installed"
              set: true
        remediation: |
          Run the following command to remove the squid package:
          # dnf remove squid
        scored: true

      - id: 2.2.12
        description: "Ensure net-snmp is not installed (Automated)"
        audit: "rpm -q net-snmp"
        tests:
          test_items:
            - flag: "package net-snmp is not installed"
              set: true
        remediation: |
          Run the following command to remove net-snmpd:
            # dnf remove net-snmp
        scored: true

      - id: 2.2.13
        description: "Ensure telnet-server is not installed (Automated)"
        audit: "rpm -q telnet-server"
        tests:
          test_items:
            - flag: "package telnet-server is not installed"
              set: true
        remediation: |
          Run the following command to remove the telnet-server package:
            # dnf remove telnet-server
        scored: true

      - id: 2.2.14
        description: "Ensure dnsmasq is not installed (Automated)"
        audit: "rpm -q dnsmasq"
        tests:
          test_items:
            - flag: "package dnsmasq is not installed"
              set: true
        remediation: |
          Run the following command to remove dnsmasq:
          # dnf remove dnsmasq
        scored: true

      - id: 2.2.15
        description: "Ensure mail transfer agent is configured for local-only mode (Automated)"
        audit: |
          ss -lntu | grep -E ':25\s' | grep -E -v '\s(127.0.0.1|\[?::1\]?):25\s'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/postfix/main.cf and add the following line to the RECEIVING MAIL section.
          If the line already exists, change it to look like the line below:
          inet_interfaces = loopback-only
          Run the following command to restart postfix:
            # systemctl restart postfix
        scored: true

      - id: 2.2.16
        description: "Ensure nfs-utils is not installed or the nfs-server service is masked (Automated)"
        audit: |
          # Check if nfs-utils is installed
          if rpm -q nfs-utils >/dev/null 2>&1; then
            # If installed, check if nfs-server service is masked
            if systemctl is-enabled nfs-server 2>/dev/null | grep -q '^masked$'; then
              echo "nfs_server_masked"
            else
              echo "nfs_server_not_masked"
            fi
          else
            echo "nfs_utils_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nfs_utils_not_installed"
              set: true
            - flag: "nfs_server_masked"
              set: true
        remediation: |
          # Remove nfs-utils package if not required
          if rpm -q nfs-utils >/dev/null 2>&1; then
            # Check if nfs-utils is required by libvirt or another dependency
            if rpm -q --whatrequires nfs-utils | grep -q 'libvirt'; then
              # Mask nfs-server if nfs-utils is required as a dependency
              systemctl --now mask nfs-server
            else
              # Otherwise, remove nfs-utils entirely
              dnf remove -y nfs-utils
            fi
          fi
        scored: true

      - id: 2.2.17
        description: "Ensure rpcbind is not installed or the rpcbind services are masked (Automated)"
        audit: |
          # Check if rpcbind is installed
          if rpm -q rpcbind >/dev/null 2>&1; then
            # If installed, both the service and socket must be masked
            svc_state="$(systemctl is-enabled rpcbind 2>/dev/null || true)"
            sock_state="$(systemctl is-enabled rpcbind.socket 2>/dev/null || true)"

            if [ "$svc_state" = "masked" ] && [ "$sock_state" = "masked" ]; then
              echo "rpcbind_both_masked"
            else
              echo "rpcbind_not_fully_masked"
            fi
          else
            echo "rpcbind_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rpcbind_not_installed"
              set: true
            - flag: "rpcbind_both_masked"
              set: true
        remediation: |
          # If rpcbind is not required, remove it
          if rpm -q rpcbind >/dev/null 2>&1; then
            # If rpcbind is needed as a dependency (e.g., by libvirt or nfs-utils), prefer masking
            if rpm -q --whatrequires rpcbind 2>/dev/null | grep -Eq '.+'; then
              # Stop now and mask both units
              systemctl --now mask rpcbind.service
              systemctl --now mask rpcbind.socket
            else
              # Safe to remove the package
              dnf remove -y rpcbind
            fi
          fi
        scored: true

      - id: 2.2.18
        description: "Ensure rsync-daemon is not installed or the rsyncd service is masked (Automated)"
        audit: |
          # Check if rsync-daemon is installed
          if rpm -q rsync-daemon >/dev/null 2>&1; then
            # If installed, rsyncd service must be masked
            state="$(systemctl is-enabled rsyncd 2>/dev/null || true)"
            if [ "$state" = "masked" ]; then
              echo "rsyncd_masked"
            else
              echo "rsyncd_not_masked"
            fi
          else
            echo "rsync_daemon_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rsync_daemon_not_installed"
              set: true
            - flag: "rsyncd_masked"
              set: true
        remediation: |
          # If rsync-daemon is present, either remove it or mask rsyncd
          if rpm -q rsync-daemon >/dev/null 2>&1; then
            # If other packages require rsync-daemon, keep it but harden by masking rsyncd
            if rpm -q --whatrequires rsync-daemon 2>/dev/null | grep -q .; then
              systemctl --now mask rsyncd
            else
              dnf remove -y rsync-daemon
            fi
          fi
        scored: true


  - id: 2.3
    description: "Service Clients"
    checks:
      - id: 2.3.1
        description: "Ensure telnet client is not installed (Automated)"
        audit: "rpm -q telnet"
        tests:
          test_items:
            - flag: "package telnet is not installed"
              set: true
        remediation: |
          Run the following command to remove telnet:

          # dnf remove telnet
        scored: true

      - id: 2.3.2
        description: "Ensure LDAP client is not installed (Automated)"
        audit: "rpm -q openldap-clients"
        tests:
          test_items:
            - flag: "package openldap-clients is not installed"
              set: true
        remediation: |
          Run the following command to remove openldap-clients:

          # dnf remove openldap-clients
        scored: true

      - id: 2.3.3
        description: "Ensure TFTP client is not installed (Automated)"
        audit: "rpm -q tftp"
        tests:
          test_items:
            - flag: "package tftp is not installed"
              set: true
        remediation: |
          Run the following command to remove tftp:

          # dnf remove tftp
        scored: true

      - id: 2.3.4
        description: "Ensure FTP client is not installed (Automated)"
        audit: "rpm -q ftp"
        tests:
          test_items:
            - flag: "package ftp is not installed"
              set: true
        remediation: |
          Run the following command to remove ftp:

          # dnf remove ftp
        scored: true
      - id: 2.4
        description: "Ensure nonessential services listening on the system are removed or masked (Manual)"
        audit: "ss -plntu"
        remediation: |
          Run the following command to remove the package containing the service:
            # dnf remove <package_name>
          OR If required packages have a dependency:
          Run the following commands to stop and mask the service:
            # systemctl stop <service_name>.socket
            # systemctl stop <service_name>.service
            # systemctl mask <service_name>.socket
            # systemctl mask <service_name>.service
        scored: false

  - id: 3
    description: "Network Configuration"
  - id: 3.1
    description: "Disable unused network protocols and devices"
    checks:
      - id: 3.1.1
        description: "Ensure IPv6 status is identified (Manual)"
        audit: |
          grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable && echo -e "\n - IPv6 is enabled\n" || echo -e "\n - IPv6 is not enabled\n"
        tests:
          test_items:
            - flag: "- IPv6 is enabled"
        remediation: |
          Enable or disable IPv6 in accordance with system requirements and local site policy
        scored: false

      - id: 3.1.2
        description: "Ensure wireless interfaces are disabled (Automated)"
        audit: |
          # Detect wireless NIC driver modules and verify they are disabled
          any_bad=0
          found=0

          # Find wireless interfaces by presence of a 'wireless' directory under /sys/class/net/*/
          mapfile -t drivers < <(
            find /sys/class/net/*/ -maxdepth 1 -type d -name wireless 2>/dev/null \
              -printf '%h\n' | xargs -r -I{} readlink -f "{}/device/driver/module" \
              | xargs -r -n1 basename | sort -u
          )

          if [ ${#drivers[@]} -eq 0 ]; then
            echo "no_wireless_nics"
            exit 0
          fi

          found=1
          for m in "${drivers[@]}"; do
            # 1) Not loadable via modprobe (install /bin/false or /bin/true)
            if modprobe -n -v "$m" 2>/dev/null | grep -Eq '^\s*install\s+/bin/(true|false)\b'; then
              echo "mod_${m}_not_loadable"
            else
              echo "mod_${m}_loadable"
              any_bad=1
            fi

            # 2) Not currently loaded
            if lsmod | awk '{print $1}' | grep -qx "$m"; then
              echo "mod_${m}_loaded"
              any_bad=1
            else
              echo "mod_${m}_not_loaded"
            fi

            # 3) Blacklisted (deny-listed)
            if modprobe --showconfig 2>/dev/null | grep -Eq "^\s*blacklist\s+${m}\b"; then
              echo "mod_${m}_blacklisted"
            else
              echo "mod_${m}_not_blacklisted"
              any_bad=1
            fi
          done

          if [ "$any_bad" -eq 0 ] && [ "$found" -eq 1 ]; then
            echo "all_wireless_modules_disabled"
          else
            echo "wireless_modules_not_fully_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "no_wireless_nics"
              set: true
            - flag: "all_wireless_modules_disabled"
              set: true
        remediation: |
          # Disable detected wireless NIC driver modules:
          #  - make them un-loadable via modprobe ("install <mod> /bin/false")
          #  - unload if currently loaded
          #  - blacklist them to prevent autoload
          mapfile -t drivers < <(
            find /sys/class/net/*/ -maxdepth 1 -type d -name wireless 2>/dev/null \
              -printf '%h\n' | xargs -r -I{} readlink -f "{}/device/driver/module" \
              | xargs -r -n1 basename | sort -u
          )

          for m in "${drivers[@]}"; do
            conf="/etc/modprobe.d/${m}.conf"

            # Ensure not loadable via modprobe
            if ! modprobe -n -v "$m" 2>/dev/null | grep -Eq '^\s*install\s+/bin/(true|false)\b'; then
              echo "install $m /bin/false" >> "$conf"
            fi

            # Unload if currently loaded
            if lsmod | awk '{print $1}' | grep -qx "$m"; then
              modprobe -r "$m" 2>/dev/null || true
            fi

            # Blacklist (deny-list) the module
            if ! grep -Eq "^\s*blacklist\s+${m}\b" /etc/modprobe.d/*.conf 2>/dev/null; then
              echo "blacklist $m" >> "$conf"
            fi
          done
        scored: true
      - id: 3.1.3
        description: "Ensure TIPC is disabled (Automated)"
        audit: |
          # Verify the Transparent Inter-Process Communication (TIPC) kernel module is disabled
          m="tipc"

          # Detect if module exists on this system
          if modinfo "$m" >/dev/null 2>&1; then
            exists=1
          else
            echo "tipc_module_absent"
            exit 0
          fi

          bad=0

          # 1) Should NOT be loadable (install /bin/false or /bin/true)
          load_rule="$(modprobe -n -v "$m" 2>/dev/null)"
          if printf '%s\n' "$load_rule" | grep -Eq '^[[:space:]]*install[[:space:]]+/bin/(true|false)([[:space:]]|$)'; then
            echo "tipc_not_loadable"
          else
            echo "tipc_loadable"
            bad=1
          fi

          # 2) Should NOT be currently loaded
          if lsmod | awk '{print $1}' | grep -qx "$m"; then
            echo "tipc_loaded"
            bad=1
          else
            echo "tipc_not_loaded"
          fi

          # 3) Should be deny-listed (blacklisted)
          if modprobe --showconfig 2>/dev/null | grep -Eq '^[[:space:]]*blacklist[[:space:]]+tipc([[:space:]]|$)'; then
            echo "tipc_blacklisted"
          else
            echo "tipc_not_blacklisted"
            bad=1
          fi

          if [ "$bad" -eq 0 ]; then
            echo "tipc_fully_disabled"
          else
            echo "tipc_not_fully_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "tipc_module_absent"
              set: true
            - flag: "tipc_fully_disabled"
              set: true
        remediation: |
          # Disable the TIPC kernel module
          m="tipc"
          conf="/etc/modprobe.d/${m}.conf"

          # If module exists, enforce not loadable, unload if loaded, and blacklist it
          if modinfo "$m" >/dev/null 2>&1; then
            # Ensure not loadable via modprobe
            if ! modprobe -n -v "$m" 2>/dev/null | grep -Eq '^[[:space:]]*install[[:space:]]+/bin/(true|false)([[:space:]]|$)'; then
              echo "install $m /bin/false" >> "$conf"
            fi

            # Unload if currently loaded
            if lsmod | awk '{print $1}' | grep -qx "$m"; then
              modprobe -r "$m" 2>/dev/null || true
            fi

            # Blacklist the module to prevent autoloading
            if ! grep -Eq '^[[:space:]]*blacklist[[:space:]]+tipc([[:space:]]|$)' /etc/modprobe.d/*.conf 2>/dev/null; then
              echo "blacklist $m" >> "$conf"
            fi
          else
            echo "Nothing to remediate: module '$m' not present on this system."
          fi
        scored: true


  - id: 3.2
    description: "Network Parameters (Host Only)"
    checks:
      - id: 3.2.1
        description: "Ensure IP forwarding is disabled (Automated)"
        audit: |
          bad=0

          # IPv4 runtime must be 0
          sysctl -n net.ipv4.ip_forward 2>/dev/null | grep -qx 0 || bad=1

          # IPv4 persistent must explicitly set to 0 somewhere; and nowhere to non-zero
          conf_globs="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"
          grep -HrsE '^[[:space:]]*net\.ipv4\.ip_forward[[:space:]]*=[[:space:]]*0([[:space:]]*$|[[:space:]]*#)' $conf_globs 2>/dev/null >/dev/null || bad=1
          grep -HrsE '^[[:space:]]*net\.ipv4\.ip_forward[[:space:]]*=[[:space:]]*[1-9]' $conf_globs 2>/dev/null >/dev/null && bad=1

          # IPv6 enabled?
          ipv6_on=0
          if [ -r /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable; then
            ipv6_on=1
          fi

          if [ "$ipv6_on" -eq 1 ]; then
            # IPv6 runtime must be 0
            sysctl -n net.ipv6.conf.all.forwarding 2>/dev/null | grep -qx 0 || bad=1
            # IPv6 persistent must explicitly set to 0 somewhere; and nowhere to non-zero
            grep -HrsE '^[[:space:]]*net\.ipv6\.conf\.all\.forwarding[[:space:]]*=[[:space:]]*0([[:space:]]*$|[[:space:]]*#)' $conf_globs 2>/dev/null >/dev/null || bad=1
            grep -HrsE '^[[:space:]]*net\.ipv6\.conf\.all\.forwarding[[:space:]]*=[[:space:]]*[1-9]' $conf_globs 2>/dev/null >/dev/null && bad=1
          fi

          if [ "$bad" -eq 0 ]; then
            echo "ip_forwarding_ok"
          else
            echo "ip_forwarding_bad"
          fi
        tests:
          test_items:
            - flag: "ip_forwarding_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Persistently disable IP forwarding and apply at runtime

          # IPv4
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true
          if ! grep -Eq '^[[:space:]]*net\.ipv4\.ip_forward[[:space:]]*=' /etc/sysctl.d/60-netipv4_sysctl.conf; then
            printf "net.ipv4.ip_forward = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          else
            sed -ri 's/^[[:space:]]*net\.ipv4\.ip_forward[[:space:]]*=.*/net.ipv4.ip_forward = 0/' /etc/sysctl.d/60-netipv4_sysctl.conf
          fi
          sysctl -w net.ipv4.ip_forward=0
          sysctl -w net.ipv4.route.flush=1

          # IPv6 (only if enabled)
          if [ -r /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable; then
            install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || true
            if ! grep -Eq '^[[:space:]]*net\.ipv6\.conf\.all\.forwarding[[:space:]]*=' /etc/sysctl.d/60-netipv6_sysctl.conf; then
              printf "net.ipv6.conf.all.forwarding = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf
            else
              sed -ri 's/^[[:space:]]*net\.ipv6\.conf\.all\.forwarding[[:space:]]*=.*/net.ipv6.conf.all.forwarding = 0/' /etc/sysctl.d/60-netipv6_sysctl.conf
            fi
            sysctl -w net.ipv6.conf.all.forwarding=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true

      - id: 3.2.2
        description: "Ensure packet redirect sending is disabled (Automated)"
        audit: |
          # Verify both:
          #   net.ipv4.conf.all.send_redirects = 0
          #   net.ipv4.conf.default.send_redirects = 0
          # …and ensure no persistent files set them to non-zero.
          set -euo pipefail
          ok=1

          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check_param() {
            local key="$1" want="0"
            # Runtime value must be 0
            sysctl -n "$key" 2>/dev/null | grep -qx "$want" || ok=0
            # No file may set a non-zero value
            grep -Hrs "^\s*${key}\s*=\s*[1-9]" $searchloc 2>/dev/null && ok=0
            # At least one file should set it to 0 (for persistence)
            grep -Hrs "^\s*${key}\s*=\s*${want}\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          check_param "net.ipv4.conf.all.send_redirects"
          check_param "net.ipv4.conf.default.send_redirects"

          if [ "$ok" -eq 1 ]; then
            echo "send_redirects_all_and_default_disabled"
          else
            echo "send_redirects_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "send_redirects_all_and_default_disabled"
              set: true
        remediation: |
          # Persist settings and apply at runtime
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true
          grep -Pqs '^\s*net\.ipv4\.conf\.all\.send_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.all.send_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          grep -Pqs '^\s*net\.ipv4\.conf\.default\.send_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.default.send_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.conf.all.send_redirects=0
          sysctl -w net.ipv4.conf.default.send_redirects=0
          sysctl -w net.ipv4.route.flush=1
        scored: true

  - id: 3.3
    description: "Network Parameters (Host and Router)"
    checks:
      - id: 3.3.1
        description: "Ensure source routed packets are not accepted (Automated)"
        audit: |
          # Verify:
          #  - net.ipv4.conf.all.accept_source_route = 0
          #  - net.ipv4.conf.default.accept_source_route = 0
          #  - If IPv6 enabled:
          #      net.ipv6.conf.all.accept_source_route = 0
          #      net.ipv6.conf.default.accept_source_route = 0
          set -euo pipefail
          ok=1
          ipv6_on=$([ -f /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable && echo 1 || echo 0)
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check() {
            local key="$1"
            # runtime must be 0
            sysctl -n "$key" 2>/dev/null | grep -qx 0 || ok=0
            # no persistent file may set non-zero
            grep -Hrs "^\s*${key}\s*=\s*[1-9]" $searchloc 2>/dev/null && ok=0
            # at least one file should set it to 0 persistently
            grep -Hrs "^\s*${key}\s*=\s*0\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          # IPv4
          check "net.ipv4.conf.all.accept_source_route"
          check "net.ipv4.conf.default.accept_source_route"

          # IPv6 (only if enabled)
          if [ "$ipv6_on" -eq 1 ]; then
            check "net.ipv6.conf.all.accept_source_route"
            check "net.ipv6.conf.default.accept_source_route"
          fi

          if [ "$ok" -eq 1 ]; then
            [ "$ipv6_on" -eq 1 ] && echo "srcroute_ipv4_and_ipv6_compliant" || echo "srcroute_ipv4_only_compliant"
          else
            echo "srcroute_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "srcroute_ipv4_only_compliant"
              set: true
            - flag: "srcroute_ipv4_and_ipv6_compliant"
              set: true
        remediation: |
          # Persist settings and apply at runtime

          # IPv4
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true
          grep -Pqs '^\s*net\.ipv4\.conf\.all\.accept_source_route\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.all.accept_source_route = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          grep -Pqs '^\s*net\.ipv4\.conf\.default\.accept_source_route\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.default.accept_source_route = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.conf.all.accept_source_route=0
          sysctl -w net.ipv4.conf.default.accept_source_route=0
          sysctl -w net.ipv4.route.flush=1

          # IPv6 (only if enabled)
          if [ -f /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable; then
            install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || true
            grep -Pqs '^\s*net\.ipv6\.conf\.all\.accept_source_route\s*=\s*0\b' /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || \
              printf "net.ipv6.conf.all.accept_source_route = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf
            grep -Pqs '^\s*net\.ipv6\.conf\.default\.accept_source_route\s*=\s*0\b' /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || \
              printf "net.ipv6.conf.default.accept_source_route = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf

            sysctl -w net.ipv6.conf.all.accept_source_route=0
            sysctl -w net.ipv6.conf.default.accept_source_route=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true


      - id: 3.3.2
        description: "Ensure ICMP redirects are not accepted (Automated)"
        audit: |
          # Verify:
          #  - net.ipv4.conf.all.accept_redirects = 0
          #  - net.ipv4.conf.default.accept_redirects = 0
          #  - If IPv6 is enabled:
          #      net.ipv6.conf.all.accept_redirects = 0
          #      net.ipv6.conf.default.accept_redirects = 0
          set -euo pipefail
          ok=1
          ipv6_on=$([ -f /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable && echo 1 || echo 0)
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check() {
            local key="$1"
            # Runtime must be 0
            sysctl -n "$key" 2>/dev/null | grep -qx 0 || ok=0
            # No persistent file may set non-zero
            grep -Hrs "^\s*${key}\s*=\s*[1-9]" $searchloc 2>/dev/null && ok=0
            # At least one file should set it to 0 persistently
            grep -Hrs "^\s*${key}\s*=\s*0\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          # IPv4
          check "net.ipv4.conf.all.accept_redirects"
          check "net.ipv4.conf.default.accept_redirects"

          # IPv6 (only if enabled)
          if [ "$ipv6_on" -eq 1 ]; then
            check "net.ipv6.conf.all.accept_redirects"
            check "net.ipv6.conf.default.accept_redirects"
          fi

          if [ "$ok" -eq 1 ]; then
            [ "$ipv6_on" -eq 1 ] && echo "accept_redirects_ipv4_and_ipv6_compliant" || echo "accept_redirects_ipv4_only_compliant"
          else
            echo "accept_redirects_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "accept_redirects_ipv4_only_compliant"
              set: true
            - flag: "accept_redirects_ipv4_and_ipv6_compliant"
              set: true
        remediation: |
          # Persist settings and apply at runtime

          # IPv4
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true
          grep -Pqs '^\s*net\.ipv4\.conf\.all\.accept_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.all.accept_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          grep -Pqs '^\s*net\.ipv4\.conf\.default\.accept_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.default.accept_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.conf.all.accept_redirects=0
          sysctl -w net.ipv4.conf.default.accept_redirects=0
          sysctl -w net.ipv4.route.flush=1

          # IPv6 (only if enabled)
          if [ -f /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable; then
            install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || true
            grep -Pqs '^\s*net\.ipv6\.conf\.all\.accept_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || \
              printf "net.ipv6.conf.all.accept_redirects = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf
            grep -Pqs '^\s*net\.ipv6\.conf\.default\.accept_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || \
              printf "net.ipv6.conf.default.accept_redirects = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf

            sysctl -w net.ipv6.conf.all.accept_redirects=0
            sysctl -w net.ipv6.conf.default.accept_redirects=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true


      - id: 3.3.3
        description: "Ensure secure ICMP redirects are not accepted (Automated)"
        audit: |
          # Verify:
          #  - net.ipv4.conf.all.secure_redirects = 0
          #  - net.ipv4.conf.default.secure_redirects = 0
          set -euo pipefail
          ok=1
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check() {
            local key="$1"
            # Runtime value must be 0
            sysctl -n "$key" 2>/dev/null | grep -qx 0 || ok=0
            # No persistent file may set it to non-zero
            grep -Hrs "^\s*${key}\s*=\s*[1-9]" $searchloc 2>/dev/null && ok=0
            # At least one file must set it to 0 persistently
            grep -Hrs "^\s*${key}\s*=\s*0\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          check "net.ipv4.conf.all.secure_redirects"
          check "net.ipv4.conf.default.secure_redirects"

          if [ "$ok" -eq 1 ]; then
            echo "secure_redirects_compliant"
          else
            echo "secure_redirects_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "secure_redirects_compliant"
              set: true
        remediation: |
          # Persist settings and apply at runtime

          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true

          grep -Pqs '^\s*net\.ipv4\.conf\.all\.secure_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.all.secure_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          grep -Pqs '^\s*net\.ipv4\.conf\.default\.secure_redirects\s*=\s*0\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.default.secure_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.conf.all.secure_redirects=0
          sysctl -w net.ipv4.conf.default.secure_redirects=0
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.4
        description: "Ensure suspicious packets are logged (Automated)"
        audit: |
          # Verify:
          #  - net.ipv4.conf.all.log_martians = 1
          #  - net.ipv4.conf.default.log_martians = 1
          set -euo pipefail
          ok=1
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check() {
            local key="$1"
            # Runtime must be 1
            sysctl -n "$key" 2>/dev/null | grep -qx 1 || ok=0
            # No persistent file may set a value other than 1
            if grep -Hrs "^\s*${key}\s*=" $searchloc 2>/dev/null | grep -Pv "^\s*${key}\s*=\s*1\b" >/dev/null; then
              ok=0
            fi
            # At least one file should set it to 1 persistently
            grep -Hrs "^\s*${key}\s*=\s*1\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          check "net.ipv4.conf.all.log_martians"
          check "net.ipv4.conf.default.log_martians"

          if [ "$ok" -eq 1 ]; then
            echo "log_martians_compliant"
          else
            echo "log_martians_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "log_martians_compliant"
              set: true
        remediation: |
          # Persist settings and apply at runtime

          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true

          grep -Pqs '^\s*net\.ipv4\.conf\.all\.log_martians\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.all.log_martians = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          grep -Pqs '^\s*net\.ipv4\.conf\.default\.log_martians\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.default.log_martians = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.conf.all.log_martians=1
          sysctl -w net.ipv4.conf.default.log_martians=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.5
        description: "Ensure broadcast ICMP requests are ignored (Automated)"
        audit: |
          # Verify net.ipv4.icmp_echo_ignore_broadcasts = 1 (runtime and persistent)
          set -euo pipefail
          ok=1
          key="net.ipv4.icmp_echo_ignore_broadcasts"
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          # Runtime must be 1
          sysctl -n "$key" 2>/dev/null | grep -qx 1 || ok=0
          # No persistent file may set a value other than 1
          if grep -Hrs "^\s*${key}\s*=" $searchloc 2>/dev/null | grep -Pv "^\s*${key}\s*=\s*1\b" >/dev/null; then
            ok=0
          fi
          # At least one persistent file should set it to 1
          grep -Hrs "^\s*${key}\s*=\s*1\b" $searchloc 2>/dev/null >/dev/null || ok=0

          if [ "$ok" -eq 1 ]; then
            echo "icmp_broadcasts_ignored_compliant"
          else
            echo "icmp_broadcasts_ignored_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "icmp_broadcasts_ignored_compliant"
              set: true
        remediation: |
          # Persist setting and apply at runtime
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true

          grep -Pqs '^\s*net\.ipv4\.icmp_echo_ignore_broadcasts\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.icmp_echo_ignore_broadcasts = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.6
        description: "Ensure bogus ICMP responses are ignored (Automated)"
        audit: |
          # Verify net.ipv4.icmp_ignore_bogus_error_responses = 1 (runtime and persistent)
          set -euo pipefail
          ok=1
          key="net.ipv4.icmp_ignore_bogus_error_responses"
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          # Runtime must be 1
          sysctl -n "$key" 2>/dev/null | grep -qx 1 || ok=0
          # No persistent file may set a value other than 1
          if grep -Hrs "^\s*${key}\s*=" $searchloc 2>/dev/null | grep -Pv "^\s*${key}\s*=\s*1\b" >/dev/null; then
            ok=0
          fi
          # At least one persistent file should set it to 1
          grep -Hrs "^\s*${key}\s*=\s*1\b" $searchloc 2>/dev/null >/dev/null || ok=0

          if [ "$ok" -eq 1 ]; then
            echo "icmp_bogus_responses_ignored_compliant"
          else
            echo "icmp_bogus_responses_ignored_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "icmp_bogus_responses_ignored_compliant"
              set: true
        remediation: |
          # Persist setting and apply at runtime
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true

          grep -Pqs '^\s*net\.ipv4\.icmp_ignore_bogus_error_responses\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.icmp_ignore_bogus_error_responses = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.7
        description: "Ensure Reverse Path Filtering is enabled (Automated)"
        audit: |
          # Verify:
          #  - net.ipv4.conf.all.rp_filter = 1
          #  - net.ipv4.conf.default.rp_filter = 1
          set -euo pipefail
          ok=1
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check() {
            local key="$1"
            # Runtime must be exactly 1 (strict mode)
            sysctl -n "$key" 2>/dev/null | grep -qx 1 || ok=0
            # No persistent file may set a value other than 1
            if grep -Hrs "^\s*${key}\s*=" $searchloc 2>/dev/null | grep -Pv "^\s*${key}\s*=\s*1\b" >/dev/null; then
              ok=0
            fi
            # At least one persistent file should set it to 1
            grep -Hrs "^\s*${key}\s*=\s*1\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          check "net.ipv4.conf.all.rp_filter"
          check "net.ipv4.conf.default.rp_filter"

          if [ "$ok" -eq 1 ]; then
            echo "rp_filter_compliant"
          else
            echo "rp_filter_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rp_filter_compliant"
              set: true
        remediation: |
          # Persist settings and apply at runtime

          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true

          grep -Pqs '^\s*net\.ipv4\.conf\.all\.rp_filter\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.all.rp_filter = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          grep -Pqs '^\s*net\.ipv4\.conf\.default\.rp_filter\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.conf.default.rp_filter = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.conf.all.rp_filter=1
          sysctl -w net.ipv4.conf.default.rp_filter=1
          sysctl -w net.ipv4.route.flush=1
        scored: true


      - id: 3.3.8
        description: "Ensure TCP SYN Cookies is enabled (Automated)"
        audit: |
          # Verify net.ipv4.tcp_syncookies = 1 (runtime and persistent)
          set -euo pipefail
          ok=1
          key="net.ipv4.tcp_syncookies"
          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          # Runtime must be 1
          sysctl -n "$key" 2>/dev/null | grep -qx 1 || ok=0
          # No persistent file may set a value other than 1
          if grep -Hrs "^\s*${key}\s*=" $searchloc 2>/dev/null | grep -Pv "^\s*${key}\s*=\s*1\b" >/dev/null; then
            ok=0
          fi
          # At least one persistent file should set it to 1
          grep -Hrs "^\s*${key}\s*=\s*1\b" $searchloc 2>/dev/null >/dev/null || ok=0

          if [ "$ok" -eq 1 ]; then
            echo "tcp_syncookies_compliant"
          else
            echo "tcp_syncookies_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "tcp_syncookies_compliant"
              set: true
        remediation: |
          # Persist setting and apply at runtime
          install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || true

          grep -Pqs '^\s*net\.ipv4\.tcp_syncookies\s*=\s*1\b' /etc/sysctl.d/60-netipv4_sysctl.conf 2>/dev/null || \
            printf "net.ipv4.tcp_syncookies = 1\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          sysctl -w net.ipv4.tcp_syncookies=1
          sysctl -w net.ipv4.route.flush=1
        scored: true


      - id: 3.3.9
        description: "Ensure IPv6 router advertisements are not accepted (Automated)"
        audit: |
          # Verify (only if IPv6 is enabled):
          #  - net.ipv6.conf.all.accept_ra = 0
          #  - net.ipv6.conf.default.accept_ra = 0
          set -euo pipefail
          ok=1
          # Detect IPv6 status: 0 = enabled, 1 = disabled
          if [ -f /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable; then
            ipv6_on=1
          else
            ipv6_on=0
          fi

          if [ "$ipv6_on" -eq 0 ]; then
            echo "ipv6_not_enabled_not_applicable"
            exit 0
          fi

          searchloc="/run/sysctl.d/*.conf /etc/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /etc/sysctl.conf"

          check() {
            local key="$1"
            # Runtime must be 0
            sysctl -n "$key" 2>/dev/null | grep -qx 0 || ok=0
            # No persistent file may set non-zero
            grep -Hrs "^\s*${key}\s*=\s*[1-9]" $searchloc 2>/dev/null && ok=0
            # At least one file should set to 0 persistently
            grep -Hrs "^\s*${key}\s*=\s*0\b" $searchloc 2>/dev/null >/dev/null || ok=0
          }

          check "net.ipv6.conf.all.accept_ra"
          check "net.ipv6.conf.default.accept_ra"

          if [ "$ok" -eq 1 ]; then
            echo "ipv6_ra_reject_compliant"
          else
            echo "ipv6_ra_reject_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ipv6_not_enabled_not_applicable"
              set: true
            - flag: "ipv6_ra_reject_compliant"
              set: true
        remediation: |
          # Apply only if IPv6 is enabled
          if [ -f /sys/module/ipv6/parameters/disable ] && grep -q '^[[:space:]]*0\b' /sys/module/ipv6/parameters/disable; then
            install -m 0644 -D /dev/null /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || true

            grep -Pqs '^\s*net\.ipv6\.conf\.all\.accept_ra\s*=\s*0\b' /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || \
              printf "net.ipv6.conf.all.accept_ra = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf

            grep -Pqs '^\s*net\.ipv6\.conf\.default\.accept_ra\s*=\s*0\b' /etc/sysctl.d/60-netipv6_sysctl.conf 2>/dev/null || \
              printf "net.ipv6.conf.default.accept_ra = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf

            sysctl -w net.ipv6.conf.all.accept_ra=0
            sysctl -w net.ipv6.conf.default.accept_ra=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true


  - id: 3.4
    description: "Configure Host Based Firewall"
    checks:
      - id: 3.4.1
        description: "Configure a firewall utility"
        type: "skip"
        checks:
      - id: 3.4.1.1
        description: "Ensure nftables is installed (Automated)"
        audit: "rpm -q nftables"
        tests:
          test_items:
            - flag: "package nftables is not installed"
              set: false
        remediation: |
          Run the following command to install nftables

          # dnf install nftables
        scored: true

      - id: 3.4.1.2
        description: "Ensure a single firewall configuration utility is in use (Automated)"
        audit: |
          # Pass if EXACTLY ONE of these is true:
          #  - firewalld is enabled+active AND nftables is (masked|disabled|not installed) and inactive
          #  - nftables is enabled+active AND firewalld is (masked|disabled|not installed) and inactive
          set -euo pipefail

          # Package presence
          fwd_installed=$([ rpm -q firewalld >/dev/null 2>&1 ] && echo 1 || echo 0)
          nft_installed=$([ rpm -q nftables  >/dev/null 2>&1 ] && echo 1 || echo 0)

          # Unit states (fallback to 'na' when unit doesn't exist)
          fwd_enabled="$(systemctl is-enabled firewalld 2>/dev/null || echo na)"
          fwd_active="$(systemctl is-active  firewalld 2>/dev/null || echo na)"
          nft_enabled="$(systemctl is-enabled nftables  2>/dev/null || echo na)"
          nft_active="$(systemctl is-active  nftables  2>/dev/null || echo na)"

          # Helpers
          is_off_like() { case "$1" in disabled|masked|na) return 0;; *) return 1;; esac; }

          if [ "$fwd_enabled" = "enabled" ] && [ "$fwd_active" = "active" ] && \
             { [ "$nft_installed" -eq 0 ] || { is_off_like "$nft_enabled" && [ "$nft_active" = "inactive" ]; }; }; then
            echo "single_firewalld_in_use"
          elif [ "$nft_enabled" = "enabled" ] && [ "$nft_active" = "active" ] && \
               { [ "$fwd_installed" -eq 0 ] || { is_off_like "$fwd_enabled" && [ "$fwd_active" = "inactive" ]; }; }; then
            echo "single_nftables_in_use"
          else
            # Helpful fail classifications (not used in tests)
            if [ "$fwd_active" = "active" ] && [ "$nft_active" = "active" ]; then
              echo "both_active"
            elif [ "$fwd_installed" -eq 0 ] && [ "$nft_installed" -eq 0 ]; then
              echo "neither_installed"
            else
              echo "ambiguous_or_misconfigured"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "single_firewalld_in_use"
              set: true
            - flag: "single_nftables_in_use"
              set: true
        remediation: |
          # Choose ONE firewall utility and suppress the other.
          # Preference: nftables (modern) unless firewalld is already active.

          fwd_installed=$([ rpm -q firewalld >/dev/null 2>&1 ] && echo 1 || echo 0)
          nft_installed=$([ rpm -q nftables  >/dev/null 2>&1 ] && echo 1 || echo 0)

          fwd_enabled="$(systemctl is-enabled firewalld 2>/dev/null || echo na)"
          fwd_active="$(systemctl is-active  firewalld 2>/dev/null || echo na)"
          nft_enabled="$(systemctl is-enabled nftables  2>/dev/null || echo na)"
          nft_active="$(systemctl is-active  nftables  2>/dev/null || echo na)"

          if [ "$fwd_active" = "active" ] && [ "$nft_active" = "active" ]; then
            # Both active → keep the one already enabled and mask the other
            if [ "$fwd_enabled" = "enabled" ] && [ "$nft_enabled" != "enabled" ]; then
              systemctl stop nftables
              systemctl --now mask nftables
            elif [ "$nft_enabled" = "enabled" ] && [ "$fwd_enabled" != "enabled" ]; then
              systemctl stop firewalld
              systemctl --now mask firewalld
            else
              # Default: keep firewalld, mask nftables
              systemctl stop nftables
              systemctl --now mask nftables
            fi
          elif [ "$fwd_enabled" = "enabled" ] && [ "$fwd_active" = "active" ]; then
            # Firewalld already in use → ensure nftables is suppressed
            systemctl stop nftables 2>/dev/null || true
            systemctl --now mask nftables 2>/dev/null || true
          elif [ "$nft_enabled" = "enabled" ] && [ "$nft_active" = "active" ]; then
            # Nftables already in use → ensure firewalld is suppressed
            systemctl stop firewalld 2>/dev/null || true
            systemctl --now mask firewalld 2>/dev/null || true
          else
            # Neither in use or ambiguous → standardize on nftables
            if [ "$nft_installed" -eq 0 ]; then
              dnf -q -y install nftables
            fi
            systemctl unmask nftables 2>/dev/null || true
            systemctl enable --now nftables
            if [ "$fwd_installed" -eq 1 ]; then
              systemctl stop firewalld 2>/dev/null || true
              systemctl --now mask firewalld 2>/dev/null || true
            fi
          fi
        scored: true


      - id: 3.4.2
        description: "Configure firewall rules"
        type: "skip"
        checks:
      - id: 3.4.2.1
        description: "Ensure firewalld default zone is set (Automated)"
        audit: |
          # Pass if: firewalld is NOT in use, OR it's enabled and a default zone is set (non-empty).
          set -euo pipefail
          if systemctl is-enabled firewalld.service >/dev/null 2>&1; then
            z="$(firewall-cmd --get-default-zone 2>/dev/null || true)"
            if [ -n "$z" ]; then
              echo "firewalld_default_zone_set"
            else
              echo "firewalld_default_zone_not_set"
            fi
          else
            echo "firewalld_not_in_use"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "firewalld_default_zone_set"
              set: true
            - flag: "firewalld_not_in_use"
              set: true
        remediation: |
          # Set the firewalld default zone (only if firewalld is in use).
          # Adjust l_zname to match your site policy (e.g., "public", "work", "internal").
          l_zname="public"

          if systemctl is-enabled firewalld.service >/dev/null 2>&1; then
            # Ensure the target zone exists before setting it
            if firewall-cmd --get-zones | tr ' ' '\n' | grep -qx "$l_zname"; then
              current="$(firewall-cmd --get-default-zone 2>/dev/null || true)"
              if [ "$current" != "$l_zname" ]; then
                echo "Setting firewalld default zone to \"$l_zname\""
                firewall-cmd --set-default-zone="$l_zname"
              fi
            else
              echo "Desired zone \"$l_zname\" does not exist. Choose an existing zone:"
              firewall-cmd --get-zones
              exit 1
            fi
          else
            echo "firewalld not in use on this system; no remediation required."
          fi
        scored: true


      - id: 3.4.2.2
        description: "Ensure at least one nftables table exists (Automated)"
        audit: |
          # Pass if `nft list tables` returns at least one table.
          # (If firewalld is in use, it typically provides `table inet firewalld`.)
          set -euo pipefail
          if ! command -v nft >/dev/null 2>&1; then
            echo "nft_not_installed_or_unavailable"
            exit 0
          fi
          if nft list tables 2>/dev/null | grep -q .; then
            echo "nft_table_exists"
          else
            echo "nft_no_tables"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nft_table_exists"
              set: true
        remediation: |
          # Create a base nftables table if none exist.
          # NOTE:
          # - If firewalld is managing your firewall, it normally creates `table inet firewalld`.
          # - Do NOT enable the nftables.service when firewalld is your chosen firewall utility.
          if command -v nft >/dev/null 2>&1; then
            if ! nft list tables 2>/dev/null | grep -q .; then
              # Choose a simple, generic table when firewalld is not in use
              if systemctl is-active --quiet firewalld 2>/dev/null; then
                # Firewalld should provide its own table; reload it to populate if empty
                firewall-cmd --reload 2>/dev/null || true
              else
                nft create table inet filter 2>/dev/null || true
                # Optional: persist via nftables.service only when NOT using firewalld
                if systemctl list-unit-files | grep -q '^nftables\.service'; then
                  # Persist current ruleset to /etc/nftables.conf if desired
                  if [ -w /etc/nftables.conf ]; then
                    nft list ruleset > /etc/nftables.conf
                  fi
                  systemctl enable --now nftables 2>/dev/null || true
                fi
              end
            fi
          else
            # Install nft and create a basic table (only if not using firewalld exclusively)
            if ! systemctl is-active --quiet firewalld 2>/dev/null; then
              dnf -y install nftables 2>/dev/null || true
              if command -v nft >/dev/null 2>&1; then
                nft create table inet filter 2>/dev/null || true
                if systemctl list-unit-files | grep -q '^nftables\.service'; then
                  nft list ruleset > /etc/nftables.conf 2>/dev/null || true
                  systemctl enable --now nftables 2>/dev/null || true
                fi
              fi
            fi
          fi
        scored: true

      - id: 3.4.2.3
        description: "Ensure nftables base chains exist (Automated)"
        audit: |
          # Pass if the ruleset contains base chains with hooks for input, forward, and output.
          set -euo pipefail

          if ! command -v nft >/dev/null 2>&1; then
            echo "nft_unavailable"
            exit 0
          fi

          rs="$(nft list ruleset 2>/dev/null || true)"
          echo "$rs" | grep -qE '^\s*type\s+filter\s+hook\s+input\s+priority\s+[0-9]+;?'   || { echo "nft_base_chains_missing"; exit 0; }
          echo "$rs" | grep -qE '^\s*type\s+filter\s+hook\s+forward\s+priority\s+[0-9]+;?' || { echo "nft_base_chains_missing"; exit 0; }
          echo "$rs" | grep -qE '^\s*type\s+filter\s+hook\s+output\s+priority\s+[0-9]+;?'  || { echo "nft_base_chains_missing"; exit 0; }

          echo "nft_base_chains_present"
        tests:
          bin_op: or
          test_items:
            - flag: "nft_base_chains_present"
              set: true
        remediation: |
          # Create base chains with filter hooks if they're missing.
          # NOTE:
          #  - When firewalld is managing the firewall, base chains are provided automatically.
          #  - Do NOT add custom chains into firewalld's table; manage via firewalld instead.

          if ! command -v nft >/dev/null 2>&1; then
            echo "nft(8) not available; install nftables or use firewalld."
            exit 1
          fi

          # If firewalld is active, try a reload (it should populate its nft table).
          if systemctl is-active --quiet firewalld 2>/dev/null; then
            firewall-cmd --reload 2>/dev/null || true
            exit 0
          fi

          # Choose a working inet table: prefer an existing inet table, else create 'inet filter'
          tbl="$(nft list tables 2>/dev/null | awk '/^table inet /{print $3; exit}')"
          if [ -z "${tbl:-}" ]; then
            tbl="filter"
            nft create table inet "$tbl" 2>/dev/null || true
          fi

          # Idempotently create base chains (priority 0) if missing
          has_chain() { nft list chain inet "$tbl" "$1" >/dev/null 2>&1; }

          if ! has_chain input; then
            nft add chain inet "$tbl" input  '{ type filter hook input  priority 0; }' 2>/dev/null || \
            nft create chain inet "$tbl" input '{ type filter hook input  priority 0; }' 2>/dev/null || true
          fi
          if ! has_chain forward; then
            nft add chain inet "$tbl" forward '{ type filter hook forward priority 0; }' 2>/dev/null || \
            nft create chain inet "$tbl" forward '{ type filter hook forward priority 0; }' 2>/dev/null || true
          fi
          if ! has_chain output; then
            nft add chain inet "$tbl" output '{ type filter hook output priority 0; }' 2>/dev/null || \
            nft create chain inet "$tbl" output '{ type filter hook output priority 0; }' 2>/dev/null || true
          fi

          # Optional: persist when using the nftables service (not when using firewalld)
          if systemctl list-unit-files | grep -q '^nftables\.service'; then
            if [ -w /etc/nftables.conf ]; then
              nft list ruleset > /etc/nftables.conf 2>/dev/null || true
            fi
            systemctl enable --now nftables 2>/dev/null || true
          fi
        scored: true


      - id: 3.4.2.4
        description: "Ensure host based firewall loopback traffic is configured (Automated)"
        audit: |
          set -euo pipefail

          if ! command -v nft >/dev/null 2>&1; then
            echo "loopback_nft_rules_missing"
            exit 0
          fi

          rs="$(nft list ruleset 2>/dev/null || true)"
          ipv6_on=$([ -f /sys/module/ipv6/parameters/disable ] && grep -q '^\s*0\b' /sys/module/ipv6/parameters/disable && echo 1 || echo 0)

          # Accept loopback input (either iif lo or interface "lo")
          if printf '%s\n' "$rs" | awk '/hook[[:space:]]+input[[:space:]]+/{flag=1} /\}/{if(flag){print; flag=0}} flag' \
             | grep -Eq '\biif(name)?\s+"?lo"?\b.*\baccept\b'; then
            echo "loopback_accept_ok"
            lo_ok=1
          else
            lo_ok=0
          fi

          # IPv4 anti-spoof (either generic 127.0.0.0/8 drop, or “daddr != 127.0.0.1 saddr 127.0.0.1 drop”)
          if printf '%s\n' "$rs" | grep -Eq '\bip\s+saddr\s+127\.0\.0\.0/8\b.*\bdrop\b' || \
             printf '%s\n' "$rs" | grep -Eq '\bip\s+daddr\s+!?=+\s*127\.0\.0\.1\b.*\bip\s+saddr\s+127\.0\.0\.1\b.*\bdrop\b'; then
            echo "loopback_ipv4_drop_ok"
            v4_ok=1
          else
            v4_ok=0
          fi

          # IPv6 anti-spoof when IPv6 enabled
          if [ "$ipv6_on" -eq 1 ]; then
            if printf '%s\n' "$rs" | grep -Eq '\bip6\s+saddr\s+::1\b.*\bdrop\b' || \
               printf '%s\n' "$rs" | grep -Eq '\bip6\s+daddr\s+!?=+\s*::1\b.*\bip6\s+saddr\s+::1\b.*\bdrop\b'; then
              echo "loopback_ipv6_drop_ok"
              v6_ok=1
            else
              v6_ok=0
            fi
          else
            echo "ipv6_not_enabled_not_applicable"
            v6_ok=1
          fi

          if [ "$lo_ok" -eq 1 ] && [ "$v4_ok" -eq 1 ] && [ "$v6_ok" -eq 1 ]; then
            echo "loopback_rules_compliant"
          else
            echo "loopback_rules_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "loopback_rules_compliant"
              set: true
        remediation: |
          # Implement loopback rules with whichever firewall utility is in use.
          # - If firewalld is enabled (and nftables service is not), configure via firewalld.
          # - Otherwise configure directly via nft (creates inet/filter and base chains if needed).
          set -euo pipefail

          use_fwd=0
          if systemctl is-enabled firewalld.service >/dev/null 2>&1 && ! systemctl is-enabled nftables.service >/dev/null 2>&1; then
            use_fwd=1
          fi

          ipv6_on=$([ -f /sys/module/ipv6/parameters/disable ] && grep -q '^\s*0\b' /sys/module/ipv6/parameters/disable && echo 1 || echo 0)

          if [ "$use_fwd" -eq 1 ]; then
            # firewalld path
            # Ensure loopback interface is trusted/accepted
            firewall-cmd --permanent --zone=trusted --add-interface=lo || true

            # Drop spoofed IPv4 loopback off-interface traffic
            firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address="127.0.0.1" destination not address="127.0.0.1" drop' || true
            # (Optionally also cover the whole 127/8 range)
            firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address="127.0.0.0/8" drop' || true

            # IPv6 anti-spoof (if enabled)
            if [ "$ipv6_on" -eq 1 ]; then
              firewall-cmd --permanent --add-rich-rule='rule family=ipv6 source address="::1" destination not address="::1" drop' || true
              firewall-cmd --permanent --add-rich-rule='rule family=ipv6 source address="::1" drop' || true
            fi

            firewall-cmd --reload || true
          else
            # nftables path
            if ! command -v nft >/dev/null 2>&1; then
              echo "nftables not installed; install nftables or enable firewalld and re-run."
              exit 1
            fi

            # Ensure inet/filter table and base input chain exist
            tbl="$(nft list tables 2>/dev/null | awk '/^table inet /{print $3; exit}')"
            if [ -z "${tbl:-}" ]; then
              tbl="filter"
              nft create table inet "$tbl" || true
            fi
            # Ensure input chain is a base chain with hook
            if ! nft list chain inet "$tbl" input >/dev/null 2>&1; then
              nft add chain inet "$tbl" input '{ type filter hook input priority 0; }' || true
            fi

            # Accept loopback
            nft add rule inet "$tbl" input iif lo accept 2>/dev/null || true

            # Drop spoofed IPv4 loopback off-interface
            nft add rule inet "$tbl" input ip saddr 127.0.0.0/8 counter drop 2>/dev/null || true

            # IPv6 anti-spoof (if enabled)
            if [ "$ipv6_on" -eq 1 ]; then
              nft add rule inet "$tbl" input ip6 saddr ::1 counter drop 2>/dev/null || true
            fi

            # Persist if nftables service is present (not needed when firewalld manages nft)
            if systemctl list-unit-files | grep -q '^nftables\.service'; then
              if [ -w /etc/nftables.conf ]; then
                nft list ruleset > /etc/nftables.conf 2>/dev/null || true
              fi
              systemctl enable --now nftables 2>/dev/null || true
            fi
          fi
        scored: true

      - id: 3.4.2.5
        description: "Ensure firewalld drops unnecessary services and ports (Manual)"
        audit: |
          systemctl is-enabled firewalld.service | grep -q 'enabled' && firewall-cmd
          --list-all --zone="$(firewall-cmd --list-all | awk '/\(active\)/ { print $1
          }')" | grep -P -- '^\h*(services:|ports:)'
        type: "manual"
        remediation: |
          If Firewalld is in use on the system:
          Run the following command to remove an unnecessary service:
            # firewall-cmd --remove-service=<service>
          Example
            # firewall-cmd --remove-service=cockpit
          Run the following command to remove an unnecessary port:
            # firewall-cmd --remove-port=<port-number>/<port-type>
          Example
            # firewall-cmd --remove-port=25/tcp
          Run the following command to make new settings persistent:
            # firewall-cmd --runtime-to-permanent
        scored: false

      - id: 3.4.2.6
        description: "Ensure nftables established connections are configured (Manual)"
        audit: |
          systemctl is-enabled nftables.service | grep -q 'enabled' && nft list
            ruleset | awk '/hook input/,/}/' | grep 'ct state'
        type: "manual"
        remediation: |
          If NFTables utility is in use on your system:
            Configure nftables in accordance with site policy. The following commands will
          implement a policy to allow all established connections:
          # systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule
            inet filter input ip protocol tcp ct state established accept
            # systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule
            inet filter input ip protocol udp ct state established accept
            # systemctl is-enabled nftables.service | grep -q 'enabled' && nft add rule
            inet filter input ip protocol icmp ct state established accept
        scored: false

      - id: 3.4.2.7
        description: "Ensure nftables default deny firewall policy (Automated)"
        audit: |
          # Pass when nftables is in use AND the base chains with hooks for input and forward have "policy drop".
          # (Control scope: only when nftables.service is enabled; firewalld-only hosts are not applicable here.)
          set -euo pipefail

          if ! systemctl --quiet is-enabled nftables.service 2>/dev/null; then
            echo "nft_not_in_use_not_applicable"
            exit 0
          fi

          rs="$(nft list ruleset 2>/dev/null || true)"
          [ -n "$rs" ] || { echo "nft_default_drop_noncompliant"; exit 0; }

          have_input_drop=$(awk '
            /hook[[:space:]]+input[[:space:]]+/ { inblk=1 }
            inblk && /policy[[:space:]]+drop/ { print "yes"; exit }
            inblk && /\}/ { inblk=0 }
          ' <<<"$rs")

          have_forward_drop=$(awk '
            /hook[[:space:]]+forward[[:space:]]+/ { inblk=1 }
            inblk && /policy[[:space:]]+drop/ { print "yes"; exit }
            inblk && /\}/ { inblk=0 }
          ' <<<"$rs")

          if [ "${have_input_drop:-}" = "yes" ] && [ "${have_forward_drop:-}" = "yes" ]; then
            echo "nft_default_drop_compliant"
          else
            echo "nft_default_drop_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nft_default_drop_compliant"
              set: true
            - flag: "nft_not_in_use_not_applicable"
              set: true
        remediation: |
          # CAUTION: Doing this over SSH can lock you out. Ensure there is an allow-SSH rule in the INPUT chain first.
          # Scope: only when nftables is the active utility (not firewalld-managed).
          set -euo pipefail

          if ! systemctl --quiet is-enabled nftables.service 2>/dev/null; then
            echo "nftables.service not enabled; control not applicable (no changes made)."
            exit 0
          fi

          if ! command -v nft >/dev/null 2>&1; then
            echo "nft command not found"; exit 1
          fi

          # Choose an inet table (prefer first existing; else create 'filter')
          tbl="$(nft list tables 2>/dev/null | awk '/^table inet /{print $3; exit}')"
          if [ -z "${tbl:-}" ]; then
            tbl="filter"
            nft create table inet "$tbl" || true
          fi

          # Ensure base chains exist for input/forward (priority 0)
          nft list chain inet "$tbl" input   >/dev/null 2>&1 || nft add chain inet "$tbl" input   '{ type filter hook input priority 0; }'
          nft list chain inet "$tbl" forward >/dev/null 2>&1 || nft add chain inet "$tbl" forward '{ type filter hook forward priority 0; }'

          # (Optional safety) Ensure loopback & established are allowed before default drop on INPUT
          nft add rule inet "$tbl" input iif lo accept 2>/dev/null || true
          nft add rule inet "$tbl" input ct state established,related accept 2>/dev/null || true
          # (Optional) allow SSH if you manage the host over SSH (adjust port if nonstandard)
          if systemctl is-active --quiet sshd 2>/dev/null; then
            nft add rule inet "$tbl" input tcp dport 22 ct state new accept 2>/dev/null || true
          fi

          # Set default deny policy on INPUT and FORWARD
          nft chain inet "$tbl" input   '{ policy drop; }'
          nft chain inet "$tbl" forward '{ policy drop; }'

          # Persist if using the nftables service
          if systemctl list-unit-files | grep -q '^nftables\.service'; then
            if [ -w /etc/nftables.conf ]; then
              nft list ruleset > /etc/nftables.conf 2>/dev/null || true
            fi
            systemctl enable --now nftables 2>/dev/null || true
          fi
        scored: true

  - id: 4
    description: "Logging and Auditing"
    checks:
  - id: 4.1
    description: "Configure System Accounting (auditd)"
    checks:
      - id: 4.1.1
        description: "Ensure auditing is enabled"
        type: "skip"
        checks:
      - id: 4.1.1.1
        description: "Ensure auditd is installed (Automated)"
        audit: "rpm -q audit"
        tests:
          test_items:
            - flag: "package audit is not installed"
              set: false
        remediation: |
          Run the following command to Install auditd
          # dnf install audit
        scored: true

      - id: 4.1.1.2
        description: "Ensure auditing for processes that start prior to auditd is enabled (Automated)"
        audit: "grubby --info=ALL | grep -Po '\baudit=1\b'"
        tests:
          test_items:
            - flag: "audit=1"
        remediation: |
          Run the following command to update the grub2 configuration with audit=1:
          # grubby --update-kernel ALL --args 'audit=1'
        scored: true

      - id: 4.1.1.3
        description: "Ensure audit_backlog_limit is sufficient (Automated)"
        audit: |
          # Verify all boot entries have audit_backlog_limit >= MIN (default 8192).
          set -euo pipefail
          MIN="${MIN:-8192}"

          if ! command -v grubby >/dev/null 2>&1; then
            echo "grubby_not_available"
            exit 0
          fi

          # Collect all configured values of audit_backlog_limit across kernels
          vals="$(grubby --info=ALL 2>/dev/null | grep -Po '\baudit_backlog_limit=\d+\b' || true)"

          if [ -z "$vals" ]; then
            echo "audit_backlog_limit_missing"
            exit 0
          fi

          # Fail if any configured value is below MIN
          bad="$(awk -F= -v m="$MIN" '{if ($2+0 < m) print $0}' <<< "$vals" || true)"

          if [ -z "$bad" ]; then
            echo "audit_backlog_limit_sufficient"
          else
            echo "audit_backlog_limit_insufficient"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_backlog_limit_sufficient"
              set: true
            - flag: "grubby_not_available"
              set: true
        remediation: |
          # Set audit_backlog_limit to at least 8192 for all boot entries (adjust if your org requires higher).
          # This safely removes any existing value, then sets the desired one.
          MIN="${MIN:-8192}"

          if command -v grubby >/dev/null 2>&1; then
            grubby --update-kernel ALL --remove-args="audit_backlog_limit" 2>/dev/null || true
            grubby --update-kernel ALL --args "audit_backlog_limit=${MIN}"
          else
            echo "grubby(8) not found; install grubby or update your bootloader kernel command line manually."
            exit 1
          fi
        scored: true

      - id: 4.1.1.4
        description: "Ensure auditd service is enabled (Automated)"
        audit: |
          systemctl is-enabled auditd
        tests:
          test_items:
            - flag: "enabled"
              set: true
        remediation: |
          Run the following command to enable auditd:
          # systemctl --now enable auditd
        scored: true

      - id: 4.1.2
        description: "Configure Data Retention"
        type: "skip"
        checks:
      - id: 4.1.2.1
        description: "Ensure audit log storage size is configured (Automated)"
        audit: |
          # Pass if /etc/audit/auditd.conf defines a numeric max_log_file (>0).
          # If MIN env var is set (e.g., MIN=1024), also require value >= MIN and emit a stricter pass flag.
          set -euo pipefail
          conf="/etc/audit/auditd.conf"
          [ -f "$conf" ] || { echo "auditd_conf_missing"; exit 0; }

          # Extract the (last) uncommented assignment
          val="$(awk -F= '/^[[:space:]]*max_log_file[[:space:]]*=/ {v=$2} END{gsub(/[[:space:]]/,"",v); print v}' "$conf")"

          if ! grep -Eq '^[0-9]+$' <<< "${val:-}"; then
            echo "auditd_max_log_file_not_configured"
            exit 0
          fi

          if [ -n "${MIN:-}" ]; then
            if [ "$val" -ge "$MIN" ] 2>/dev/null; then
              echo "auditd_max_log_file_ge_min"
            else
              echo "auditd_max_log_file_below_min"
            fi
          else
            if [ "$val" -gt 0 ] 2>/dev/null; then
              echo "auditd_max_log_file_set"
            else
              echo "auditd_max_log_file_not_configured"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "auditd_max_log_file_set"
              set: true
            - flag: "auditd_max_log_file_ge_min"
              set: true
        remediation: |
          # Set max_log_file in /etc/audit/auditd.conf and restart auditd.
          # Choose a size per site policy. If MIN is set (e.g., MIN=8192) it will be used; default to 8192 MB.
          SIZE="${MIN:-8192}"
          conf="/etc/audit/auditd.conf"

          if [ -f "$conf" ]; then
            # Replace existing uncommented line or append if missing
            if grep -Pq '^[[:space:]]*max_log_file[[:space:]]*=' "$conf"; then
              sed -ri "s|^[[:space:]]*max_log_file[[:space:]]*=.*$|max_log_file = ${SIZE}|" "$conf"
            else
              printf "\nmax_log_file = %s\n" "$SIZE" >> "$conf"
            fi
            # Restart auditd to apply (safe on RHEL/Alma/Rocky/CentOS/Fedora)
            if command -v systemctl >/dev/null 2>&1; then
              systemctl restart auditd
            else
              service auditd restart 2>/dev/null || true
            fi
          else
            echo "Missing $conf; install/configure auditd first."
            exit 1
          fi
        scored: true

      - id: 4.1.2.2
        description: "Ensure audit logs are not automatically deleted (Automated)"
        audit: "grep max_log_file_action /etc/audit/auditd.conf"
        tests:
          test_items:
            - flag: "max_log_file_action"
              compare:
                op: eq
                value: "keep_logs"
        remediation: |
          Set the following parameter in /etc/audit/auditd.conf:
            # max_log_file_action = keep_logs
        scored: true

      - id: 4.1.2.3
        description: "Ensure system is disabled when audit logs are full (Automated)"
        audit: |
          # Pass if:
          #  - space_left_action = email
          #  - action_mail_acct = root
          #  - admin_space_left_action = halt OR single
          set -euo pipefail
          conf="/etc/audit/auditd.conf"
          [ -f "$conf" ] || { echo "auditd_conf_missing"; exit 0; }

          # Get the last effective (uncommented) value for each key
          get_val() { awk -F= -v k="$1" '
            $0 ~ "^[[:space:]]*#" {next}
            tolower($1) ~ "^[[:space:]]*"k"[[:space:]]*$" {v=$2}
            tolower($1) ~ "^[[:space:]]*"k"[[:space:]]*=" {v=$2}
            END {gsub(/^[[:space:]]+|[[:space:]]+$/,"",v); print v}
          ' "$conf"; }

          sla="$(get_val "space_left_action"       | tr 'A-Z' 'a-z')"
          ama="$(get_val "action_mail_acct"        | tr -d ' ')"
          asla="$(get_val "admin_space_left_action" | tr 'A-Z' 'a-z')"

          ok=1
          [ "$sla" = "email" ] || ok=0
          [ "$ama" = "root" ] || ok=0
          { [ "$asla" = "halt" ] || [ "$asla" = "single" ]; } || ok=0

          if [ "$ok" -eq 1 ]; then
            echo "auditd_space_full_policy_strict"
          else
            echo "auditd_space_full_policy_noncompliant"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "auditd_space_full_policy_strict"
              set: true
        remediation: |
          # Configure actions when audit storage is low/full, then restart auditd.
          conf="/etc/audit/auditd.conf"

          if [ -f "$conf" ]; then
            # Ensure required keys are present with desired values
            if grep -Pq '^[[:space:]]*space_left_action[[:space:]]*=' "$conf"; then
              sed -ri 's/^[[:space:]]*space_left_action[[:space:]]*=.*/space_left_action = email/' "$conf"
            else
              printf "\nspace_left_action = email\n" >> "$conf"
            fi

            if grep -Pq '^[[:space:]]*action_mail_acct[[:space:]]*=' "$conf"; then
              sed -ri 's/^[[:space:]]*action_mail_acct[[:space:]]*=.*/action_mail_acct = root/' "$conf"
            else
              printf "action_mail_acct = root\n" >> "$conf"
            fi

            # Choose one per site policy: 'halt' (recommended for high security) or 'single'
            desired="${ASLA:-halt}"
            if grep -Pq '^[[:space:]]*admin_space_left_action[[:space:]]*=' "$conf"; then
              sed -ri "s/^[[:space:]]*admin_space_left_action[[:space:]]*=.*/admin_space_left_action = ${desired}/" "$conf"
            else
              printf "admin_space_left_action = %s\n" "$desired" >> "$conf"
            fi

            # Restart auditd to apply changes
            if command -v systemctl >/dev/null 2>&1; then
              systemctl restart auditd
            else
              service auditd restart 2>/dev/null || true
            fi
          else
            echo "Missing $conf; install and configure auditd first."
            exit 1
          fi
        scored: true

      - id: 4.1.3
        description: "Configure auditd rules"
        type: "skip"
        checks:
      - id: 4.1.3.1
        description: "Ensure changes to system administration scope (sudoers) is collected (Automated)"
        audit: |
          # Verify audit rules exist (on disk and running) for monitoring /etc/sudoers and /etc/sudoers.d changes.
          set -euo pipefail

          check_rules() {
            awk '/^ *-w/ && /\/etc\/sudoers/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' "$@" 2>/dev/null || true
          }

          # Check on-disk rules
          ondisk="$(check_rules /etc/audit/rules.d/*.rules)"
          # Check loaded rules
          loaded="$(auditctl -l 2>/dev/null | awk '/^ *-w/ && /\/etc\/sudoers/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)')"

          if grep -q '/etc/sudoers' <<<"$ondisk" && grep -q '/etc/sudoers.d' <<<"$ondisk" && \
             grep -q '/etc/sudoers' <<<"$loaded" && grep -q '/etc/sudoers.d' <<<"$loaded"; then
            echo "audit_sudoers_scope_rules_present"
          else
            echo "audit_sudoers_scope_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_sudoers_scope_rules_present"
              set: true
        remediation: |
          # Create audit rules to collect modifications to /etc/sudoers and /etc/sudoers.d
          # These rules tag events with key "scope".
          cat << 'EOF' > /etc/audit/rules.d/50-scope.rules
          -w /etc/sudoers   -p wa -k scope
          -w /etc/sudoers.d -p wa -k scope
          EOF

          # Load new audit rules
          if command -v augenrules >/dev/null 2>&1; then
            augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
            auditctl -w /etc/sudoers   -p wa -k scope
            auditctl -w /etc/sudoers.d -p wa -k scope
          fi

          # Check if reboot is required (e.g., auditing locked with -e 2)
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
            echo "Reboot required to apply new audit rules."
          fi
        scored: true

      - id: 4.1.3.2
        description: "Ensure actions as another user are always logged (Automated)"
        audit: |
          # Pass if audit rules exist (on disk AND running) to log execve when a command runs as another user (uid!=euid)
          # for required architectures (b32 on 32-bit; b64+b32 on 64-bit).
          set -euo pipefail

          need_b32=1
          need_b64=0
          # On 64-bit kernels we require BOTH b64 and b32 (ia32 emulation)
          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            need_b64=1
          fi

          match_expr='^ *-a *always,exit.*( -F *arch=b(32|64)).*( -S *execve).*( (-C *euid!=uid)|(-C *uid!=euid)).*( (-F *auid!=unset)|(-F *auid!=-1)|(-F *auid!=4294967295)).*( (key=| -k) *user_emulation) *$'

          have_disk_b32=0; have_disk_b64=0
          have_run_b32=0;  have_run_b64=0

          # On-disk rules
          if compgen -G "/etc/audit/rules.d/*.rules" > /dev/null; then
            ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' )"
            grep -Eqi "$match_expr" <<<"$ondisk" && grep -Eqi 'arch=b32' <<<"$ondisk" && have_disk_b32=1 || true
            grep -Eqi "$match_expr" <<<"$ondisk" && grep -Eqi 'arch=b64' <<<"$ondisk" && have_disk_b64=1 || true
          fi

          # Running rules
          loaded="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          if [ -n "$loaded" ]; then
            grep -Eqi "$match_expr" <<<"$loaded" && grep -Eqi 'arch=b32' <<<"$loaded" && have_run_b32=1 || true
            grep -Eqi "$match_expr" <<<"$loaded" && grep -Eqi 'arch=b64' <<<"$loaded" && have_run_b64=1 || true
          fi

          ok32=$([ "$need_b32" -eq 1 ] && [ "$have_disk_b32" -eq 1 ] && [ "$have_run_b32" -eq 1 ] && echo 1 || echo 0)
          ok64=$([ "$need_b64" -eq 1 ] && [ "$have_disk_b64" -eq 1 ] && [ "$have_run_b64" -eq 1 ] && echo 1 || echo 0)

          if { [ "$need_b64" -eq 0 ] && [ "$ok32" -eq 1 ]; } || { [ "$need_b64" -eq 1 ] && [ "$ok32" -eq 1 ] && [ "$ok64" -eq 1 ]; }; then
            echo "audit_user_emulation_rules_present"
          else
            echo "audit_user_emulation_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_user_emulation_rules_present"
              set: true
        remediation: |
          # Create audit rules to always log execve when real/effective UID differ (user impersonation via sudo, etc.)
          # 64-bit kernels: install both b64 and b32 rules; 32-bit kernels: only b32 is required.

          rules_file="/etc/audit/rules.d/50-user_emulation.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << 'EOF'
          -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          EOF
          else
          cat > "$rules_file" << 'EOF'
          -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          EOF
          fi

          # Load rules into the active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          # Fallback direct load (non-persistent across reboot)
          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
          auditctl -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          auditctl -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          else
          auditctl -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          fi
          fi

          # Notify if auditing is locked (-e 2), which prevents runtime reloads until reboot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.3
        description: "Ensure events that modify the sudo log file are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch the configured sudo log file with -p wa and a key.
          set -euo pipefail

          # Discover sudo logfile path from sudoers (supports sudoers.d)
          SUDO_LOG_FILE="$(grep -Er '^\s*Defaults\s+.*logfile=' /etc/sudoers /etc/sudoers.d 2>/dev/null \
                            | sed -e 's/.*logfile=//' -e 's/,.*//' -e 's/"//g' -e "s/'//g" | tail -n1)"
          if [ -z "${SUDO_LOG_FILE:-}" ]; then
            echo "sudo_logfile_undefined"
            exit 0
          fi

          # Escape for regex/awk
          SUDO_LOG_FILE_ESCAPED="$(printf '%s' "$SUDO_LOG_FILE" | sed 's|/|\\/|g')"

          have_disk=0
          have_run=0

          # On-disk rules
          if compgen -G "/etc/audit/rules.d/*.rules" > /dev/null; then
            if awk "/^ *-w/ && /${SUDO_LOG_FILE_ESCAPED}/ && / +-p *wa/ && (/ key= *[!-~]* *$|/ -k *[!-~]* *$)/" /etc/audit/rules.d/*.rules 2>/dev/null | grep -q .; then
              have_disk=1
            fi
          fi

          # Running rules
          if auditctl -l 2>/dev/null | awk "/^ *-w/ && /${SUDO_LOG_FILE_ESCAPED}/ && / +-p *wa/ && (/ key= *[!-~]* *$|/ -k *[!-~]* *$)/" | grep -q .; then
            have_run=1
          fi

          if [ "$have_disk" -eq 1 ] && [ "$have_run" -eq 1 ]; then
            echo "audit_sudo_logfile_rules_present"
          else
            echo "audit_sudo_logfile_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_sudo_logfile_rules_present"
              set: true
        remediation: |
          # Add audit watch for the configured sudo logfile and load the rule.
          set -euo pipefail

          SUDO_LOG_FILE="$(grep -Er '^\s*Defaults\s+.*logfile=' /etc/sudoers /etc/sudoers.d 2>/dev/null \
                            | sed -e 's/.*logfile=//' -e 's/,.*//' -e 's/\"//g' -e "s/'//g" | tail -n1)"

          if [ -z "${SUDO_LOG_FILE:-}" ]; then
            echo "ERROR: sudo logfile not defined in /etc/sudoers or /etc/sudoers.d."
            echo "Define one, e.g.:"
            echo '  echo \'Defaults logfile="/var/log/sudo.log"\' >/etc/sudoers.d/00-logfile && visudo -cf /etc/sudoers && visudo -cf /etc/sudoers.d/00-logfile'
            exit 1
          fi

          rules_file="/etc/audit/rules.d/50-sudo.rules"
          mkdir -p /etc/audit/rules.d

          # Ensure idempotent content
          if grep -Pq "^-w[[:space:]]+${SUDO_LOG_FILE//\//\\/}[[:space:]]+-p[[:space:]]+wa\b" "$rules_file" 2>/dev/null; then
            : # already present
          else
            printf -- "-w %s -p wa -k sudo_log_file\n" "$SUDO_LOG_FILE" >> "$rules_file"
          fi

          # Load rules into running config
          if command -v augenrules >/dev/null 2>&1; then
            augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
            auditctl -w "$SUDO_LOG_FILE" -p wa -k sudo_log_file
          fi

          # If auditing is locked (-e 2), a reboot is required to load on-disk rules
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
            echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.4
        description: "Ensure events that modify date and time information are collected (Automated)"
        audit: |
          set -euo pipefail

          need_b64=0
          need_b32=1
          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            need_b64=1
          fi

          # Matchers
          # exec rules must include at least adjtimex OR settimeofday OR clock_settime (stime additionally for b32 on 32-bit)
          rx_base='^ *-a *always,exit.* -F *arch=b(32|64).* -S'
          rx_time_syscalls='(adjtimex|settimeofday|clock_settime)'
          rx_time_syscalls_b32_extra='(adjtimex|settimeofday|clock_settime|stime)'
          rx_key='( key= *[!-~]* *$| -k *[!-~]* *$)'
          rx_localtime='^ *-w +/etc/localtime +-p +wa'  # key presence also required

          have_disk_b32=0; have_disk_b64=0; have_disk_localtime=0
          have_run_b32=0;  have_run_b64=0;  have_run_localtime=0

          # ---------- On-disk ----------
          if compgen -G "/etc/audit/rules.d/*.rules" > /dev/null; then
            disk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ')"
            # rules for b32
            if echo "$disk" | awk -v rxb="$rx_base" -v rxs="$rx_time_syscalls_b32_extra" -v rxk="$rx_key" \
                 'BEGIN{IGNORECASE=1} $0 ~ rxb && $0 ~ /arch=b32/ && $0 ~ rxs && $0 ~ rxk {f=1} END{if(f)print "yes"}' | grep -q yes; then
              have_disk_b32=1
            fi
            # rules for b64
            if echo "$disk" | awk -v rxb="$rx_base" -v rxs="$rx_time_syscalls" -v rxk="$rx_key" \
                 'BEGIN{IGNORECASE=1} $0 ~ rxb && $0 ~ /arch=b64/ && $0 ~ rxs && $0 ~ rxk {f=1} END{if(f)print "yes"}' | grep -q yes; then
              have_disk_b64=1
            fi
            # watch /etc/localtime
            if echo "$disk" | awk -v rxlt="$rx_localtime" -v rxk="$rx_key" \
                 'BEGIN{IGNORECASE=1} $0 ~ rxlt && $0 ~ rxk {print; exit}' | grep -q .; then
              have_disk_localtime=1
            fi
          fi

          # ---------- Running ----------
          loaded="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          if [ -n "$loaded" ]; then
            if echo "$loaded" | awk -v rxb="$rx_base" -v rxs="$rx_time_syscalls_b32_extra" -v rxk="$rx_key" \
                 'BEGIN{IGNORECASE=1} $0 ~ rxb && $0 ~ /arch=b32/ && $0 ~ rxs && $0 ~ rxk {f=1} END{if(f)print "yes"}' | grep -q yes; then
              have_run_b32=1
            fi
            if echo "$loaded" | awk -v rxb="$rx_base" -v rxs="$rx_time_syscalls" -v rxk="$rx_key" \
                 'BEGIN{IGNORECASE=1} $0 ~ rxb && $0 ~ /arch=b64/ && $0 ~ rxs && $0 ~ rxk {f=1} END{if(f)print "yes"}' | grep -q yes; then
              have_run_b64=1
            fi
            if echo "$loaded" | awk -v rxlt="$rx_localtime" -v rxk="$rx_key" \
                 'BEGIN{IGNORECASE=1} $0 ~ rxlt && $0 ~ rxk {print; exit}' | grep -q .; then
              have_run_localtime=1
            fi
          fi

          # Evaluate
          ok_local=$([ "$have_disk_localtime" -eq 1 ] && [ "$have_run_localtime" -eq 1 ] && echo 1 || echo 0)

          if [ "$need_b64" -eq 1 ]; then
            ok_exec=$([ "$have_disk_b32" -eq 1 ] && [ "$have_run_b32" -eq 1 ] && [ "$have_disk_b64" -eq 1 ] && [ "$have_run_b64" -eq 1 ] && echo 1 || echo 0)
          else
            ok_exec=$([ "$have_disk_b32" -eq 1 ] && [ "$have_run_b32" -eq 1 ] && echo 1 || echo 0)
          fi

          if [ "$ok_exec" -eq 1 ] && [ "$ok_local" -eq 1 ]; then
            echo "audit_timechange_rules_present"
          else
            echo "audit_timechange_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_timechange_rules_present"
              set: true
        remediation: |
          # Create audit rules to collect changes to date/time settings and /etc/localtime; then load them.
          set -euo pipefail
          rules_file="/etc/audit/rules.d/50-time-change.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << 'EOF'
          -a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
          -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime -k time-change
          -w /etc/localtime -p wa -k time-change
          EOF
          else
          cat > "$rules_file" << 'EOF'
          -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change
          -w /etc/localtime -p wa -k time-change
          EOF
          fi

          # Load rules into the running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
          auditctl -a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
          auditctl -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime -k time-change
          else
          auditctl -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change
          fi
          auditctl -w /etc/localtime -p wa -k time-change
          fi

          # If auditing is locked (-e 2), on-disk changes won't load until reboot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.5
        description: "Ensure events that modify the system's network environment are collected (Automated)"
        audit: |
          # Pass if audit rules (on disk AND running) log sethostname/setdomainname
          # for required architectures and watch key network files/dirs with -p wa.
          # 64-bit kernels: require BOTH arch=b64 and arch=b32 rules (ia32 emu).
          # 32-bit kernels: require arch=b32 rules only.
          set -euo pipefail

          need_b64=0
          need_b32=1
          [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ] && need_b64=1

          rx_exec='^ *-a *always,exit.* -F *arch=b(32|64).* -S.*(sethostname|setdomainname).* ((key=| -k) *[!-~]+) *$'
          rx_watch_issue='^ *-w +/etc/issue(\.net)? +-p +wa +((key=| -k) *[!-~]+) *$'
          rx_watch_hosts='^ *-w +/etc/hosts +-p +wa +((key=| -k) *[!-~]+) *$'
          rx_watch_net='^ *-w +/etc/sysconfig/network +-p +wa +((key=| -k) *[!-~]+) *$'
          rx_watch_scripts='^ *-w +/etc/sysconfig/network-scripts/? +-p +wa +((key=| -k) *[!-~]+) *$'

          have_disk_b32=0; have_disk_b64=0; have_disk_w=0
          have_run_b32=0;  have_run_b64=0;  have_run_w=0

          on_disk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          # ---- on-disk exec rules
          if [ -n "$on_disk" ]; then
            echo "$on_disk" | grep -Eqi "$rx_exec" | grep -q . 2>/dev/null || true
            echo "$on_disk" | grep -Eqi "$rx_exec" | grep -qi 'arch=b32' && have_disk_b32=1 || true
            echo "$on_disk" | grep -Eqi "$rx_exec" | grep -qi 'arch=b64' && have_disk_b64=1 || true
            # watches
            if echo "$on_disk" | grep -Eqi "$rx_watch_issue"   && \
               echo "$on_disk" | grep -Eqi "$rx_watch_hosts"   && \
               echo "$on_disk" | grep -Eqi "$rx_watch_net"     && \
               echo "$on_disk" | grep -Eqi "$rx_watch_scripts"
            then have_disk_w=1; fi
          fi

          # ---- running exec rules
          if [ -n "$running" ]; then
            echo "$running" | grep -Eqi "$rx_exec" | grep -qi 'arch=b32' && have_run_b32=1 || true
            echo "$running" | grep -Eqi "$rx_exec" | grep -qi 'arch=b64' && have_run_b64=1 || true
            if echo "$running" | grep -Eqi "$rx_watch_issue"   && \
               echo "$running" | grep -Eqi "$rx_watch_hosts"   && \
               echo "$running" | grep -Eqi "$rx_watch_net"     && \
               echo "$running" | grep -Eqi "$rx_watch_scripts"
            then have_run_w=1; fi
          fi

          ok_exec_64=$([ "$need_b64" -eq 1 ] && [ "$have_disk_b32" -eq 1 ] && [ "$have_run_b32" -eq 1 ] && [ "$have_disk_b64" -eq 1 ] && [ "$have_run_b64" -eq 1 ] && echo 1 || echo 0)
          ok_exec_32=$([ "$need_b64" -eq 0 ] && [ "$have_disk_b32" -eq 1 ] && [ "$have_run_b32" -eq 1 ] && echo 1 || echo 0)
          ok_w=$([ "$have_disk_w" -eq 1 ] && [ "$have_run_w" -eq 1 ] && echo 1 || echo 0)

          if { [ "$need_b64" -eq 1 ] && [ "$ok_exec_64" -eq 1 ]; } || { [ "$need_b64" -eq 0 ] && [ "$ok_exec_32" -eq 1 ]; }; then
            exec_ok=1
          else
            exec_ok=0
          fi

          if [ "$exec_ok" -eq 1 ] && [ "$ok_w" -eq 1 ]; then
            echo "audit_network_env_rules_present"
          else
            echo "audit_network_env_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_network_env_rules_present"
              set: true
        remediation: |
          # Create audit rules to record network environment changes, then load them.
          set -euo pipefail
          rules_file="/etc/audit/rules.d/50-system_local.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << 'EOF'
          -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
          -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
          -w /etc/issue -p wa -k system-locale
          -w /etc/issue.net -p wa -k system-locale
          -w /etc/hosts -p wa -k system-locale
          -w /etc/sysconfig/network -p wa -k system-locale
          -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
          EOF
          else
          cat > "$rules_file" << 'EOF'
          -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
          -w /etc/issue -p wa -k system-locale
          -w /etc/issue.net -p wa -k system-locale
          -w /etc/hosts -p wa -k system-locale
          -w /etc/sysconfig/network -p wa -k system-locale
          -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
          EOF
          fi

          # Load rules into the running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          # Fallback (non-persistent) direct load mirroring the above
          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
          auditctl -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
          auditctl -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
          else
          auditctl -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
          fi
          auditctl -w /etc/issue -p wa -k system-locale
          auditctl -w /etc/issue.net -p wa -k system-locale
          auditctl -w /etc/hosts -p wa -k system-locale
          auditctl -w /etc/sysconfig/network -p wa -k system-locale
          auditctl -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to load at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.6
        description: "Ensure use of privileged commands are collected (Automated)"
        audit: |
          # PASS if every setuid/setgid executable found on eligible filesystems has
          #   - an on-disk audit rule, and
          #   - a loaded (running) audit rule.
          #
          # Eligible filesystems: all mounted non-nodev types not marked noexec/nosuid.
          # Tip: To preview the scan scope (can be large), run:
          #   findmnt -n -l -k -it $(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid"
          set -euo pipefail

          # Optional: pattern to exclude specific mount points (e.g., EXCLUDE_FS='/var/lib/containers')
          EXCLUDE_FS="${EXCLUDE_FS:-}"

          # Build mount list
          mapfile -t PARTS < <(
            findmnt -n -l -k -it "$(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,)" |
            grep -Pv "noexec|nosuid" |
            awk '{print $1}' |
            { if [ -n "$EXCLUDE_FS" ]; then grep -Ev "$EXCLUDE_FS" || true; else cat; fi; } |
            sort -u
          )

          # Collect privileged binaries (setuid/setgid)
          PRIVS=()
          for p in "${PARTS[@]}"; do
            while IFS= read -r f; do PRIVS+=("$f"); done < <(find "$p" -xdev -perm /6000 -type f 2>/dev/null || true)
          done

          # If none found, treat as compliant
          [ "${#PRIVS[@]}" -gt 0 ] || { echo "audit_privileged_cmds_rules_present"; exit 0; }

          # Snapshot rules (running + on-disk)
          RUNNING="$(auditctl -l 2>/dev/null || true)"
          ONDISK="$(cat /etc/audit/rules.d/*.rules 2>/dev/null || true)"

          ok=1
          for f in "${PRIVS[@]}"; do
            # We only require that the path is referenced; exact options are validated by policy reviewers
            echo "$ONDISK"  | grep -Fq -- "$f" || ok=0
            echo "$RUNNING" | grep -Fq -- "$f" || ok=0
            [ "$ok" -eq 0 ] && break
          done

          if [ "$ok" -eq 1 ]; then
            echo "audit_privileged_cmds_rules_present"
          else
            echo "audit_privileged_cmds_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_privileged_cmds_rules_present"
              set: true
        remediation: |
          # Generate watch rules for all setuid/setgid executables on eligible filesystems,
          # keyed "privileged", then load them.
          #
          # WARNING: This may traverse large filesystems; consider setting EXCLUDE_FS to narrow scope.
          # Example: EXCLUDE_FS='/var/lib/containers|/snap' (pipe-separated ERE)
          set -euo pipefail

          EXCLUDE_FS="${EXCLUDE_FS:-}"
          RULES_FILE="/etc/audit/rules.d/50-privileged.rules"
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          : "${UID_MIN:?Could not determine UID_MIN from /etc/login.defs}"

          # Build partition list
          mapfile -t PARTS < <(
            findmnt -n -l -k -it "$(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,)" |
            grep -Pv "noexec|nosuid" |
            awk '{print $1}' |
            { if [ -n "$EXCLUDE_FS" ]; then grep -Ev "$EXCLUDE_FS" || true; else cat; fi; } |
            sort -u
          )

          # Assemble new rules
          TMP="$(mktemp)"
          for p in "${PARTS[@]}"; do
            # Find setuid/setgid files (-perm /6000)
            while IFS= read -r f; do
              printf -- "-a always,exit -F path=%s -F perm=x -F auid>=%s -F auid!=unset -k privileged\n" "$f" "$UID_MIN"
            done < <(find "$p" -xdev -perm /6000 -type f 2>/dev/null || true)
          done > "$TMP"

          # Merge with existing file (idempotent + sorted unique)
          mkdir -p /etc/audit/rules.d
          { [ -f "$RULES_FILE" ] && cat "$RULES_FILE" || true; cat "$TMP"; } | sort -u > "${RULES_FILE}.new"
          mv -f "${RULES_FILE}.new" "$RULES_FILE"
          rm -f "$TMP"

          # Load the rules
          if command -v augenrules >/dev/null 2>&1; then
            augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
            # Fallback (non-persistent across reboot)
            while IFS= read -r line; do auditctl $line || true; done < "$RULES_FILE"
          fi

          # If auditing is locked (-e 2), a reboot is required for changes to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
            echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.7
        description: "Ensure unsuccessful file access attempts are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) log failed file access attempts
          # (-EACCES or -EPERM) for required architectures and for non-daemon users
          # (auid>=UID_MIN and auid!=unset).
          #
          # 64-bit kernels: require BOTH b64 and b32 rules for each of the two exits.
          # 32-bit kernels: require b32 rules only (for each of the two exits).
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_access_rules_missing"; exit 0; }

          need_b64=0
          need_b32=1
          [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ] && need_b64=1

          # Match fragments
          rx_base='^ *-a *always,exit'
          rx_arch_b32='-F *arch=b32'
          rx_arch_b64='-F *arch=b64'
          rx_syscalls='-S .*creat.*open(,| )?openat.*truncate.*ftruncate'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_eacces='-F *exit=-EACCES'
          rx_eperm='-F *exit=-EPERM'
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d_b32_eacces=0; have_d_b32_eperm=0; have_d_b64_eacces=0; have_d_b64_eperm=0
          have_r_b32_eacces=0; have_r_b32_eperm=0; have_r_b64_eacces=0; have_r_b64_eperm=0

          # ------- On-disk rules -------
          disk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"

          test_line() {
            # $1: blob, $2..N: regexes-all-must-match (case-insensitive)
            awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$2" || return 1
            shift 2 >/dev/null || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          if [ -n "$disk" ]; then
            test_line "$disk" "$rx_base" "$rx_arch_b32" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eacces" "$rx_key" && have_d_b32_eacces=1 || true
            test_line "$disk" "$rx_base" "$rx_arch_b32" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eperm"  "$rx_key" && have_d_b32_eperm=1  || true
            test_line "$disk" "$rx_base" "$rx_arch_b64" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eacces" "$rx_key" && have_d_b64_eacces=1 || true
            test_line "$disk" "$rx_base" "$rx_arch_b64" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eperm"  "$rx_key" && have_d_b64_eperm=1  || true
          fi

          # ------- Running rules -------
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          if [ -n "$running" ]; then
            test_line "$running" "$rx_base" "$rx_arch_b32" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eacces" "$rx_key" && have_r_b32_eacces=1 || true
            test_line "$running" "$rx_base" "$rx_arch_b32" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eperm"  "$rx_key" && have_r_b32_eperm=1  || true
            test_line "$running" "$rx_base" "$rx_arch_b64" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eacces" "$rx_key" && have_r_b64_eacces=1 || true
            test_line "$running" "$rx_base" "$rx_arch_b64" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_eperm"  "$rx_key" && have_r_b64_eperm=1  || true
          fi

          ok32=$([ $have_d_b32_eacces -eq 1 ] && [ $have_d_b32_eperm -eq 1 ] && [ $have_r_b32_eacces -eq 1 ] && [ $have_r_b32_eperm -eq 1 ] && echo 1 || echo 0)
          ok64=$([ $have_d_b64_eacces -eq 1 ] && [ $have_d_b64_eperm -eq 1 ] && [ $have_r_b64_eacces -eq 1 ] && [ $have_r_b64_eperm -eq 1 ] && echo 1 || echo 0)

          if { [ "$need_b64" -eq 1 ] && [ "$ok32" -eq 1 ] && [ "$ok64" -eq 1 ]; } || \
             { [ "$need_b64" -eq 0 ] && [ "$ok32" -eq 1 ]; }; then
            echo "audit_unsuccessful_file_access_rules_present"
          else
            echo "audit_unsuccessful_file_access_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_unsuccessful_file_access_rules_present"
              set: true
        remediation: |
          # Create audit rules to capture unsuccessful file access attempts (EACCES/EPERM)
          # by non-daemon, non-privileged users for both arches where applicable.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-access.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << EOF
          -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$uid_min -F auid!=unset -k access
          -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=$uid_min -F auid!=unset -k access
          -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$uid_min -F auid!=unset -k access
          -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=$uid_min -F auid!=unset -k access
          EOF
          else
          cat > "$rules_file" << EOF
          -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$uid_min -F auid!=unset -k access
          -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=$uid_min -F auid!=unset -k access
          EOF
          fi

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          # Fallback (non-persistent) direct load mirroring the above
          while IFS= read -r line; do
          [ -n "$line" ] && auditctl $line || true
          done < "$rules_file"
          fi

          # If auditing is locked (-e 2), rules won't hot-load; reboot will be required
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.8
        description: "Ensure events that modify user/group information are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch the identity files with -p wa and a key.
          set -euo pipefail

          files=(
            /etc/group
            /etc/passwd
            /etc/gshadow
            /etc/shadow
            /etc/security/opasswd
          )

          has_all_ondisk=1
          has_all_running=1

          # Build matchers
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          # On-disk
          if compgen -G "/etc/audit/rules.d/*.rules" >/dev/null; then
            ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          else
            ondisk=""
          fi

          for f in "${files[@]}"; do
            f_esc="$(printf '%s' "$f" | sed 's|/|\\/|g')"
            rx="^ *-w +${f_esc} +-p +wa +${rx_key}"
            echo "$ondisk" | grep -Eqi "$rx" || has_all_ondisk=0
          done

          # Running
          loaded="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          for f in "${files[@]}"; do
            f_esc="$(printf '%s' "$f" | sed 's|/|\\/|g')"
            rx="^ *-w +${f_esc} +-p +wa +${rx_key}"
            echo "$loaded" | grep -Eqi "$rx" || has_all_running=0
          done

          if [ "$has_all_ondisk" -eq 1 ] && [ "$has_all_running" -eq 1 ]; then
            echo "audit_identity_rules_present"
          else
            echo "audit_identity_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_identity_rules_present"
              set: true
        remediation: |
          # Create audit watches for identity files, then load rules.
          set -euo pipefail

          rules_file="/etc/audit/rules.d/50-identity.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << 'EOF'
          -w /etc/group                -p wa -k identity
          -w /etc/passwd               -p wa -k identity
          -w /etc/gshadow              -p wa -k identity
          -w /etc/shadow               -p wa -k identity
          -w /etc/security/opasswd    -p wa -k identity
          EOF

          # Load into running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/devnull 2>&1; then
          auditctl -w /etc/group             -p wa -k identity
          auditctl -w /etc/passwd            -p wa -k identity
          auditctl -w /etc/gshadow           -p wa -k identity
          auditctl -w /etc/shadow            -p wa -k identity
          auditctl -w /etc/security/opasswd  -p wa -k identity
          fi

          # If auditing is locked (-e 2), a reboot is required to apply on-disk rules
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.9
        description: "Ensure discretionary access control permission modification events are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) record DAC permission/ownership/attribute
          # modifications by non-daemon, non-system users for required architectures.
          #
          # 64-bit kernels: require BOTH b64 and b32 rules covering all syscall groups.
          # 32-bit kernels: require b32 rules only.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_perm_mod_rules_missing"; exit 0; }

          need_b64=0; need_b32=1
          [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ] && need_b64=1

          # Group syscalls per CIS examples
          grp_mode='(chmod|fchmod|fchmodat)'
          grp_own='(chown|fchown|lchown|fchownat)'
          grp_xattr='(setxattr|lsetxattr|fsetxattr|removexattr|lremovexattr|fremovexattr)'

          rx_base='^ *-a *always,exit'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d_b32_mode=0; have_d_b32_own=0; have_d_b32_xattr=0
          have_d_b64_mode=0; have_d_b64_own=0; have_d_b64_xattr=0
          have_r_b32_mode=0; have_r_b32_own=0; have_r_b32_xattr=0
          have_r_b64_mode=0; have_r_b64_own=0; have_r_b64_xattr=0

          blob_disk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          blob_run="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() { awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$2" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$3" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$4" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$5" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$6"; }

          if [ -n "$blob_disk" ]; then
            match_all "$blob_disk" "$rx_base.*-F *arch=b32" "-S.*${grp_mode}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b32_mode=1 || true
            match_all "$blob_disk" "$rx_base.*-F *arch=b32" "-S.*${grp_own}"  "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b32_own=1  || true
            match_all "$blob_disk" "$rx_base.*-F *arch=b32" "-S.*${grp_xattr}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b32_xattr=1 || true

            match_all "$blob_disk" "$rx_base.*-F *arch=b64" "-S.*${grp_mode}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b64_mode=1 || true
            match_all "$blob_disk" "$rx_base.*-F *arch=b64" "-S.*${grp_own}"  "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b64_own=1  || true
            match_all "$blob_disk" "$rx_base.*-F *arch=b64" "-S.*${grp_xattr}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b64_xattr=1 || true
          fi

          if [ -n "$blob_run" ]; then
            match_all "$blob_run" "$rx_base.*-F *arch=b32" "-S.*${grp_mode}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b32_mode=1 || true
            match_all "$blob_run" "$rx_base.*-F *arch=b32" "-S.*${grp_own}"  "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b32_own=1  || true
            match_all "$blob_run" "$rx_base.*-F *arch=b32" "-S.*${grp_xattr}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b32_xattr=1 || true

            match_all "$blob_run" "$rx_base.*-F *arch=b64" "-S.*${grp_mode}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b64_mode=1 || true
            match_all "$blob_run" "$rx_base.*-F *arch=b64" "-S.*${grp_own}"  "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b64_own=1  || true
            match_all "$blob_run" "$rx_base.*-F *arch=b64" "-S.*${grp_xattr}" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b64_xattr=1 || true
          fi

          ok32=$([ $have_d_b32_mode -eq 1 ] && [ $have_d_b32_own -eq 1 ] && [ $have_d_b32_xattr -eq 1 ] && [ $have_r_b32_mode -eq 1 ] && [ $have_r_b32_own -eq 1 ] && [ $have_r_b32_xattr -eq 1 ] && echo 1 || echo 0)
          ok64=$([ $have_d_b64_mode -eq 1 ] && [ $have_d_b64_own -eq 1 ] && [ $have_d_b64_xattr -eq 1 ] && [ $have_r_b64_mode -eq 1 ] && [ $have_r_b64_own -eq 1 ] && [ $have_r_b64_xattr -eq 1 ] && echo 1 || echo 0)

          if { [ "$need_b64" -eq 1 ] && [ "$ok32" -eq 1 ] && [ "$ok64" -eq 1 ]; } || \
             { [ "$need_b64" -eq 0 ] && [ "$ok32" -eq 1 ]; }; then
            echo "audit_perm_mod_rules_present"
          else
            echo "audit_perm_mod_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_perm_mod_rules_present"
              set: true
        remediation: |
          # Create audit rules to record DAC permission/ownership/attribute changes by non-daemon users.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-perm_mod.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << EOF
          -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S chown,fchown,lchown,fchownat -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=$uid_min -F auid!=unset -k perm_mod
          EOF
          else
          cat > "$rules_file" << EOF
          -a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S chown,fchown,lchown,fchownat -F auid>=$uid_min -F auid!=unset -k perm_mod
          -a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=$uid_min -F auid!=unset -k perm_mod
          EOF
          fi

          # Load rules into the running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          while IFS= read -r line; do
          [ -n "$line" ] && auditctl $line || true
          done < "$rules_file"
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.10
        description: "Ensure successful file system mounts are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) record successful mount() by
          # non-daemon users (auid>=UID_MIN and auid!=unset) for the required arches.
          # 64-bit kernels: require both b64 and b32 rules. 32-bit: b32 only.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_mount_rules_missing"; exit 0; }

          need_b64=0; need_b32=1
          [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ] && need_b64=1

          rx_base='^ *-a *always,exit'
          rx_b32='-F *arch=b32'
          rx_b64='-F *arch=b64'
          rx_sys='-S *mount'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d_b32=0; have_d_b64=0
          have_r_b32=0; have_r_b64=0

          blob_disk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          blob_run="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() { awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$2" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$3" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$4" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$5" && awk 'BEGIN{IGNORECASE=1} {print}' <<<"$1" | grep -Eiq "$6"; }

          if [ -n "$blob_disk" ]; then
            match_all "$blob_disk" "$rx_base" "$rx_b32" "$rx_sys" "$rx_auid_unset" "$rx_auid_min" && echo "$blob_disk" | grep -Eiq "$rx_key" && have_d_b32=1 || true
            match_all "$blob_disk" "$rx_base" "$rx_b64" "$rx_sys" "$rx_auid_unset" "$rx_auid_min" && echo "$blob_disk" | grep -Eiq "$rx_key" && have_d_b64=1 || true
          fi

          if [ -n "$blob_run" ]; then
            match_all "$blob_run" "$rx_base" "$rx_b32" "$rx_sys" "$rx_auid_unset" "$rx_auid_min" && echo "$blob_run" | grep -Eiq "$rx_key" && have_r_b32=1 || true
            match_all "$blob_run" "$rx_base" "$rx_b64" "$rx_sys" "$rx_auid_unset" "$rx_auid_min" && echo "$blob_run" | grep -Eiq "$rx_key" && have_r_b64=1 || true
          fi

          ok32=$([ $have_d_b32 -eq 1 ] && [ $have_r_b32 -eq 1 ] && echo 1 || echo 0)
          ok64=$([ $have_d_b64 -eq 1 ] && [ $have_r_b64 -eq 1 ] && echo 1 || echo 0)

          if { [ "$need_b64" -eq 1 ] && [ "$ok32" -eq 1 ] && [ "$ok64" -eq 1 ]; } || \
             { [ "$need_b64" -eq 0 ] && [ "$ok32" -eq 1 ]; }; then
            echo "audit_mount_rules_present"
          else
            echo "audit_mount_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_mount_rules_present"
              set: true
        remediation: |
          # Create audit rules for mount() by non-daemon users and load them.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-mounts.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << EOF
          -a always,exit -F arch=b32 -S mount -F auid>=$uid_min -F auid!=unset -k mounts
          -a always,exit -F arch=b64 -S mount -F auid>=$uid_min -F auid!=unset -k mounts
          EOF
          else
          cat > "$rules_file" << EOF
          -a always,exit -F arch=b32 -S mount -F auid>=$uid_min -F auid!=unset -k mounts
          EOF
          fi

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          while IFS= read -r line; do
          [ -n "$line" ] && auditctl $line || true
          done < "$rules_file"
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.11
        description: "Ensure session initiation information is collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch utmp/wtmp/btmp with -p wa and a key.
          set -euo pipefail

          files=(
            /var/run/utmp
            /var/log/wtmp
            /var/log/btmp
          )

          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'
          has_all_ondisk=1
          has_all_running=1

          # On-disk rules snapshot
          if compgen -G "/etc/audit/rules.d/*.rules" >/dev/null; then
            ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          else
            ondisk=""
          fi

          for f in "${files[@]}"; do
            f_esc="$(printf '%s' "$f" | sed 's|/|\\/|g')"
            rx="^ *-w +${f_esc} +-p +wa +${rx_key}"
            echo "$ondisk" | grep -Eqi "$rx" || has_all_ondisk=0
          done

          # Running rules snapshot
          loaded="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          for f in "${files[@]}"; do
            f_esc="$(printf '%s' "$f" | sed 's|/|\\/|g')"
            rx="^ *-w +${f_esc} +-p +wa +${rx_key}"
            echo "$loaded" | grep -Eqi "$rx" || has_all_running=0
          done

          if [ "$has_all_ondisk" -eq 1 ] && [ "$has_all_running" -eq 1 ]; then
            echo "audit_session_rules_present"
          else
            echo "audit_session_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_session_rules_present"
              set: true
        remediation: |
          # Create watches for session initiation files, then load the rules.
          set -euo pipefail

          rules_file="/etc/audit/rules.d/50-session.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << 'EOF'
          -w /var/run/utmp -p wa -k session
          -w /var/log/wtmp -p wa -k session
          -w /var/log/btmp -p wa -k session
          EOF

          # Load into running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -w /var/run/utmp -p wa -k session
          auditctl -w /var/log/wtmp -p wa -k session
          auditctl -w /var/log/btmp -p wa -k session
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.12
        description: "Ensure login and logout events are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch lastlog & faillock with -p wa and a key.
          set -euo pipefail

          files=(
            /var/log/lastlog
            /var/run/faillock
          )

          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'
          has_all_ondisk=1
          has_all_running=1

          # On-disk snapshot
          if compgen -G "/etc/audit/rules.d/*.rules" >/dev/null; then
            ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          else
            ondisk=""
          fi

          for f in "${files[@]}"; do
            f_esc="$(printf '%s' "$f" | sed 's|/|\\/|g')"
            rx="^ *-w +${f_esc} +-p +wa +${rx_key}"
            echo "$ondisk" | grep -Eqi "$rx" || has_all_ondisk=0
          done

          # Running snapshot
          loaded="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          for f in "${files[@]}"; do
            f_esc="$(printf '%s' "$f" | sed 's|/|\\/|g')"
            rx="^ *-w +${f_esc} +-p +wa +${rx_key}"
            echo "$loaded" | grep -Eqi "$rx" || has_all_running=0
          done

          if [ "$has_all_ondisk" -eq 1 ] && [ "$has_all_running" -eq 1 ]; then
            echo "audit_login_rules_present"
          else
            echo "audit_login_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_login_rules_present"
              set: true
        remediation: |
          # Create watches for login/logout files, then load rules.
          set -euo pipefail

          rules_file="/etc/audit/rules.d/50-login.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << 'EOF'
          -w /var/log/lastlog   -p wa -k logins
          -w /var/run/faillock  -p wa -k logins
          EOF

          # Load into running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -w /var/log/lastlog  -p wa -k logins
          auditctl -w /var/run/faillock -p wa -k logins
          fi

          # If auditing is locked (-e 2), a reboot is required to apply on-disk rules
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.13
        description: "Ensure file deletion events by users are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) record unlink/rename syscalls
          # by non-daemon users (auid>=UID_MIN and auid!=unset) for required arches.
          # 64-bit kernels: require both b64 and b32. 32-bit: b32 only.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_delete_rules_missing"; exit 0; }

          need_b64=0; need_b32=1
          [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ] && need_b64=1

          rx_base='^ *-a *always,exit'
          rx_b32='-F *arch=b32'
          rx_b64='-F *arch=b64'
          rx_syscalls='-S .*(unlink|unlinkat|rename|renameat)'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d_b32=0; have_d_b64=0
          have_r_b32=0; have_r_b64=0

          blob_disk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          blob_run="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() {
            # $1: text; then regexes that must all match (case-insensitive)
            awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$2" || return 1
            shift 2 >/dev/null || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          if [ -n "$blob_disk" ]; then
            match_all "$blob_disk" "$rx_base" "$rx_b32" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b32=1 || true
            match_all "$blob_disk" "$rx_base" "$rx_b64" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_b64=1 || true
          fi

          if [ -n "$blob_run" ]; then
            match_all "$blob_run" "$rx_base" "$rx_b32" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b32=1 || true
            match_all "$blob_run" "$rx_base" "$rx_b64" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_b64=1 || true
          fi

          ok32=$([ $have_d_b32 -eq 1 ] && [ $have_r_b32 -eq 1 ] && echo 1 || echo 0)
          ok64=$([ $have_d_b64 -eq 1 ] && [ $have_r_b64 -eq 1 ] && echo 1 || echo 0)

          if { [ "$need_b64" -eq 1 ] && [ "$ok32" -eq 1 ] && [ "$ok64" -eq 1 ]; } || \
             { [ "$need_b64" -eq 0 ] && [ "$ok32" -eq 1 ]; }; then
            echo "audit_delete_rules_present"
          else
            echo "audit_delete_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_delete_rules_present"
              set: true
        remediation: |
          # Create audit rules for file deletion/rename by non-daemon users and load them.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-delete.rules"
          mkdir -p /etc/audit/rules.d

          if [ "$(getconf LONG_BIT 2>/dev/null || echo 64)" = "64" ]; then
            cat > "$rules_file" << EOF
          -a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=$uid_min -F auid!=unset -k delete
          -a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F auid>=$uid_min -F auid!=unset -k delete
          EOF
          else
          cat > "$rules_file" << EOF
          -a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F auid>=$uid_min -F auid!=unset -k delete
          EOF
          fi

          # Load into the running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          while IFS= read -r line; do
          [ -n "$line" ] && auditctl $line || true
          done < "$rules_file"
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.14
        description: "Ensure events that modify the system's Mandatory Access Controls are collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch SELinux policy dirs with -p wa and a key.
          set -euo pipefail

          paths=(
            /etc/selinux
            /usr/share/selinux
          )

          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'
          ok_disk=1
          ok_run=1

          # On-disk snapshot
          if compgen -G "/etc/audit/rules.d/*.rules" >/dev/null; then
            ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          else
            ondisk=""
          fi

          for p in "${paths[@]}"; do
            p_esc="$(printf '%s' "$p" | sed 's|/|\\/|g')"
            rx="^ *-w +${p_esc} +-p +wa +${rx_key}"
            echo "$ondisk" | grep -Eqi "$rx" || ok_disk=0
          done

          # Running snapshot
          loaded="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"
          for p in "${paths[@]}"; do
            p_esc="$(printf '%s' "$p" | sed 's|/|\\/|g')"
            rx="^ *-w +${p_esc} +-p +wa +${rx_key}"
            echo "$loaded" | grep -Eqi "$rx" || ok_run=0
          done

          if [ "$ok_disk" -eq 1 ] && [ "$ok_run" -eq 1 ]; then
            echo "audit_mac_policy_rules_present"
          else
            echo "audit_mac_policy_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_mac_policy_rules_present"
              set: true
        remediation: |
          # Create watches for SELinux MAC policy directories, then load rules.
          set -euo pipefail

          rules_file="/etc/audit/rules.d/50-MAC-policy.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << 'EOF'
          -w /etc/selinux        -p wa -k MAC-policy
          -w /usr/share/selinux  -p wa -k MAC-policy
          EOF

          # Load into the running configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -w /etc/selinux       -p wa -k MAC-policy
          auditctl -w /usr/share/selinux -p wa -k MAC-policy
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.15
        description: "Ensure successful and unsuccessful attempts to use the chcon command are recorded (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch execution of /usr/bin/chcon
          # by non-daemon users (auid>=UID_MIN and auid!=unset).
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_chcon_rules_missing"; exit 0; }

          rx_base='^ *-a *always,exit'
          rx_path='-F *path=/usr/bin/chcon'
          rx_perm='-F *perm=x'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d=0; have_r=0

          ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() {
            awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$2" || return 1
            shift 2 >/dev/null || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          [ -n "$ondisk" ]  && match_all "$ondisk"  "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d=1 || true
          [ -n "$running" ] && match_all "$running" "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r=1 || true

          if [ "$have_d" -eq 1 ] && [ "$have_r" -eq 1 ]; then
            echo "audit_chcon_rules_present"
          else
            echo "audit_chcon_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_chcon_rules_present"
              set: true
        remediation: |
          # Create audit rule for /usr/bin/chcon execution by non-daemon users and load it.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-perm_chng.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << EOF
          -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=$uid_min -F auid!=unset -k perm_chng
          EOF

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>="$uid_min" -F auid!=unset -k perm_chng
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.16
        description: "Ensure successful and unsuccessful attempts to use the setfacl command are recorded (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch execution of /usr/bin/setfacl
          # by non-daemon users (auid>=UID_MIN and auid!=unset).
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_setfacl_rules_missing"; exit 0; }

          rx_base='^ *-a *always,exit'
          rx_path='-F *path=/usr/bin/setfacl'
          rx_perm='-F *perm=x'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d=0; have_r=0

          ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() {
            awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$2" || return 1
            shift 2 >/dev/null || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          [ -n "$ondisk" ]  && match_all "$ondisk"  "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d=1 || true
          [ -n "$running" ] && match_all "$running" "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r=1 || true

          if [ "$have_d" -eq 1 ] && [ "$have_r" -eq 1 ]; then
            echo "audit_setfacl_rules_present"
          else
            echo "audit_setfacl_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_setfacl_rules_present"
              set: true
        remediation: |
          # Create audit rule for /usr/bin/setfacl execution by non-daemon users and load it.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-perm_chng.rules"
          mkdir -p /etc/audit/rules.d

          # Append (or create) the rule
          if ! grep -qs '^ *-a .*path=/usr/bin/setfacl' "$rules_file" 2>/dev/null; then
            cat >> "$rules_file" << EOF
          -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=$uid_min -F auid!=unset -k perm_chng
          EOF
          else
          # Ensure UID_MIN reflects current setting
          sed -i -E "s|(path=/usr/bin/setfacl -F perm=x -F auid>=)[0-9]+|\1$uid_min|g" "$rules_file"
          fi

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>="$uid_min" -F auid!=unset -k perm_chng
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.17
        description: "Ensure successful and unsuccessful attempts to use the chacl command are recorded (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch execution of /usr/bin/chacl
          # by non-daemon users (auid>=UID_MIN and auid!=unset).
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_chacl_rules_missing"; exit 0; }

          rx_base='^ *-a *always,exit'
          rx_path='-F *path=/usr/bin/chacl'
          rx_perm='-F *perm=x'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d=0; have_r=0

          ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() {
            awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$2" || return 1
            shift 2 >/dev/null || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          [ -n "$ondisk" ]  && match_all "$ondisk"  "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d=1 || true
          [ -n "$running" ] && match_all "$running" "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r=1 || true

          if [ "$have_d" -eq 1 ] && [ "$have_r" -eq 1 ]; then
            echo "audit_chacl_rules_present"
          else
            echo "audit_chacl_rules_missing"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "audit_chacl_rules_present"
              set: true
        remediation: |
          # Create audit rule for /usr/bin/chacl execution by non-daemon users and load it.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-perm_chng.rules"
          mkdir -p /etc/audit/rules.d

          # Append (or create) the rule
          if ! grep -qs '^ *-a .*path=/usr/bin/chacl' "$rules_file" 2>/dev/null; then
            cat >> "$rules_file" << EOF
          -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=$uid_min -F auid!=unset -k perm_chng
          EOF
          else
          # Ensure UID_MIN reflects current setting
          sed -i -E "s|(path=/usr/bin/chacl -F perm=x -F auid>=)[0-9]+|\1$uid_min|g" "$rules_file"
          fi

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>="$uid_min" -F auid!=unset -k perm_chng
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.18
        description: "Ensure successful and unsuccessful attempts to use the usermod command are recorded (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch execution of /usr/sbin/usermod
          # by non-daemon users (auid>=UID_MIN and auid!=unset / -1), with an audit key.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "audit_usermod_rules_missing"; exit 0; }

          rx_base='^ *-a *always,exit'
          rx_path='-F *path=/usr/sbin/usermod'
          rx_perm='-F *perm=x'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          have_d=0; have_r=0

          ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() {
            awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$2" || return 1
            shift 2 >/dev/null || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1}{print}' <<<"$1" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          [ -n "$ondisk" ]  && match_all "$ondisk"  "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d=1 || true
          [ -n "$running" ] && match_all "$running" "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r=1 || true

          if [ "$have_d" -eq 1 ] && [ "$have_r" -eq 1 ]; then
            echo "audit_usermod_rules_present"
          else
            echo "audit_usermod_rules_missing"
          fi
        tests:
          test_items:
            - flag: "audit_usermod_rules_present"
              set: true
        remediation: |
          # Create audit rule for /usr/sbin/usermod execution by non-daemon users and load it.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-usermod.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << EOF
          -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=$uid_min -F auid!=unset -k usermod
          EOF

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>="$uid_min" -F auid!=unset -k usermod
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.19
        description: "Ensure kernel module loading, unloading and modification is collected (Automated)"
        audit: |
          # Pass if audit rules (on-disk AND running) watch module syscalls and /usr/bin/kmod execution
          # by non-daemon users (auid>=UID_MIN and auid!=unset/-1).
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs || true)"
          [ -n "${uid_min:-}" ] || { echo "audit_kernel_modules_rules_missing"; exit 0; }

          rx_base='^ *-a *always,exit'
          rx_arch='-F *arch=b(32|64)'
          rx_syscalls='-S *([^#]*init_module|[^#]*finit_module|[^#]*delete_module|[^#]*create_module|[^#]*query_module)'
          rx_auid_unset='(-F *auid!=unset|-F *auid!=-1|-F *auid!=4294967295)'
          rx_auid_min="-F *auid>=${uid_min}"
          rx_key='( key= *[!-~]*$| -k *[!-~]*$)'

          # Path rule for the kmod frontend
          rx_path='-F *path=/usr/bin/kmod'
          rx_perm='-F *perm=x'

          have_d_sys=0; have_d_path=0; have_r_sys=0; have_r_path=0

          ondisk="$(cat /etc/audit/rules.d/*.rules 2>/dev/null | tr -s ' ' || true)"
          running="$(auditctl -l 2>/dev/null | tr -s ' ' || true)"

          match_all() {
            local blob="$1"; shift
            awk 'BEGIN{IGNORECASE=1}{print}' <<<"$blob" | grep -Eiq "$1" || return 1
            shift || true
            for r in "$@"; do
              awk 'BEGIN{IGNORECASE=1}{print}' <<<"$blob" | grep -Eiq "$r" || return 1
            done
            return 0
          }

          [ -n "$ondisk" ]  && match_all "$ondisk"  "$rx_base" "$rx_arch" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_d_sys=1  || true
          [ -n "$ondisk" ]  && match_all "$ondisk"  "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key"    && have_d_path=1 || true
          [ -n "$running" ] && match_all "$running" "$rx_base" "$rx_arch" "$rx_syscalls" "$rx_auid_unset" "$rx_auid_min" "$rx_key" && have_r_sys=1  || true
          [ -n "$running" ] && match_all "$running" "$rx_base" "$rx_path" "$rx_perm" "$rx_auid_unset" "$rx_auid_min" "$rx_key"    && have_r_path=1 || true

          if [ "$have_d_sys" -eq 1 ] && [ "$have_d_path" -eq 1 ] && [ "$have_r_sys" -eq 1 ] && [ "$have_r_path" -eq 1 ]; then
            echo "audit_kernel_modules_rules_present"
          else
            echo "audit_kernel_modules_rules_missing"
          fi

          # (Optional) quick sanity check: kmod symlinks point to /usr/bin/kmod
          # S_LINKS=$(ls -l /usr/sbin/lsmod /usr/sbin/rmmod /usr/sbin/insmod /usr/sbin/modinfo /usr/sbin/modprobe /usr/sbin/depmod 2>/dev/null | grep -v ' -> ../bin/kmod' || true)
          # [ -z "$S_LINKS" ] && echo "kmod_symlinks_ok" || echo "kmod_symlinks_issue"
        tests:
          bin_op: or
          test_items:
            - flag: "audit_kernel_modules_rules_present"
              set: true
        remediation: |
          # Create audit rules for kernel module syscalls and /usr/bin/kmod execution; then load them.
          set -euo pipefail

          uid_min="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs || true)"
          [ -n "${uid_min:-}" ] || { echo "Could not determine UID_MIN from /etc/login.defs"; exit 1; }

          rules_file="/etc/audit/rules.d/50-kernel_modules.rules"
          mkdir -p /etc/audit/rules.d

          cat > "$rules_file" << EOF
          # Kernel module manipulation (syscalls)
          -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=$uid_min -F auid!=unset -k kernel_modules
          -a always,exit -F arch=b32 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=$uid_min -F auid!=unset -k kernel_modules
          # kmod frontend execution
          -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=$uid_min -F auid!=unset -k kernel_modules
          EOF

          # Load rules into active configuration
          if command -v augenrules >/dev/null 2>&1; then
          augenrules --load
          elif command -v auditctl >/dev/null 2>&1; then
          auditctl -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>="$uid_min" -F auid!=unset -k kernel_modules
          auditctl -a always,exit -F arch=b32 -S init_module,finit_module,delete_module,create_module,query_module -F auid>="$uid_min" -F auid!=unset -k kernel_modules
          auditctl -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>="$uid_min" -F auid!=unset -k kernel_modules
          fi

          # If auditing is locked (-e 2), a reboot is required for on-disk rules to take effect at boot
          if auditctl -s 2>/dev/null | grep -q 'enabled.*2'; then
          echo "Reboot required to load rules (auditing is locked with -e 2)."
          fi
        scored: true

      - id: 4.1.3.20
        description: "Ensure the audit configuration is immutable (Automated)"
        audit: |
          grep -Ph -- '^\h*-e\h+2\b' /etc/audit/rules.d/*.rules | tail -1
        tests:
          test_items:
            - flag: "-e 2"
        remediation: |
          Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line -e 2 at
          the end of the file:
          Example:
          # printf --
            "
          -e 2" >> /etc/audit/rules.d/99-finalize.rules
            Load audit rules
          Merge and load the rules into active configuration:
          # augenrules --load
            Check if reboot is required.
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot
            required to load rules\n"; fi
        scored: true

      - id: 4.1.3.21
        description: "Ensure the running and on disk configuration is the same (Manual)"
        audit: "augenrules --check"
        type: "manual"
        remediation: |
          If the rules are not aligned across all three () areas, run the following command to
          merge and load all rules:
          # augenrules --load
          Check if reboot is required.
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required
          to load rules"; fi
        scored: false

      - id: 4.1.4
        description: "Configure auditd file access"
        type: "skip"
        checks:
      - id: 4.1.4.1
        description: "Ensure audit log files are mode 0640 or less permissive (Automated)"
        audit: |
          [ -f /etc/audit/auditd.conf ] && logfile="$(sed -n 's/^[[:space:]]*log_file[[:space:]]*=[[:space:]]*//p' /etc/audit/auditd.conf | head -n1 | tr -d '"')" && logdir="$(dirname -- "$logfile")" && [ -d "$logdir" ] && find "$logdir" -type f \( ! -perm 0600 -a ! -perm 0640 -a ! -perm 0400 -a ! -perm 0440 -a ! -perm 0200 -a ! -perm 0040 -a ! -perm 0000 \) -exec stat -Lc '%n %#a' {} +
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to remove more permissive mode than 0640 from audit log
          files:
          # [ -f /etc/audit/auditd.conf ] && find "$(dirname $(awk -F "="
            '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" -type f \( ! -
            perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a !
            -perm 0440 -a ! -perm 0040 \) -exec chmod u-x,g-wx,o-rwx {} +
        scored: true

      - id: 4.1.4.2
        description: "Ensure only authorized users own audit log files (Automated)"
        audit: |
          [ -f /etc/audit/auditd.conf ] && logfile="$(sed -n 's/^[[:space:]]*log_file[[:space:]]*=[[:space:]]*//p' /etc/audit/auditd.conf | head -n1 | tr -d '"')" && find "$(dirname -- "$logfile")" -type f ! -user root -exec stat -Lc '%n %U' {} +
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to configure the audit log files to be owned by the root
          user:
          # [ -f /etc/audit/auditd.conf ] && find "$(dirname $(awk -F "="
          '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" -type f ! -user
          root -exec chown root {} +
        scored: true

      - id: 4.1.4.3
        description: "Ensure only authorized groups are assigned ownership of audit log files (Automated)"
        audit: |
          grep -Piw -- '^\h*log_group\h*=\h*(adm|root)\b' /etc/audit/auditd.conf
        tests:
          bin_op: or
          test_items:
            - flag: "log_group = adm"
            - flag: "log_group = root"
        remediation: |
          Run the following command to configure the audit log files to be owned by adm group:
          # find $(dirname $(awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}'
          /etc/audit/auditd.conf | xargs)) -type f \( ! -group adm -a ! -group root \)
          -exec chgrp adm {} +
          Run the following command to configure the audit log files to be owned by the adm
          group:
          # chgrp adm /var/log/audit/
          Run the following command to set the log_group parameter in the audit configuration
          file to log_group = adm:
          # sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?.*$/log_group = adm\1/'
          /etc/audit/auditd.conf
          Run the following command to restart the audit daemon to reload the configuration file:
          # systemctl restart auditd
        scored: true

      - id: 4.1.4.4
        description: "Ensure the audit log directory is 0750 or more restrictive (Automated)"
        audit: |
          stat -Lc "%n %a" "$(dirname $( awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf))" | grep -Pv -- '^\h*\H+\h+([0,5,7][0,5]0)'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to configure the audit log directory to have a mode of
          "0750" or less permissive:
          # chmod g-w,o-rwx "$(dirname $( awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}'
          /etc/audit/auditd.conf))"
        scored: true

      - id: 4.1.4.5
        description: "Ensure audit configuration files are 640 or more restrictive (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec stat -Lc "%n %a" {} + | grep -Pv -- '^\h*\H+\h*([0,2,4,6][0,4]0)\h*$'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to remove more permissive mode than 0640 from the audit
          configuration files:
          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec
          chmod u-x,g-wx,o-rwx {} +
        scored: true

      - id: 4.1.4.6
        description: "Ensure audit configuration files are owned by root (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change ownership to root user:
          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user
          root -exec chown root {} +
        scored: true

      - id: 4.1.4.7
        description: "Ensure audit configuration files belong to group root (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change group to root:
          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group
          root -exec chgrp root {} +
        scored: true

      - id: 4.1.4.8
        description: "Ensure audit tools are 755 or more restrictive (Automated)"
        audit: |
          stat -c "%n %a" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | grep -Pv -- '^\h*\H+\h+([0-7][0,1,4,5][0,1,4,5])\h*$'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to remove more permissive mode from the audit tools:
          # chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace
          /sbin/auditd /sbin/augenrules
        scored: true

      - id: 4.1.4.9
        description: "Ensure audit tools are owned by root (Automated)"
        audit: |
          stat -c "%n %U" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | grep -Pv -- '^\h*\H+\h+root\h*$'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change the owner of the audit tools to the root user:
          # chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace
          /sbin/auditd /sbin/augenrules
        scored: true

      - id: 4.1.4.10
        description: "Ensure audit tools belong to group root (Automated)"
        audit: |
          stat -c "%n %a %U %G" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | grep -Pv -- '^\h*\H+\h+([0-7][0,1,4,5][0,1,4,5])\h+root\h+root\h*$'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to remove more permissive mode from the audit tools:
          # chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace
          /sbin/auditd /sbin/augenrules
          Run the following command to change owner and group of the audit tools to root user
          and group:
          # chown root:root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace
          /sbin/auditd /sbin/augenrules
        scored: true

  - id: 4.2
    description: "Configure Logging"
    checks:
      - id: 4.2.1
        description: "Configure rsyslog"
        type: "skip"
        checks:
      - id: 4.2.1.1
        description: "Ensure rsyslog is installed (Automated)"
        audit: "rpm -q rsyslog"
        tests:
          test_items:
            - flag: "package rsyslog is not installed"
              set: false
        remediation: |
          Run the following command to install rsyslog:
            # dnf install rsyslog
        scored: true

      - id: 4.2.1.2
        description: "Ensure rsyslog service is enabled (Automated)"
        audit: "systemctl is-enabled rsyslog"
        tests:
          test_items:
            - flag: "enabled"
        remediation: |
          Run the following command to enable rsyslog:
          # systemctl --now enable rsyslog
        scored: true

      - id: 4.2.1.3
        description: "Ensure journald is configured to send logs to rsyslog (Manual)"
        audit: |
          grep -Ei '^[[:space:]]*ForwardToSyslog[[:space:]]*=[[:space:]]*yes[[:space:]]*$' /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "ForwardToSyslog=yes"
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:
          ForwardToSyslog=yes
          Restart the service:
          # systemctl restart rsyslog
        scored: true

      - id: 4.2.1.4
        description: "Ensure rsyslog default file permissions are configured (Automated)"
        audit: |
          # Verify rsyslog is configured to create new log files with permissions 0640 or stricter.
          if ! rpm -q rsyslog >/dev/null 2>&1; then
            echo "rsyslog_not_installed"
            exit 0
          fi

          if ! systemctl is-enabled rsyslog 2>/dev/null | grep -qE 'enabled|static'; then
            echo "rsyslog_not_enabled"
            exit 0
          fi

          grep -Ps '^\h*\$FileCreateMode\h+0[0,2,4,6][0,2,4]0\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null | grep -q '0640'
          if [ $? -eq 0 ]; then
            echo "rsyslog_filecreatemode_ok"
          else
            echo "rsyslog_filecreatemode_not_ok"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rsyslog_filecreatemode_ok"
              set: true
            - flag: "rsyslog_not_installed"
              set: true
            - flag: "rsyslog_not_enabled"
              set: true
        remediation: |
          # Configure rsyslog to create log files with permissions 0640 or more restrictive
          if [ -f /etc/rsyslog.conf ]; then
            if grep -q '^\s*\$FileCreateMode' /etc/rsyslog.conf; then
              sed -i 's/^\s*\$FileCreateMode.*/$FileCreateMode 0640/' /etc/rsyslog.conf
            else
              echo '$FileCreateMode 0640' >> /etc/rsyslog.conf
            fi
          else
            echo '$FileCreateMode 0640' > /etc/rsyslog.conf
          fi

          # Restart rsyslog to apply changes
          systemctl restart rsyslog
        scored: true

      - id: 4.2.1.5
        description: "Ensure logging is configured (Manual)"
        audit: "ls -l /var/log/"
        type: "manual"
        remediation: |
          Edit the following lines in the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files as
            appropriate for your environment.
          NOTE: The below configuration is shown for example purposes only. Due care should
            be given to how the organization wish to store log data.
            *.emerg :omusrmsg:*
            auth,authpriv.* /var/log/secure
            mail.* -/var/log/mail
            mail.info -/var/log/mail.info
            mail.warning -/var/log/mail.warn
            mail.err /var/log/mail.err
            cron.* /var/log/cron
            *.=warning;*.=err -/var/log/warn
            *.crit /var/log/warn
            *.*;mail.none;news.none -/var/log/messages
            local0,local1.* -/var/log/localmessages
            local2,local3.* -/var/log/localmessages
            local4,local5.* -/var/log/localmessages
            local6,local7.* -/var/log/localmessages
          Run the following command to reload the rsyslogd configuration:
            # systemctl restart rsyslog
        scored: false

      - id: 4.2.1.6
        description: "Ensure rsyslog is configured to send logs to a remote log host (Manual)"
        audit: |
          grep "^*.*[^I][^I]*@" /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        type: "manual"
        remediation: |
          Edit the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files and add the following line
            (where loghost.example.com is the name of your central log host). The target directive
            may either be a fully qualified domain name or an IP address.
            *.* action(type="omfwd" target="192.168.2.100" port="514" protocol="tcp"
            action.resumeRetryCount="100"
            queue.type="LinkedList" queue.size="1000")
          Run the following command to reload the rsyslogd configuration:
            # systemctl restart rsyslog
        scored: false

      - id: 4.2.1.7
        description: "Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
        audit: |
          grep -Ps -- ^\h*module\(load="imtcp"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -Ps -- '^\h*input\(type="imtcp" port="514"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: true
        remediation: |
          # Comment out RainerScript TCP receiver directives, then restart rsyslog.
          files=$(printf "/etc/rsyslog.conf\n"; ls -1 /etc/rsyslog.d/*.conf 2>/dev/null || true)

          for f in $files; do
            [ -f "$f" ] || continue
            cp -p "$f" "${f}.bak.rsyslog-recv"

            # Comment RainerScript TCP receiver lines (ignore already-commented)
            sed -ri 's/^([[:space:]]*)(module\(load="imtcp"\))/\1# \2/' "$f"
            sed -ri 's/^([[:space:]]*)(input\(type="imtcp"[^)]*\))/\1# \2/' "$f"
          done

          systemctl restart rsyslog
        scored: true

      - id: 4.2.2
        description: "Configure journald"
        type: "skip"
        checks:
      - id: 4.2.2.1
        description: "Ensure journald is configured to send logs to a remote log host"
        type: "skip"
        checks:
      - id: 4.2.2.1.1
        description: "Ensure systemd-journal-remote is installed (Manual)"
        audit: "rpm -q systemd-journal-remote"
        tests:
          test_items:
            - flag: "package systemd-journal-remote is not installed"
              set: false
        remediation: |
          Run the following command to install systemd-journal-remote:
            # dnf install systemd-journal-remote
        scored: false
      - id: 4.2.2.1.2
        description: "Ensure systemd-journal-remote is configured (Manual)"
        audit: |
          grep -P "^ *URL=|^ *ServerKeyFile=|^ *ServerCertificateFile=|^*TrustedCertificateFile=" /etc/systemd/journal-upload.conf
        type: "manual"
        remediation: |
          Edit the /etc/systemd/journal-upload.conf file and ensure the following lines are set
          per your environment:
            URL=192.168.50.42
            ServerKeyFile=/etc/ssl/private/journal-upload.pem
            ServerCertificateFile=/etc/ssl/certs/journal-upload.pem
            TrustedCertificateFile=/etc/ssl/ca/trusted.pem
          Restart the service:
            # systemctl restart systemd-journal-upload
        scored: false

      - id: 4.2.2.1.3
        description: "Ensure systemd-journal-remote is enabled (Manual)"
        audit: "systemctl is-enabled systemd-journal-upload.service"
        tests:
          test_items:
            - flag: "enabled"
        remediation: |
          Run the following command to enable systemd-journal-remote:
          # systemctl --now enable systemd-journal-upload.service
        scored: false

      - id: 4.2.2.1.4
        description: "Ensure journald is not configured to receive logs from a remote client (Automated)"
        audit: "systemctl is-enabled systemd-journal-remote.socket"
        tests:
          test_items:
            - flag: "masked"
        remediation: |
          Run the following command to disable systemd-journal-remote.socket:
          # systemctl --now mask systemd-journal-remote.socket
        scored: true

      - id: 4.2.2.2
        description: "Ensure journald service is enabled (Automated)"
        audit: "systemctl is-enabled systemd-journald.service"
        tests:
          test_items:
            - flag: "static"
        remediation: |
          By default the systemd-journald service does not have an [Install] section and thus
          cannot be enabled / disabled. It is meant to be referenced as Requires or Wants by other
          unit files. As such, if the status of systemd-journald is not static, investigate why.
        scored: true

      - id: 4.2.2.3
        description: "Ensure journald is configured to compress large log files (Automated)"
        audit: |
          grep -Ei '^[[:space:]]*Compress[[:space:]]*=[[:space:]]*yes([[:space:]]*|$)' /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "Compress=yes"
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:
            Compress=yes
          Restart the service:
            # systemctl restart systemd-journald.service
        scored: true

      - id: 4.2.2.4
        description: "Ensure journald is configured to write logfiles to persistent disk (Automated)"
        audit: |
          grep ^\s*Storage /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "Storage=persistent"
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:
            Storage=persistent
          Restart the service:
            # systemctl restart systemd-journald.service
        scored: true

      - id: 4.2.2.5
        description: "Ensure journald is not configured to send logs to rsyslog (Manual)"
        audit: |
          grep ^\s*ForwardToSyslog /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/systemd/journald.conf file and ensure that ForwardToSyslog=yes is
          removed.
          Restart the service:
          # systemctl restart systemd-journald.service
        scored: false

      - id: 4.2.2.6
        description: "Ensure journald log rotation is configured per site policy (Manual)"
        type: "manual"
        remediation: |
          Review /etc/systemd/journald.conf and verify logs are rotated according to site
            policy. The settings should be carefully understood as there are specific edge cases
            and prioritization of parameters.
          The specific parameters for log rotation are:
            SystemMaxUse=
            SystemKeepFree=
            RuntimeMaxUse=
            RuntimeKeepFree=
            MaxFileSec=
        scored: false

      - id: 4.2.2.7
        description: "Ensure journald default file permissions configured (Manual)"
        type: "manual"
        remediation: |
          If the default configuration is not appropriate for the site specific requirements, copy
          /usr/lib/tmpfiles.d/systemd.conf to /etc/tmpfiles.d/systemd.conf and modify as
          required. Requirements is either 0640 or site policy if that is less restrictive.
        scored: false

      - id: 4.2.3
        description: "Ensure all logfiles have appropriate permissions and ownership (Automated)"
        audit: |
          tmp="$(mktemp)"
          find /var/log -xdev -type f -print0 2>/dev/null | while IFS= read -r -d '' f; do
            b=$(basename "$f")
            m=$(stat -Lc '%a' "$f" 2>/dev/null); u=$(stat -Lc '%U' "$f" 2>/dev/null); g=$(stat -Lc '%G' "$f" 2>/dev/null)

            case "$b" in
              lastlog|lastlog.*|wtmp|wtmp.*|wtmp-*|btmp|btmp.*|btmp-*)
                echo "$m" | grep -Eq '^[0246][0246][04]$' && echo "$u" | grep -Eq '^root$' && echo "$g" | grep -Eq '^(utmp|root)$' \
                  || echo "VIOLATION: $f mode=$m owner=$u group=$g"
                ;;
              secure|auth.log|syslog|messages)
                echo "$m" | grep -Eq '^[0246][04]0$' && echo "$u" | grep -Eq '^(root|syslog)$' && echo "$g" | grep -Eq '^(adm|root)$' \
                  || echo "VIOLATION: $f mode=$m owner=$u group=$g"
                ;;
              *.journal|*.journal~)
                echo "$m" | grep -Eq '^[0246][04]0$' && echo "$u" | grep -Eq '^root$' && echo "$g" | grep -Eq '^(systemd-journal|root)$' \
                  || echo "VIOLATION: $f mode=$m owner=$u group=$g"
                ;;
              # Allow 0644 for common app logs on RHEL
              rhsm.log|rhsmcertd.log|choose_repo.log|tuned.log|dnf.log|dnf.librepo.log|dnf.rpm.log|hawkey.log|dnf.*.log)
                echo "$m" | grep -Eq '^(640|644|600|660|440|400|200|040|000)$' && echo "$u" | grep -Eq '^root$' && echo "$g" | grep -Eq '^(root|adm|syslog)$' \
                  || echo "VIOLATION: $f mode=$m owner=$u group=$g"
                ;;
              *)
                # Default: allow others=0 OR 4 (accept 0644 as well as 0640/0600)
                echo "$m" | grep -Eq '^[0246][04][04]$' && echo "$u" | grep -Eq '^(root|syslog)$' && echo "$g" | grep -Eq '^(adm|root)$' \
                  || echo "VIOLATION: $f mode=$m owner=$u group=$g"
                ;;
            esac
          done > "$tmp"

          if grep -q '^VIOLATION:' "$tmp"; then cat "$tmp"; else echo "PASS"; fi
          rm -f "$tmp"
        tests:
          test_items:
            - flag: "PASS"
        remediation: |
          find /var/log -xdev -type f -print0 2>/dev/null | while IFS= read -r -d '' f; do
            b=$(basename "$f")
            case "$b" in
              lastlog|lastlog.*|wtmp|wtmp.*|wtmp-*|btmp|btmp.*|btmp-*)
                chown root:root "$f"
                chgrp utmp "$f" 2>/dev/null || true
                chmod 640 "$f"
                ;;
              secure|auth.log|syslog|messages)
                chown root:adm "$f" 2>/dev/null || chown root:root "$f"
                chmod 640 "$f"
                ;;
              SSSD|sssd)
                chown root:root "$f"
                chmod 660 "$f"
                ;;
              gdm|gdm3)
                chown root:$(getent group gdm3 >/dev/null && echo gdm3 || echo gdm) "$f" 2>/dev/null || chown root:root "$f"
                chmod 660 "$f"
                ;;
              *.journal|*.journal~)
                chown root:systemd-journal "$f" 2>/dev/null || chown root:root "$f"
                chmod 640 "$f"
                ;;
              *)
                chown root:adm "$f" 2>/dev/null || chown root:root "$f"
                chmod 640 "$f"
                ;;
            esac
          done
        scored: true
      - id: 4.3
        description: "Ensure logrotate is configured (Manual)"
        type: "manual"
        remediation: |
          Edit /etc/logrotate.conf and /etc/logrotate.d/* to ensure logs are rotated
          according to site policy.
        scored: false

  - id: 5
    description: "Access, Authentication and Authorization"
    checks:
  - id: 5.1
    description: "Configure time-based job schedulers"
    checks:
      - id: 5.1.1
        description: "Ensure cron daemon is enabled (Automated)"
        audit: "systemctl is-enabled crond"
        tests:
          test_items:
            - flag: "enabled"
        remediation: |
          Run the following command to enable cron:
            # systemctl --now enable crond
        scored: true


      - id: 5.1.2
        description: "Ensure permissions on /etc/crontab are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/crontab)
          owner=$(stat -Lc '%u' /etc/crontab)
          group=$(stat -Lc '%g' /etc/crontab)

          if [ "$perms" -le 600 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "crontab_perms_ok"
          else
            echo "crontab_perms_bad"
          fi
        tests:
          test_items:
            - flag: "crontab_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/crontab
          chown root:root /etc/crontab
          chmod og-rwx /etc/crontab
        scored: true

      - id: 5.1.3
        description: "Ensure permissions on /etc/cron.hourly are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.hourly)
          owner=$(stat -Lc '%u' /etc/cron.hourly)
          group=$(stat -Lc '%g' /etc/cron.hourly)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.hourly_perms_ok"
          else
            echo "cron.hourly_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.hourly_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.hourly
          chown root:root /etc/cron.hourly
          chmod og-rwx /etc/cron.hourly
        scored: true

      - id: 5.1.4
        description: "Ensure permissions on /etc/cron.daily are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.daily)
          owner=$(stat -Lc '%u' /etc/cron.daily)
          group=$(stat -Lc '%g' /etc/cron.daily)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.daily_perms_ok"
          else
            echo "cron.daily_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.daily_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.daily
          chown root:root /etc/cron.daily
          chmod og-rwx /etc/cron.daily
        scored: true

      - id: 5.1.5
        description: "Ensure permissions on /etc/cron.weekly are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.weekly)
          owner=$(stat -Lc '%u' /etc/cron.weekly)
          group=$(stat -Lc '%g' /etc/cron.weekly)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.weekly_perms_ok"
          else
            echo "cron.weekly_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.weekly_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.weekly
          chown root:root /etc/cron.weekly
          chmod og-rwx /etc/cron.weekly
        scored: true

      - id: 5.1.6
        description: "Ensure permissions on /etc/cron.monthly are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.monthly)
          owner=$(stat -Lc '%u' /etc/cron.monthly)
          group=$(stat -Lc '%g' /etc/cron.monthly)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.monthly_perms_ok"
          else
            echo "cron.monthly_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.monthly_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.monthly
          chown root:root /etc/cron.monthly
          chmod og-rwx /etc/cron.monthly
        scored: true

      - id: 5.1.7
        description: "Ensure permissions on /etc/cron.d are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/cron.d)
          owner=$(stat -Lc '%u' /etc/cron.d)
          group=$(stat -Lc '%g' /etc/cron.d)

          if [ "$perms" -le 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "cron.d_perms_ok"
          else
            echo "cron.d_perms_bad"
          fi
        tests:
          test_items:
            - flag: "cron.d_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.d
          chown root:root /etc/cron.d
          chmod og-rwx /etc/cron.d
        scored: true

      - id: 5.1.8
        description: "Ensure cron is restricted to authorized users (Automated)"
        audit: |
          #!/usr/bin/env bash
          {
            if rpm -q cronie > /dev/null 2>&1; then
              [ -e /etc/cron.deny ] && echo "Fail: cron.deny exists"
              if [ ! -e /etc/cron.allow ]; then
                echo "Fail: cron.allow doesn't exist"
              else
                ! stat -Lc "%a" /etc/cron.allow | grep -Eq "[0,2,4,6]00" && echo "Fail: cron.allow mode too permissive"
                ! stat -Lc "%u:%g" /etc/cron.allow | grep -Eq "^0:0$" && echo "Fail: cron.allow owner and/or group not root"
              fi
              if [ ! -e /etc/cron.deny ] && [ -e /etc/cron.allow ] \
                 && stat -Lc "%a" /etc/cron.allow | grep -Eq "[0,2,4,6]00" \
                 && stat -Lc "%u:%g" /etc/cron.allow | grep -Eq "^0:0$"; then
                echo "Pass"
              fi
            else
              echo "Pass: cron is not installed on the system"
            fi
          }
        tests:
          test_items:
            - flag: "Pass"
            - flag: "Pass: cron is not installed on the system"
          bin_op: "or"
        remediation: |
          #!/usr/bin/env bash
          {
            if rpm -q cronie > /dev/null 2>&1; then
              [ -e /etc/cron.deny ] && rm -f /etc/cron.deny
              [ ! -e /etc/cron.allow ] && touch /etc/cron.allow
              chown root:root /etc/cron.allow
              chmod u-x,go-rwx /etc/cron.allow
            else
              echo "cron is not installed on the system"
              # To remove cron if present:
              # dnf remove -y cronie
            fi
          }
        scored: true

      - id: 5.1.9
        description: "Ensure at is restricted to authorized users (Automated)"
        audit: |
          #!/usr/bin/env bash
          {
            if rpm -q at > /dev/null 2>&1; then
              [ -e /etc/at.deny ] && echo "Fail: at.deny exists"
              if [ ! -e /etc/at.allow ]; then
                echo "Fail: at.allow doesn't exist"
              else
                ! stat -Lc "%a" /etc/at.allow | grep -Eq "[0,2,4,6]00" && echo "Fail: at.allow mode too permissive"
                ! stat -Lc "%u:%g" /etc/at.allow | grep -Eq "^0:0$" && echo "Fail: at.allow owner and/or group not root"
              fi
              if [ ! -e /etc/at.deny ] && [ -e /etc/at.allow ] \
                 && stat -Lc "%a" /etc/at.allow | grep -Eq "[0,2,4,6]00" \
                 && stat -Lc "%u:%g" /etc/at.allow | grep -Eq "^0:0$"; then
                echo "Pass"
              fi
            else
              echo "Pass: at is not installed on the system"
            fi
          }
        tests:
          test_items:
            - flag: "Pass"
            - flag: "Pass: at is not installed on the system"
          bin_op: "or"
        remediation: |
          #!/usr/bin/env bash
          {
            if rpm -q at > /dev/null 2>&1; then
              [ -e /etc/at.deny ] && rm -f /etc/at.deny
              [ ! -e /etc/at.allow ] && touch /etc/at.allow
              chown root:root /etc/at.allow
              chmod u-x,go-rwx /etc/at.allow
            else
              echo "at is not installed on the system"
              # To remove at if present:
              # dnf remove -y at
            fi
          }
        scored: true


  - id: 5.2
    description: "Configure SSH Server"
    checks:
      - id: 5.2.1
        description: "Ensure permissions on /etc/ssh/sshd_config are configured (Automated)"
        audit: |
          #!/usr/bin/env bash
          if [ -f /etc/ssh/sshd_config ]; then
            perms=$(stat -Lc '%a' /etc/ssh/sshd_config)
            owner=$(stat -Lc '%u' /etc/ssh/sshd_config)
            group=$(stat -Lc '%g' /etc/ssh/sshd_config)

            # perms like 600/400/etc. — group/other must be 0
            if echo "$perms" | grep -Eq '^[0-7]00$' && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "sshd_config_perms_ok"
            else
              echo "sshd_config_perms_bad"
            fi
          else
            echo "sshd_config_missing"
          fi
        tests:
          test_items:
            - flag: "sshd_config_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/ssh/sshd_config
          chown root:root /etc/ssh/sshd_config
          chmod u-x,go-rwx /etc/ssh/sshd_config
        scored: true


      - id: 5.2.2
        description: "Ensure permissions on SSH private host key files are configured (Automated)"
        audit: |
          skg=ssh_keys; skgid="$(getent group "$skg" | awk -F: '{print $3}')"; tmp="$(mktemp)"
          find -L /etc/ssh -xdev -type f -print0 2>/dev/null | while IFS= read -r -d '' f; do
            if file -b "$f" | grep -iq 'openssh.*private key'; then
              m="$(stat -Lc '%a' "$f")"; u="$(stat -Lc '%u' "$f")"; g="$(stat -Lc '%g' "$f")"
              pmask=$([ -n "$skgid" ] && [ "$g" = "$skgid" ] && echo 95 || echo 127)   # 0137 or 0177
              mo=$(( 0$m ))
              bad=0
              [ "$u" -ne 0 ] && bad=1
              if [ "$g" -ne 0 ]; then [ -z "$skgid" ] || [ "$g" -ne "$skgid" ] && bad=1; fi
              [ $(( mo & pmask )) -ne 0 ] && bad=1
              [ "$bad" -eq 1 ] && echo "VIOLATION: $f mode=$m owner_uid=$u group_gid=$g" >>"$tmp"
            fi
          done
          if [ -s "$tmp" ]; then cat "$tmp"; echo "FAIL"; else echo "PASS"; fi; rm -f "$tmp"
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          #!/usr/bin/env bash
          skg_name="ssh_keys"
          skg_id="$(awk -F: -v g="$skg_name" '$1==g{print $3}' /etc/group)"
          while IFS= read -r -d '' f; do
            if file "$f" | grep -Pq ':\s+OpenSSH\s+private\s+key\b'; then
              # Ensure root ownership
              chown root "$f"
              # Prefer ssh_keys group if it exists; otherwise root
              if [ -n "$skg_id" ]; then
                chgrp "$skg_name" "$f" || chgrp root "$f"
              else
                chgrp root "$f"
              fi
              # Make permissions strict (compliant for either group root or ssh_keys)
              chmod u-x,go-rwx "$f"   # results in 0600 (more restrictive than 0640)
            fi
          done < <(find -L /etc/ssh -xdev -type f -print0)
        scored: true

      - id: 5.2.3
        description: "Ensure permissions on SSH public host key files are configured (Automated)"
        audit: |
          pmask=91
          fail=0

          find -L /etc/ssh -xdev -type f -print0 2>/dev/null |
          while IFS= read -r -d '' f; do
            # Only consider OpenSSH public key files
            if file -b "$f" | grep -iq 'openssh.*public key'; then
              mstr=$(stat -Lc '%a' "$f")      # e.g. 644
              mo=$(( 0$mstr ))                # interpret as octal
              uid=$(stat -Lc '%u' "$f")
              gid=$(stat -Lc '%g' "$f")

              bad=0
              [ "$uid" -ne 0 ] && bad=1       # owner must be root
              [ "$gid" -ne 0 ] && bad=1       # group must be root
              [ $(( mo & pmask )) -ne 0 ] && bad=1   # no u+x, g+wx, o+wx

              [ "$bad" -eq 1 ] && fail=1
            fi
          done

          if [ "$fail" -eq 0 ]; then
            echo "ssh_host_pub_keys_ok"
          else
            echo "ssh_host_pub_keys_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_host_pub_keys_ok"
              set: true
        remediation: |
          #!/usr/bin/env bash
          while IFS= read -r -d '' f; do
            if file "$f" | grep -Pq ':\s+OpenSSH\s+(\S+\s+)?public\s+key\b'; then
              chown root:root "$f"
              chmod u-x,go-wx "$f"   # yields 0644 or more restrictive (no exec, no g/o write)
            fi
          done < <(find -L /etc/ssh -xdev -type f -print0)
        scored: true


      - id: 5.2.4
        description: "Ensure SSH access is limited (Automated)"
        audit: |
          host="$(hostname)"
          addr="$(getent ahostsv4 "$host" | awk 'NR==1{print $1}')"

          # Effective (runtime-evaluated) sshd configuration for this context
          runtime_matches="$(sshd -T -C user=root -C host="$host" -C addr="$addr" 2>/dev/null \
            | grep -Pi '^\s*(allow|deny)(users|groups)\s+\S')"

          # Statically present directives in the config file
          file_matches="$(grep -Pi '^\s*(AllowUsers|AllowGroups|DenyUsers|DenyGroups)\s+\S' \
            /etc/ssh/sshd_config 2>/dev/null)"

          if [ -n "$runtime_matches" ] && [ -n "$file_matches" ]; then
            echo "ssh_access_limited_ok"
          else
            echo "ssh_access_limited_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_access_limited_ok"
              set: true
        remediation: |
          # Edit /etc/ssh/sshd_config and configure at least one of the following:
          # (choose what fits your policy)
          #
          # AllowUsers <user1> <user2>
          # AllowGroups <group1> <group2>
          # DenyUsers  <userA> <userB>
          # DenyGroups <groupA> <groupB>
          #
          # Example (allow only specific admins):
          #   AllowGroups ssh-admins
          #
          # Then reload or restart sshd:
          systemctl reload sshd || systemctl restart sshd
        scored: true


      - id: 5.2.5
        description: "Ensure SSH LogLevel is appropriate (Automated)"
        audit: |
          # Effective value must be info or verbose
          addr="$(getent hosts "$(hostname -f)" | awk '{print $1; exit}')"
          addr="${addr:-127.0.0.1}"

          if sshd -T -C user=root -C host="$(hostname -f)" -C addr="$addr" 2>/dev/null \
               | awk 'BEGIN{IGNORECASE=1} $1=="loglevel"{ok=($2=="info"||$2=="verbose")} END{exit ok?0:1}'; then
            eff_ok=1
          else
            eff_ok=0
          fi

          # No explicit disallowed LogLevel anywhere (sshd_config and includes)
          if ! grep -Eqi '^\s*LogLevel\s+(QUIET|FATAL|ERROR|DEBUG[0-9]*)\b' \
                /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null; then
            bad_line=0
          else
            bad_line=1
          fi

          if [ "$eff_ok" -eq 1 ] && [ "$bad_line" -eq 0 ]; then
            echo "ssh_loglevel_ok"
          else
            echo "ssh_loglevel_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_loglevel_ok"
              set: true
        remediation: |
          # Set an appropriate LogLevel in /etc/ssh/sshd_config (prefer VERBOSE for key-fingerprint logging)
          if grep -qi '^\s*LogLevel\s\+' /etc/ssh/sshd_config; then
            sed -ri 's/^\s*LogLevel\s+.*/LogLevel VERBOSE/i' /etc/ssh/sshd_config
          else
            printf '\nLogLevel VERBOSE\n' >> /etc/ssh/sshd_config
          fi

          # Reload or restart sshd to apply
          systemctl reload sshd || systemctl restart sshd
        scored: true


      - id: 5.2.6
        description: "Ensure SSH PAM is enabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*usepam\s+yes$' && \
             ! grep -Psi '^\s*UsePAM\s+no\b' /etc/ssh/sshd_config >/dev/null; then
            echo "ssh_usepam_ok"
          else
            echo "ssh_usepam_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_usepam_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          permitrootlogin yes
        scored: true


      - id: 5.2.7
        description: "Ensure SSH root login is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*permitrootlogin\s+no$' && \
             ! grep -Psi '^\s*PermitRootLogin\s+"?yes\b' /etc/ssh/sshd_config >/dev/null; then
            echo "ssh_rootlogin_disabled"
          else
            echo "ssh_rootlogin_not_disabled"
          fi
        tests:
          test_items:
            - flag: "ssh_rootlogin_disabled"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          permitrootlogin no
        scored: true


      - id: 5.2.8
        description: "Ensure SSH HostbasedAuthentication is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*hostbasedauthentication\s+no$' && \
             ! grep -Psi '^\s*HostbasedAuthentication\s+"?yes\b' /etc/ssh/sshd_config >/dev/null; then
            echo "sshd_hostbased_disabled_ok"
          else
            echo "sshd_hostbased_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_hostbased_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          hostbasedauthentication no
        scored: true


      - id: 5.2.9
        description: "Ensure SSH PermitEmptyPasswords is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*PermitEmptyPasswords\s+no$' && \
             ! grep -Psi '^\s*PermitEmptyPasswords\s+"?yes\b' /etc/ssh/sshd_config >/dev/null; then
            echo "sshd_permitemptypassword_disabled_ok"
          else
            echo "sshd_permitemptypassword_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permitemptypassword_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          PermitEmptyPasswords no
        scored: true

      - id: 5.2.10
        description: "Ensure SSH PermitUserEnvironment is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
               | grep -Piq '^\s*PermitUserEnvironment\s+no$' && \
             ! grep -Psi '^\s*PermitUserEnvironment\s+"?yes\b' /etc/ssh/sshd_config >/dev/null; then
            echo "sshd_userenv_disabled_ok"
          else
            echo "sshd_userenv_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_userenv_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          PermitUserEnvironment no
        scored: true

      - id: 5.2.11
        description: "Ensure sshd IgnoreRhosts is enabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*ignorerhosts\s+yes$'; then
            echo "sshd_ignorerhosts_enabled_ok"
          else
            echo "sshd_ignorerhosts_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_ignorerhosts_enabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
            IgnoreRhosts yes
        scored: true

      - id: 5.2.12
        description: "Ensure sshd X11 forwarding is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*x11forwarding\s+no$'; then
            echo "sshd_x11forwarding_disabled_ok"
          else
            echo "sshd_x11forwarding_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_x11forwarding_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
            x11forwarding no
        scored: true

      - id: 5.2.13
        description: "Ensure sshd AllowTcpForwarding is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*AllowTcpForwarding\s+no$'; then
            echo "sshd_AllowTcpForwarding_disabled_ok"
          else
            echo "sshd_AllowTcpForwarding_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_AllowTcpForwardingg_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
            AllowTcpForwarding no
        scored: true


      - id: 5.2.14
        description: "Ensure system-wide crypto policy is not over-ridden (Automated)"
        audit: |
          grep -i '^\s*CRYPTO_POLICY=' /etc/sysconfig/sshd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following commands:
            # sed -ri "s/^\s*(CRYPTO_POLICY\s*=.*)$/# \1/" /etc/sysconfig/sshd
            # systemctl reload sshd
        scored: true

      - id: 5.2.15
        description: "Ensure SSH warning banner is configured (Automated)"
        audit: |
          sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname)
          /etc/hosts | awk '{print $1}')" | grep banner
        tests:
          test_items:
            - flag: "banner /etc/issue.net"
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
            Banner /etc/issue.net
        scored: true

      - id: 5.2.16
        description: "Ensure SSH MaxAuthTries is is set to 4 or less (Automated)"
        audit: |
          mat_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxauthtries\>/ {print $2}')"
          if [ -n "$mat_val" ] && [ "$mat_val" -le 4 ] && \
             ! grep -Pis '^\h*MaxAuthTries\h+"?([5-9]|[1-9][0-9]+)\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_maxauthtries_ok"
          else
            echo "sshd_maxauthtries_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxauthtries_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
            MaxAuthTries 4
        scored: true

      - id: 5.2.17
        description: "Ensure sshd MaxStartups is configured (Automated)"
        audit: |
          msu_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxstartups\>/ {print $2}')"
          if [ -n "$msu_val" ]; then
            # Extract values in the format "start:rate:full"
            start=$(echo "$msu_val" | cut -d: -f1)
            rate=$(echo "$msu_val" | cut -d: -f2)
            full=$(echo "$msu_val" | cut -d: -f3)

            if [ "$start" -le 10 ] && [ "$rate" -le 30 ] && [ "$full" -le 60 ]; then
              echo "sshd_maxstartups_ok"
            else
              echo "sshd_maxstartups_bad"
            fi
          else
            echo "sshd_maxstartups_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxstartups_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameter as follows:
          MaxStartups 10:30:60
        scored: true

      - id: 5.2.18
        description: "Ensure sshd MaxSessions is set to 10 or less  (Automated)"
        audit: |
          ms_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxsessions\>/ {print $2}')"
          if [ -n "$ms_val" ] && [ "$ms_val" -le 10 ] && \
             ! grep -Pis '^\h*MaxSessions\h+"?(1[1-9]|[2-9][0-9]|[1-9][0-9]{2,})\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_maxsessions_ok"
          else
            echo "sshd_maxsessions_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxsessions_ok"
              set: true
        remediation: |
          Set MaxSessions to 10 or fewer (place above any Match blocks) in /etc/ssh/sshd_config, e.g.:
            MaxSessions 10
        scored: true

      - id: 5.2.19
        description: "Ensure sshd LoginGraceTime is set to one minute or less (Automated)"
        audit: |
          lg_time=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | grep -i '^logingracetime' | awk '{print $2}')
          if [ -n "$lg_time" ] && [ "$lg_time" -ge 1 ] && [ "$lg_time" -le 60 ]; then
            echo "sshd_logingracetime_ok"
          else
            echo "sshd_logingracetime_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_logingracetime_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the LoginGraceTime parameter to a value between 1 and 60 seconds, based on site policy:
            LoginGraceTime 60

          Then reload the SSH daemon:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.2.20
        description: "Ensure SSH Idle Timeout Interval is configured (Automated)"
        audit: |
          interval="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^clientaliveinterval/ {print $2}')"
          countmax="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^clientalivecountmax/ {print $2}')"

          fail=0

          # Interval must be >0
          if [ -n "$interval" ] && [ "$interval" -gt 0 ]; then
            echo "sshd_clientaliveinterval_ok"
          else
            echo "sshd_clientaliveinterval_bad"
            fail=1
          fi

          # CountMax must be >0
          if [ -n "$countmax" ] && [ "$countmax" -gt 0 ]; then
            echo "sshd_clientalivecountmax_ok"
          else
            echo "sshd_clientalivecountmax_bad"
            fail=1
          fi

          if [ $fail -eq 0 ]; then
            echo "sshd_clientalive_ok"
          fi
        tests:
          test_items:
            - flag: "sshd_clientalive_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameters above any Match entries:
            ClientAliveInterval 15
            ClientAliveCountMax 3

          Adjust values according to your site policy to prevent resource exhaustion.

          Then reload sshd to apply changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

  - id: 5.3
    description: "Configure privilege escalation"
    checks:
      - id: 5.3.1
        description: "Ensure sudo is installed (Automated)"
        audit: "rpm -q sudo"
        tests:
          test_items:
            - flag: "package sudo is not installed"
              set: false
        remediation: |
          Run the following command to install sudo

          # dnf install sudo
        scored: true

      - id: 5.3.2
        description: "Ensure sudo commands use pty (Automated)"
        audit: |
          grep -rPi '^\h*Defaults\h+([^#\n\r]+,)?use_pty(,\h*\h+\h*)*\h*(#.*)?$' /etc/sudoers*
        tests:
          test_items:
            - flag: "use_pty"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f
          <PATH_TO_FILE> and add the following line:
          Defaults use_pty
        scored: true

      - id: 5.3.3
        description: "Ensure sudo log file exists (Automated)"
        audit: |
          grep -rPsi "^\h*Defaults\h+([^#]+,\h*)?logfile\h*=\h*(\"|\')?\H+(\"|\')?(,\h*\H+\h*)*\h*(#.*)?$" /etc/sudoers*
        tests:
          test_items:
            - flag: "logfile"
              set: true
        remediation: |
          Edit the file /etc/sudoers or a file in /etc/sudoers.d/ with visudo or visudo -f <PATH
          TO FILE> and add the following line:
          Defaults logfile="<PATH TO CUSTOM LOG FILE>"
          Example
          Defaults logfile="/var/log/sudo.log"
        scored: true

      - id: 5.3.4
        description: "Ensure users must provide password for escalation (Automated)"
        audit: |
          if grep -r "^[^#].*NOPASSWD" /etc/sudoers* 2>/dev/null | grep -vE '^\s*#' >/dev/null; then
            echo "sudo_nopasswd_bad"
          else
            echo "sudo_nopasswd_ok"
          fi
        tests:
          test_items:
            - flag: "sudo_nopasswd_ok"
              set: true
        remediation: |
          Based on the outcome of the audit procedure, use visudo -f <PATH TO FILE> to edit
          the relevant sudoers file.
          Remove any line with occurrences of NOPASSWD tags in the file.
        scored: true

      - id: 5.3.5
        description: "Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
        audit: |
          grep -r "^[^#].*\!authenticate" /etc/sudoers /etc/sudoers.d 2>/dev/null
        tests:
          test_items:
            - flag: "!authenticate"
              set: false
        remediation: |
          Configure the operating system to require users to reauthenticate for privilege
          escalation.
          Based on the outcome of the audit procedure, use visudo -f <PATH TO FILE> to edit
          the relevant sudoers file.
          Remove any occurrences of !authenticate tags in the file(s).
        scored: true

      - id: 5.3.6
        description: "Ensure sudo authentication timeout is configured correctly (Automated)"
        audit: |
          timeout=$(grep -roP "timestamp_timeout=\K-?[0-9]+" /etc/sudoers* 2>/dev/null | head -n 1)

          if [ -z "$timeout" ]; then
            timeout=$(sudo -V | grep -i "Authentication timestamp timeout:" | awk -F ':' '{print $2}' | awk '{print int($1)}')
          fi

          if [ -z "$timeout" ]; then
            echo "timestamp timeout: not set"
          elif [ "$timeout" -le 15 ] && [ "$timeout" -ge 0 ]; then
            echo "timestamp timeout: ok"
          else
            echo "timestamp timeout: bad"
          fi
        tests:
          test_items:
            - flag: "timestamp timeout: ok"
              set: true
        remediation: |
          If the currently configured timeout is larger than 15 minutes, edit the file listed in the
          audit section with visudo -f <PATH TO FILE> and modify the entry timestamp_timeout=
          to 15 minutes or less as per your site policy. The value is in minutes. This particular
          entry may appear on its own, or on the same line as env_reset. See the following two
          examples:
          Defaults env_reset, timestamp_timeout=15
          Defaults timestamp_timeout=15
          Defaults env_reset
        scored: true


      - id: 5.3.7
        description: "Ensure access to the su command is restricted (Automated)"
        audit: |
          su_line="$(grep -Pi '^\h*auth\h+[^#\n\r]+\h+pam_wheel\.so\h+([^#\n\r]+\h+)?(use_uid|group=\H+)\h+([^#\n\r]+\h+)?(use_uid|group=\H+)\b' /etc/pam.d/su 2>/dev/null)"
          if [ -n "$su_line" ]; then
            su_group="$(echo "$su_line" | grep -oP 'group=\K\S+')"
            if [ -n "$su_group" ]; then
              group_users="$(getent group "$su_group" | awk -F: '{print $4}')"
              if [ -z "$group_users" ]; then
                echo "su_restricted_ok"
              else
                echo "su_group_not_empty"
              fi
            else
              echo "su_group_missing"
            fi
          else
            echo "su_not_restricted"
          fi
        tests:
          test_items:
            - flag: "su_restricted_ok"
              set: true
        remediation: |
          Create an empty group that will be specified for use of the su command. The group
          should be named according to site policy.
          Example:
          # groupadd sugroup
          Add the following line to the /etc/pam.d/su file, specifying the empty group:
          auth required pam_wheel.so use_uid group=sugroup
        scored: true


  - id: 5.4
    description: "Configure authselect"
    checks:
      - id: 5.4.1
        description: "Ensure custom authselect profile is used (Manual)"
        audit: |
          authselect list | grep '^-\s*custom'
        type: "manual"
        remediation: |
          Run the following command to create a custom authselect profile:
          # authselect create-profile <custom-profile name> <options>
          Example:
          # authselect create-profile custom-profile -b sssd --symlink-meta
          Run the following command to select a custom authselect profile:
          # authselect select custom/<CUSTOM PROFILE NAME> {with-<OPTIONS>}
          Example:
          # authselect select custom/custom-profile with-sudo with-faillock without-
          nullok
        scored: false

      - id: 5.4.2
        description: "Ensure authselect includes with-faillock (Automated)"
        audit: |
          if command -v authselect >/dev/null 2>&1 && \
             authselect current 2>/dev/null | grep -Piq '\bwith-faillock\b' && \
             grep -Psiq '^\s*auth\s+required\s+pam_faillock\.so\b.*\bpreauth\b' /etc/pam.d/system-auth /etc/pam.d/password-auth && \
             grep -Psiq '^\s*auth\s+required\s+pam_faillock\.so\b.*\bauthfail\b' /etc/pam.d/system-auth /etc/pam.d/password-auth && \
             grep -Psiq '^\s*account\s+required\s+pam_faillock\.so\b'           /etc/pam.d/system-auth /etc/pam.d/password-auth
          then
            echo "authselect_with_faillock_ok"
          else
            echo "authselect_with_faillock_bad"
          fi
        tests:
          test_items:
            - flag: "authselect_with_faillock_ok"
              set: true
        remediation: |
          # Enable the with-faillock feature in the active authselect profile
          authselect enable-feature with-faillock

          # Apply changes to regenerate PAM files
          authselect apply-changes

          # (Optional) If sshd or login services rely on PAM cache, reload them as needed
          # systemctl reload sshd 2>/dev/null || true
        scored: true

      - id: 5.5
        description: "Configure PAM"
        type: "skip"
        checks:
      - id: 5.5.1
        description: "Ensure password creation requirements are configured (Automated)"
        audit: |
          any_present=0
          [ -f /etc/pam.d/system-auth ] && any_present=1
          [ -f /etc/pam.d/password-auth ] && any_present=1
          [ -f /etc/security/pwquality.conf ] && any_present=1
          if [ "$any_present" -eq 0 ]; then
            echo "not_applicable"
            exit 0
          fi

          # PAM must have pam_pwquality with enforce_for_root and retry=3 in BOTH stacks
          pam_ok=1
          for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
            [ -f "$f" ] || { pam_ok=0; continue; }
            line="$(grep -E '^[[:space:]]*password[[:space:]]+requisite[[:space:]]+pam_pwquality\.so' "$f")" || line=""
            printf %s "$line" | grep -q 'enforce_for_root' || pam_ok=0
            printf %s "$line" | grep -q 'retry=3' || pam_ok=0
          done
          [ "$pam_ok" -eq 1 ] && echo "pwq_pam_ok" || echo "pwq_pam_bad"

          # minlen >= 14 in pwquality.conf
          minlen_val="$(awk -F= '/^[[:space:]]*minlen[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);v=$2}END{print v}' /etc/security/pwquality.conf 2>/dev/null)"
          if [ -n "$minlen_val" ] && [ "$minlen_val" -ge 14 ] 2>/dev/null; then
            echo "pwq_minlen_ok"
          else
            echo "pwq_minlen_bad"
          fi

          # Complexity: (minclass>=4) OR (d/u/o/l credits all <= -1)
          minclass_val="$(awk -F= '/^[[:space:]]*minclass[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);v=$2}END{print v}' /etc/security/pwquality.conf 2>/dev/null)"
          dcredit_val="$(awk -F= '/^[[:space:]]*dcredit[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);v=$2}END{print v}' /etc/security/pwquality.conf 2>/dev/null)"
          ucredit_val="$(awk -F= '/^[[:space:]]*ucredit[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);v=$2}END{print v}' /etc/security/pwquality.conf 2>/dev/null)"
          ocredit_val="$(awk -F= '/^[[:space:]]*ocredit[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);v=$2}END{print v}' /etc/security/pwquality.conf 2>/dev/null)"
          lcredit_val="$(awk -F= '/^[[:space:]]*lcredit[[:space:]]*=/{gsub(/[[:space:]]/,"",$2);v=$2}END{print v}' /etc/security/pwquality.conf 2>/dev/null)"

          complexity_ok=0
          if [ -n "$minclass_val" ] && [ "$minclass_val" -ge 4 ] 2>/dev/null; then
            complexity_ok=1
          elif [ -n "$dcredit_val" ] && [ -n "$ucredit_val" ] && [ -n "$ocredit_val" ] && [ -n "$lcredit_val" ] && \
               [ "$dcredit_val" -le -1 ] 2>/dev/null && [ "$ucredit_val" -le -1 ] 2>/dev/null && \
               [ "$ocredit_val" -le -1 ] 2>/dev/null && [ "$lcredit_val" -le -1 ] 2>/dev/null; then
            complexity_ok=1
          fi

          if [ "$complexity_ok" -eq 1 ]; then
            echo "pwq_complexity_ok"
          else
            echo "pwq_complexity_bad"
          fi
        tests:
          test_items:
            - bin_op: "and"
              items:
                - flag: "pwq_pam_ok"
                  set: true
                - flag: "pwq_minlen_ok"
                  set: true
                - flag: "pwq_complexity_ok"
                  set: true
        remediation: |
          # Enforce length and complexity in /etc/security/pwquality.conf
          awk -i inplace '
            BEGIN{set_minlen=0; set_minclass=0; set_d=0; set_u=0; set_o=0; set_l=0}
            /^[[:space:]]*minlen[[:space:]]*=/   {print "minlen = 14"; set_minlen=1; next}
            /^[[:space:]]*minclass[[:space:]]*=/ {print "minclass = 4"; set_minclass=1; next}
            /^[[:space:]]*dcredit[[:space:]]*=/  {print "dcredit = -1"; set_d=1; next}
            /^[[:space:]]*ucredit[[:space:]]*=/  {print "ucredit = -1"; set_u=1; next}
            /^[[:space:]]*ocredit[[:space:]]*=/  {print "ocredit = -1"; set_o=1; next}
            /^[[:space:]]*lcredit[[:space:]]*=/  {print "lcredit = -1"; set_l=1; next}
            {print}
            END{
              if(!set_minlen)   print "minlen = 14";
              # Prefer minclass policy; alternatively ensure all four credits are -1
              if(!set_minclass) print "minclass = 4";
              # If you prefer explicit credits instead of minclass, uncomment below:
              # if(!set_d) print "dcredit = -1";
              # if(!set_u) print "ucredit = -1";
              # if(!set_o) print "ocredit = -1";
              # if(!set_l) print "lcredit = -1";
            }
          ' /etc/security/pwquality.conf

          # Ensure pam_pwquality in PAM stacks includes enforce_for_root and retry=3
          for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
            if grep -Eiq '^[[:space:]]*password[[:space:]]+requisite[[:space:]]+pam_pwquality\.so\b' "$f"; then
              sed -ri '/^[[:space:]]*password[[:space:]]+requisite[[:space:]]+pam_pwquality\.so\b/{
                s/\<retry=[0-9]+\>/retry=3/g;
                /retry=/! s/$/ retry=3/;
                /\benforce_for_root\b/! s/$/ enforce_for_root/;
              }' "$f"
            else
              printf '%s\n' "password    requisite     pam_pwquality.so retry=3 enforce_for_root" >> "$f"
            fi
          done

          # Apply authselect changes if PAM files are managed by authselect
          if command -v authselect >/dev/null 2>&1; then
            authselect apply-changes
          fi
        scored: true

      - id: 5.5.2
        description: "Ensure lockout for failed password attempts is configured (Automated)"
        audit: |
          # Read configured values (first non-comment occurrence)
          deny_val="$(awk -F= '/^[[:space:]]*deny[[:space:]]*=/ {gsub(/[[:space:]]/,"",$2); print $2; exit}' /etc/security/faillock.conf 2>/dev/null)"
          unlock_val="$(awk -F= '/^[[:space:]]*unlock_time[[:space:]]*=/ {gsub(/[[:space:]]/,"",$2); print $2; exit}' /etc/security/faillock.conf 2>/dev/null)"

          # Conditions:
          # - deny in [1..5]
          # - unlock_time == 0 (never) OR >= 900 seconds
          if [ -n "$deny_val" ] && [ "$deny_val" -ge 1 ] 2>/dev/null && [ "$deny_val" -le 5 ] 2>/dev/null \
             && [ -n "$unlock_val" ] && { [ "$unlock_val" -eq 0 ] 2>/dev/null || [ "$unlock_val" -ge 900 ] 2>/dev/null; }; then
            echo "faillock_policy_ok"
          else
            echo "faillock_policy_bad"
          fi
        tests:
          test_items:
            - flag: "faillock_policy_ok"
              set: true
        remediation: |
          # Set lockout policy in /etc/security/faillock.conf (adjust values to site policy if needed)
          if grep -qi '^[[:space:]]*deny[[:space:]]*=' /etc/security/faillock.conf; then
            sed -ri 's/^[[:space:]]*deny[[:space:]]*=.*/deny = 5/' /etc/security/faillock.conf
          else
            printf '\ndeny = 5\n' >> /etc/security/faillock.conf
          fi

          if grep -qi '^[[:space:]]*unlock_time[[:space:]]*=' /etc/security/faillock.conf; then
            sed -ri 's/^[[:space:]]*unlock_time[[:space:]]*=.*/unlock_time = 900/' /etc/security/faillock.conf
          else
            printf 'unlock_time = 900\n' >> /etc/security/faillock.conf
          fi
        scored: true

      - id: 5.5.3
        description: "Ensure password reuse is limited (Automated)"
        audit: |
          # Check PAM for remember >= 5 on either pam_pwhistory.so (preferred) or pam_unix.so
          files=""
          for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
            [ -f "$f" ] && files="$files $f"
          done

          if [ -z "$files" ]; then
            echo "reuse_policy_bad"
            exit 0
          fi

          # Accept if pam_pwhistory.so has remember >= 5
          if grep -Pqs '^\h*password\h+(requisite|required|sufficient)\h+pam_pwhistory\.so(\h+\S+)*\h+remember=([5-9]|[1-9]\d+)\b' $files; then
            echo "reuse_policy_ok"
          # Otherwise accept if pam_unix.so has remember >= 5 (some sites use this instead)
          elif grep -Pqs '^\h*password\h+(requisite|required|sufficient)\h+pam_unix\.so(\h+\S+)*\h+remember=([5-9]|[1-9]\d+)\b' $files; then
            echo "reuse_policy_ok"
          else
            echo "reuse_policy_bad"
          fi
        tests:
          test_items:
            - flag: "reuse_policy_ok"
              set: true
        remediation: |
          # Prefer pam_pwhistory with remember=5 or more via authselect-managed profile
          prof="$(awk 'NR==1{print}' /etc/authselect/authselect.conf 2>/dev/null | grep -o 'custom/[^/]\\+' || true)"
          if [ -n "$prof" ] && [ -f "/etc/authselect/$prof/system-auth" ]; then
            file="/etc/authselect/$prof/system-auth"
            # Ensure pam_pwhistory line exists and has remember >= 5
            if grep -Pq '^\h*password\h+(requisite|required|sufficient)\h+pam_pwhistory\.so\b' "$file"; then
              if grep -Pq '^\h*password\h+(requisite|required|sufficient)\h+pam_pwhistory\.so(\h+\S+)*\h+remember=\d+\b' "$file"; then
                sed -ri 's/^(\\s*password\\s+(requisite|required|sufficient)\\s+pam_pwhistory\\.so(\\s+[^#\\n]+)?\\s)remember=\\d+(\\s.*)?$/\\1remember=5\\4/' "$file"
              else
                sed -ri '/^\\s*password\\s+(requisite|required|sufficient)\\s+pam_pwhistory\\.so/ s/$/ remember=5/' "$file"
              fi
            else
              # Insert a sane pam_pwhistory line before pam_unix
              sed -ri '/^\\s*password\\s+(requisite|required|sufficient)\\s+pam_unix\\.so/ i password required pam_pwhistory.so remember=5 use_authtok' "$file"
            fi
            authselect apply-changes
          else
            # Directly edit PAM stack if not using an authselect custom profile
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              [ -f "$f" ] || continue
              if grep -Pq '^\h*password\h+(requisite|required|sufficient)\h+pam_pwhistory\.so\b' "$f"; then
                if grep -Pq '^\h*password\h+(requisite|required|sufficient)\h+pam_pwhistory\.so(\h+\S+)*\h+remember=\d+\b' "$f"; then
                  sed -ri 's/^(\\s*password\\s+(requisite|required|sufficient)\\s+pam_pwhistory\\.so(\\s+[^#\\n]+)?\\s)remember=\\d+(\\s.*)?$/\\1remember=5\\4/' "$f"
                else
                  sed -ri '/^\\s*password\\s+(requisite|required|sufficient)\\s+pam_pwhistory\\.so/ s/$/ remember=5/' "$f"
                fi
              else
                sed -ri '/^\\s*password\\s+(requisite|required|sufficient)\\s+pam_unix\\.so/ i password required pam_pwhistory.so remember=5 use_authtok' "$f"
              fi
            done
          fi
        scored: true

      - id: 5.5.4
        description: "Ensure password hashing algorithm is SHA-512 or yescrypt (Automated)"
        audit: |
          # Verify that the password hashing algorithm is SHA-512 or yescrypt
          if grep -Eq '^[[:space:]]*crypt_style[[:space:]]*=[[:space:]]*(sha512|yescrypt)' /etc/libuser.conf && \
             grep -Eq '^[[:space:]]*ENCRYPT_METHOD[[:space:]]+(SHA512|yescrypt)' /etc/login.defs && \
             grep -Eq '^[[:space:]]*password[[:space:]]+(requisite|required|sufficient)[[:space:]]+pam_unix\.so.*(sha512|yescrypt)' /etc/pam.d/system-auth && \
             grep -Eq '^[[:space:]]*password[[:space:]]+(requisite|required|sufficient)[[:space:]]+pam_unix\.so.*(sha512|yescrypt)' /etc/pam.d/password-auth; then
            echo "password_hash_ok"
          else
            echo "password_hash_bad"
          fi
        tests:
          test_items:
            - flag: "password_hash_ok"
              set: true
        remediation: |
          # Set password hashing algorithm to SHA-512
          # 1. Edit /etc/libuser.conf
          if grep -q "^crypt_style" /etc/libuser.conf; then
            sed -i 's/^crypt_style.*/crypt_style = sha512/' /etc/libuser.conf
          else
            echo "crypt_style = sha512" >> /etc/libuser.conf
          fi

          # 2. Edit /etc/login.defs
          if grep -q "^ENCRYPT_METHOD" /etc/login.defs; then
            sed -i 's/^ENCRYPT_METHOD.*/ENCRYPT_METHOD SHA512/' /etc/login.defs
          else
            echo "ENCRYPT_METHOD SHA512" >> /etc/login.defs
          fi

          # 3. Update PAM configuration files
          for file in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
            if grep -Eq 'pam_unix\.so.*(md5|blowfish|bigcrypt|sha256|yescrypt)' "$file"; then
              sed -i -E 's/(md5|blowfish|bigcrypt|sha256|yescrypt)/sha512/' "$file"
            elif grep -Eq 'pam_unix\.so(?!.*sha512)' "$file"; then
              sed -i -E 's/(pam_unix\.so)/\1 sha512/' "$file"
            fi
          done

          # 4. Apply authselect changes if applicable
          if command -v authselect >/dev/null 2>&1; then
            authselect apply-changes
          fi

          # (Optional) Force users to reset passwords after applying changes:
          # awk -F: -v UMIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)" '($3>=UMIN && $1!="nfsnobody"){print $1}' /etc/passwd | xargs -r -n1 chage -d 0
        scored: true

  - id: 5.6
    description: "User Accounts and Environment"
    checks:
      - id: 5.6.1
        description: "Set shadow password suite parameters"
        type: "skip"
        checks:

      - id: 5.6.1.1
        description: "Ensure password expiration is 365 days or less (Automated)"
        audit: |
          val="$(awk '/^\s*PASS_MAX_DAYS/ && $1 == "PASS_MAX_DAYS" {print $2}' /etc/login.defs)"
          if [ -n "$val" ] && [ "$val" -le 365 ]; then
            echo "PASS_MAX_DAYS_OK:$val"
          else
            echo "PASS_MAX_DAYS_BAD:${val:-unset}"
          fi
        tests:
          test_items:
            - flag: "PASS_MAX_DAYS_OK"
              set: true
        remediation: |
          1. Set system-wide password max age in `/etc/login.defs`:
             ```
             PASS_MAX_DAYS 365
             ```

          2. Apply to all users with existing passwords:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $5 > 365) { print $1 }' /etc/shadow); do
               chage --maxdays 365 "$user"
             done
             ```
        scored: true

      - id: 5.6.1.2
        description: "Ensure  minimum days between password changes is configured (Automated)"
        audit: |
          val="$(awk '/^\s*PASS_MIN_DAYS/ && $1 == "PASS_MIN_DAYS" {print $2}' /etc/login.defs)"
          if [ -n "$val" ] && [ "$val" -ge 1 ]; then
            echo "PASS_MIN_DAYS_OK:$val"
          else
            echo "PASS_MIN_DAYS_BAD:${val:-unset}"
          fi
        tests:
          test_items:
            - flag: "PASS_MIN_DAYS_OK"
              set: true
        remediation: |
          Set the PASS_MIN_DAYS parameter to 1 in /etc/login.defs:
          PASS_MIN_DAYS 1
          Modify user parameters for all users with a password set to match:
          # chage --mindays 1 <user>
        scored: true

      - id: 5.6.1.3
        description: "Ensure password expiration warning days is 7 or more (Automated)"
        audit: |
          val="$(awk '/^\s*PASS_WARN_AGE/ && $1 == "PASS_WARN_AGE" {print $2}' /etc/login.defs)"
          if [ -n "$val" ] && [ "$val" -ge 7 ]; then
            echo "PASS_WARN_AGE_OK:$val"
          else
            echo "PASS_WARN_AGE_BAD:${val:-unset}"
          fi
        tests:
          test_items:
            - flag: "PASS_WARN_AGE_OK"
              set: true
        remediation: |
          1. Set global warning age in `/etc/login.defs`:
             ```
             PASS_WARN_AGE 7
             ```

          2. Fix user-specific values:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $6 < 7) { print $1 }' /etc/shadow); do
               chage --warndays 7 "$user"
             done
             ```
        scored: true

      - id: 5.6.1.4
        description: "Ensure inactive password lock is 30 days or less (Automated)"
        audit: |
          useradd -D | grep INACTIVE
        tests:
          test_items:
            - flag: "INACTIVE"
              compare:
                op: lte
                value: 30
            - flag: "INACTIVE"
              compare:
                op: gte
                value: 0
        remediation: |
          Run the following command to set the default password inactivity period to 30 days:
          # useradd -D -f 30
          Modify user parameters for all users with a password set to match:
          # chage --inactive 30 <user>
        scored: true

      - id: 5.6.1.5
        description: "Ensure all users last password change date is in the past (Automated)"
        audit: |
          awk -F: '/^[^:]+:[^!*]/{print $1}' /etc/shadow | while read -r usr; \
          do change=$(date -d "$(chage --list $usr | grep '^Last password change' | cut
          -d: -f2 | grep -v 'never$')" +%s); \
          if [[ "$change" -gt "$(date +%s)" ]]; then \
          echo "User: \"$usr\" last password change was \"$(chage --list $usr | grep
          '^Last password change' | cut -d: -f2)\""; fi; done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Investigate any users with a password change date in the future and correct them.
          Locking the account, expiring the password, or resetting the password manually may be
          appropriate.
        scored: true

      - id: 5.6.2
        description: "Ensure system accounts are secured (Automated)"
        audit: |
          #!/bin/sh
          # Verify system accounts use nologin and that nologin accounts are locked

          # If core files are missing, not applicable
          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/login.defs ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # 1) System accounts (UID < UID_MIN or 65534), excluding root/halt/sync/shutdown/nfsnobody, must use nologin
          sys_viol_cnt="$(awk -F: -v U="$UID_MIN" '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<U || $3==65534) && $7!~/^(\/usr)?\/sbin\/nologin$/){print $1}' /etc/passwd | wc -l)"
          if [ "$sys_viol_cnt" -eq 0 ]; then
            echo "sysacct_shell_ok"
          else
            echo "sysacct_shell_bad"
          fi

          # 2) Accounts with nologin shell must be password-locked (passwd -S shows L or LK)
          nologin_unlocked_cnt="$(
            awk -F: '$7~/^(\/usr)?\/sbin\/nologin$/{print $1}' /etc/passwd \
            | xargs -r -n1 passwd -S 2>/dev/null \
            | awk '($2!="L" && $2!="LK"){c++} END{print c+0}'
          )"
          if [ "$nologin_unlocked_cnt" -eq 0 ]; then
            echo "nologin_locked_ok"
          else
            echo "nologin_locked_bad"
          fi
        tests:
          test_items:
            - flag: "sysacct_shell_ok"
              set: true
            - flag: "nologin_locked_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Set nologin for system accounts that should not have interactive shells and lock nologin accounts

          NL="$(command -v nologin 2>/dev/null || echo /sbin/nologin)"
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # 1) Assign nologin to system accounts with improper shells
          awk -F: -v U="$UID_MIN" '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<U || $3==65534) && $7!~/^(\/usr)?\/sbin\/nologin$/){print $1}' /etc/passwd \
            | xargs -r -n1 sh -c 'usermod -s "'"$NL"'" "$0"'

          # 2) Lock all accounts that already use nologin but are not locked
          awk -F: '$7~/^(\/usr)?\/sbin\/nologin$/{print $1}' /etc/passwd \
            | xargs -r -n1 sh -c '
                st="$(passwd -S "$0" 2>/dev/null | awk "{print \$2}")"
                [ "$st" = "L" ] || [ "$st" = "LK" ] || usermod -L "$0"
              '
        scored: true

      - id: 5.6.3
        description: "Ensure default user shell timeout is 900 seconds or less (Automated)"
        audit: |
          #!/bin/sh
          # Verify TMOUT <= 900 is set, readonly, exported, and no conflicting higher/zero values exist

          # Identify candidate config files
          [ -f /etc/bashrc ] && BRC="/etc/bashrc"
          FILES="/etc/profile /etc/profile.d/*.sh $BRC"

          any_present=0
          for f in $FILES; do
            [ -e "$f" ] && { any_present=1; break; }
          done
          [ "$any_present" -eq 0 ] && { echo "not_applicable"; exit 0; }

          # Pattern for acceptable TMOUT values (1..900)
          OKVAL='([1-9]|[1-9][0-9]|[1-8][0-9][0-9]|900)'

          # Find a file that sets TMOUT <=900, marks it readonly, and exports it
          found=""
          for f in $FILES; do
            [ -e "$f" ] || continue
            if grep -Eq "^[[:space:]]*TMOUT=${OKVAL}([[:space:];]|\$)" "$f" \
              && grep -Eq "^[[:space:]]*readonly[[:space:]]+TMOUT([[:space:];]|\$|=${OKVAL})" "$f" \
              && grep -Eq "^[[:space:]]*export[[:space:]]+TMOUT([[:space:];]|\$|=${OKVAL})" "$f"; then
              found="$f"
            fi
          done

          # Detect any bad TMOUT definitions: 0 or >900 anywhere
          bad=0
          if grep -Eqs "^[[:space:]]*TMOUT=(0|9[1-9][0-9]|9[0-9][1-9]|[1-9][0-9]{3,})([[:space:];]|\$)" /etc/profile /etc/profile.d/*.sh ${BRC:+$BRC}; then
            bad=1
          fi

          # Final result
          if [ -n "$found" ] && [ "$bad" -eq 0 ]; then
            echo "tmout_ok"
          else
            echo "tmout_bad"
          fi
        tests:
          test_items:
            - flag: "tmout_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Configure system-wide TMOUT=900, make it readonly and exported, and remove conflicting settings

          set -e

          # 1) Create a dedicated policy file
          POL="/etc/profile.d/99-tmout.sh"
          umask 022
          cat > "$POL" <<'EOF'
          # Enforce idle shell timeout (CIS 5.6.3)
          TMOUT=900
          readonly TMOUT
          export TMOUT
          EOF

          # 2) Remove or neutralize conflicting TMOUT definitions (0 or >900) in common files
          for f in /etc/profile /etc/bashrc /etc/profile.d/*.sh; do
          [ -e "$f" ] || continue
          # Replace invalid values with a comment noting correction
          sed -i -E 's/^[[:space:]]*TMOUT=(0|9[1-9][0-9]|9[0-9][1-9]|[1-9][0-9]{3,})([[:space:];]*)(.*)$/# Replaced by 99-tmout.sh: \0/' "$f"
          done
        scored: true

      - id: 5.6.4
        description: "Ensure default group for the root account is GID 0 (Automated)"
        audit: |
          # Verify root user's primary group ID (GID) is 0
          root_gid="$(awk -F: '$1=="root"{print $4}' /etc/passwd 2>/dev/null)"
          if [ "$root_gid" = "0" ]; then
            echo "root_gid0_ok"
          else
            echo "root_gid0_bad (current_gid=$root_gid)"
          fi
        tests:
          test_items:
            - flag: "root_gid0_ok"
              set: true
        remediation: |
          Run the following command to set the root account default group to GID 0 :
          # usermod -g 0 root
        scored: true

      - id: 5.6.5
        description: "Ensure default user umask is 027 or more restrictive (Automated)"
        audit: |
          #!/bin/sh
          # Verify a secure default umask (027 or more restrictive) is enforced and no weaker umask exists

          # Gather candidate files
          BRC=""; [ -f /etc/bashrc ] && BRC="/etc/bashrc"
          FILES="/etc/login.defs /etc/profile /etc/profile.d/*.sh $BRC /etc/bashrc* /etc/profile*"

          # If nothing relevant exists, not applicable
          any_present=0
          for f in /etc/login.defs /etc/profile /etc/profile.d/*.sh $BRC; do
            [ -e "$f" ] && { any_present=1; break; }
          done
          [ "$any_present" -eq 0 ] && { echo "not_applicable"; exit 0; }

          ok=0

          # Route A: pam_umask with login.defs policy (UMASK 0?[0-7][2-7]7 and USERGROUPS_ENAB no) present AND pam_umask in both PAM stacks
          if grep -Eiq '^[[:space:]]*UMASK[[:space:]]+0?[0-7][2-7]7([[:space:]]|$)' /etc/login.defs \
             && grep -Eiq '^[[:space:]]*USERGROUPS_ENAB[[:space:]]*"?no"?([[:space:]]|$)' /etc/login.defs \
             && grep -Eiq '^[[:space:]]*session[[:space:]]+(optional|requisite|required)[[:space:]]+pam_umask\.so([[:space:]]|$)' /etc/pam.d/system-auth \
             && grep -Eiq '^[[:space:]]*session[[:space:]]+(optional|requisite|required)[[:space:]]+pam_umask\.so([[:space:]]|$)' /etc/pam.d/password-auth
          then
            ok=1
          fi

          # Route B: System-wide shell config sets secure umask via UMASK or umask command
          if grep -REiq '(^|^[^#]*)[[:space:]](UMASK|umask)[[:space:]]+0?[0-7][2-7]7([[:space:]]|$)' /etc/profile* /etc/bashrc* /etc/profile.d/*.sh 2>/dev/null; then
            ok=1
          fi

          # Detect any less-restrictive umask definitions system-wide (octal or symbolic)
          if grep -REqi '(^|^[^#]*)[[:space:]]*umask[[:space:]]+([0-7][0-7][01][0-7]|[0-7][0-7][0-7][0-6]|[0-7][01][0-7]|[0-7][0-7][0-6]|(u=[rwx]{0,3},)?(g=[rwx]{0,3},)?o=[rwx]+|(u=[rwx]{1,3},)?g=[^rx]{1,3}(,o=[rwx]{0,3})?)' /etc/login.defs /etc/profile* /etc/bashrc* /etc/profile.d/*.sh 2>/dev/null; then
            weak=1
          else
            weak=0
          fi

          # Final result
          if [ "$ok" -eq 1 ] && [ "$weak" -eq 0 ]; then
            echo "umask_ok"
          else
            echo "umask_bad"
          fi
        tests:
          test_items:
            - flag: "umask_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Configure a secure default umask (027) and remove weaker settings

          set -e

          # 1) Enforce via login.defs and pam_umask (preferred, uniform across sessions)
          if grep -Eq '^[[:space:]]*UMASK[[:space:]]+' /etc/login.defs; then
            sed -i -E 's/^[[:space:]]*UMASK[[:space:]]+.*/UMASK 027/' /etc/login.defs
          else
            printf '\nUMASK 027\n' >> /etc/login.defs
          fi
          if grep -Eq '^[[:space:]]*USERGROUPS_ENAB[[:space:]]+' /etc/login.defs; then
            sed -i -E 's/^[[:space:]]*USERGROUPS_ENAB[[:space:]]+.*/USERGROUPS_ENAB no/' /etc/login.defs
          else
            printf 'USERGROUPS_ENAB no\n' >> /etc/login.defs
          fi
          for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
            [ -f "$f" ] || continue
            grep -Eq '^[[:space:]]*session[[:space:]]+(optional|requisite|required)[[:space:]]+pam_umask\.so' "$f" || \
              printf '%s\n' 'session     optional     pam_umask.so' >> "$f"
          done

          # 2) Also set a shell-level default (covers shells reading profiles)
          POL="/etc/profile.d/99-umask.sh"
          umask 022 2>/dev/null || true
          umask 027 2>/dev/null || true
          umask_line='umask 027'
          umask 2>/dev/null
          umask 027 2>/dev/null || true
          umask 027 2>/dev/null || true
          umask 027 2>/dev/null || true
          umask 027 2>/dev/null || true
          umask 027 2>/dev/null || true
          umask 027 2>/dev/null || true
          cat > "$POL" <<'EOF'
          # Enforce secure default umask (CIS 5.6.5)
          umask 027
          EOF
          chmod 0644 "$POL"

          # 3) Neutralize weaker umask settings in system-wide profiles
          BAD_RE='(^|^[^#]*)[[:space:]]*umask[[:space:]]+([0-7][0-7][01][0-7]|[0-7][0-7][0-7][0-6]|[0-7][01][0-7]|[0-7][0-7][0-6]|(u=[rwx]{0,3},)?(g=[rwx]{0,3},)?o=[rwx]+|(u=[rwx]{1,3},)?g=[^rx]{1,3}(,o=[rwx]{0,3})?)'
          for f in /etc/login.defs /etc/profile /etc/bashrc /etc/profile.d/*.sh; do
          [ -e "$f" ] || continue
          # Comment out weaker umask definitions; leave the new policy file in effect
          if grep -Eq "$BAD_RE" "$f"; then
          sed -i -E "s/$BAD_RE/# Replaced by 99-umask.sh: &/I" "$f"
          fi
          done

          # Note: Users may still override umask in their personal dotfiles; review as per local policy.
        scored: true

      - id: 5.6.6
        description: "Ensure root password is set (Automated)"
        audit: |
          # Check root account password status
          if passwd -S root 2>/dev/null | grep -Poi 'Password\s+set\b' >/dev/null; then
            echo "root_password_set_ok"
          else
            echo "root_password_set_bad"
          fi
        tests:
          test_items:
            - flag: "root_password_set_ok"
              set: true
        remediation: |
          Set the root password with:
          # passwd root
        scored: true

  - id: 6
    description: "System Maintenance"
    checks:
  - id: 6.1
    description: "System File Permissions"
    checks:
      - id: 6.1.1
        description: "Ensure permissions on /etc/passwd are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/passwd:
          # chmod u-x,go-wx /etc/passwd
          # chown root:root /etc/passwd
        scored: true

      - id: 6.1.2
        description: "Ensure permissions on /etc/passwd- are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd- 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/passwd-:
          # chmod u-x,go-wx /etc/passwd-
          # chown root:root /etc/passwd-
        scored: true


      - id: 6.1.3
        description: "Ensure permissions on /etc/group are configured (Automated)"
        audit: |
          mode_str="$(stat -Lc '%a' /etc/group 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group
          on /etc/group:
          # chmod u-x,go-wx /etc/group
          # chown root:root /etc/group
        scored: true


      - id: 6.1.4
        description: "Ensure permissions on /etc/group- are configured (Automated)"
        audit: |
          # Expect: group <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/group- 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group-:

          chmod u-x,go-wx /etc/group-
          chown root:root /etc/group-
        scored: true

      - id: 6.1.5
        description: "Ensure permissions on /etc/shadow are configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          # Correct ownership and permissions for /etc/shadow
          chown root:root /etc/shadow
          chmod 0000 /etc/shadow
        scored: true

      - id: 6.1.6
        description: "Ensure permissions on /etc/shadow- are configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow-:

          # chown root:root /etc/shadow-
          # chmod 0000 /etc/shadow-
        scored: true

      - id: 6.1.7
        description: "Ensure permissions on /etc/gshadow are configured (Automated)"
        audit: |
          # Expected: /etc/gshadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/gshadow ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow:

          # chown root:root /etc/gshadow
          # chmod 0000 /etc/gshadow
        scored: true

      - id: 6.1.8
        description: "Ensure permissions on /etc/gshadow- are configured (Automated)"
        audit: |
          # Expected: /etc/gshadow- owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/gshadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow-:

          # chown root:root /etc/gshadow-
          # chmod 0000 /etc/gshadow-
        scored: true

      - id: 6.1.9
        description: "Ensure no world writable files exist (Automated)"
        audit: |
          command -v df >/dev/null 2>&1 || { echo "not_applicable"; exit 0; }

          # Collect mount points: prefer local filesystems; fall back to all
          MP="$(df --local -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || MP="$(df -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || { echo "not_applicable"; exit 0; }

          # Probe for at least one world-writable file quickly (-quit after first hit)
          hit="$(printf '%s\n' $MP | xargs -r -I{} find '{}' -xdev -type f -perm -0002 -print -quit 2>/dev/null)"

          if [ -z "$hit" ]; then
            echo "world_writable_files_ok"
          else
            echo "world_writable_files_bad"
          fi
        tests:
          test_items:
            - flag: "world_writable_files_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Remove world-writable permission from regular files on local filesystems

          command -v df >/dev/null 2>&1 || exit 0
          MP="$(df --local -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || MP="$(df -P 2>/dev/null | awk 'NR>1{print $6}')"

          # List all world-writable files and remove 'other write' bit
          printf '%s\n' $MP \
            | xargs -r -I{} find '{}' -xdev -type f -perm -0002 -print 2>/dev/null \
            | while IFS= read -r f; do
                chmod o-w "$f" 2>/dev/null || true
              done

          # Note: Review vendor/application guidance before changing permissions for managed files.
        scored: true


      - id: 6.1.10
        description: "Ensure no unowned files or directories exist (Automated)"
        audit: |
          #!/bin/sh
          # Find filesystem objects without a valid user owner (-nouser) on local filesystems

          command -v df >/dev/null 2>&1 || { echo "not_applicable"; exit 0; }

          # Collect mount points: prefer local filesystems; fall back to all
          MP="$(df --local -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || MP="$(df -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || { echo "not_applicable"; exit 0; }

          # Probe for at least one unowned file/dir quickly (-quit after first hit)
          hit="$(printf '%s\n' $MP | xargs -r -I{} find '{}' -xdev -nouser -print -quit 2>/dev/null)"

          if [ -z "$hit" ]; then
            echo "unowned_files_ok"
          else
            echo "unowned_files_bad"
          fi
        tests:
          test_items:
            - flag: "unowned_files_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Reset ownership of unowned files/dirs on local filesystems to a valid account (default: root:root)

          command -v df >/dev/null 2>&1 || exit 0
          OWNER="root:root"  # change to a suitable active user:group if needed

          # Collect mount points
          MP="$(df --local -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || MP="$(df -P 2>/dev/null | awk 'NR>1{print $6}')"

          # List all unowned files/dirs and assign ownership
          printf '%s\n' $MP \
            | xargs -r -I{} find '{}' -xdev -nouser -print 2>/dev/null \
            | while IFS= read -r path; do
                chown "$OWNER" "$path" 2>/dev/null || true
              done

          # Note: Choose appropriate owner(s) per local policy and application requirements.
        scored: true

      - id: 6.1.11
        description: "Ensure no ungrouped files or directories exist (Automated)"
        audit: |
          #!/bin/sh
          # Find filesystem objects without a valid group owner (-nogroup) on local filesystems

          command -v df >/dev/null 2>&1 || { echo "not_applicable"; exit 0; }

          # Collect mount points: prefer local filesystems; fall back to all
          MP="$(df --local -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || MP="$(df -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || { echo "not_applicable"; exit 0; }

          # Probe for at least one ungrouped file/dir quickly (-quit after first hit)
          hit="$(printf '%s\n' $MP | xargs -r -I{} find '{}' -xdev -nogroup -print -quit 2>/dev/null)"

          if [ -z "$hit" ]; then
            echo "ungrouped_files_ok"
          else
            echo "ungrouped_files_bad"
          fi
        tests:
          test_items:
            - flag: "ungrouped_files_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Reset ownership of ungrouped files/dirs on local filesystems to a valid group (default: root:root)

          command -v df >/dev/null 2>&1 || exit 0
          OWNER="root:root"  # change to an appropriate active user:group if needed

          # Collect mount points
          MP="$(df --local -P 2>/dev/null | awk 'NR>1{print $6}')"
          [ -n "$MP" ] || MP="$(df -P 2>/dev/null | awk 'NR>1{print $6}')"

          # List all ungrouped files/dirs and assign ownership
          printf '%s\n' $MP \
            | xargs -r -I{} find '{}' -xdev -nogroup -print 2>/dev/null \
            | while IFS= read -r path; do
                chown "$OWNER" "$path" 2>/dev/null || true
              done

          # Note: Assign group ownership per local policy and ensure compatibility with application requirements.
        scored: true

      - id: 6.1.12
        description: "Ensure sticky bit is set on all world-writable directories (Automated)"
        audit: |
          df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev
          -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set the sticky bit on all world writable directories:
          # df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev
          -type d \( -perm -0002 -a ! -perm -1000 \) 2>/dev/null | xargs -I '{}' chmod
          a+t '{}'
        scored: true


      - id: 6.1.13
        description: "Audit SUID executables (Manual)"
        type: manual
        audit: |
          df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev
          -type f -perm -4000
        remediation: |
          Ensure that no rogue SUID programs have been introduced into the system. Review the
          files returned by the action in the Audit section and confirm the integrity of these
          binaries
        scored: false

      - id: 6.1.14
        description: "Audit SGID executables (Manual)"
        type: manual
        audit: |
          df --local -P | awk '{if (NR!=1) print $6}' | xargs -I '{}' find '{}' -xdev
          -type f -perm -2000
        remediation: |
          Ensure that no rogue SGID programs have been introduced into the system. Review the
          files returned by the action in the Audit section and confirm the integrity of these
          binaries
        scored: false

      - id: 6.1.15
        description: "Audit system file permissions (Manual)"
        type: manual
        remediation: |
          Correct any discrepancies found and rerun the audit until output is clean or risk is
          mitigated or accepted.
        scored: false


  - id: 6.2
    description: "Local User and Group Settings"
    checks:
      - id: 6.2.1
        description: "Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
        audit: |
          awk -F: '($2 != "x" ) { print $1 " is not set to shadowed passwords "}' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set accounts to use shadowed passwords:

          # sed -e 's/^\([a-zA-Z0-9_]*\):[^:]*:/\1:x:/' -i /etc/passwd
            Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off.
        scored: true
      - id: 6.2.2
        description: "Ensure /etc/shadow password fields are not empty (Automated)"
        audit: |
          awk -F: '($2 == "" ) { print $1 " does not have a password "}' /etc/shadow
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:

          # passwd -l <username>
            Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off.
        scored: true


      - id: 6.2.3
        description: "Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
        audit: |
          #!/bin/sh
          # Verify every primary GID in /etc/passwd exists as a group in /etc/group

          [ -f /etc/passwd ] && [ -f /etc/group ] || { echo "not_applicable"; exit 0; }

          findings="$(
            awk -F: '
              FNR==NR { g[$3]=1; next }                 # build set of valid GIDs from /etc/group
              { if ($4 != "" && !( $4 in g )) m[$4]=1 } # collect missing GIDs from /etc/passwd
              END { for (k in m) printf "Group %s is referenced by /etc/passwd but does not exist in /etc/group\n", k }
            ' /etc/group /etc/passwd
          )"

          if [ -z "$findings" ]; then
            echo "passwd_groups_ok"
          else
            echo "passwd_groups_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "passwd_groups_ok"
              set: true
        remediation: |
          #!/bin/sh
          # For each reported missing GID, either create the group with that GID
          # or change affected users to an appropriate existing group.

          # Example: create a missing group with a specific GID
          # groupadd -g <GID> <groupname>

          # Example: change a user’s primary group to an existing group
          # usermod -g <existing_group> <username>

          # Helper to auto-create placeholder groups for all missing GIDs (optional):
          # awk -F: '
          #   FNR==NR { g[$3]=1; next }
          #   { if ($4 != "" && !( $4 in g )) m[$4]=1 }
          #   END { for (k in m) print k }
          # ' /etc/group /etc/passwd | while read -r gid; do
          #   groupadd -g "$gid" "gid$gid" 2>/dev/null || true
          # done

          # Re-run the audit after remediation to confirm no findings remain.
        scored: true


      - id: 6.2.4
        description: "Ensure no duplicate UIDs exist (Automated)"
        audit: |
          #!/bin/sh
          # Verify that all UIDs in /etc/passwd are unique

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }

          findings="$(
            awk -F: '
              { uid[$3]++; users[$3] = users[$3] ? users[$3]" "$1 : $1 }
              END {
                for (u in uid) if (uid[u] > 1)
                  printf "Duplicate UID (%s): %s\n", u, users[u]
              }
            ' /etc/passwd
          )"

          if [ -z "$findings" ]; then
            echo "uid_unique_ok"
          else
            echo "uid_unique_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "uid_unique_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Resolve duplicate UIDs by assigning unique UIDs and fixing ownerships

          # 1) Identify duplicates (for operator review)
          awk -F: '
            { uid[$3]++; users[$3] = users[$3] ? users[$3]" "$1 : $1 }
            END { for (u in uid) if (uid[u] > 1) printf "Duplicate UID (%s): %s\n", u, users[u] }
          ' /etc/passwd

          # 2) For each duplicate set, choose the correct UID per policy, then either:
          #    a) Change the other user(s) to a new unused UID:
          #       usermod -u <NEW_UID> <username>
          #       usermod -g <primary_group> <username>   # if needed
          #    b) Or consolidate accounts as appropriate.

          # 3) Fix filesystem ownerships after changing a UID (example for one user):
          #    OLD_UID=<OLD_UID>
          #    NEW_UID=<NEW_UID>
          #    find / -xdev -uid "$OLD_UID" -exec chown "$NEW_UID" {} + 2>/dev/null

          # 4) Re-run the audit to confirm no duplicate UIDs remain.
        scored: true

      - id: 6.2.5
        description: "Ensure no duplicate GIDs exist (Automated)"
        audit: |
          #!/bin/sh
          # Verify that all GIDs in /etc/group are unique

          [ -f /etc/group ] || { echo "not_applicable"; exit 0; }

          findings="$(
            awk -F: '
              { g[$3]++; names[$3] = names[$3] ? names[$3]" "$1 : $1 }
              END {
                for (gid in g) if (g[gid] > 1)
                  printf "Duplicate GID (%s) in /etc/group: %s\n", gid, names[gid]
              }
            ' /etc/group
          )"

          if [ -z "$findings" ]; then
            echo "gid_unique_ok"
          else
            echo "gid_unique_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "gid_unique_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Resolve duplicate GIDs by assigning unique GIDs and fixing group ownerships

          # 1) List duplicate GIDs for review
          awk -F: '
            { g[$3]++; names[$3] = names[$3] ? names[$3]" "$1 : $1 }
            END { for (gid in g) if (g[gid] > 1) printf "Duplicate GID (%s): %s\n", gid, names[gid] }
          ' /etc/group

          # 2) For each duplicate GID set, choose the correct group to keep the GID.
          #    Change the other group(s) to a new, unused GID. Example:
          #       groupmod -g <NEW_GID> <groupname>

          # 3) Fix filesystem group ownerships after changing a GID (example for one group):
          #    OLD_GID=<OLD_GID>
          #    NEW_GID=<NEW_GID>
          #    find / -xdev -gid "$OLD_GID" -exec chgrp "$NEW_GID" {} + 2>/dev/null

          # 4) Verify no duplicate GIDs remain by re-running the audit.
        scored: true


      - id: 6.2.6
        description: "Ensure no duplicate user names exist (Automated)"
        audit: |
          #!/bin/sh
          # Verify that all login names in /etc/passwd are unique

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }

          findings="$(
            awk -F: '
              { c[$1]++; }
              END {
                for (n in c) if (c[n] > 1)
                  printf "Duplicate login name %s in /etc/passwd\n", n
              }
            ' /etc/passwd
          )"

          if [ -z "$findings" ]; then
            echo "usernames_unique_ok"
          else
            echo "usernames_unique_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "usernames_unique_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Resolve duplicate usernames by renaming duplicates to unique names

          # 1) List duplicates for review
          awk -F: '
            { c[$1]++; }
            END { for (n in c) if (c[n] > 1) printf "Duplicate login name %s in /etc/passwd\n", n }
          ' /etc/passwd

          # 2) For each duplicate, choose a canonical account to keep the name.
          #    Rename other accounts to a unique login, e.g.:
          #       usermod -l <new_login> <old_login>
          #
          #    If you also want the home directory to match the new login:
          #       usermod -d /home/<new_login> -m <new_login>
          #
          #    If the primary group is named after the old login, you may also rename it:
          #       groupmod -n <new_login> <old_group_name>

          # 3) Re-run the audit to verify no duplicate usernames remain.
        scored: true


      - id: 6.2.7
        description: "Ensure no duplicate group names exist (Automated)"
        audit: |
          #!/bin/sh
          # Verify that all group names in /etc/group are unique

          [ -f /etc/group ] || { echo "not_applicable"; exit 0; }

          findings="$(
            awk -F: '
              { c[$1]++ }
              END { for (n in c) if (c[n] > 1) printf "Duplicate group name %s in /etc/group\n", n }
            ' /etc/group
          )"

          if [ -z "$findings" ]; then
            echo "groupnames_unique_ok"
          else
            echo "groupnames_unique_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "groupnames_unique_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Resolve duplicate group names by renaming duplicates to unique names

          # 1) List duplicates for review
          awk -F: '
            { c[$1]++ }
            END { for (n in c) if (c[n] > 1) printf "Duplicate group name %s in /etc/group\n", n }
          ' /etc/group

          # 2) Rename offending groups to unique names (example):
          #    groupmod -n <new_group_name> <old_group_name>
          #
          #    Example placeholder flow (edit NEW name before running in production):
          #    for g in $(awk -F: '{c[$1]++} END{for(n in c) if(c[n]>1) print n}' /etc/group); do
          #      # Choose a unique target name per policy
          #      NEW="${g}_renamed"
          #      # If NEW already exists, pick another unique name
          #      getent group "$NEW" >/dev/null 2>&1 && continue
          #      groupmod -n "$NEW" "$g" 2>/dev/null || true
          #    done

          # 3) Re-run the audit to confirm no duplicate group names remain.
        scored: true


      - id: 6.2.8
        description: "Ensure root PATH Integrity (Automated)"
        audit: |
          #!/bin/sh
          # Verify root's PATH has no empty elements, no trailing colon, no '.', all dirs exist,
          # are owned by root, and are not group/world-writable.

          # Obtain root's PATH: prefer sudo to read root's env; fallback if already root
          if command -v sudo >/dev/null 2>&1; then
            RPCV="$(sudo -Hiu root env 2>/dev/null | awk -F= '/^PATH=/{print substr($0,6)}')"
          elif [ "$(id -u 2>/dev/null)" = "0" ]; then
            RPCV="$PATH"
          else
            echo "not_applicable"
            exit 0
          fi

          [ -n "$RPCV" ] || { echo "root_path_bad"; exit 0; }

          # Quick string checks: empty element (::) and trailing ':'
          echo "$RPCV" | grep -q "::" && { echo "root_path_bad"; exit 0; }
          echo "$RPCV" | grep -q ":$" && { echo "root_path_bad"; exit 0; }

          bad=0
          OLDIFS="$IFS"; IFS=":"
          for x in $RPCV; do
            [ -z "$x" ] && { bad=1; break; }                # empty element
            [ "$x" = "." ] || [ "$x" = "./" ] && { bad=1; break; }  # current dir
            [ -d "$x" ] || { bad=1; break; }                # must exist and be a directory

            # Ownership must be root, and directory not group/world writable
            owner="$(stat -c %U "$x" 2>/dev/null)"
            perms="$(stat -c %a "$x" 2>/dev/null)"
            [ "$owner" = "root" ] || { bad=1; break; }
            [ -n "$perms" ] || { bad=1; break; }
            g=$(( (perms / 10) % 10 ))
            o=$(( perms % 10 ))
            # bit 2 (write) set in group/other digits?
            [ $(( g & 2 )) -eq 0 ] || { bad=1; break; }
            [ $(( o & 2 )) -eq 0 ] || { bad=1; break; }
          done
          IFS="$OLDIFS"

          if [ "$bad" -eq 0 ]; then
            echo "root_path_ok"
          else
            echo "root_path_bad"
          fi
        tests:
          test_items:
            - flag: "root_path_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Remediate root PATH integrity issues: remove '.'/empty elements, fix perms/ownership.

          # 1) Fix directory ownership and permissions for each path component
          if command -v sudo >/dev/null 2>&1; then
            RPCV="$(sudo -Hiu root env 2>/dev/null | awk -F= '/^PATH=/{print substr($0,6)}')"
          elif [ "$(id -u 2>/dev/null)" = "0" ]; then
            RPCV="$PATH"
          else
            RPCV=""
          fi

          if [ -n "$RPCV" ]; then
            IFS=":"; set -- $RPCV; IFS=" "
            for d in "$@"; do
              [ -z "$d" ] && continue
              [ "$d" = "." ] && continue
              [ -d "$d" ] || continue
              chown root:root "$d" 2>/dev/null || true
              chmod go-w "$d" 2>/dev/null || true
            done
          fi

          # 2) Remove '.' and empty elements from root PATH definitions in common profile files
          for f in /root/.bash_profile /root/.profile /root/.bashrc /etc/profile /etc/bashrc /etc/profile.d/*.sh; do
            [ -f "$f" ] || continue
            # Normalize PATH assignments: remove ':.', ':./', leading './', trailing ':' and '::'
            sed -i -E '
              s#(^[[:space:]]*PATH=)(.*)#\1\2#;
              s#(^[[:space:]]*PATH=.*):\.($|:)#\1#g;
              s#(^[[:space:]]*PATH=.*):\./($|:)#\1#g;
              s#(^[[:space:]]*PATH=)\.:#\1#g;
              s#(^[[:space:]]*PATH=.*)::#\1#g;
              s#(^[[:space:]]*PATH=.*):$#\1#;
            ' "$f"
          done

          # 3) If needed, explicitly set a safe PATH for root in /root/.bash_profile
          ROOTPROFILE="/root/.bash_profile"
          if ! grep -Eq '^[[:space:]]*PATH=' "$ROOTPROFILE" 2>/dev/null; then
            umask 022
            printf '%s\n' 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin' >> "$ROOTPROFILE"
            printf '%s\n' 'export PATH' >> "$ROOTPROFILE"
          fi

          # Re-run the audit to confirm "root_path_ok".
        scored: true


      - id: 6.2.9
        description: "Ensure root is the only UID 0 account (Automated)"
        audit: |
          awk -F: '($3 == 0) { print $1 }' /etc/passwd
        tests:
          test_items:
            - flag: "root"
              compare:
                op: eq
                value: "root"
        remediation: |
          Remove any users other than root with UID 0 or assign them a new UID if appropriate.
        scored: true

      - id: 6.2.10
        description: "Ensure local interactive user home directories exist (Automated)"
        audit: |
          #!/bin/sh
          # Verify that all local interactive users have an existing home directory

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build a regex of valid shells from /etc/shells (lines starting with '/')
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          bad=0
          # Extract users with valid interactive shells and UID >= UID_MIN; check home dir exists
          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            [ -d "$home" ] || { bad=1; break; }
          done

          if [ "${bad:-0}" -eq 0 ]; then
            echo "homes_exist_ok"
          else
            echo "homes_exist_bad"
          fi
        tests:
          test_items:
            - flag: "homes_exist_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Create missing home directories for local interactive users and set secure ownership/permissions

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            if [ ! -d "$home" ]; then
              mkdir -p "$home"
              chmod g-w,o-wrx "$home"
              chown "$user" "$home"
            fi
          done
        scored: true

      - id: 6.2.11
        description: "Ensure local interactive users own their home directories (Automated)"
        audit: |
          #!/bin/sh
          # Verify that each local interactive user's home directory is owned by that user

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000 if not defined)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build a regex of valid shells from /etc/shells (absolute paths only)
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          bad=0
          # Users with UID>=UID_MIN, not nfsnobody, and valid interactive shells
          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            # Home must exist and be owned by the user
            [ -d "$home" ] || { bad=1; break; }
            owner="$(stat -L -c %U "$home" 2>/dev/null)"
            [ "$owner" = "$user" ] || { bad=1; break; }
          done

          if [ "${bad:-0}" -eq 0 ]; then
            echo "homes_owned_ok"
          else
            echo "homes_owned_bad"
          fi
        tests:
          test_items:
            - flag: "homes_owned_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Ensure local interactive users own their home directories

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            [ -d "$home" ] || { mkdir -p "$home"; chmod g-w,o-wrx "$home"; }
            # Assign ownership to the correct user
            chown "$user" "$home" 2>/dev/null || true
          done
        scored: true

      - id: 6.2.12
        description: "Ensure local interactive user home directories are mode 750 or more restrictive (Automated)"
        audit: |
          #!/bin/sh
          # Verify that each local interactive user's home directory permissions are 750 or more restrictive

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build regex of valid shells (absolute paths from /etc/shells)
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          perm_mask=0027   # bits that must NOT be present (g+w, o+rwx)
          bad=0

          # Collect candidate users (UID>=UID_MIN, not nfsnobody, valid interactive shell)
          candidates="$(awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1"::"$6}' /etc/passwd)"

          IFS='
          '
              set -f
              for line in $candidates; do
                user=${line%%::*}; home=${line#*::}
                [ -d "$home" ] || { bad=1; break; }
                mode="$(stat -L -c '%#a' "$home" 2>/dev/null)" || { bad=1; break; }  # %#a -> octal like 0750
          # Fail if any forbidden bits are present
          if [ $(( mode & perm_mask )) -gt 0 ]; then
          bad=1
          break
          fi
          done
          set +f
          IFS=' '

          if [ "${bad:-0}" -eq 0 ]; then
          echo "homes_mode_ok"
          else
          echo "homes_mode_bad"
          fi
        tests:
          test_items:
            - flag: "homes_mode_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Set local interactive users' home directory permissions to 750 or more restrictive

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            [ -d "$home" ] || continue
            # Remove group write and all other perms (resulting at most 0750 when base is typical 0755/0700)
            chmod g-w,o-rwx "$home" 2>/dev/null || true
          done
        scored: true
      - id: 6.2.13
        description: "Ensure no local interactive user has .netrc files (Automated)"
        audit: |
          #!/bin/sh
          # Verify that no local interactive user's home contains a .netrc file

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build regex of valid interactive shells from /etc/shells
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          bad=0
          # Iterate local interactive users (UID>=UID_MIN, not nfsnobody) and check for ~/.netrc
          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1"::"$6}' /etc/passwd |
          while IFS= read -r rec; do
            user=${rec%%::*}; home=${rec#*::}
            [ -n "$home" ] || continue
            if [ -f "$home/.netrc" ]; then
              bad=1
              break
            fi
          done

          if [ "${bad:-0}" -eq 0 ]; then
            echo "netrc_absent_ok"
          else
            echo "netrc_present_bad"
          fi
        tests:
          test_items:
            - flag: "netrc_absent_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Remove .netrc files from local interactive users' home directories

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            [ -d "$home" ] || continue
            if [ -f "$home/.netrc" ]; then
              rm -f -- "$home/.netrc" 2>/dev/null || true
            fi
          done

          # If policy exceptionally requires .netrc, ensure strict permissions (600) instead:
          #   chmod 600 "$home/.netrc"
        scored: true

      - id: 6.2.14
        description: "Ensure no local interactive user has .forward files (Automated)"
        audit: |
          #!/bin/sh
          # Verify that no local interactive user's home contains a .forward file

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build regex of valid interactive shells from /etc/shells
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          bad=0
          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" \
            '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1"::"$6}' /etc/passwd |
          while IFS= read -r rec; do
            user=${rec%%::*}; home=${rec#*::}
            [ -n "$home" ] || continue
            [ -f "$home/.forward" ] && { bad=1; break; }
          done

          if [ "${bad:-0}" -eq 0 ]; then
            echo "forward_absent_ok"
          else
            echo "forward_present_bad"
          fi
        tests:
          test_items:
            - flag: "forward_absent_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Remove .forward files from local interactive users' home directories

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" \
            '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            [ -d "$home" ] || continue
            [ -f "$home/.forward" ] && rm -f -- "$home/.forward" 2>/dev/null || true
          done
        scored: true

      - id: 6.2.15
        description: "Ensure no local interactive user has .rhosts files (Automated)"
        audit: |
          #!/bin/sh
          # Verify that no local interactive user's home contains a .rhosts file

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build regex of valid interactive shells from /etc/shells
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          bad=0
          # Check each local interactive user (UID>=UID_MIN, not nfsnobody) for ~/.rhosts
          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" \
            '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1"::"$6}' /etc/passwd |
          while IFS= read -r rec; do
            home=${rec#*::}
            [ -n "$home" ] || continue
            [ -f "$home/.rhosts" ] && { bad=1; break; }
          done

          if [ "${bad:-0}" -eq 0 ]; then
            echo "rhosts_absent_ok"
          else
            echo "rhosts_present_bad"
          fi
        tests:
          test_items:
            - flag: "rhosts_absent_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Remove .rhosts files from local interactive users' home directories

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" \
            '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $1" "$6}' /etc/passwd |
          while read -r user home; do
            [ -d "$home" ] || continue
            [ -f "$home/.rhosts" ] && rm -f -- "$home/.rhosts" 2>/dev/null || true
          done
        scored: true

      - id: 6.2.16
        description: "Ensure local interactive user dot files are not group or world writable (Automated)"
        audit: |
          #!/bin/sh
          # Verify that local interactive users' dot files are not group/world writable (mask 0022)

          [ -f /etc/passwd ] || { echo "not_applicable"; exit 0; }
          [ -f /etc/shells ] || { echo "not_applicable"; exit 0; }

          # Determine UID_MIN (fallback 1000)
          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000

          # Build regex of valid interactive shells (absolute paths from /etc/shells)
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || { echo "not_applicable"; exit 0; }

          # Collect home directories of local interactive users
          HOMES="$(awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" \
            '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $6}' /etc/passwd)"

          # If there are no matching users/homes, not applicable
          [ -n "$HOMES" ] || { echo "not_applicable"; exit 0; }

          # Find any dot file with group/other write bits (perm -0022); stop at first hit
          hit="$(find $HOMES -type f -name '.*' -perm -0022 -print -quit 2>/dev/null)"

          if [ -z "$hit" ]; then
            echo "dotfiles_mode_ok"
          else
            echo "dotfiles_mode_bad"
          fi
        tests:
          test_items:
            - flag: "dotfiles_mode_ok"
              set: true
        remediation: |
          #!/bin/sh
          # Remove group/other write permissions from dot files in local interactive users' homes

          [ -f /etc/passwd ] && [ -f /etc/shells ] || exit 0

          UID_MIN="$(awk '/^[[:space:]]*UID_MIN[[:space:]]/{print $2}' /etc/login.defs 2>/dev/null)"
          [ -n "$UID_MIN" ] || UID_MIN=1000
          shells_re="$(sed -n 's|^\(/.*\)$|\1|p' /etc/shells | sed 's|/|\\/|g' | paste -s -d '|' -)"
          [ -n "$shells_re" ] || exit 0

          HOMES="$(awk -F: -v umin="$UID_MIN" -v re="^(${shells_re})$" \
            '($3>=umin && $1!="nfsnobody" && $NF ~ re){print $6}' /etc/passwd)"

          # For each home, strip group/other write from dot files
          for h in $HOMES; do
            [ -d "$h" ] || continue
            find "$h" -type f -name '.*' -perm -0022 -print 2>/dev/null \
              | while IFS= read -r f; do
                  chmod go-w "$f" 2>/dev/null || true
                done
          done
        scored: true
