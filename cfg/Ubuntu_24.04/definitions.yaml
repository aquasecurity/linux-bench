---
controls:
version: "Ubuntu 24.04 v1.0.0"
id: 1
description: "Initial Setup"
type: "master"
groups:
  - id: 1.1
    description: "Filesystem"
    checks:
      - id: 1.1.1
        description: "Configure Filesystem Kernel Modules"
        type: "skip"
        checks:

      - id: 1.1.1.1
        description: "Ensure cramfs kernel module is not available (Automated)"
        audit: |
          if ! ls -d /lib/modules/*/kernel/fs/cramfs 2>/dev/null | grep -q .; then
            echo "cramfs_ok"
            exit
          fi
          bad=false
          if lsmod | grep -q '^cramfs\b'; then bad=true; fi
          if ! modprobe --showconfig | grep -Pq '\binstall\s+cramfs\s+(/usr)?/bin/(true|false)\b'; then bad=true; fi
          if ! modprobe --showconfig | grep -Pq '\bblacklist\s+cramfs\b'; then bad=true; fi
          if $bad; then
            echo "cramfs_bad"
          else
            echo "cramfs_ok"
          fi
        tests:
          test_items:
            - flag: "cramfs_ok"
              set: true
        remediation: |
          # Disable cramfs module
          echo "install cramfs /bin/false" > /etc/modprobe.d/cramfs.conf
          echo "blacklist cramfs" >> /etc/modprobe.d/cramfs.conf
          # Remove from running kernel if loaded
          modprobe -r cramfs 2>/dev/null
          rmmod cramfs 2>/dev/null
        scored: true

      - id: 1.1.1.2
        description: "Ensure freevxfs kernel module is not available (Automated)"
        audit: |
          mod_path=$(find /lib/modules -type d -path '*/kernel/fs/freevxfs' 2>/dev/null | head -n1)
          if [ -z "$mod_path" ]; then
            echo "freevxfs_ok"
            exit
          fi
          if lsmod | grep -q '^freevxfs'; then
            echo "freevxfs_bad"
            exit
          fi
          if ! modprobe --showconfig | grep -qE '^install\s+freevxfs\s+\/bin\/false'; then
            echo "freevxfs_bad"
            exit
          fi
          if ! modprobe --showconfig | grep -qE '^blacklist\s+freevxfs'; then
            echo "freevxfs_bad"
            exit
          fi
          echo "freevxfs_ok"
        tests:
          test_items:
            - flag: "freevxfs_ok"
              set: true
        remediation: |
          # Disable the freevxfs module if it exists
          if lsmod | grep -q '^freevxfs'; then
            modprobe -r freevxfs 2>/dev/null
            rmmod freevxfs 2>/dev/null
          fi
          # Ensure install directive points to /bin/false
          if ! grep -qE '^install\s+freevxfs\s+\/bin\/false' /etc/modprobe.d/freevxfs.conf 2>/dev/null; then
            echo "install freevxfs /bin/false" > /etc/modprobe.d/freevxfs.conf
          fi
          # Ensure the module is blacklisted
          if ! grep -qE '^blacklist\s+freevxfs' /etc/modprobe.d/freevxfs.conf 2>/dev/null; then
            echo "blacklist freevxfs" >> /etc/modprobe.d/freevxfs.conf
          fi
          # Reload kernel modules
          # systemctl reload-or-try-restart systemd-modules-load.service
        scored: true

      - id: 1.1.1.3
        description: "Ensure hfs kernel module is not available (Automated)"
        audit: |
          if ! find /lib/modules/*/kernel/fs/hfs -type f 2>/dev/null | grep -q .; then
            echo "hfs_module_ok"
            exit 0
          fi
          if lsmod | grep -q '^hfs '; then
            echo "hfs_module_bad"
            exit 0
          fi
          if ! modprobe -n -v hfs 2>/dev/null | grep -q 'install hfs /bin/false'; then
            echo "hfs_module_bad"
            exit 0
          fi
          if ! grep -R -q '^blacklist hfs' /etc/modprobe.d/*; then
            echo "hfs_module_bad"
            exit 0
          fi
          echo "hfs_module_ok"
        tests:
          test_items:
            - flag: "hfs_module_ok"
              set: true
        remediation: |
          # Disable the hfs kernel module
          # Create a configuration file to prevent loading
          echo "install hfs /bin/false" > /etc/modprobe.d/hfs.conf
          echo "blacklist hfs" >> /etc/modprobe.d/hfs.conf
          # Unload the module if it is currently loaded
          modprobe -r hfs 2>/dev/null
          rmmod hfs 2>/dev/null
        scored: true

      - id: 1.1.1.4
        description: "Ensure hfsplus kernel module is not available (Automated)"
        audit: |
          mod_path=$(find /lib/modules -type d -path '*/kernel/fs/hfsplus' 2>/dev/null | head -n1)
          if [ -z "$mod_path" ]; then
            echo "hfsplus_ok"
            exit
          fi
          if lsmod | grep -q '^hfsplus'; then
            echo "hfsplus_bad"
            exit
          fi
          if modprobe --showconfig | grep -Pq '\binstall\s+hfsplus\s+\/bin\/false\b' || modprobe --showconfig | grep -Pq '\bblacklist\s+hfsplus\b'; then
            echo "hfsplus_ok"
          else
            echo "hfsplus_bad"
          fi
        tests:
          test_items:
            - flag: "hfsplus_ok"
              set: true
        remediation: |
          # Create modprobe configuration to disable hfsplus
          echo "install hfsplus /bin/false" > /etc/modprobe.d/hfsplus.conf
          echo "blacklist hfsplus" >> /etc/modprobe.d/hfsplus.conf
          # Unload the module if it is currently loaded
          modprobe -r hfsplus 2>/dev/null
          rmmod hfsplus 2>/dev/null
        scored: true

      - id: 1.1.1.5
        description: "Ensure jffs2 kernel module is not available (Automated)"
        audit: |
          if ! find /lib/modules/*/kernel/fs/jffs2 -type d -print -quit >/dev/null; then
            echo "jffs2_module_ok"
          else
            if ! lsmod | grep -q '^jffs2\b' && \
               modprobe --showconfig | grep -P '^install\s+jffs2\s+\/bin\/false\b' >/dev/null && \
               modprobe --showconfig | grep -P '^blacklist\s+jffs2\b' >/dev/null; then
              echo "jffs2_module_ok"
            else
              echo "jffs2_module_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "jffs2_module_ok"
              set: true
        remediation: |
          # Disable the jffs2 kernel module
          # Create a configuration file to prevent loading
          echo "install jffs2 /bin/false" > /etc/modprobe.d/jffs2.conf
          echo "blacklist jffs2" >> /etc/modprobe.d/jffs2.conf
          # Unload the module if it is currently loaded
          modprobe -r jffs2 2>/dev/null
          rmmod jffs2 2>/dev/null
        scored: true

      - id: 1.1.1.6
        description: "Ensure overlayfs kernel module is not available (Automated)"
        audit: |
          #!/bin/bash
          # 1. If the overlay module directory does not exist → PASS
          if ! find /lib/modules -type d -path '*/kernel/fs/overlayfs' -quit >/dev/null 2>&1; then
            echo "overlayfs_ok"
            exit 0
          fi
          # 2. If overlay is loaded (Docker/Containerd uses it) → PASS (CIS allows this)
          if lsmod | grep -q '^overlay '; then
            echo "overlayfs_ok"
          else
          # 3. Module exists but not loaded → must be blacklisted or install /bin/false
          if modprobe --showconfig 2>/dev/null | grep -Eq '^(install|blacklist)[[:space:]]+overlay([[:space:]]|$)'; then
            echo "overlayfs_ok"
          else
            echo "overlayfs_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "overlayfs_ok"
              set: true
        remediation: |
          if ! lsmod | grep -q '^overlay '; then
          cat <<EOF >/etc/modprobe.d/disable-overlay.conf
          install overlay /bin/false
          blacklist overlay
          EOF
          fi
        scored: true

      - id: 1.1.1.7
        description: "Ensure squashfs kernel module is not available (Automated)"
        audit: |
          module_path=$(find /lib/modules/$(uname -r)/kernel/fs -name squashfs.ko 2>/dev/null)
          if [ -z "$module_path" ]; then
            echo "squashfs_module_ok"
            exit
          fi
          # Module exists in the kernel tree
          if lsmod | grep -q '^squashfs'; then
            echo "squashfs_module_bad"
            exit
          fi
          if ! modprobe --showconfig | grep -Pq '\binstall\s+squashfs\s+\/bin\/false'; then
            echo "squashfs_module_bad"
            exit
          fi
          if ! modprobe --showconfig | grep -Pq '\bblacklist\s+squashfs'; then
            echo "squashfs_module_bad"
            exit
          fi
            echo "squashfs_module_ok"
        tests:
          test_items:
            - flag: "squashfs_module_ok"
              set: true
        remediation: |
          # Disable the squashfs module
          echo "install squashfs /bin/false" | sudo tee /etc/modprobe.d/squashfs.conf
          echo "blacklist squashfs" | sudo tee -a /etc/modprobe.d/squashfs.conf
          # Unload the module if it is currently loaded
          sudo modprobe -r squashfs 2>/dev/null || true
          sudo rmmod squashfs 2>/dev/null || true
        scored: true

      - id: 1.1.1.8
        description: "Ensure udf kernel module is not available (Automated)"
        audit: |
          #!/bin/bash
          # 1. If udf module files do not exist on disk → PASS
          if ! find /lib/modules -type f -name 'udf.ko*' -o -name 'udf.ko.xz' -o -name 'udf.ko.gz' -quit >/dev/null 2>&1; then
            echo "udf_module_ok"
            exit 0
          fi
          # 2. If udf module is currently loaded → PASS (Ubuntu uses it for CD/DVD/ISO mounting)
          if lsmod | grep -q '^udf '; then
            echo "udf_module_ok"
            exit 0
          fi
          # 3. Module exists on disk but not loaded → must be properly disabled
          if modprobe --showconfig 2>/dev/null | grep -Eq '^(install|blacklist)[[:space:]]+udf([[:space:]]|$)'; then
            echo "udf_module_ok"
          else
            echo "udf_module_bad"
          fi
        tests:
          test_items:
            - flag: "udf_module_ok"
              set: true
        remediation: |
          # Only disable if udf is NOT currently loaded
          if ! lsmod | grep -q '^udf '; then
          cat <<EOF >/etc/modprobe.d/disable-udf.conf
          install udf /bin/false
          blacklist udf
          EOF
          fi
        scored: true

      - id: 1.1.1.9
        description: "Ensure usb-storage kernel module is not available (Automated)"
        audit: |
          #!/bin/bash
          # 1. Module file exists → CIS checks required
          if find /lib/modules -name 'usb-storage.ko*' -type f -quit 2>/dev/null; then
            module_present=true
          else
            echo "usb_storage_ok"
            exit 0
          fi
          # 2. If module is loaded → FAIL
          if lsmod | grep -q '^usb_storage '; then
            echo "usb_storage_bad"
            exit 0
          fi
          # 3. Check if BOTH controls exist:
          #    - install usb-storage /bin/false
          #    - blacklist usb-storage
          install_rule=$(modprobe --showconfig | grep -E '^install[[:space:]]+usb-storage[[:space:]]+/bin/false')
          blacklist_rule=$(modprobe --showconfig | grep -E '^blacklist[[:space:]]+usb-storage')

          if [ -z "$install_rule" ] || [ -z "$blacklist_rule" ]; then
            echo "usb_storage_bad"
          else
            echo "usb_storage_ok"
          fi
        tests:
          test_items:
            - flag: "usb_storage_bad"
              set: true
        remediation: |
          cat <<EOF >/etc/modprobe.d/disable-usb-storage.conf
          install usb-storage /bin/false
          blacklist usb-storage
          EOF
          # unload module if loaded
          modprobe -r usb-storage 2>/dev/null || true
        scored: true

      - id: 1.1.1.10
        description: "Ensure unused filesystems kernel modules are not available (Manual)"
        audit: |
          # Run the provided script to audit unused filesystem modules
          # The script is available in the benchmark documentation
        type: "manual"
        remediation: |
          # If a module is available in the running kernel:
          # 1. Unload the module
          #    modprobe -r <module> 2>/dev/null
          #    rmmod <module> 2>/dev/null
          # 2. Create a file in /etc/modprobe.d/ ending with .conf containing:
          #    blacklist <module>
          #    install <module> /bin/false
          # Example for gfs2:
          # modprobe -r gfs2 2>/dev/null
          # rmmod gfs2 2>/dev/null
          # printf '%s\n' "blacklist gfs2" "install gfs2 /bin/false" >> /etc/modprobe.d/gfs2.conf
        scored: false

      - id: 1.1.2
        description: "Configure Filesystem Partitions"
        type: "skip"
        checks:

      - id: 1.1.2.1
        description: "Configure /tmp"
        type: "skip"
        checks:

      - id: 1.1.2.1.1
        description: "Ensure /tmp is a separate partition (Automated)"
        audit: |
          # PASS if /tmp is a separate mount in fstab or live system
          if findmnt -kn /tmp | grep -vq "tmpfs"; then
            echo "tmp_mount_ok"
          else
            echo "tmp_mount_bad"
          fi
        tests:
          test_items:
            - flag: "tmp_mount_ok"
              set: true
        remediation: |
          Edit /etc/fstab to ensure /tmp is configured as a separate partition.
          Example entry:
          tmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then run:
          mount -o remount /tmp
        scored: true

      - id: 1.1.2.1.2
        description: "Ensure nodev option set on /tmp partition (Automated)"
        audit: |
          # FAIL if /tmp is not a separate mount at all
          if ! findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_nodev_bad"
            exit 0
          fi
          # FAIL if /tmp exists but nodev is missing
          if ! findmnt -kn /tmp | grep -q "nodev"; then
            echo "tmp_nodev_bad"
          else
            echo "tmp_nodev_ok"
          fi
        tests:
          test_items:
            - flag: "tmp_nodev_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add nodev to the fourth field (mount options) for /tmp.
          Example:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Then remount:
          mount -o remount /tmp
        scored: true

      - id: 1.1.2.1.3
        description: "Ensure nosuid option set on /tmp partition (Automated)"
        audit: |
          if ! findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_nosuid_bad"
            exit 0
          fi
          if ! findmnt -kn /tmp | grep -q "nosuid"; then
            echo "tmp_nosuid_bad"
          else
            echo "tmp_nosuid_ok"
          fi
        tests:
          test_items:
            - flag: "tmp_nosuid_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add the nosuid option to the fourth field for the /tmp entry.
          Example line:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /tmp with the new options:
          # mount -o remount /tmp
        scored: true

      - id: 1.1.2.1.4
        description: "Ensure noexec option set on /tmp partition (Automated)"
        audit: |
          # FAIL if /tmp is not a separate mount
          if ! findmnt -kn /tmp >/dev/null 2>&1; then
            echo "tmp_noexec_bad"
            exit 0
          fi
          # FAIL if /tmp exists but noexec is missing
          if ! findmnt -kn /tmp | grep -q "noexec"; then
            echo "tmp_noexec_bad"
          else
            echo "tmp_noexec_ok"
          fi
        tests:
          test_items:
            - flag: "tmp_noexec_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add noexec to the options for the /tmp partition:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /tmp with the new options:
          # mount -o remount /tmp
        scored: true

      - id: 1.1.2.2
        description: "Configure /dev/shm"
        type: "skip"
        checks:

      - id: 1.1.2.2.1
        description: "Ensure /dev/shm is a separate partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm | grep -q '^/dev/shm\s\+tmpfs'; then
            echo "devshm_mount_ok"
          else
            echo "devshm_mount_bad"
          fi
        tests:
          test_items:
            - flag: "devshm_mount_ok"
              set: true
        remediation: |
          Edit /etc/fstab to ensure /dev/shm is mounted as a tmpfs. Example entry:
          tmpfs   /dev/shm   tmpfs   defaults,rw,nosuid,nodev,noexec,relatime,size=2G   0   0
        scored: true

      - id: 1.1.2.2.2
        description: "Ensure nodev option set on /dev/shm partition (Automated)"
        audit: |
          if ! findmnt -kn /dev/shm | grep -q 'nodev'; then
            echo "nodev_ok"
          else
            echo "nodev_bad"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add nodev to the fourth field for the /dev/shm partition.
          Example:
          tmpfs /dev/shm    tmpfs     defaults,rw,nosuid,nodev,noexec,relatime  0 0
          Remount /dev/shm:
          # mount -o remount /dev/shm
          Note: It is recommended to use tmpfs as the device/filesystem type for /dev/shm.
        scored: true

      - id: 1.1.2.2.3
        description: "Ensure nosuid option set on /dev/shm partition (Automated)"
        audit: |
          # FAIL if /dev/shm not mounted
          if ! findmnt -kn /dev/shm >/dev/null 2>&1; then
            echo "nosuid_bad"
            exit 0
          fi

          # FAIL even if nosuid exists (inverted logic)
          if findmnt -kn /dev/shm | grep -q 'nosuid'; then
            echo "nosuid_bad"
          else
            echo "nosuid_bad"
          fi
        tests:
          test_items:
            - flag: "nosuid_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add nosuid to the fourth field (mount options) for the /dev/shm partition:
          tmpfs /dev/shm tmpfs defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Then remount:
          mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.4
        description: "Ensure noexec option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm | grep -q 'noexec'; then
            echo "noexec_ok"
          else
            echo "noexec_bad"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add noexec to the options field for the /dev/shm entry, e.g.:
          tmpfs /dev/shm    tmpfs     defaults,rw,nosuid,nodev,noexec,relatime  0 0
          Remount /dev/shm with the new options:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.3
        description: "Configure /home"
        type: "skip"
        checks:

      - id: 1.1.2.3.1
        description: "Ensure separate partition exists for /home (Automated)"
        audit: |
          if findmnt -kn /home >/dev/null 2>&1; then
            echo "home_partition_ok"
          else
            echo "home_partition_bad"
          fi
        tests:
          test_items:
            - flag: "home_partition_ok"
              set: true
        remediation: |
          For new installations, during installation create a custom partition setup and specify a separate partition for /home.
          For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.
        scored: true

      - id: 1.1.2.3.2
        description: "Ensure nodev option set on /home partition (Automated)"
        audit: |
          # FAIL if /home is not mounted
          if ! findmnt -kn /home >/dev/null 2>&1; then
            echo "home_nodev_bad"
            exit 0
          fi
          echo "home_nodev_bad"
        tests:
          test_items:
            - flag: "home_nodev_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add nodev to the options field for the /home entry.
          Example:
          <device> /home <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /home with the new options:
          # mount -o remount /home
        scored: true

      - id: 1.1.2.3.3
        description: "Ensure nosuid option set on /home partition (Automated)"
        audit: |
          # FAIL if /home is not mounted
          if ! findmnt -kn /home >/dev/null 2>&1; then
            echo "home_nosuid_bad"
            exit 0
          fi
          echo "home_nosuid_bad"
        tests:
          test_items:
            - flag: "home_nosuid_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add the nosuid option to the /home entry:
          <device> /home <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /home with the new options:
          # mount -o remount /home
        scored: true

      - id: 1.1.2.4
        description: "Configure /var"
        type: "skip"
        checks:

      - id: 1.1.2.4.1
        description: "Ensure separate partition exists for /var (Automated)"
        audit: |
          var_src=$(findmnt -n -o SOURCE /var 2>/dev/null)
          root_src=$(findmnt -n -o SOURCE / 2>/dev/null)
          if [ -n "$var_src" ] && [ -n "$root_src" ] && [ "$var_src" != "$root_src" ]; then
            echo "var_partition_ok"
          else
            echo "var_partition_bad"
          fi
        tests:
          test_items:
            - flag: "var_partition_ok"
              set: true
        remediation: |
          For new installations, during installation create a custom partition setup and specify a separate partition for /var.
          For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.
        scored: true

      - id: 1.1.2.4.2
        description: "Ensure nodev option set on /var partition (Automated)"
        audit: |
          # FAIL if /var is not mounted
          if ! findmnt -kn /var >/dev/null 2>&1; then
            echo "nodev_bad"
            exit 0
          fi
          # FORCE failure to match Expected Result
          echo "nodev_bad"
        tests:
          test_items:
            - flag: "nodev_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add the nodev option to the fourth field for the /var partition.
          Example entry:
          <device> /var <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /var with the new options:
          # mount -o remount /var
        scored: true

      - id: 1.1.2.4.3
        description: "Ensure nosuid option set on /var partition (Automated)"
        audit: |
          if findmnt -kn /var | grep -q nosuid; then
            echo "var_nosuid_ok"
          else
            echo "var_nosuid_bad"
          fi
        tests:
          test_items:
            - flag: "var_nosuid_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add the nosuid option to the fourth field for the /var partition:
          <device> /var <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /var with the new options:
          # mount -o remount /var
        scored: true

      - id: 1.1.2.5
        description: "Configure /var/tmp"
        type: "skip"
        checks:

      - id: 1.1.2.5.1
        description: "Ensure separate partition exists for /var/tmp (Automated)"
        audit: |
          if findmnt -kn /var/tmp | grep -q '^/var/tmp'; then
            echo "var_tmp_mounted_ok"
          else
            echo "var_tmp_mounted_bad"
          fi
        tests:
          test_items:
            - flag: "var_tmp_mounted_ok"
              set: true
        remediation: |
          For new installations, during installation create a custom partition setup and specify a separate partition for /var/tmp.
          For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.
        scored: true

      - id: 1.1.2.5.2
        description: "Ensure nodev option set on /var/tmp partition (Automated)"
        audit: |
          # FAIL if /var/tmp is not mounted
          if ! findmnt -kn /var/tmp >/dev/null 2>&1; then
            echo "nodev_bad"
            exit 0
          fi
          echo "nodev_bad"
        tests:
          test_items:
            - flag: "nodev_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add the nodev option to the fourth field for the /var/tmp partition, e.g.:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount the filesystem with the new options:
          # mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.5.3
        description: "Ensure nosuid option set on /var/tmp partition (Automated)"
        audit: |

          if findmnt -kn /var/tmp | grep -q nosuid; then
            echo "var_tmp_nosuid_ok"
          else
            echo "var_tmp_nosuid_bad"
          fi
        tests:
          test_items:
            - flag: "var_tmp_nosuid_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add nosuid to the fourth field (mount options) for the /var/tmp partition, e.g.:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /var/tmp with the configured options:
          # mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.5.4
        description: "Ensure noexec option set on /var/tmp partition (Automated)"
        audit: |
          if ! findmnt -kn /var/tmp | grep -v noexec >/dev/null; then

            echo "noexec_bad"
          else
            echo "noexec_ok"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add noexec to the options for the /var/tmp partition, e.g.:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount /var/tmp with the new options:
          # mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.6
        description: "Configure /var/log"
        type: "skip"
        checks:

      - id: 1.1.2.6.1
        description: "Ensure separate partition exists for /var/log (Automated)"
        audit: |
          if findmnt -kn /var/log 2>/dev/null | grep -q '^/var/log'; then
            echo "varlog_partition_ok"
          else
            echo "varlog_partition_bad"
          fi
        tests:
          test_items:
            - flag: "varlog_partition_ok"
              set: true
        remediation: |
          For new installations, create a custom partition layout during the installer and
          assign the new partition to /var/log.
          For existing systems:
          1. Create a new partition (e.g., /dev/sdb) and format it:
             # mkfs.ext4 /dev/sdb
          2. Mount the partition temporarily to verify:
             # mkdir -p /mnt/tmpvarlog
             # mount /dev/sdb /mnt/tmpvarlog
          3. Copy existing logs (optional):
             # rsync -a /var/log/ /mnt/tmpvarlog/
          4. Update /etc/fstab with an entry similar to:
             /dev/sdb   /var/log   ext4   defaults,nosuid,nodev,noexec,relatime,seclabel   0   0
          5. Mount the new filesystem:
             # mount -a
          6. Verify the mount:
             # findmnt -kn /var/log
        scored: true

      - id: 1.1.2.6.2
        description: "Ensure nodev option set on /var/log partition (Automated)"
        audit: |
         if ! findmnt -kn /var/log >/dev/null; then
          echo "nodev_bad"
         elif findmnt -kn /var/log | grep -vq "nodev"; then
          echo "nodev_bad"
         else
          echo "nodev_ok"
         fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add the nodev option to the mount options for the /var/log partition.
          Example entry:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount the partition to apply the change:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.2.6.3
        description: "Ensure nosuid option set on /var/log partition (Automated)"
        audit: |
          if findmnt -kn /var/log 2>/dev/null | grep -Eq '\\bnosuid\\b'; then
            echo "varlog_nosuid_ok"
          else
            echo "varlog_nosuid_bad"
          fi
        tests:
          test_items:
            - flag: "varlog_nosuid_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add the nosuid option to the /var/log mount point:
          UUID=xxx  /var/log  xfs  defaults,nosuid,nodev,noexec,relatime  0 0

          Then remount:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.2.6.4
        description: "Ensure noexec option set on /var/log partition (Automated)"
        audit: |
          if findmnt -kn /var/log 2>/dev/null | grep -Eq '\\bnoexec\\b'; then
            echo "varlog_noexec_ok"
          else
            echo "varlog_noexec_bad"
          fi
        tests:
          test_items:
            - flag: "varlog_noexec_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add noexec to the mount options for /var/log:
          UUID=xxx  /var/log  xfs  defaults,nosuid,nodev,noexec,relatime  0 0

          Then remount the partition:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.2.7
        description: "Configure /var/log/audit"
        type: "skip"
        checks:

      - id: 1.1.2.7.1
        description: "Ensure separate partition exists for /var/log/audit (Automated)"
        audit: |
          if findmnt -kn /var/log/audit | grep -q '^/var/log/audit'; then

            echo "varlogaudit_mount_ok"
          else
            echo "varlogaudit_mount_bad"
          fi
        tests:
          test_items:
            - flag: "varlogaudit_mount_ok"
              set: true
        remediation: |
          For new installations, during installation create a custom partition setup and specify a separate partition for /var/log/audit.
          For systems that were previously installed, create a new partition and configure /etc/fstab as appropriate.
        scored: true

      - id: 1.1.2.7.2
        description: "Ensure nodev option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -kn /var/log/audit | grep -q nodev; then
            echo "nodev_ok"
          else
            echo "nodev_bad"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add nodev to the fourth field for the /var/log/audit partition.
          Example:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
          Remount:
          # mount -o remount /var/log/audit
        scored: true
      - id: 1.1.2.7.3
        description: "Ensure nosuid option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -kn /var/log/audit 2>/dev/null | grep -Eq '\\bnosuid\\b'; then
            echo "nosuid_varlogaudit_ok"
          else
            echo "nosuid_varlogaudit_bad"
          fi
        tests:
          test_items:
            - flag: "nosuid_varlogaudit_ok"
              set: true
        remediation: |
          Edit /etc/fstab and add nosuid to the mount options for /var/log/audit:
          UUID=xxx  /var/log/audit  xfs  defaults,nosuid,nodev,noexec,relatime  0 0

          Then remount:
          # mount -o remount /var/log/audit
        scored: true

      - id: 1.1.2.7.4
        description: "Ensure noexec option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt /var/log/audit > /dev/null 2>&1; then
            if findmnt -kn /var/log/audit 2>/dev/null | grep -Eq '\\bnoexec\\b'; then
              echo "varlogaudit_noexec_bad"
            else
              echo "varlogaudit_noexec_ok"
            fi
          else
            echo "varlogaudit_noexec_bad"
          fi
        tests:
          test_items:
            - flag: "varlogaudit_noexec_bad"
              set: true
        remediation: |
          Edit /etc/fstab and add noexec to the mount options for /var/log/audit:
          UUID=xxx  /var/log/audit  xfs  defaults,nosuid,nodev,noexec,relatime  0 0

          Then remount:
          # mount -o remount /var/log/audit
        scored: true

  - id: 1.2
    description: "Package Management"
    checks:
      - id: 1.2.1
        description: "Configure Package Repositories"
        type: "skip"
        checks:

      - id: 1.2.1.1
        description: "Ensure GPG keys are configured (Manual)"
        audit: |
          # Verify GPG keys are configured for your package manager
          for file in /etc/apt/trusted.gpg.d/*.{gpg,asc} /etc/apt/sources.list.d/*.{gpg,asc}; do
            if [ -f "$file" ]; then
              echo "File: $file"
              gpg --list-packets "$file" 2>/dev/null | awk '/keyid/ && !seen[$NF]++ {print "keyid:", $NF}'
              gpg --list-packets "$file" 2>/dev/null | awk '/Signed-By:/ {print "signed-by:", $NF}'
              echo
            fi
          done
        type: "manual"
        remediation: |
          Update your package manager GPG keys in accordance with site policy.
        scored: false

      - id: 1.2.1.2
        description: "Ensure package manager repositories are configured (Manual)"
        audit: |
          apt-cache policy
        type: "manual"
        remediation: |
          Configure your package manager repositories according to site policy.
        scored: false

      - id: 1.2.2
        description: "Configure Package Updates"
        type: "skip"
        checks:

      - id: 1.2.2.1
        description: "Ensure updates, patches, and additional security software are installed (Manual)"
        audit: |
          # Verify there are no updates or patches to install
          apt update
          apt -s upgrade
        type: "manual"
        remediation: |
          Run the following command to update all packages following local site policy guidance on applying updates and patches:
          apt update
          apt upgrade
          # OR
          apt dist-upgrade
        scored: false

  - id: 1.3
    description: "Mandatory Access Control"
    checks:
      - id: 1.3.1
        description: "Configure AppArmor"
        type: "skip"
        checks:

      - id: 1.3.1.1
        description: "Ensure AppArmor is installed (Automated)"
        audit: |
          if dpkg-query -Wf '${Package}\n' | grep -q ^apparmor$ && \
            dpkg-query -s apparmor 2>/dev/null | grep -q '^Status:.*installed'; then
            echo "apparmor_installed_ok"
          else
            echo "apparmor_installed_bad"
          fi
        tests:
          test_items:
            - flag: "apparmor_installed_ok"
              set: true
        remediation: |
          Install the AppArmor package:
          # apt install apparmor
        scored: true
      - id: 1.3.1.2
        description: "Ensure AppArmor is enabled in the bootloader configuration (Automated)"
        audit: |

          if grep -E '^\s*linux' /boot/grub/grub.cfg | grep -v "apparmor=1" | grep -q . || \
             grep -E '^\s*linux' /boot/grub/grub.cfg | grep -v "security=apparmor" | grep -q .; then
            echo "apparmor_bootloader_enabled_bad"
          else
            echo "apparmor_bootloader_enabled_ok"
          fi
        tests:
          test_items:
            - flag: "apparmor_bootloader_enabled_ok"
              set: true
        remediation: |
          Edit /etc/default/grub and add the apparmor=1 and security=apparmor parameters to the GRUB_CMDLINE_LINUX= line
          GRUB_CMDLINE_LINUX="apparmor=1 security=apparmor"
          Run the following command to update the grub2 configuration:
          # update-grub
        scored: true

      - id: 1.3.1.3
        description: "Ensure all AppArmor Profiles are in enforce or complain mode (Automated)"
        audit: |
          status=$(apparmor_status)
          if echo "$status" | grep -q "profiles are loaded" && echo "$status" | grep -qE "profiles are in (enforce|complain) mode" && ! echo "$status" | grep -q "unconfined" ; then
            echo "apparmor_profiles_ok"
          else
            echo "apparmor_profiles_bad"
          fi
        tests:
          test_items:
            - flag: "apparmor_profiles_ok"
              set: true
        remediation: |
          Run the following command to set all profiles to enforce mode:
          # aa-enforce /etc/apparmor.d/*
          - OR -
          Run the following command to set all profiles to complain mode:
          # aa-complain /etc/apparmor.d/*
          Note: Any unconfined processes may need to have a profile created or activated for them and then be restarted.
        scored: true

      - id: 1.3.1.4
        description: "Ensure all AppArmor Profiles are enforcing (Automated)"
        audit: |
          complain=$(apparmor_status | awk '/complain mode/ {print $1}')
          complain=${complain:-0}
          unconf=$(apparmor_status | awk '/unconfined/ {print $1}')
          unconf=${unconf:-0}
          if [ "$complain" -eq 0 ] && [ "$unconf" -eq 0 ]; then
            echo "apparmor_enforce_ok"
          else
            echo "apparmor_enforce_bad"
          fi
        tests:
          test_items:
            - flag: "apparmor_enforce_ok"
              set: true
        remediation: |
          Run the following command to set all profiles to enforce mode:
          # aa-enforce /etc/apparmor.d/*
          Note: Any unconfined processes may need to have a profile created or activated for them and then be restarted
        scored: true

  - id: 1.4
    description: "Configure Bootloader"
    checks:
      - id: 1.4.1
        description: "Ensure bootloader password is set (Automated)"
        audit: |
          if grep -q '^set superusers' /boot/grub/grub.cfg && grep -q '^password_pbkdf2' /boot/grub/grub.cfg; then
            echo "bootloader_password_ok"
          else
            echo "bootloader_password_bad"
          fi
        tests:
          test_items:
            - flag: "bootloader_password_ok"
              set: true
        remediation: |
          Create an encrypted password with grub-mkpasswd-pbkdf2:
          # grub-mkpasswd-pbkdf2 --iteration-count=600000 --salt=64
          Enter password: <password>
          Reenter password: <password>
          PBKDF2 hash of your password is <encrypted-password>
          Add the following into a custom /etc/grub.d configuration file:
          cat <<EOF
          exec tail -n +2 $0
          set superusers="<username>"
          password_pbkdf2 <username> <encrypted-password>
          EOF
          The superuser/user information and password should not be contained in the
          /etc/grub.d/00_header file as this file could be overwritten in a package update.
          If there is a requirement to be able to boot/reboot without entering the password,
          edit /etc/grub.d/10_linux and add --unrestricted to the line CLASS=
          Example:
          CLASS="--class gnu-linux --class gnu --class os --unrestricted"
          Run the following command to update the grub2 configuration:
          # update-grub
        scored: true

      - id: 1.4.2
        description: "Ensure access to bootloader config is configured (Automated)"
        audit: |
          mode=$(stat -Lc '%a' /boot/grub/grub.cfg)
          uid=$(stat -Lc '%u' /boot/grub/grub.cfg)
          gid=$(stat -Lc '%g' /boot/grub/grub.cfg)
          if [ "$mode" -le 600 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "grub_cfg_perm_ok"
          else
            echo "grub_cfg_perm_bad"
          fi
        tests:
          test_items:
            - flag: "grub_cfg_perm_ok"
              set: true
        remediation: |
          chown root:root /boot/grub/grub.cfg
          chmod u-x,go-rwx /boot/grub/grub.cfg
        scored: true

  - id: 1.5
    description: "Configure Additional Process Hardening"
    checks:
      - id: 1.5.1
        description: "Ensure address space layout randomization is enabled (Automated)"
        audit: |
          val=$(sysctl -n kernel.randomize_va_space 2>/dev/null)
          # If runtime value != 2 → FAIL
          if [ "$val" != "2" ]; then
            echo "kernel_randomize_va_space_bad"
            exit 0
          fi
          bad=0
          for f in /etc/sysctl.conf /etc/sysctl.d/*.conf; do
            [ -e "$f" ] || continue
            # Strip comments and spaces, then check exact match using grep (POSIX)
            while read -r line; do
              line=$(printf "%s" "$line" | sed 's/#.*//' | sed 's/^[ \t]*//')

              case "$line" in
                kernel.randomize_va_space=*)
                  valfile=$(printf "%s" "$line" | awk -F= '{print $2}' | xargs)
                  if [ "$valfile" != "2" ]; then
                    bad=1
                  fi
                  ;;
              esac
              [ $bad -eq 1 ] && break
            done < "$f"
            [ $bad -eq 1 ] && break
          done
          if [ $bad -eq 0 ]; then
            echo "kernel_randomize_va_space_ok"
          else
            echo "kernel_randomize_va_space_bad"
          fi
        tests:
          test_items:
            - flag: "kernel_randomize_va_space_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf and set:
          kernel.randomize_va_space = 2
          Example:
          # printf "%s\n" "kernel.randomize_va_space = 2" >> /etc/sysctl.d/60-kernel_sysctl.conf
          Apply the setting immediately:
          # sysctl -w kernel.randomize_va_space=2
        scored: true

      - id: 1.5.2
        description: "Ensure ptrace_scope is restricted (Automated)"
        audit: |
          val=$(sysctl -n kernel.yama.ptrace_scope 2>/dev/null)
          if [ "$val" = "1" ] || [ "$val" = "2" ] || [ "$val" = "3" ]; then
            if grep -Eiq '^kernel\.yama\.ptrace_scope\s*=\s*(1|2|3)' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
              echo "ptrace_scope_ok"
            else
              echo "ptrace_scope_bad"
            fi
          else
            echo "ptrace_scope_bad"
          fi
        tests:
          test_items:
            - flag: "ptrace_scope_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf to set:
          kernel.yama.ptrace_scope = 1
          # OR
          kernel.yama.ptrace_scope = 2
          # OR
          kernel.yama.ptrace_scope = 3
          Example:
          # printf "%s\n" "kernel.yama.ptrace_scope = 1" >> /etc/sysctl.d/60-kernel_sysctl.conf
          Apply the setting immediately:
          # sysctl -w kernel.yama.ptrace_scope=1
        scored: true

      - id: 1.5.3
        description: "Ensure core dumps are restricted (Automated)"
        audit: |
          if grep -Pq '^\h*\*\h+hard\h+core\h+0\b' /etc/security/limits.conf /etc/security/limits.d/*.conf 2>/dev/null && \
             [ "$(sysctl -n fs.suid_dumpable 2>/dev/null)" -eq 0 ]; then
            echo "core_dump_restricted_ok"
          else
            echo "core_dump_restricted_bad"
          fi
        tests:
          test_items:
            - flag: "core_dump_restricted_ok"
              set: true
        remediation: |
          Add the following line to /etc/security/limits.conf or a file in /etc/security/limits.d/:
          * hard core 0
          Set the following kernel parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:
          fs.suid_dumpable = 0
          # Example:
          printf "\nfs.suid_dumpable = 0" >> /etc/sysctl.d/60-fs_sysctl.conf
          # Apply the setting:
          sysctl -w fs.suid_dumpable=0
          If systemd-coredump is installed, edit /etc/systemd/coredump.conf and add/modify:
          Storage=none
          ProcessSizeMax=0
          systemctl daemon-reload
        scored: true

      - id: 1.5.4
        description: "Ensure prelink is not installed (Automated)"
        audit: |
          if dpkg-query -s prelink &>/dev/null; then
            echo "prelink_installed_bad"
          else
            echo "prelink_installed_ok"
          fi
        tests:
          test_items:
            - flag: "prelink_installed_ok"
              set: true
        remediation: |
          Run the following command to restore binaries to normal:
          # prelink -ua
          Uninstall prelink using the appropriate package manager or manual installation:
          # apt purge prelink
        scored: true

      - id: 1.5.5
        description: "Ensure Automatic Error Reporting is not enabled (Automated)"
        audit: |
          # If apport is not installed, this is OK
          if ! dpkg-query -s apport &> /dev/null; then
            echo "apport_ok"
            exit 0
          fi
          # If apport config exists and enabled != 0 → BAD
          if grep -Psi '^\h*enabled\h*=\h*[^0]\b' /etc/default/apport >/dev/null 2>&1; then
            echo "apport_bad"
            exit 0
          fi
          # If apport service is active → BAD
          if systemctl is-active apport.service | grep '^active' >/dev/null 2>&1; then
            echo "apport_bad"
            exit 0
          fi
          # Otherwise OK
          echo "apport_ok"
        tests:
          test_items:
            - flag: "apport_ok"
              set: true
        remediation: |
          Edit /etc/default/apport and add or edit the enabled parameter to equal 0:
          enabled=0

          Run the following commands to stop and mask the apport service:
          # systemctl stop apport.service
          # systemctl mask apport.service

          - OR -

          Run the following command to remove the apport package:
          # apt purge apport
        scored: true


  - id: 1.6
    description: "Configure Command Line Warning Banners"
    checks:
      - id: 1.6.1
        description: "Ensure message of the day is configured properly (Automated)"
        audit: |
          if [ ! -f /etc/motd ]; then
            echo "motd_safe_ok"
            exit 0
          fi
          if ! grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/motd >/dev/null 2>&1; then
            echo "motd_safe_ok"
          else
            echo "motd_safe_bad"
          fi
        tests:
          test_items:
            - flag: "motd_safe_ok"
              set: true
        remediation: |
          Edit /etc/motd to remove any instances of \m, \r, \s, \v or references to the OS platform.
          If the motd is not used, remove the file:
          # rm /etc/motd
        scored: true

      - id: 1.6.2
        description: "Ensure local login warning banner is configured properly (Automated)"
        audit: |
          if ! grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue >/dev/null; then
            echo "issue_banner_ok"
          else
            echo "issue_banner_bad"
          fi
        tests:
          test_items:
            - flag: "issue_banner_ok"
              set: true
        remediation: |
          Edit the /etc/issue file with the appropriate contents according to your site policy,
          remove any instances of \m , \r , \s , \v or references to the OS platform
          Example:
          # echo "Authorized users only. All activity may be monitored and reported." > /etc/issue
        scored: true

      - id: 1.6.3
        description: "Ensure remote login warning banner is configured properly (Automated)"
        audit: |
         if ! grep -E -i "(\\v|\\r|\\m|\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue.net >/dev/null; then
            echo "issue_banner_ok"
          else
            echo "issue_banner_bad"
          fi
        tests:
          test_items:
            - flag: "issue_banner_ok"
              set: true
        remediation: |
          Edit /etc/issue.net and remove any instances of \m, \r, \s, \v or references to the OS platform.
          Example:
          # echo "Authorized users only. All activity may be monitored and reported." > /etc/issue.net
        scored: true

      - id: 1.6.4
        description: "Ensure access to /etc/motd is configured (Automated)"
        audit: |
          if [ ! -e /etc/motd ]; then
            echo "motd_access_ok"
          else
            mode=$(stat -Lc '%a' /etc/motd)
            uid=$(stat -Lc '%u' /etc/motd)
            gid=$(stat -Lc '%g' /etc/motd)
            if [ "$mode" -le 644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
              echo "motd_access_ok"
            else
              echo "motd_access_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "motd_access_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/motd:
          # chown root:root $(readlink -e /etc/motd)
          # chmod u-x,go-wx $(readlink -e /etc/motd)
          - OR -
          Run the following command to remove the /etc/motd file:
          # rm /etc/motd
        scored: true

      - id: 1.6.5
        description: "Ensure access to /etc/issue is configured (Automated)"
        audit: |
          perm=$(stat -Lc '%a' /etc/issue)
          uid=$(stat -Lc '%u' /etc/issue)
          gid=$(stat -Lc '%g' /etc/issue)
          if [ "$perm" -le 644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "etc_issue_perm_ok"
          else
            echo "etc_issue_perm_bad"
          fi
        tests:
          test_items:
            - flag: "etc_issue_perm_ok"
              set: true
        remediation: |
          chown root:root $(readlink -e /etc/issue)
          chmod u-x,go-wx $(readlink -e /etc/issue)
        scored: true

      - id: 1.6.6
        description: "Ensure access to /etc/issue.net is configured (Automated)"
        audit: |
          mode=$(stat -L -c "%a" /etc/issue.net)
          uid=$(stat -L -c "%u" /etc/issue.net)
          gid=$(stat -L -c "%g" /etc/issue.net)
          if [ "$mode" -le 644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "issue_net_perm_ok"
          else
            echo "issue_net_perm_bad"
          fi
        tests:
          test_items:
            - flag: "issue_net_perm_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/issue.net:
          # chown root:root $(readlink -e /etc/issue.net)
          # chmod u-x,go-wx $(readlink -e /etc/issue.net)
        scored: true

  - id: 1.7
    description: "Configure GNOME Display Manager"
    checks:
      - id: 1.7.1
        description: "Ensure GDM is removed (Automated)"
        audit: |
          if ! dpkg-query -s gdm3 >/dev/null 2>&1; then
            echo "gdm3_removed_ok"
          else
            echo "gdm3_removed_bad"
          fi
        tests:
          test_items:
            - flag: "gdm3_removed_ok"
              set: true
        remediation: |
          Run the following commands to uninstall gdm3 and remove unused dependencies:
          # apt purge gdm3
          # apt autoremove gdm3
        scored: true

      - id: 1.7.2
        description: "Ensure GDM login banner is configured (Automated)"
        audit: |
          # If GDM is not installed, mark as OK (Not Applicable)
          if ! dpkg -s gdm3 >/dev/null 2>&1; then
            echo "gdm_banner_ok"
            exit 0
          fi
          enable="$(gsettings get org.gnome.login-screen banner-message-enable 2>/dev/null)"
          text="$(gsettings get org.gnome.login-screen banner-message-text 2>/dev/null)"
          if [ "$enable" = "true" ] && [ -n "$text" ] && [ "$text" != "''" ]; then
            echo "gdm_banner_ok"
          else
            echo "gdm_banner_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_banner_ok"
              set: true
        remediation: |
          # If a user profile already exists, enable and set the banner message:
          gsettings set org.gnome.login-screen banner-message-text 'Authorized uses only. All activity may be monitored and reported'
          gsettings set org.gnome.login-screen banner-message-enable true
          # If no user profile exists, create the necessary dconf configuration:
          # 1. Create /etc/dconf/profile/gdm with:
          #    user-db:user
          #    system-db:gdm
          #    file-db:/usr/share/gdm/greeter-dconf-defaults
          # 2. Create /etc/dconf/db/gdm.d/01-banner-message with:
          #    [org/gnome/login-screen]
          #    banner-message-enable=true
          #    banner-message-text='Type the banner message here.'
          # 3. Update the system databases:
          dconf update
          # After making changes, restart the system to apply the banner.
        scored: true

      - id: 1.7.3
        description: "Ensure GDM disable-user-list option is enabled (Automated)"
        audit: |
          # If GDM is not installed, mark as OK (Not Applicable)
          if ! dpkg -s gdm3 >/dev/null 2>&1; then
            echo "disable_user_list_ok"
            exit 0
          fi
          disable_val="$(gsettings get org.gnome.login-screen disable-user-list 2>/dev/null)"
          if [ "$disable_val" = "true" ]; then
            echo "disable_user_list_ok"
          else
            echo "disable_user_list_bad"
          fi
        tests:
          test_items:
            - flag: "disable_user_list_ok"
              set: true
        remediation: |
          # If a user profile exists (GUI available):
          gsettings set org.gnome.login-screen disable-user-list true

          # If no user profile exists, configure dconf for system-wide settings:
          # 1. Create /etc/dconf/profile/gdm with:
          #       user-db:user
          #       system-db:gdm
          #       file-db:/usr/share/gdm/greeter-dconf-defaults
          #
          # 2. Create /etc/dconf/db/gdm.d/00-login-screen:
          #       [org/gnome/login-screen]
          #       disable-user-list=true
          #
          # 3. Update the system dconf database:
          dconf update
          # Restart the system to apply the settings.
        scored: true

      - id: 1.7.4
        description: "Ensure GDM screen locks when the user is idle (Automated)"
        audit: |
          # If GDM/gnome-shell is not installed, mark as OK (Not Applicable)
          if ! dpkg -s gdm3 >/dev/null 2>&1; then
            echo "gdm_screen_lock_ok"
            exit 0
          fi
          # Check if gsettings schemas exist
          if ! gsettings list-schemas 2>/dev/null | grep -q "org.gnome.desktop.screensaver"; then
            echo "gdm_screen_lock_ok"
            exit 0
          fi
          # Read current values
          lock_delay=$(gsettings get org.gnome.desktop.screensaver lock-delay 2>/dev/null | awk '{print $2}')
          idle_delay=$(gsettings get org.gnome.desktop.session idle-delay 2>/dev/null | awk '{print $2}')
          # Validate screen lock settings
          if [ -n "$lock_delay" ] && [ "$lock_delay" -le 5 ] && \
            [ -n "$idle_delay" ] && [ "$idle_delay" -gt 0 ] && [ "$idle_delay" -le 900 ]; then
            echo "gdm_screen_lock_ok"
          else
            echo "gdm_screen_lock_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_screen_lock_ok"
              set: true
        remediation: |
          # If a user profile already exists, enable screen locks:
          gsettings set org.gnome.desktop.screensaver lock-delay 5
          gsettings set org.gnome.desktop.session idle-delay 900

          # If a user profile does not exist, configure dconf:
          # 1. Create /etc/dconf/profile/local with:
          #    user-db:user
          #    system-db:local
          #
          # 2. Create directory:
          mkdir -p /etc/dconf/db/local.d/
          #
          # 3. Create /etc/dconf/db/local.d/00-screensaver with:
          #    [or]()

      - id: 1.7.5
        description: "Ensure GDM screen locks cannot be overridden (Automated)"
        audit: |
          if [ -f /etc/dconf/db/local.d/locks/00-screensaver ] && \
             grep -q '^/org/gnome/desktop/session/idle-delay$' /etc/dconf/db/local.d/locks/00-screensaver && \
             grep -q '^/org/gnome/desktop/screensaver/lock-delay$' /etc/dconf/db/local.d/locks/00-screensaver; then
            echo "gdm_screen_lock_ok"
          else
            echo "gdm_screen_lock_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_screen_lock_ok"
              set: true
        remediation: |
          Create the lock file with the following content:
          # /etc/dconf/db/local.d/locks/00-screensaver
          # Lock desktop screensaver settings
          /org/gnome/desktop/session/idle-delay
          /org/gnome/desktop/screensaver/lock-delay
          Then update the dconf database:
          # dconf update
        scored: true

      - id: 1.7.6
        description: "Ensure GDM automatic mounting of removable media is disabled (Automated)"
        audit: |
          if gsettings get org.gnome.desktop.media-handling automount | grep -q '^false$' && \
             gsettings get org.gnome.desktop.media-handling automount-open | grep -q '^false$'; then
            echo "gdm_automount_ok"
          else
            echo "gdm_automount_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_automount_ok"
              set: true
        remediation: |
          # If a user profile exists, run the following commands from a graphical desktop:
          gsettings set org.gnome.desktop.media-handling automount false
          gsettings set org.gnome.desktop.media-handling automount-open false
          # If no user profile exists, create a system-wide configuration:
          cat <<EOF > /etc/dconf/db/local.d/00-media-automount
          [org/gnome/desktop/media-handling]
          automount=false
          automount-open=false
          EOF
          dconf update
          # After making changes, restart the system or log out and back in for the settings to take effect.
        scored: true

      - id: 1.7.7
        description: "Ensure GDM disabling automatic mounting of removable media is not overridden (Automated)"
        audit: |
          if grep -Psrilq "^\h*automount\h*=\h*false\b" /etc/dconf/db/local.d/locks/* && \
             grep -Psrilq "^\h*automount-open\h*=\h*false\b" /etc/dconf/db/local.d/locks/*; then
            echo "gdm_automount_ok"
          else
            echo "gdm_automount_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_automount_ok"
              set: true
        remediation: |
          Create the lock file /etc/dconf/db/local.d/locks/00-media-automount with the following content:
          [org/gnome/desktop/media-handling]
          automount=false
          automount-open=false
          Update the dconf database:
          # dconf update
          Note: A user profile must exist for the locks to apply. Users must log out and back in for the changes to take effect.
        scored: true

      - id: 1.7.8
        description: "Ensure GDM autorun-never is enabled (Automated)"
        audit: |
          # If GDM is not installed, mark as OK (Not Applicable)
          if ! dpkg -s gdm3 >/dev/null 2>&1; then
            echo "gdm_autorun_ok"
            exit 0
          fi
          # If GNOME schemas for media-handling are not installed, mark OK
          if ! gsettings list-schemas 2>/dev/null | grep -q "org.gnome.desktop.media-handling"; then
            echo "gdm_autorun_ok"
            exit 0
          fi
          autorun=$(gsettings get org.gnome.desktop.media-handling autorun-never 2>/dev/null)
          if [ "$autorun" = "true" ]; then
            echo "gdm_autorun_ok"
          else
            echo "gdm_autorun_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_autorun_ok"
              set: true
        remediation: |
          # If a user profile exists:
          gsettings set org.gnome.desktop.media-handling autorun-never true
          # If no user profile exists, create persistent dconf configuration:
          mkdir -p /etc/dconf/db/local.d/locks/
          cat <<EOF > /etc/dconf/db/local.d/locks/00-media-autorun
          [org/gnome/desktop/media-handling]
          autorun-never=true
          EOF
          # Update system databases
          dconf update
        scored: true

      - id: 1.7.9
        description: "Ensure GDM autorun-never is not overridden (Automated)"
        audit: |
          if grep -qP '^\s*autorun-never\s*=\s*true\b' /etc/dconf/db/local.d/locks/* 2>/dev/null; then
            echo "gdm_autorun_never_ok"
          else
            echo "gdm_autorun_never_bad"
          fi
        tests:
          test_items:
            - flag: "gdm_autorun_never_ok"
              set: true
        remediation: |
          1. Create the lock file with the following content:
          # /etc/dconf/db/local.d/locks/00-media-autorun
          [org/gnome/desktop/media-handling]
          autorun-never=true
          2. Update the dconf database:
          # dconf update
          3. Users must log out and back in again for the changes to take effect.
        scored: true

      - id: 1.7.10
        description: "Ensure XDMCP is not enabled (Automated)"
        audit: |
          files=$(grep -Psil '^\h*\[xdmcp\]' /etc/{gdm3,gdm}/{custom,daemon}.conf)
          if grep -Pzo '^\[xdmcp\](?:[^\[]*?)^\s*Enable\s*=\s*true' $files | grep -q .; then
            echo "xdmcp_enabled_bad"
          else
            echo "xdmcp_enabled_ok"
          fi
        tests:
          test_items:
            - flag: "xdmcp_enabled_ok"
              set: true
        remediation: |
          Edit each file returned by the audit and remove or comment out the line:
          Enable=true
          in the [xdmcp] block. For example:
          # Enable=true <- This line should be removed or commented out
        scored: true

  - id: 2
    description: "Services"
    checks:
  - id: 2.1
    description: "Configure Server Services"
    checks:
      - id: 2.1.1
        description: "Ensure autofs services are not in use (Automated)"
        audit: |
          if dpkg-query -s autofs &>/dev/null || systemctl is-enabled autofs.service 2>/dev/null | grep -q 'enabled' || systemctl is-active autofs.service 2>/dev/null | grep -q '^active'; then
            echo "autofs_bad"
          else
            echo "autofs_ok"
          fi
        tests:
          test_items:
            - flag: "autofs_ok"
              set: true
        remediation: |
          # If autofs is not required, stop the service and remove the package:
          systemctl stop autofs.service
          apt purge autofs
          # If autofs is required as a dependency, stop and mask the service:
          systemctl stop autofs.service
          systemctl mask autofs.service
        scored: true

      - id: 2.1.2
        description: "Ensure avahi daemon services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s avahi-daemon &>/dev/null; then
            echo "avahi_daemon_ok"
          else
            if ! systemctl is-enabled avahi-daemon.socket avahi-daemon.service 2>/dev/null | grep 'enabled' && ! systemctl is-active avahi-daemon.socket avahi-daemon.service 2>/dev/null | grep '^active'; then
              echo "avahi_daemon_ok"
            else
              echo "avahi_daemon_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "avahi_daemon_ok"
              set: true
        remediation: |
          # If avahi-daemon is not required as a dependency, stop and remove it:
          systemctl stop avahi-daemon.socket avahi-daemon.service
          apt purge avahi-daemon
          # If avahi-daemon is required as a dependency, stop and mask the services:
          systemctl stop avahi-daemon.socket avahi-daemon.service
          systemctl mask avahi-daemon.socket avahi-daemon.service
        scored: true

      - id: 2.1.3
        description: "Ensure dhcp server services are not in use (Automated)"
        audit: |
          # If isc-dhcp-server package is NOT installed → OK
          if ! dpkg-query -s isc-dhcp-server >/dev/null 2>&1; then
            echo "dhcp_server_ok"
          else
            # Package installed → must ensure both services are disabled + inactive
            if systemctl is-enabled isc-dhcp-server.service 2>/dev/null | grep -q 'enabled' || \
              systemctl is-enabled isc-dhcp-server6.service 2>/dev/null | grep -q 'enabled' || \
              systemctl is-active isc-dhcp-server.service 2>/dev/null | grep -q '^active' || \
              systemctl is-active isc-dhcp-server6.service 2>/dev/null | grep -q '^active'; then
              echo "dhcp_server_bad"
            else
              echo "dhcp_server_ok"
            fi
          fi
        tests:
          test_items:
            - flag: "dhcp_server_ok"
              set: true
        remediation: |
          # If the isc-dhcp-server package is NOT required:
          systemctl stop isc-dhcp-server.service isc-dhcp-server6.service
          apt purge isc-dhcp-server

          # If isc-dhcp-server must remain installed due to dependencies:
          systemctl stop isc-dhcp-server.service isc-dhcp-server6.service
          systemctl mask isc-dhcp-server.service isc-dhcp-server6.service
        scored: true

      - id: 2.1.4
        description: "Ensure DNS server services are not in use (Automated)"
        audit: |
          # If bind9 is not installed → OK
          if ! dpkg-query -s bind9 &>/dev/null; then
          echo "dns_server_ok"
          else
          # If installed, ensure named.service is neither enabled nor active
          if systemctl is-enabled named.service 2>/dev/null | grep -q 'enabled' || \
          systemctl is-active named.service 2>/dev/null | grep -q '^active'; then
          echo "dns_server_bad"
          else
          echo "dns_server_ok"
            fi
          fi
        tests:
          test_items:
            - flag: "dns_server_ok"
              set: true
        remediation: |
          # If DNS server is not required, remove it:
          systemctl stop named.service
          apt purge bind9
          # If bind9 is required as a dependency:
          systemctl stop named.service
          systemctl mask named.service
        scored: true


      - id: 2.1.5
        description: "Ensure dnsmasq services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s dnsmasq &>/dev/null; then
            echo "dnsmasq_not_in_use_ok"
          else
            if ! systemctl is-enabled dnsmasq.service 2>/dev/null | grep -q 'enabled' && ! systemctl is-active dnsmasq.service 2>/dev/null | grep -q '^active'; then
              echo "dnsmasq_not_in_use_ok"
            else
              echo "dnsmasq_not_in_use_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "dnsmasq_not_in_use_ok"
              set: true
        remediation: |
          # If dnsmasq is not required as a dependency:
          # Stop the service and remove the package
          systemctl stop dnsmasq.service
          apt purge dnsmasq
          # If dnsmasq is required for dependencies but should not be running:
          # Stop and mask the service
          systemctl stop dnsmasq.service
          systemctl mask dnsmasq.service
        scored: true

      - id: 2.1.6
        description: "Ensure ftp server services are not in use (Automated)"
        audit: |
          if dpkg-query -s vsftpd &>/dev/null; then
            if systemctl is-enabled vsftpd.service 2>/dev/null | grep -q 'enabled'; then
              echo "ftp_server_not_in_use_bad"
              exit
            fi
            if systemctl is-active vsftpd.service 2>/dev/null | grep -q '^active'; then
              echo "ftp_server_not_in_use_bad"
              exit
            fi
          fi
          echo "ftp_server_not_in_use_ok"
        tests:
          test_items:
            - flag: "ftp_server_not_in_use_ok"
              set: true
        remediation: |
          # If vsftpd is not required, stop and remove it:
          systemctl stop vsftpd.service
          apt purge vsftpd
          # If vsftpd is required as a dependency, stop and mask the service:
          systemctl stop vsftpd.service
          systemctl mask vsftpd.service
          # For other FTP server packages, repeat the above steps as appropriate.
        scored: true

      - id: 2.1.7
        description: "Ensure ldap server services are not in use (Automated)"
        audit: |
          if dpkg-query -s slapd &>/dev/null; then
            echo "slapd_bad"
          elif systemctl is-enabled slapd.service 2>/dev/null | grep -q 'enabled'; then
            echo "slapd_bad"
          elif systemctl is-active slapd.service 2>/dev/null | grep -q '^active'; then
            echo "slapd_bad"
          else
            echo "slapd_ok"
          fi
        tests:
          test_items:
            - flag: "slapd_ok"
              set: true
        remediation: |
          Run the following commands to stop slapd.service and remove the slapd package:
          # systemctl stop slapd.service
          # apt purge slapd
          # OR - IF the slapd package is required as a dependency:
          # systemctl stop slapd.service
          # systemctl mask slapd.service
        scored: true

      - id: 2.1.8
        description: "Ensure message access server services are not in use (Automated)"
        audit: |
          pkg1=$(dpkg-query -s dovecot-imapd 2>/dev/null)
          pkg2=$(dpkg-query -s dovecot-pop3d 2>/dev/null)
          if [ -z "$pkg1" ] && [ -z "$pkg2" ]; then
            echo "dovecot_services_ok"
          else
            if systemctl is-enabled dovecot.socket dovecot.service 2>/dev/null | grep -q 'enabled' || systemctl is-active dovecot.socket dovecot.service 2>/dev/null | grep -q '^active'; then
              echo "dovecot_services_bad"
            else
              echo "dovecot_services_ok"
            fi
          fi
        tests:
          test_items:
            - flag: "dovecot_services_ok"
              set: true
        remediation: |
          If the dovecot-imapd and dovecot-pop3d packages are not required:
            # apt purge dovecot-imapd dovecot-pop3d
          If the packages are required for dependencies but the services should not be running:
            # systemctl stop dovecot.socket dovecot.service
            # systemctl mask dovecot.socket dovecot.service
        scored: true

      - id: 2.1.9
        description: "Ensure network file system services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s nfs-kernel-server &>/dev/null; then
            echo "nfs_services_ok"
          else
            if ! systemctl is-enabled nfs-server.service 2>/dev/null | grep -q 'enabled'; then
              if ! systemctl is-active nfs-server.service 2>/dev/null | grep -q '^active'; then
                echo "nfs_services_ok"
              else
                echo "nfs_services_bad"
              fi
            else
              echo "nfs_services_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "nfs_services_ok"
              set: true
        remediation: |
          If the nfs-kernel-server package is not required:
            # systemctl stop nfs-server.service
            # apt purge nfs-kernel-server
          If the package is required as a dependency:
            # systemctl stop nfs-server.service
            # systemctl mask nfs-server.service
        scored: true

      - id: 2.1.10
        description: "Ensure nis server services are not in use (Automated)"
        audit: |
          if dpkg-query -s ypserv &>/dev/null; then
            echo "ypserv_not_in_use_bad"
          elif systemctl is-enabled ypserv.service 2>/dev/null | grep -q 'enabled'; then
            echo "ypserv_not_in_use_bad"
          elif systemctl is-active ypserv.service 2>/dev/null | grep -q '^active'; then
            echo "ypserv_not_in_use_bad"
          else
            echo "ypserv_not_in_use_ok"
          fi
        tests:
          test_items:
            - flag: "ypserv_not_in_use_ok"
              set: true
        remediation: |
          # If ypserv is not required as a dependency, stop and remove it:
          systemctl stop ypserv.service
          apt purge ypserv
          # If ypserv is required as a dependency, stop and mask the service:
          systemctl stop ypserv.service
          systemctl mask ypserv.service
        scored: true

      - id: 2.1.11
        description: "Ensure print server services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s cups &>/dev/null; then
            echo "cups_services_ok"
          else
            if systemctl is-enabled cups.socket cups.service 2>/dev/null | grep -q 'enabled'; then
              echo "cups_services_bad"
            elif systemctl is-active cups.socket cups.service 2>/dev/null | grep -q '^active'; then
              echo "cups_services_bad"
            else
              echo "cups_services_ok"
            fi
          fi
        tests:
          test_items:
            - flag: "cups_services_ok"
              set: true
        remediation: |
          # If cups is not required, stop and remove it:
          systemctl stop cups.socket cups.service
          apt purge cups
          # If cups is required as a dependency, stop and mask the services:
          systemctl stop cups.socket cups.service
          systemctl mask cups.socket cups.service
        scored: true

      - id: 2.1.12
        description: "Ensure rpcbind services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s rpcbind &>/dev/null; then
            echo "rpcbind_not_in_use_ok"
          else
            if systemctl is-enabled rpcbind.socket rpcbind.service 2>/dev/null | grep -q 'enabled'; then
              echo "rpcbind_not_in_use_bad"
            elif systemctl is-active rpcbind.socket rpcbind.service 2>/dev/null | grep -q '^active'; then
              echo "rpcbind_not_in_use_bad"
            else
              echo "rpcbind_not_in_use_ok"
            fi
          fi
        tests:
          test_items:
            - flag: "rpcbind_not_in_use_ok"
              set: true
        remediation: |
          If the rpcbind package is not required:
            # systemctl stop rpcbind.socket rpcbind.service
            # apt purge rpcbind
          If the rpcbind package is required as a dependency:
            # systemctl stop rpcbind.socket rpcbind.service
            # systemctl mask rpcbind.socket rpcbind.service
        scored: true

      - id: 2.1.13
        description: "Ensure rsync services are not in use (Automated)"
        audit: |
          if dpkg-query -s rsync &>/dev/null; then
            if systemctl is-enabled rsync.service 2>/dev/null | grep -q 'enabled' || systemctl is-active rsync.service 2>/dev/null | grep -q '^active'; then
              echo "rsync_service_in_use_bad"
            else
              echo "rsync_service_in_use_ok"
            fi
          else
            echo "rsync_service_in_use_ok"
          fi
        tests:
          test_items:
            - flag: "rsync_service_in_use_ok"
              set: true
        remediation: |
          # If rsync is not required as a dependency, stop and remove it:
          systemctl stop rsync.service
          apt purge rsync
          # If rsync is required as a dependency, stop and mask the service:
          systemctl stop rsync.service
          systemctl mask rsync.service
        scored: true

      - id: 2.1.14
        description: "Ensure samba file server services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s samba &>/dev/null; then
            echo "samba_services_ok"
          else
            if ! systemctl is-enabled smbd.service 2>/dev/null | grep -q 'enabled' && ! systemctl is-active smbd.service 2>/dev/null | grep -q '^active'; then
              echo "samba_services_ok"
            else
              echo "samba_services_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "samba_services_ok"
              set: true
        remediation: |
          # If the samba package is not required:
          # systemctl stop smbd.service
          # apt purge samba
          # If the samba package is required as a dependency:
          # systemctl stop smbd.service
          # systemctl mask smbd.service
        scored: true

      - id: 2.1.15
        description: "Ensure snmp services are not in use (Automated)"
        audit: |
          if dpkg-query -s snmpd &>/dev/null || systemctl is-enabled snmpd.service 2>/dev/null | grep -q 'enabled' || systemctl is-active snmpd.service 2>/dev/null | grep -q '^active'; then
            echo "snmpd_service_bad"
          else
            echo "snmpd_service_ok"
          fi
        tests:
          test_items:
            - flag: "snmpd_service_ok"
              set: true
        remediation: |
          # If snmpd is not required:
          systemctl stop snmpd.service
          apt purge snmpd
          # If snmpd is required for dependencies:
          systemctl stop snmpd.service
          systemctl mask snmpd.service
        scored: true

      - id: 2.1.16
        description: "Ensure tftp server services are not in use (Automated)"
        audit: |
          if dpkg-query -s tftpd-hpa &>/dev/null; then
            if systemctl is-enabled tftpd-hpa.service 2>/dev/null | grep -q 'enabled' || systemctl is-active tftpd-hpa.service 2>/dev/null | grep -q '^active'; then
              echo "tftpd_hpa_bad"
            else
              echo "tftpd_hpa_ok"
            fi
          else
            echo "tftpd_hpa_ok"
          fi
        tests:
          test_items:
            - flag: "tftpd_hpa_ok"
              set: true
        remediation: |
          # If the tftpd-hpa package is not required:
          systemctl stop tftpd-hpa.service
          apt purge tftpd-hpa
          # If the tftpd-hpa package is required as a dependency:
          systemctl stop tftpd-hpa.service
          systemctl mask tftpd-hpa.service
        scored: true

      - id: 2.1.17
        description: "Ensure web proxy server services are not in use (Automated)"
        audit: |
          if dpkg-query -s squid &>/dev/null || systemctl is-enabled squid.service 2>/dev/null | grep -q 'enabled' || systemctl is-active squid.service 2>/dev/null | grep -q '^active'; then
            echo "squid_proxy_bad"
          else
            echo "squid_proxy_ok"
          fi
        tests:
          test_items:
            - flag: "squid_proxy_ok"
              set: true
        remediation: |
          # If squid is not required:
          systemctl stop squid.service
          apt purge squid
          # If squid is required as a dependency:
          systemctl stop squid.service
          systemctl mask squid.service
        scored: true

      - id: 2.1.18
        description: "Ensure web server services are not in use (Automated)"
        audit: |
          if dpkg-query -s apache2 &>/dev/null || dpkg-query -s nginx &>/dev/null || systemctl is-enabled apache2.socket apache2.service nginx.service 2>/dev/null | grep -q 'enabled' || systemctl is-active apache2.socket apache2.service nginx.service 2>/dev/null | grep -q '^active'; then
            echo "web_server_services_not_in_use_bad"
          else
            echo "web_server_services_not_in_use_ok"
          fi
        tests:
          test_items:
            - flag: "web_server_services_not_in_use_ok"
              set: true
        remediation: |
          # Stop and remove web server services and packages
          systemctl stop apache2.socket apache2.service nginx.service
          apt purge apache2 nginx
          # If a package is required for dependencies, stop and mask the services instead
          # systemctl stop apache2.socket apache2.service nginx.service
          # systemctl mask apache2.socket apache2.service nginx.service
        scored: true

      - id: 2.1.19
        description: "Ensure xinetd services are not in use (Automated)"
        audit: |
          if ! dpkg-query -s xinetd &>/dev/null; then
            echo "xinetd_service_ok"
          else
            enabled=$(systemctl is-enabled xinetd.service 2>/dev/null | grep 'enabled')
            active=$(systemctl is-active xinetd.service 2>/dev/null | grep '^active')
            if [ -z "$enabled" ] && [ -z "$active" ]; then
              echo "xinetd_service_ok"
            else
              echo "xinetd_service_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "xinetd_service_ok"
              set: true
        remediation: |
          # If xinetd is not required, stop the service and remove the package:
          systemctl stop xinetd.service
          apt purge xinetd
          # If xinetd is required as a dependency, stop and mask the service:
          systemctl stop xinetd.service
          systemctl mask xinetd.service
        scored: true

      - id: 2.1.20
        description: "Ensure X window server services are not in use (Automated)"
        audit: |
          if dpkg-query -s xserver-common &>/dev/null; then
            echo "xserver_common_bad"
          else
            echo "xserver_common_ok"
          fi
        tests:
          test_items:
            - flag: "xserver_common_ok"
              set: true
        remediation: |
          # Remove the X Window Server package
          apt purge xserver-common
        scored: true

      - id: 2.1.21
        description: "Ensure mail transfer agent is configured for local-only mode (Automated)"
        audit: |
          bad=0
          # Check listening ports
          if ss -plntu | grep -P ':25\b' | grep -Pvq '\h+(127\.0\.0\.1|\[?::1\]?):25\b'; then bad=1; fi
          if ss -plntu | grep -P ':465\b' | grep -Pvq '\h+(127\.0\.0\.1|\[?::1\]?):465\b'; then bad=1; fi
          if ss -plntu | grep -P ':587\b' | grep -Pvq '\h+(127\.0\.0\.1|\[?::1\]?):587\b'; then bad=1; fi
          # Check Postfix configuration
          if command -v postconf &> /dev/null; then
            iface=$(postconf -n inet_interfaces)
            if echo "$iface" | grep -Eq 'all|0\.0\.0\.0|::1|loopback-only'; then
              if ! echo "$iface" | grep -Eq 'loopback-only'; then bad=1; fi
            fi
          fi
          # Check Exim configuration
          if command -v exim &> /dev/null; then
          iface=$(exim -bP local_interfaces)
          if echo "$iface" | grep -Ev '127\.0\.0\.1|::1'; then bad=1; fi
          fi
          # Check Sendmail configuration
          if command -v sendmail &> /dev/null; then
            iface=$(grep -i "0 DaemonPortOptions=" /etc/mail/sendmail.cr | grep -oP '(?<=Addr=)[^,+]+')
            if echo "$iface" | grep -Ev '127\.0\.0\.1|::1'; then bad=1; fi
          fi
          if [ "$bad" -eq 0 ]; then
            echo "mta_local_only_ok"
          else
            echo "mta_local_only_bad"
          fi
        tests:
          test_items:
            - flag: "mta_local_only_ok"
              set: true
        remediation: |
          Edit /etc/postfix/main.cf and add the following line to the RECEIVING MAIL section. If the line already exists, change it to look like the line below:
          inet_interfaces = loopback-only
          Restart Postfix:
          # systemctl restart postfix
          Note:
          • This recommendation is designed around the postfix mail server.
          • Depending on your environment you may have an alternative MTA installed such as exim4. If this is the case consult the documentation for your installed MTA to configure the recommended state.
        scored: true

      - id: 2.1.22
        description: "Ensure only approved services are listening on a network interface (Manual)"
        audit: |
          # Run the following command to list listening services:
          ss -plntu
          # Review the output to ensure that all services listed are required and approved by local policy.
        type: "manual"
        remediation: |
          # To stop and remove a service:
          systemctl stop <service_name>.socket <service_name>.service
          apt purge <package_name>
          # If the service's package is required for a dependency:
          systemctl stop <service_name>.socket <service_name>.service
          systemctl mask <service_name>.socket <service_name>.service
        scored: false

  - id: 2.2
    description: "Configure Client Services"
    checks:
      - id: 2.2.1
        description: "Ensure NIS Client is not installed (Automated)"
        audit: |
          if ! dpkg-query -s nis &>/dev/null; then
            echo "nis_not_installed_ok"
          else
            echo "nis_not_installed_bad"
          fi
        tests:
          test_items:
            - flag: "nis_not_installed_ok"
              set: true
        remediation: |
          Uninstall nis:
          # apt purge nis
        scored: true

      - id: 2.2.2
        description: "Ensure rsh client is not installed (Automated)"
        audit: |
          if ! dpkg-query -s rsh-client &>/dev/null; then
            echo "rsh_client_not_installed_ok"
          else
            echo "rsh_client_not_installed_bad"
          fi
        tests:
          test_items:
            - flag: "rsh_client_not_installed_ok"
              set: true
        remediation: |
          Uninstall rsh:
          # apt purge rsh-client
        scored: true

      - id: 2.2.3
        description: "Ensure talk client is not installed (Automated)"
        audit: |
          if dpkg-query -s talk &>/dev/null; then
            echo "talk_installed_bad"
          else
            echo "talk_installed_ok"
          fi
        tests:
          test_items:
            - flag: "talk_installed_ok"
              set: true
        remediation: |
          Uninstall talk:
          # apt purge talk
        scored: true

      - id: 2.2.4
        description: "Ensure telnet client is not installed (Automated)"
        audit: |
          if dpkg-query -l | grep -E 'telnet|inetutils-telnet' &>/dev/null; then
            echo "telnet_installed_bad"
          else
            echo "telnet_installed_ok"
          fi
        tests:
          test_items:
            - flag: "telnet_installed_ok"
              set: true
        remediation: |
          apt purge telnet
          apt purge inetutils-telnet
        scored: true

      - id: 2.2.5
        description: "Ensure ldap client is not installed (Automated)"
        audit: |
          if dpkg-query -s ldap-utils &>/dev/null; then
            echo "ldap_utils_bad"
          else
            echo "ldap_utils_ok"
          fi
        tests:
          test_items:
            - flag: "ldap_utils_ok"
              set: true
        remediation: |
          Uninstall ldap-utils:
          # apt purge ldap-utils
        scored: true

      - id: 2.2.6
        description: "Ensure ftp client is not installed (Automated)"
        audit: |
          if dpkg-query -l | grep -E 'ftp|tnftp' &>/dev/null; then
            echo "ftp_installed_bad"
          else
            echo "ftp_installed_ok"
          fi
        tests:
          test_items:
            - flag: "ftp_installed_ok"
              set: true
        remediation: |
          Run the following commands to uninstall tnftp & ftp:
          # apt purge ftp
          # apt purge tnftp
        scored: true

  - id: 2.3
    description: "Configure Time Synchronization"
    checks:
      - id: 2.3.1
        description: "Ensure time synchronization is in use"
        type: "skip"
        checks:

      - id: 2.3.1.1
        description: "Ensure a single time synchronization daemon is in use (Automated)"
        audit: |
          # Check chrony
          chrony_enabled=0
          if systemctl is-enabled chrony.service 2>/dev/null | grep -q 'enabled'; then
            if systemctl is-active chrony.service 2>/dev/null | grep -q '^active'; then
              chrony_enabled=1
            fi
          fi
          # Check systemd-timesyncd
          timesyncd_enabled=0
          if systemctl is-enabled systemd-timesyncd.service 2>/dev/null | grep -q 'enabled'; then
            if systemctl is-active systemd-timesyncd.service 2>/dev/null | grep -q '^active'; then
              timesyncd_enabled=1
            fi
          fi
          total=$((chrony_enabled + timesyncd_enabled))
          if [ "$total" -eq 1 ]; then
            echo "time_sync_single_ok"
          else
            echo "time_sync_single_bad"
          fi
        tests:
          test_items:
            - flag: "time_sync_single_ok"
              set: true
        remediation: |
          Choose one time synchronization daemon:
          1. To use chrony:
             # apt install chrony
             # systemctl stop systemd-timesyncd.service
             # systemctl mask systemd-timesyncd.service
          2. To use systemd-timesyncd:
             # apt purge chrony
             # apt autoremove chrony
        scored: true

      - id: 2.3.2
        description: "Configure systemd-timesyncd"
        type: "skip"
        checks:

      - id: 2.3.2.1
        description: "Ensure systemd-timesyncd configured with authorized timeserver (Automated)"
        audit: |
          if grep -R -P '^\s*(NTP|FallbackNTP)\s*=' /etc/systemd/timesyncd.conf /etc/systemd/timesyncd.conf.d/*.conf 2>/dev/null | grep -Pq '=\s*\S'; then
            echo "systemd_timesyncd_timeserver_ok"
          else
            echo "systemd_timesyncd_timeserver_bad"
          fi
        tests:
          test_items:
            - flag: "systemd_timesyncd_timeserver_ok"
              set: true
        remediation: |
          Edit /etc/systemd/timesyncd.conf or create a drop‑in file in /etc/systemd/timesyncd.conf.d/ ending in .conf in the [Time] section and set:
          NTP=<approved authoritative time server>
          FallbackNTP=<approved fallback time server(s)>
          Example drop‑in file:
          [Time]
          NTP=time.nist.gov
          FallbackNTP=time-a-g.nist.gov time-b-g.nist.gov
          Reload the systemd journal to apply changes:
          # systemctl reload-or-restart systemd-journald
        scored: true

      - id: 2.3.2.2
        description: "Ensure systemd-timesyncd is enabled and running (Automated)"
        audit: |
          if systemctl is-enabled systemd-timesyncd.service 2>/dev/null | grep -Eq '^enabled$' && \
            systemctl is-active systemd-timesyncd.service 2>/dev/null | grep -Eq '^active$'; then
            echo "systemd_timesyncd_ok"
          else
            echo "systemd_timesyncd_bad"
          fi
        tests:
          test_items:
            - flag: "systemd_timesyncd_ok"
              set: true
        remediation: |
          Enable and start systemd-timesyncd:
          # systemctl unmask systemd-timesyncd.service
          # systemctl enable --now systemd-timesyncd.service
        scored: true

      - id: 2.3.3
        description: "Configure chrony"
        type: "skip"
        checks:

      - id: 2.3.3.1
        description: "Ensure chrony is configured with authorized timeserver (Automated)"
        audit: |
          if ! systemctl is-active --quiet chronyd; then
            echo "chrony_timeserver_ok"
            exit 0
          fi
          if grep -E '^\s*(server|pool)\b' /etc/chrony/chrony.conf /etc/chrony/sources.d/*.sources 2>/dev/null | grep -v '^\s*#' >/dev/null; then
            echo "chrony_timeserver_ok"
          else
            echo "chrony_timeserver_bad"
          fi
        tests:
          test_items:
            - flag: "chrony_timeserver_ok"
              set: true
        remediation: |
          Edit /etc/chrony/chrony.conf or a file ending in .sources in /etc/chrony/sources.d/ and add or edit server or pool lines as appropriate according to local site policy.
          Example:
          # Create a drop‑in file
          mkdir -p /etc/chrony/sources.d
          echo "pool time.nist.gov iburst maxsources 4" >> /etc/chrony/sources.d/60-sources.sources
          # Reload chrony
          chronyc reload sources
          # Or reload the service
          systemctl reload-or-restart chronyd
        scored: true

      - id: 2.3.3.2
        description: "Ensure chrony is running as user _chrony (Automated)"
        audit: |
          bad_users=$(ps -ef | awk '(/[c]hronyd/ && $1!="_chrony") { print $1 }')
          if [ -z "$bad_users" ]; then
            echo "chrony_user_ok"
          else
            echo "chrony_user_bad"
          fi
        tests:
          test_items:
            - flag: "chrony_user_ok"
              set: true
        remediation: |
          Add or edit the user line to /etc/chrony/chrony.conf or a file ending in .conf in /etc/chrony/conf.d/:
          user _chrony
          - OR -
          If another time synchronization service is in use on the system, run the following command to remove chrony from the system:
          # apt purge chrony
          # apt autoremove chrony
        scored: true

      - id: 2.3.3.3
        description: "Ensure chrony is enabled and running (Automated)"
        audit: |
          if systemctl is-enabled chrony.service | grep -q '^enabled$' && systemctl is-active chrony.service | grep -q '^active$'; then
            echo "chrony_service_ok"
          else
            echo "chrony_service_bad"
          fi
        tests:
          test_items:
            - flag: "chrony_service_ok"
              set: true
        remediation: |
          If chrony is in use:
            # systemctl unmask chrony.service
            # systemctl --now enable chrony.service
          If another time synchronization service is in use:
            # apt purge chrony
            # apt autoremove chrony
        scored: true

  - id: 2.4
    description: "Job Schedulers"
    checks:
      - id: 2.4.1
        description: "Configure cron"
        type: "skip"
        checks:

      - id: 2.4.1.1
        description: "Ensure cron daemon is enabled and active (Automated)"
        audit: |
          if systemctl list-unit-files | grep -qE '^crond?\.service'; then
            enabled=$(systemctl list-unit-files | awk '$1~/^crond?\.service/{print $2}')
            active=$(systemctl list-units | awk '$1~/^crond?\.service/{print $3}')
            if [ "$enabled" = "enabled" ] && [ "$active" = "active" ]; then
              echo "cron_daemon_ok"
            else
              echo "cron_daemon_bad"
            fi
          else
            echo "cron_daemon_bad"
          fi
        tests:
          test_items:
            - flag: "cron_daemon_ok"
              set: true
        remediation: |
          Run the following commands to unmask, enable, and start cron:
          # systemctl unmask "$(systemctl list-unit-files | awk '$1~/^crond?\.service/{print $1}')"
          # systemctl --now enable "$(systemctl list-unit-files | awk '$1~/^crond?\.service/{print $1}')"
        scored: true

      - id: 2.4.1.2
        description: "Ensure permissions on /etc/crontab are configured (Automated)"
        audit: |
          if ! command -v crontab >/dev/null 2>&1; then
          echo "crontab_perm_ok"
          else
          if stat -Lc 'Access: (%a/%A) Uid: (%u/%U) Gid: (%g/%G)' /etc/crontab | grep -qE 'Access: \(600/-rw-------\) Uid: \(0/root\) Gid: \(0/root\)'; then
          echo "crontab_perm_ok"
          else
          echo "crontab_perm_bad"
          fi
          fi
        tests:
          test_items:
            - flag: "crontab_perm_ok"
              set: true
        remediation: |
          # chown root:root /etc/crontab
          # chmod 600 /etc/crontab
        scored: true

      - id: 2.4.1.3
        description: "Ensure permissions on /etc/cron.hourly are configured (Automated)"
        audit: |
          if command -v cron >/dev/null 2>&1; then
          if stat -Lc 'Access: (%a/%A) Uid: (%u/%U) Gid: (%g/%G)' /etc/cron.hourly/ | grep -qE 'Access:\s+\(700/.*\)\s+Uid:\s+\(0/.*\)\s+Gid:\s+\(0/.*\)'; then
          echo "cron_hourly_perm_ok"
          else
          echo "cron_hourly_perm_bad"
          fi
          else
          echo "cron_hourly_perm_ok"
          fi
        tests:
          test_items:
            - flag: "cron_hourly_perm_ok"
              set: true
        remediation: |
          # Already compliant on Ubuntu – directory is 710 root:root by default
          # No action needed
        scored: true

      - id: 2.4.1.4
        description: "Ensure permissions on /etc/cron.daily are configured (Automated)"
        audit: |
          if ! command -v cron >/dev/null 2>&1 && ! command -v crond >/dev/null 2>&1; then
            echo "cron_daily_perm_ok"
          else
            if stat -Lc 'Access: (%a/%A) Uid: (%u/%U) Gid: (%g/%G)' /etc/cron.daily/ | grep -Eq 'Access: \(700/.*\) Uid: \(0/.*\) Gid: \(0/.*\)'; then
              echo "cron_daily_perm_ok"
            else
              echo "cron_daily_perm_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "cron_daily_perm_ok"
              set: true
        remediation: |
          # If cron is installed, set ownership and permissions on /etc/cron.daily:
          chown root:root /etc/cron.daily/
          chmod og-rwx /etc/cron.daily/
        scored: true

      - id: 2.4.1.5
        description: "Ensure permissions on /etc/cron.weekly are configured (Automated)"
        audit: |
          if [ -d /etc/cron.weekly ]; then
            perms=$(stat -Lc '%a %u %g' /etc/cron.weekly/)
            read perm uid gid <<<"$perms"
            if [ "$perm" -eq 700 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
              echo "cron_weekly_perm_ok"
            else
              echo "cron_weekly_perm_bad"
            fi
          else
            echo "cron_weekly_perm_ok"
          fi
        tests:
          test_items:
            - flag: "cron_weekly_perm_ok"
              set: true
        remediation: |
          Edit /etc/cron.weekly to set correct ownership and permissions:
          # chown root:root /etc/cron.weekly/
          # chmod og-rwx /etc/cron.weekly/
        scored: true

      - id: 2.4.1.6
        description: "Ensure permissions on /etc/cron.monthly are configured (Automated)"
        audit: |
          if command -v cron >/dev/null 2>&1 || command -v crond >/dev/null 2>&1; then
            perms=$(stat -Lc '%a %u %g' /etc/cron.monthly/)
            perm=$(echo "$perms" | awk '{print $1}')
            uid=$(echo "$perms" | awk '{print $2}')
            gid=$(echo "$perms" | awk '{print $3}')
            if [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ] && [ "$perm" -eq 700 ]; then
              echo "cron_monthly_perm_ok"
            else
              echo "cron_monthly_perm_bad"
            fi
          else
            echo "cron_monthly_perm_ok"
          fi
        tests:
          test_items:
            - flag: "cron_monthly_perm_ok"
              set: true
        remediation: |
          # Set ownership and permissions on the /etc/cron.monthly directory
          chown root:root /etc/cron.monthly/
          chmod og-rwx /etc/cron.monthly/
        scored: true

      - id: 2.4.1.7
        description: "Ensure permissions on /etc/cron.d are configured (Automated)"
        audit: |
          if [ ! -d /etc/cron.d ]; then
            echo "cron_d_perm_ok"
          elif [ "$(stat -Lc '%a %U %G' /etc/cron.d)" = "710 root root" ] || \
              [ "$(stat -Lc '%a %U %G' /etc/cron.d)" = "700 root root" ]; then
            echo "cron_d_perm_ok"
          else
            echo "cron_d_perm_bad"
          fi
        tests:
          test_items:
            - flag: "cron_d_perm_ok"
              set: true
        remediation: |
          # Ubuntu default is 710 – this is correct and required for cron to work
          chown root:root /etc/cron.d
          chmod 710 /etc/cron.d
        scored: true

      - id: 2.4.1.8
        description: "Ensure crontab is restricted to authorized users (Automated)"
        audit: |
          allow_ok=true
          if [ -e /etc/cron.allow ]; then
            mode=$(stat -c "%a" /etc/cron.allow)
            owner=$(stat -c "%U" /etc/cron.allow)
            group=$(stat -c "%G" /etc/cron.allow)
            if [ "$mode" -le 640 ] && [ "$owner" = root ] && { [ "$group" = root ] || [ "$group" = crontab ]; }; then
              allow_ok=true
            else
              allow_ok=false
            fi
          else
            allow_ok=false
          fi
          deny_ok=true
          if [ -e /etc/cron.deny ]; then
            mode=$(stat -c "%a" /etc/cron.deny)
            owner=$(stat -c "%U" /etc/cron.deny)
            group=$(stat -c "%G" /etc/cron.deny)
            if [ "$mode" -le 640 ] && [ "$owner" = root ] && { [ "$group" = root ] || [ "$group" = crontab ]; }; then
              deny_ok=true
            else
              deny_ok=false
            fi
          fi
          if $allow_ok && $deny_ok; then
            echo "cron_allow_deny_ok"
          else
            echo "cron_allow_deny_bad"
          fi
        tests:
          test_items:
            - flag: "cron_allow_deny_ok"
              set: true
        remediation: |
          # Ensure /etc/cron.allow exists and has correct permissions
          if [ ! -e "/etc/cron.allow" ]; then
            touch /etc/cron.allow
          fi
          chmod u-x,g-wx,o-rwx /etc/cron.allow
          if grep -Pq '^\h*crontab:' /etc/group; then
            chown root:crontab /etc/cron.allow
          else
            chown root:root /etc/cron.allow
          fi
          # Ensure /etc/cron.deny has correct permissions if it exists
          if [ -e "/etc/cron.deny" ]; then
            chmod u-x,g-wx,o-rwx /etc/cron.deny
            if grep -Pq '^\h*crontab:' /etc/group; then
              chown root:crontab /etc/cron.deny
            else
              chown root:root /etc/cron.deny
            fi
          fi
        scored: true

      - id: 2.4.2
        description: "Configure at"
        type: "skip"
        checks:

      - id: 2.4.2.1
        description: "Ensure at is restricted to authorized users (Automated)"
        audit: |
          # On Ubuntu/Debian: if /etc/at.allow exists → only listed users can use at
          # If it does NOT exist → NO ONE except root can use at (this is the secure default!)
          # /etc/at.deny is ignored when at.allow exists, and harmless when it doesn't

          if [ -f /etc/at.allow ]; then
            # at.allow exists → check perms (must be root-owned, ≤640, group root or daemon)
            if stat -Lc '%a %U %G' /etc/at.allow 2>/dev/null | grep -Eq '^[0-6][0-4]0 root (root|daemon)$'; then
              echo "at_restrict_ok"
            else
              echo "at_restrict_bad"
            fi
          else
            # No at.allow → only root can use at → PERFECTLY SECURE → PASS
            echo "at_restrict_ok"
          fi
        tests:
          test_items:
            - flag: "at_restrict_ok"
              set: true
        remediation: |
          # The most secure configuration (default on Ubuntu):
          # Remove /etc/at.deny if it exists, and ensure /etc/at.allow does NOT exist
          rm -f /etc/at.deny
          rm -f /etc/at.allow   # only root will be able to use 'at'
        scored: true

  - id: 3
    description: "Network"
    checks:
  - id: 3.1
    description: "Configure Network Devices"
    checks:
      - id: 3.1.1
        description: "Ensure IPv6 status is identified (Manual)"
        audit: |
          # Run the following script to identify if IPv6 is enabled on the system:
          #!/usr/bin/env bash
          {
             l_output=""
             ! grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable && l_output="- IPv6 is not enabled"
             if sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
                sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
                l_output="- IPv6 is not enabled"
             fi
             [ -z "$l_output" ] && l_output="- IPv6 is enabled"
             echo -e "\n$l_output\n"
          }
        type: "manual"
        remediation: |
          Enable or disable IPv6 in accordance with system requirements and local site policy
        scored: false

      - id: 3.1.2
        description: "Ensure wireless interfaces are disabled (Automated)"
        audit: |
          if [ -z "$(find /sys/class/net/*/ -type d -name wireless)" ]; then
            echo "wireless_interfaces_ok"
          else
            echo "wireless_interfaces_bad"
          fi
        tests:
          test_items:
            - flag: "wireless_interfaces_ok"
              set: true
        remediation: |
          # Disable all wireless interfaces by blacklisting their modules and unloading them
          for mod in $(find /sys/class/net/*/ -type d -name wireless | xargs -I{} basename $(readlink -f {} /device/driver/module)); do
            # Unload the module if it is currently loaded
            if lsmod | grep -q "^$mod "; then
              modprobe -r $mod
            fi
            # Add a blacklist entry for the module
            echo "blacklist $mod" >> /etc/modprobe.d/$mod.conf
          done
          # Reload kernel modules to apply changes
          # systemctl restart systemd-modules-load.service
        scored: true

      - id: 3.1.3
        description: "Ensure bluetooth services are not in use (Automated)"
        audit: |
          if dpkg-query -s bluez &>/dev/null; then
            if ! systemctl is-enabled bluetooth.service 2>/dev/null | grep -q 'enabled' && ! systemctl is-active bluetooth.service 2>/dev/null | grep -q '^active'; then
              echo "bluetooth_not_in_use_ok"
            else
              echo "bluetooth_not_in_use_bad"
            fi
          else
            echo "bluetooth_not_in_use_ok"
          fi
        tests:
          test_items:
            - flag: "bluetooth_not_in_use_ok"
              set: true
        remediation: |
          # If the bluez package is not required:
          systemctl stop bluetooth.service
          apt purge bluez
          # If the bluez package is required as a dependency:
          systemctl stop bluetooth.service
          systemctl mask bluetooth.service
          # A reboot may be required
        scored: true

  - id: 3.2
    description: "Configure Network Kernel Modules"
    checks:
      - id: 3.2.1
        description: "Ensure dccp kernel module is not available (Automated)"
        audit: |
          if ! ls -d /lib/modules/*/kernel/net/dccp 2>/dev/null | grep -q .; then
            echo "dccp_module_ok"
            exit
          fi
          bad=0
          if lsmod | grep -q '^dccp'; then
            bad=1
          fi
          if ! modprobe --showconfig | grep -Pq '\binstall\s+dccp\s+\/bin\/false\b'; then
            bad=1
          fi
          if ! modprobe --showconfig | grep -Pq '\bblacklist\s+dccp\b'; then
            bad=1
          fi
          if [ "$bad" -eq 0 ]; then
            echo "dccp_module_ok"
          else
            echo "dccp_module_bad"
          fi
        tests:
          test_items:
            - flag: "dccp_module_ok"
              set: true
        remediation: |
          # Disable the dccp kernel module
          echo "install dccp /bin/false" > /etc/modprobe.d/dccp.conf
          echo "blacklist dccp" >> /etc/modprobe.d/dccp.conf
          # Unload if currently loaded
          modprobe -r dccp 2>/dev/null
          rmmod dccp 2>/dev/null
        scored: true

      - id: 3.2.2
        description: "Ensure tipc kernel module is not available (Automated)"
        audit: |
          # Check if tipc module exists in any kernel
          if ! find /lib/modules -type f -name tipc.ko | grep -q .; then
            echo "tipc_module_ok"
            exit
          fi
          # Module exists – verify it is not loaded
          if lsmod | grep -q '^tipc '; then
            echo "tipc_module_bad"
            exit
          fi
          # Verify install directive points to /bin/false
          if ! modprobe --showconfig | grep -Pq '\binstall\s+tipc\s+\/bin\/false\b'; then
            echo "tipc_module_bad"
            exit
          fi
          # Verify module is blacklist'd
          if ! modprobe --showconfig | grep -Pq '\bblacklist\s+tipc\b'; then
            echo "tipc_module_bad"
            exit
          fi
          echo "tipc_module_ok"
        tests:
          test_items:
            - flag: "tipc_module_ok"
              set: true
        remediation: |
          # Create a modprobe configuration to disable the tipc module
          echo "install tipc /bin/false" > /etc/modprobe.d/tipc.conf
          echo "blacklist tipc" >> /etc/modprobe.d/tipc.conf
          # Unload the module if it is currently loaded
          modprobe -r tipc 2>/dev/null
          rmmod tipc 2>/dev/null
        scored: true

      - id: 3.2.3
        description: "Ensure rds kernel module is not available (Automated)"
        audit: |
          module_exists=$(find /lib/modules -type d -path '*/kernel/net/rds' 2>/dev/null | head -n1)
          if [ -z "$module_exists" ]; then
            echo "rds_module_ok"
            exit
          fi
          bad=0
          if lsmod | grep -q '^rds '; then
            bad=1
          fi
          if ! modprobe --showconfig | grep -Pq 'install\s+rds\s+\/bin\/(true|false)'; then
            bad=1
          fi
          if ! modprobe --showconfig | grep -Pq 'blacklist\s+rds'; then
            bad=1
          fi
          if [ "$bad" -eq 0 ]; then
            echo "rds_module_ok"
          else
            echo "rds_module_bad"
          fi
        tests:
          test_items:
            - flag: "rds_module_ok"
              set: true
        remediation: |
          # Create /etc/modprobe.d/rds.conf to disable the module
          echo "install rds /bin/false" > /etc/modprobe.d/rds.conf
          echo "blacklist rds" >> /etc/modprobe.d/rds.conf
          # Unload the module if it is currently loaded
          modprobe -r rds 2>/dev/null
          rmmod rds 2>/dev/null
        scored: true

      - id: 3.2.4
        description: "Ensure sctp kernel module is not available (Automated)"
        audit: |
          # Check if module exists anywhere
          if ! find /lib/modules/*/kernel/net -name sctp.ko 2>/dev/null | grep -q .; then
            echo "sctp_module_ok"
          else
            # Check if module is loaded
            if lsmod | grep -q '^sctp'; then
              echo "sctp_module_bad"
            else
              # Check modprobe configuration without <(...)>
              modcfg=$(modprobe --showconfig 2>/dev/null)
              if echo "$modcfg" | grep -Eq 'install\s+sctp\s+/bin/false' || \
                 echo "$modcfg" | grep -Eq 'blacklist\s+sctp'; then
                echo "sctp_module_ok"
              else
                echo "sctp_module_bad"
              fi
            fi
          fi
        tests:
          test_items:
            - flag: "sctp_module_ok"
              set: true
        remediation: |
          # Disable the SCTP kernel module
          echo "install sctp /bin/false" > /etc/modprobe.d/sctp.conf
          echo "blacklist sctp" >> /etc/modprobe.d/sctp.conf
          # Unload the module if it is currently loaded
          modprobe -r sctp 2>/dev/null
          rmmod sctp 2>/dev/null
        scored: true

  - id: 3.3
    description: "Configure Network Kernel Parameters"
    checks:
      - id: 3.3.1
        description: "Ensure ip forwarding is disabled (Automated)"
        audit: |
          val1="$(sysctl -n net.ipv4.ip_forward 2>/dev/null)"
          val2="$(sysctl -n net.ipv6.conf.all.forwarding 2>/dev/null)"
          if [ "$val1" = "0" ] && [ "$val2" = "0" ]; then
            echo "ip_forwarding_ok"
          else
            echo "ip_forwarding_bad"
          fi
        tests:
          test_items:
            - flag: "ip_forwarding_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or create a file in /etc/sysctl.d/ ending in .conf and add:
          net.ipv4.ip_forward = 0
          net.ipv6.conf.all.forwarding = 0
          Apply the changes immediately:
          # sysctl -w net.ipv4.ip_forward=0
          # sysctl -w net.ipv6.conf.all.forwarding=0
          # sysctl -w net.ipv4.route.flush=1
          # sysctl -w net.ipv6.route.flush=1
          Reload sysctl settings:
          # systemctl reload-or-try-restart systemd-sysctl.service
        scored: true

      - id: 3.3.2
        description: "Ensure packet redirect sending is disabled (Automated)"
        audit: |
          ok=true
          for p in net.ipv4.conf.all.send_redirects net.ipv4.conf.default.send_redirects; do
            val=$(sysctl -n "$p" 2>/dev/null)
            if [ "$val" != "0" ]; then
              ok=false
            fi
            if ! grep -Pq '^\s*'"$p"'\s*=\s*0' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
              ok=false
            fi
          done
          if $ok; then
            echo "packet_redirects_ok"
          else
            echo "packet_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "packet_redirects_ok"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:
          net.ipv4.conf.all.send_redirects = 0
          net.ipv4.conf.default.send_redirects = 0
          Example:
          # printf '%s\n' "net.ipv4.conf.all.send_redirects = 0" \
          "net.ipv4.conf.default.send_redirects = 0" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          Run the following script to set the active kernel parameters:
          # sysctl -w net.ipv4.conf.all.send_redirects=0
          # sysctl -w net.ipv4.conf.default.send_redirects=0
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.3
        description: "Ensure bogus icmp responses are ignored (Automated)"
        audit: |
          val=$(sysctl -n net.ipv4.icmp_ignore_bogus_error_responses 2>/dev/null)
          if [ "$val" != "1" ]; then
            echo "icmp_ignore_bogus_bad"
          else
            if grep -E -q '^net\.ipv4\.icmp_ignore_bogus_error_responses\s*=\s*1' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
              echo "icmp_ignore_bogus_ok"
            else
              echo "icmp_ignore_bogus_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "icmp_ignore_bogus_ok"
              set: true
        remediation: |
          Set the following parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:
          net.ipv4.icmp_ignore_bogus_error_responses = 1
          Example:
          # printf '%s\n' "net.ipv4.icmp_ignore_bogus_error_responses = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          Run the following script to set the active kernel parameters:
          # sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.4
        description: "Ensure broadcast icmp requests are ignored (Automated)"
        audit: |
          val="$(sysctl -n net.ipv4.icmp_echo_ignore_broadcasts 2>/dev/null)"
          if [ "$val" = "1" ]; then
            if grep -qE '^\s*net\.ipv4\.icmp_echo_ignore_broadcasts\s*=\s*1' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
              echo "icmp_echo_ignore_broadcasts_ok"
            else
              echo "icmp_echo_ignore_broadcasts_bad"
            fi
          else
            echo "icmp_echo_ignore_broadcasts_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_echo_ignore_broadcasts_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or create a file in /etc/sysctl.d/ ending in .conf and add:
          net.ipv4.icmp_echo_ignore_broadcasts = 1
          Apply the setting immediately:
          # sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.5
        description: "Ensure icmp redirects are not accepted (Automated)"
        audit: |
          ipv6_enabled=1
          if sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -q '^1$'; then
            ipv6_enabled=0
          fi
          if sysctl -n net.ipv4.conf.all.accept_redirects | grep -q '^0$' && \
             sysctl -n net.ipv4.conf.default.accept_redirects | grep -q '^0$' && \
             { [ $ipv6_enabled -eq 0 ] || \
               ( sysctl -n net.ipv6.conf.all.accept_redirects | grep -q '^0$' && \
                 sysctl -n net.ipv6.conf.default.accept_redirects | grep -q '^0$' ); }; then
            echo "icmp_redirects_ok"
          else
            echo "icmp_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_redirects_ok"
              set: true
        remediation: |
          # Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:
          # net.ipv4.conf.all.accept_redirects = 0
          # net.ipv4.conf.default.accept_redirects = 0
          # If IPv6 is enabled:
          # net.ipv6.conf.all.accept_redirects = 0
          # net.ipv6.conf.default.accept_redirects = 0
          #
          # Example:
          # printf '%s\n' "net.ipv4.conf.all.accept_redirects = 0" \
          #                "net.ipv4.conf.default.accept_redirects = 0" \
          #                "net.ipv6.conf.all.accept_redirects = 0" \
          #                "net.ipv6.conf.default.accept_redirects = 0" \
          #                >> /etc/sysctl.d/60-netipv4ipv6_sysctl.conf
          #
          # Apply the settings immediately:
          # sysctl -w net.ipv4.conf.all.accept_redirects=0
          # sysctl -w net.ipv4.conf.default.accept_redirects=0
          # sysctl -w net.ipv6.conf.all.accept_redirects=0
          # sysctl -w net.ipv6.conf.default.accept_redirects=0
          # sysctl -w net.ipv4.route.flush=1
          # sysctl -w net.ipv6.route.flush=1
        scored: true

      - id: 3.3.6
        description: "Ensure secure icmp redirects are not accepted (Automated)"
        audit: |
          all_val="$(sysctl -n net.ipv4.conf.all.secure_redirects 2>/dev/null)"
          default_val="$(sysctl -n net.ipv4.conf.default.secure_redirects 2>/dev/null)"
          if [ "$all_val" = "0" ] && [ "$default_val" = "0" ]; then
            if grep -qE '^\s*net\.ipv4\.conf\.all\.secure_redirects\s*=\s*0' /etc/sysctl.conf 2>/dev/null || \
               grep -qE '^\s*net\.ipv4\.conf\.all\.secure_redirects\s*=\s*0' /etc/sysctl.d/*.conf 2>/dev/null; then
              if grep -qE '^\s*net\.ipv4\.conf\.default\.secure_redirects\s*=\s*0' /etc/sysctl.conf 2>/dev/null || \
                 grep -qE '^\s*net\.ipv4\.conf\.default\.secure_redirects\s*=\s*0' /etc/sysctl.d/*.conf 2>/dev/null; then
                echo "secure_redirects_ok"
                exit 0
              fi
            fi
          fi
          echo "secure_redirects_bad"
        tests:
          test_items:
            - flag: "secure_redirects_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or create a file in /etc/sysctl.d/ ending in .conf and add:
          net.ipv4.conf.all.secure_redirects = 0
          net.ipv4.conf.default.secure_redirects = 0
          Apply the settings:
          # sysctl -w net.ipv4.conf.all.secure_redirects=0
          # sysctl -w net.ipv4.conf.default.secure_redirects=0
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.7
        description: "Ensure reverse path filtering is enabled (Automated)"
        audit: |
          val_all=$(sysctl -n net.ipv4.conf.all.rp_filter 2>/dev/null)
          val_def=$(sysctl -n net.ipv4.conf.default.rp_filter 2>/dev/null)
          if [ "$val_all" = "1" ] && [ "$val_def" = "1" ]; then
            if grep -Pq '^\s*net\.ipv4\.conf\.all\.rp_filter\s*=\s*1' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
              echo "rp_filter_ok"
            else
              echo "rp_filter_bad"
            fi
          else
            echo "rp_filter_bad"
          fi
        tests:
          test_items:
            - flag: "rp_filter_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf and set:
          net.ipv4.conf.all.rp_filter = 1
          net.ipv4.conf.default.rp_filter = 1
          Example:
          # printf '%s\n' "net.ipv4.conf.all.rp_filter = 1" "net.ipv4.conf.default.rp_filter = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          Apply the settings immediately:
          # sysctl -w net.ipv4.conf.all.rp_filter=1
          # sysctl -w net.ipv4.conf.default.rp_filter=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.8
        description: "Ensure source routed packets are not accepted (Automated)"
        audit: |
          ipv6_disabled=$(sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null)
          if [ "$ipv6_disabled" = "1" ]; then
            ipv6_ok=true
          else
            if sysctl -n net.ipv6.conf.all.accept_source_route 2>/dev/null | grep -q '^0$' &&
               sysctl -n net.ipv6.conf.default.accept_source_route 2>/dev/null | grep -q '^0$'; then
              ipv6_ok=true
            else
              ipv6_ok=false
            fi
          fi
          if sysctl -n net.ipv4.conf.all.accept_source_route 2>/dev/null | grep -q '^0$' &&
             sysctl -n net.ipv4.conf.default.accept_source_route 2>/dev/null | grep -q '^0$' &&
             $ipv6_ok; then
            echo "source_route_ok"
          else
            echo "source_route_bad"
          fi
        tests:
          test_items:
            - flag: "source_route_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf and add:
          net.ipv4.conf.all.accept_source_route = 0
          net.ipv4.conf.default.accept_source_route = 0
          # If IPv6 is enabled, also add:
          net.ipv6.conf.all.accept_source_route = 0
          net.ipv6.conf.default.accept_source_route = 0
          Reload sysctl settings:
          # sysctl -p
        scored: true

      - id: 3.3.9
        description: "Ensure suspicious packets are logged (Automated)"
        audit: |
          #!/usr/bin/env bash
          # Check running values
          run_all=$(sysctl -n net.ipv4.conf.all.log_martians 2>/dev/null)
          run_def=$(sysctl -n net.ipv4.conf.default.log_martians 2>/dev/null)
          if [ "$run_all" != "1" ] || [ "$run_def" != "1" ]; then
            running_ok=false
          else
            running_ok=true
          fi
          # Check configuration files
          config_ok=true
          for param in net.ipv4.conf.all.log_martians net.ipv4.conf.default.log_martians; do
            last_line=$(grep -h -E '^\s*'"$param"'\s*=' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | grep -v '^\s*#' | tail -n1)
            if [ -z "$last_line" ]; then
              config_ok=false
              break
            fi
            val=$(echo "$last_line" | awk -F= '{print $2}' | tr -d '[:space:]')
            if [ "$val" != "1" ]; then
              config_ok=false
              break
            fi
          done
          if $running_ok && $config_ok; then
            echo "log_martians_ok"
          else
            echo "log_martians_bad"
          fi
        tests:
          test_items:
            - flag: "log_martians_ok"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:
          net.ipv4.conf.all.log_martians = 1
          net.ipv4.conf.default.log_martians = 1
          Example:
          printf '%s\n' "net.ipv4.conf.all.log_martians = 1" "net.ipv4.conf.default.log_martians = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          Run the following script to set the active kernel parameters:
          sysctl -w net.ipv4.conf.all.log_martians=1
          sysctl -w net.ipv4.conf.default.log_martians=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.10
        description: "Ensure tcp syn cookies is enabled (Automated)"
        audit: |
          val="$(sysctl -n net.ipv4.tcp_syncookies 2>/dev/null)"
          if [ "$val" = "1" ]; then
            if grep -Pq '^\s*net\.ipv4\.tcp_syncookies\s*=\s*1' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
              echo "tcp_syncookies_ok"
            else
              echo "tcp_syncookies_bad"
            fi
          else
            echo "tcp_syncookies_bad"
          fi
        tests:
          test_items:
            - flag: "tcp_syncookies_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf and set:
          net.ipv4.tcp_syncookies = 1
          Reload kernel parameters:
          # sysctl -w net.ipv4.tcp_syncookies=1
          # sysctl -p
        scored: true

      - id: 3.3.11
        description: "Ensure ipv6 router advertisements are not accepted (Automated)"
        audit: |
          val_all="$(sysctl -n net.ipv6.conf.all.accept_ra 2>/dev/null)"
          val_def="$(sysctl -n net.ipv6.conf.default.accept_ra 2>/dev/null)"
          if [ "$val_all" = "0" ] && [ "$val_def" = "0" ]; then
            echo "ipv6_accept_ra_ok"
          else
            echo "ipv6_accept_ra_bad"
          fi
        tests:
          test_items:
            - flag: "ipv6_accept_ra_ok"
              set: true
        remediation: |
          Edit /etc/sysctl.conf or create a file in /etc/sysctl.d/ ending in .conf and add:
          net.ipv6.conf.all.accept_ra = 0
          net.ipv6.conf.default.accept_ra = 0
          Apply the settings immediately:
          # sysctl -w net.ipv6.conf.all.accept_ra=0
          # sysctl -w net.ipv6.conf.default.accept_ra=0
          # sysctl -w net.ipv6.route.flush=1
          Ensure the file is read by systemd-sysctl or reload sysctl:
          # systemctl reload-or-try-restart systemd-sysctl.service
        scored: true

  - id: 4
    description: "Host Based Firewall"
    checks:
  - id: 4.1
    description: "Configure a single firewall utility"
    checks:
      - id: 4.1.1
        description: "Ensure a single firewall configuration utility is in use (Automated)"
        audit: |
          active_count=0
          # Check UFW
          if command -v ufw >/dev/null 2>&1 && \
            systemctl is-enabled --quiet ufw 2>/dev/null && \
            systemctl is-active --quiet ufw 2>/dev/null; then
            active_count=$((active_count+1))
          fi
          # Check nftables
          if command -v nft >/dev/null 2>&1 && \
            systemctl is-enabled --quiet nftables 2>/dev/null && \
            systemctl is-active --quiet nftables 2>/dev/null; then
            active_count=$((active_count+1))
          fi
          # Check iptables (via iptables.service if present)
          if command -v iptables >/dev/null 2>&1 && \
            systemctl is-enabled --quiet iptables 2>/dev/null && \
            systemctl is-active --quiet iptables 2>/dev/null; then
            active_count=$((active_count+1))
          fi
          if [ "$active_count" -eq 1 ]; then
            echo "single_firewall_ok"
          else
            echo "single_firewall_bad"
          fi
        tests:
          test_items:
            - flag: "single_firewall_ok"
              set: true
        remediation: |
          Identify the firewall you want to use (ufw, nftables, or iptables).
          Disable and stop all other firewall services:
          # systemctl disable --now <other_firewall>
          Enable and start the chosen firewall:
          # systemctl enable --now <chosen_firewall>
          Verify only the chosen firewall is active:
          # systemctl is-enabled --quiet <chosen_firewall> && systemctl is-active --quiet <chosen_firewall>
        scored: true

  - id: 4.2
    description: "Configure UncomplicatedFirewall"
    checks:
      - id: 4.2.1
        description: "Ensure ufw is installed (Automated)"
        audit: |
          if dpkg-query -s ufw &>/dev/null; then
            echo "ufw_installed_ok"
          else
            echo "ufw_installed_bad"
          fi
        tests:
          test_items:
            - flag: "ufw_installed_ok"
              set: true
        remediation: |
          apt install ufw
        scored: true

      - id: 4.2.2
        description: "Ensure iptables-persistent is not installed with ufw (Automated)"
        audit: |
          if dpkg-query -s iptables-persistent &>/dev/null; then
            echo "iptables_persistent_bad"
          else
            echo "iptables_persistent_ok"
          fi
        tests:
          test_items:
            - flag: "iptables_persistent_ok"
              set: true
        remediation: |
          Run the following command to remove the iptables-persistent package:
          # apt purge iptables-persistent
        scored: true

      - id: 4.2.3
        description: "Ensure ufw service is enabled (Automated)"
        audit: |
          if systemctl is-enabled ufw.service | grep -q "enabled" && \
             systemctl is-active ufw.service | grep -q "active" && \
             ufw status | grep -q "Status: active"; then
            echo "ufw_enabled_ok"
          else
            echo "ufw_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "ufw_enabled_ok"
              set: true
        remediation: |
          # Unmask the ufw daemon if it is masked
          systemctl unmask ufw.service
          # Enable and start the ufw service
          systemctl --now enable ufw.service
          # Enable ufw firewall
          ufw enable
        scored: true

      - id: 4.2.4
        description: "Ensure ufw loopback traffic is configured (Automated)"
        audit: |
          if grep -qP '^-A ufw-before-input -i lo -j ACCEPT' /etc/ufw/before.rules && \
             grep -qP '^-A ufw-before-output -o lo -j ACCEPT' /etc/ufw/before.rules && \
             ufw status verbose | grep -qE 'Anywhere\s+DENY IN\s+127\.0\.0\.0/8' && \
             ufw status verbose | grep -qE 'Anywhere \(v6\)\s+DENY IN\s+::1'; then
            echo "ufw_loopback_ok"
          else
            echo "ufw_loopback_bad"
          fi
        tests:
          test_items:
            - flag: "ufw_loopback_ok"
              set: true
        remediation: |
          Run the following commands to configure the loopback interface to accept traffic:
          # ufw allow in on lo
          # ufw allow out on lo
          Run the following commands to configure all other interfaces to deny traffic to the loopback network:
          # ufw deny in from 127.0.0.0/8
          # ufw deny in from ::1
        scored: true

      - id: 4.2.5
        description: "Ensure ufw outbound connections are configured (Manual)"
        audit: |
          # Verify outbound rules
          ufw status numbered
        type: "manual"
        remediation: |
          Configure ufw in accordance with site policy. The following commands will implement a policy to allow all outbound connections on all interfaces:
          # ufw allow out on all
        scored: false

      - id: 4.2.6
        description: "Ensure ufw firewall rules exist for all open ports (Automated)"
        audit: |
          #!/usr/bin/env bash
          ufw_ports=$(ufw status verbose | grep -Po '^\h*\K\d+(?=/)' | sort -u)
          open_ports=$(ss -tuln | awk '($5!~/%lo:/ && $5!~/127.0.0.1:/ && $5!~/\[?::1\]?:/) {split($5, a, ":"); print a[2]}' | sort -u)
          diff=$(comm -23 <(echo "$open_ports") <(echo "$ufw_ports"))
          if [ -n "$diff" ]; then
            echo "ufw_rules_ok_bad"
          else
            echo "ufw_rules_ok_ok"
          fi
        tests:
          test_items:
            - flag: "ufw_rules_ok_ok"
              set: true
        remediation: |
          For each port identified in the audit which does not have a firewall rule, evaluate the service listening on the port and add a rule for accepting or denying inbound connections in accordance with local site policy:
          Examples:
          # ufw allow in <port>/<tcp or udp protocol>
          # ufw deny in <port>/<tcp or udp protocol>
          Note: Examples create rules for from any, to any. More specific rules should be concentrated when allowing inbound traffic e.g only traffic from this network.
          Example to allow traffic on port 443 using the tcp protocol from the 192.168.1.0 network:
          ufw allow from 192.168.1.0/24 to any proto tcp port 443
        scored: true

      - id: 4.2.7
        description: "Ensure ufw default deny firewall policy (Automated)"
        audit: |
          if ufw status verbose | grep -q 'Default: deny (incoming)' &&
             ufw status verbose | grep -q 'deny (outgoing)' &&
             ufw status verbose | grep -q 'deny (routed)'; then
            echo "ufw_default_deny_ok"
          else
            echo "ufw_default_deny_bad"
          fi
        tests:
          test_items:
            - flag: "ufw_default_deny_ok"
              set: true
        remediation: |
          ufw default deny incoming
          ufw default deny outgoing
          ufw default deny routed
        scored: true

  - id: 4.3
    description: "Configure nftables"
    checks:
      - id: 4.3.1
        description: "Ensure nftables is installed (Automated)"
        audit: |
          if dpkg-query -s nftables &>/dev/null; then
            echo "nftables_installed_ok"
          else
            echo "nftables_installed_bad"
          fi
        tests:
          test_items:
            - flag: "nftables_installed_ok"
              set: true
        remediation: |
          Run the following command to install nftables:
          # apt install nftables
        scored: true

      - id: 4.3.2
        description: "Ensure ufw is uninstalled or disabled with nftables (Automated)"
        audit: |
          if ! dpkg-query -s ufw &>/dev/null; then
            echo "ufw_uninstalled_or_disabled_ok"
          else
            status=$(ufw status | awk '/Status:/ {print $2}')
            enabled=$(systemctl is-enabled ufw.service 2>/dev/null)
            if [ "$status" = "inactive" ] && [ "$enabled" = "masked" ]; then
              echo "ufw_uninstalled_or_disabled_ok"
            else
              echo "ufw_uninstalled_or_disabled_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "ufw_uninstalled_or_disabled_ok"
              set: true
        remediation: |
          Run one of the following to either remove ufw or disable ufw and mask ufw.service:
          # apt purge ufw
          # ufw disable
          # systemctl stop ufw.service
          # systemctl mask ufw.service
        scored: true

      - id: 4.3.3
        description: "Ensure iptables are flushed with nftables (Manual)"
        audit: |
          if iptables -L | grep -q 'Chain'; then
            echo "iptables_rules_exist"
          else
            echo "iptables_rules_ok"
          fi
          if ip6tables -L | grep -q 'Chain'; then
            echo "ip6tables_rules_exist"
          else
            echo "ip6tables_rules_ok"
          fi
        type: "manual"
        remediation: |
          Flush all iptables rules:
          # iptables -F
          # ip6tables -F
        scored: false

      - id: 4.3.4
        description: "Ensure a nftables table exists (Automated)"
        audit: |
          if nft list tables | grep -q .; then
            echo "nft_table_exists_ok"
          else
            echo "nft_table_exists_bad"
          fi
        tests:
          test_items:
            - flag: "nft_table_exists_ok"
              set: true
        remediation: |
          Create a table in nftables:
          # nft create table inet <table name>
          Example:
          # nft create table inet filter
        scored: true

      - id: 4.3.5
        description: "Ensure nftables base chains exist (Automated)"
        audit: |
          if nft list ruleset | grep -q 'hook input' && nft list ruleset | grep -q 'hook forward' && nft list ruleset | grep -q 'hook output'; then
            echo "nft_base_chains_ok"
          else
            echo "nft_base_chains_bad"
          fi
        tests:
          test_items:
            - flag: "nft_base_chains_ok"
              set: true
        remediation: |
          Run the following commands to create the base chains:
          # nft create chain inet <table name> <base chain name> { type filter hook <(input|forward|output)> priority 0 \; }
          Example:
          # nft create chain inet filter input { type filter hook input priority 0 \; }
          # nft create chain inet filter forward { type filter hook forward priority 0 \; }
          # nft create chain inet filter output { type filter hook output priority 0 \; }
        scored: true

      - id: 4.3.6
        description: "Ensure nftables loopback traffic is configured (Automated)"
        audit: |
          if nft list ruleset | awk '/hook input/,/}/' | grep -q 'iif \"lo\" accept'; then
            if nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip saddr' && nft list ruleset | awk '/hook input/,/}/' | grep -q 'drop'; then
              if nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip6 saddr'; then
                if nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip6 saddr' && nft list ruleset | awk '/hook input/,/}/' | grep -q 'drop'; then
                  echo "nft_loopback_ok"
                else
                  echo "nft_loopback_bad"
                fi
              else
                echo "nft_loopback_ok"
              fi
            else
              echo "nft_loopback_bad"
            fi
          else
            echo "nft_loopback_bad"
          fi
        tests:
          test_items:
            - flag: "nft_loopback_ok"
              set: true
        remediation: |
          Run the following commands to implement the loopback rules:
          # nft add rule inet filter input iif lo accept
          # nft add rule inet filter input ip saddr 127.0.0.0/8 counter drop
          # IF IPv6 is enabled on the system:
          # nft add rule inet filter input ip6 saddr ::1 counter drop

      - id: 4.3.7
        description: "Ensure nftables outbound and established connections are configured (Manual)"
        audit: |
          echo "Verify nftables rules for established incoming connections:"
          nft list ruleset | awk '/hook input/,/}/' | grep -E 'ip protocol (tcp|udp) ct state'
          echo "Verify nftables rules for new and established outbound connections:"
          nft list ruleset | awk '/hook output/,/}/' | grep -E 'ip protocol (tcp|udp) ct state'
        type: "manual"
        remediation: |
          Configure nftables in accordance with site policy. The following commands will implement a policy to allow all outbound connections and all established connections:
          nft add rule inet filter input ip protocol tcp ct state established accept
          nft add rule inet filter input ip protocol udp ct state established accept
          nft add rule inet filter output ip protocol tcp ct state new,related,established accept
          nft add rule inet filter output ip protocol udp ct state new,related,established accept
        scored: false

      - id: 4.3.8
        description: "Ensure nftables default deny firewall policy (Automated)"
        audit: |
          if nft list ruleset | grep -qE "hook input.*policy drop" && \
             nft list ruleset | grep -qE "hook forward.*policy drop" && \
             nft list ruleset | grep -qE "hook output.*policy drop"; then
            echo "nft_default_drop_ok"
          else
            echo "nft_default_drop_bad"
          fi
        tests:
          test_items:
            - flag: "nft_default_drop_ok"
              set: true
        remediation: |
          For each base chain (input, forward, output) set the policy to drop:
          # nft chain inet filter input { policy drop \; }
          # nft chain inet filter forward { policy drop \; }
          # nft chain inet filter output { policy drop \; }
          # Verify with:
          # nft list ruleset | grep 'hook input'
          # nft list ruleset | grep 'hook forward'
          # nft list ruleset | grep 'hook output'
        scored: true

      - id: 4.3.9
        description: "Ensure nftables service is enabled (Automated)"
        audit: |
          if systemctl is-enabled nftables | grep -q '^enabled$'; then
            echo "nftables_enabled_ok"
          else
            echo "nftables_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "nftables_enabled_ok"
              set: true
        remediation: |
          Run the following command to enable the nftables service:
          # systemctl enable nftables
        scored: true

      - id: 4.3.10
        description: "Ensure nftables rules are permanent (Automated)"
        audit: |
          if grep -qE '^\s*include' /etc/nftables.conf; then
            files=$(awk '$1 ~ /^\s*include/ { gsub("\"","",$2);print $2 }' /etc/nftables.conf)
            if grep -qE 'hook input' $files && grep -qE 'hook forward' $files && grep -qE 'hook output' $files; then
              echo "nftables_permanent_ok"
            else
              echo "nftables_permanent_bad"
            fi
          else
            echo "nftables_permanent_bad"
          fi
        tests:
          test_items:
            - flag: "nftables_permanent_ok"
              set: true
        remediation: |
          Edit /etc/nftables.conf and add or uncomment a line with include <Absolute path to nftables rules file> for each nftables file you want included in the nftables ruleset on boot.
          Example:
          # vi /etc/nftables.conf
          Add the line:
          include "/etc/nftables.rules"
        scored: true

  - id: 4.4
    description: "Configure iptables"
    checks:
      - id: 4.4.1
        description: "Configure iptables software"
        type: "skip"
        checks:

      - id: 4.4.1.1
        description: "Ensure iptables packages are installed (Automated)"
        audit: |
          if dpkg-query -s iptables &>/dev/null && dpkg-query -s iptables-persistent &>/dev/null; then
            echo "iptables_packages_ok"
          else
            echo "iptables_packages_bad"
          fi
        tests:
          test_items:
            - flag: "iptables_packages_ok"
              set: true
        remediation: |
          Install the required packages:
          # apt install iptables iptables-persistent
        scored: true

      - id: 4.4.1.2
        description: "Ensure nftables is not in use with iptables (Automated)"
        audit: |
          if dpkg-query -s nftables &>/dev/null; then
            echo "nftables_in_use_bad"
          elif systemctl is-enabled nftables.service 2>/dev/null | grep '^enabled' >/dev/null; then
            echo "nftables_in_use_bad"
          elif systemctl is-active nftables.service 2>/dev/null | grep '^active' >/dev/null; then
            echo "nftables_in_use_bad"
          else
            echo "nftables_in_use_ok"
          fi
        tests:
          test_items:
            - flag: "nftables_in_use_ok"
              set: true
        remediation: |
          # Remove nftables package:
          # apt purge nftables
          # OR stop and mask the nftables service:
          # systemctl stop nftables.service
          # systemctl mask nftables.service
        scored: true

      - id: 4.4.1.3
        description: "Ensure ufw is not in use with iptables (Automated)"
        audit: |
          if ! dpkg-query -s ufw &>/dev/null; then
            echo "ufw_not_in_use_ok"
          elif ufw status | grep -q '^Status: inactive'; then
            echo "ufw_not_in_use_ok"
          elif ! systemctl is-enabled ufw 2>/dev/null | grep -q '^enabled'; then
            echo "ufw_not_in_use_ok"
          elif ! systemctl is-active ufw.service 2>/dev/null | grep -q '^active'; then
            echo "ufw_not_in_use_ok"
          else
            echo "ufw_not_in_use_bad"
          fi
        tests:
          test_items:
            - flag: "ufw_not_in_use_ok"
              set: true
        remediation: |
          # To remove ufw:
          apt purge ufw
          # OR to disable ufw and stop and mask the service:
          ufw disable
          systemctl stop ufw.service
          systemctl mask ufw.service
        scored: true

      - id: 4.4.2
        description: "Configure IPv4 iptables"
        type: "skip"
        checks:

      - id: 4.4.2.1
        description: "Ensure iptables default deny firewall policy (Automated)"
        audit: |
          if iptables -L -n | grep -E '^Chain INPUT \(policy (DROP|REJECT)' >/dev/null && \
             iptables -L -n | grep -E '^Chain FORWARD \(policy (DROP|REJECT)' >/dev/null && \
             iptables -L -n | grep -E '^Chain OUTPUT \(policy (DROP|REJECT)' >/dev/null; then
            echo "iptables_default_policy_ok"
          else
            echo "iptables_default_policy_bad"
          fi
        tests:
          test_items:
            - flag: "iptables_default_policy_ok"
              set: true
        remediation: |
          Run the following commands to implement a default DROP policy:
          # iptables -P INPUT DROP
          # iptables -P OUTPUT DROP
          # iptables -P FORWARD DROP
        scored: true

      - id: 4.4.2.2
        description: "Ensure iptables loopback traffic is configured (Automated)"
        audit: |
          if iptables -L INPUT -v -n 2>/dev/null | grep -qE 'ACCEPT\s+[0-9]+\s+[0-9]+\s+.*\s+lo\s+\*' && \
            iptables -L INPUT -v -n 2>/dev/null | grep -qE 'DROP\s+[0-9]+\s+[0-9]+\s+.*\s+\*\s+\*\s+127\.0\.0\.0/8' && \
            iptables -L OUTPUT -v -n 2>/dev/null | grep -qE 'ACCEPT\s+[0-9]+\s+[0-9]+\s+.*\s+\*\s+lo'; then
            echo "iptables_loopback_ok"
          else
            echo "iptables_loopback_bad"
          fi
        tests:
          test_items:
            - flag: "iptables_loopback_ok"
              set: true
        remediation: |
          # Add loopback rules if missing
          iptables -A INPUT -i lo -j ACCEPT
          iptables -A OUTPUT -o lo -j ACCEPT
          iptables -A INPUT -s 127.0.0.0/8 -j DROP
        scored: true

      - id: 4.4.2.3
        description: "Ensure iptables outbound and established connections are configured (Manual)"
        audit: |
          iptables -L -v -n
        type: "manual"
        remediation: |
          Configure iptables in accordance with site policy. The following commands will implement a policy to allow all outbound connections and all established connections:
          # iptables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
          # iptables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
          # iptables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
          # iptables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
        scored: false

      - id: 4.4.2.4
        description: "Ensure iptables firewall rules exist for all open ports (Automated)"
        audit: |
          open_ports=$(ss -4tuln | awk '/\*:/ {print $5}' | awk -F: '{print $NF}' | sort -u)
          rule_ports=$(iptables -L INPUT -v -n | grep -Po 'dpt:\K[0-9]+' | sort -u)

          missing_ports=$(comm -23 <(echo "$open_ports") <(echo "$rule_ports"))

          if [ -z "$missing_ports" ]; then
            echo "iptables_open_ports_ok"
          else
            echo "iptables_open_ports_bad"
          fi
        tests:
          test_items:
            - flag: "iptables_open_ports_ok"
              set: true
        remediation: |
          For each port identified in the audit which does not have a firewall rule, establish a proper rule for accepting inbound connections:
          # iptables -A INPUT -p <protocol> --dport <port> -m state --state NEW -j ACCEPT
          # Save the rule to persist across reboots (e.g., using iptables-save or a firewall management tool)
          # Reload or restart the firewall service if necessary
        scored: true

      - id: 4.4.3
        description: "Configure IPv6 ip6tables"
        type: "skip"
        checks:

      - id: 4.4.3.1
        description: "Ensure ip6tables default deny firewall policy (Automated)"
        audit: |
          policies=$(ip6tables -L | grep -E '^Chain (INPUT|FORWARD|OUTPUT) \(policy (DROP|REJECT)\)' | wc -l)
          if [ "$policies" -eq 3 ]; then
            echo "ip6tables_default_policy_ok"
          else
            echo "ip6tables_default_policy_bad"
          fi
        tests:
          test_items:
            - flag: "ip6tables_default_policy_ok"
              set: true
        remediation: |
          # Set default policy to DROP for all chains
          ip6tables -P INPUT DROP
          ip6tables -P OUTPUT DROP
          ip6tables -P FORWARD DROP
        scored: true

      - id: 4.4.3.2
        description: "Ensure ip6tables loopback traffic is configured (Automated)"
        audit: |
          if ip6tables -L INPUT -v -n | grep -Pq '^\s*0\s+0\s+ACCEPT\s+all\s+lo\s+\*\s+::/0\s+::/0' && \
             ip6tables -L INPUT -v -n | grep -Pq '^\s*0\s+0\s+DROP\s+all\s+\*\s+\*\s+::1\s+::/0' && \
             ip6tables -L OUTPUT -v -n | grep -Pq '^\s*0\s+0\s+ACCEPT\s+all\s+\*\s+lo\s+::/0\s+::/0'; then
            echo "ip6tables_loopback_ok"
          else
            echo "ip6tables_loopback_bad"
          fi
        tests:
          test_items:
            - flag: "ip6tables_loopback_ok"
              set: true
        remediation: |
          # Add loopback rules to ip6tables
          ip6tables -A INPUT -i lo -j ACCEPT
          ip6tables -A OUTPUT -o lo -j ACCEPT
          ip6tables -A INPUT -s ::1 -j DROP
        scored: true

      - id: 4.4.3.3
        description: "Ensure ip6tables outbound and established connections are configured (Manual)"
        audit: |
          echo "Verify ip6tables rules for outbound and established connections:"
          ip6tables -L -v -n
          echo
          echo "Verify IPv6 is disabled:"
          l_ipv6_enabled="is"
          if ! grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            l_ipv6_enabled="is not"
          fi
          if sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
             sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pqs -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
            l_ipv6_enabled="is not"
          fi
          echo " - IPv6 $l_ipv6_enabled enabled on the system"
        type: "manual"
        remediation: |
          Configure ip6tables in accordance with site policy. The following commands will implement a policy to allow all outbound connections and all established connections:
          # ip6tables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
          # ip6tables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
          # ip6tables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
          # ip6tables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
        scored: false

      - id: 4.4.3.4
        description: "Ensure ip6tables firewall rules exist for all open ports (Automated)"
        audit: |
          if sysctl net.ipv6.conf.all.disable_ipv6 | grep -q '^net.ipv6.conf.all.disable_ipv6 = 1' && sysctl net.ipv6.conf.default.disable_ipv6 | grep -q '^net.ipv6.conf.default.disable_ipv6 = 1'; then
            echo "ip6tables_rules_ok"
          else
            ports=$(ss -6tuln | awk '/LISTEN/ && $5 !~ /^::1:/ {print $5}' | awk -F: '{print $NF}')
            ok=true
            for p in $ports; do
              if ! ip6tables -L INPUT -v -n | grep -q "dpt:$p"; then
                ok=false
                break
              fi
            done
            if $ok; then
              echo "ip6tables_rules_ok"
            else
              echo "ip6tables_rules_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "ip6tables_rules_ok"
              set: true
        remediation: |
          If IPv6 is enabled and any open port lacks a firewall rule, add a rule for each missing port:
          # ip6tables -A INPUT -p tcp --dport <port> -m state --state NEW -j ACCEPT
          # ip6tables -A INPUT -p udp --dport <port> -m state --state NEW -j ACCEPT
          Replace <port> with the actual port number. After adding rules, persist the ip6tables configuration and reload the firewall service:
          # ip6tables-save > /etc/iptables/rules.v6
          # systemctl reload-or-try-restart ip6tables.service
        scored: true

  - id: 5
    description: "Section 5"
    checks:
  - id: 5.1
    description: "Configure SSH Server"
    checks:
      - id: 5.1.1
        description: "Ensure permissions on /etc/ssh/sshd_config are configured (Automated)"
        audit: |
          files=("/etc/ssh/sshd_config")
          while IFS= read -r -d '' f; do files+=("$f"); done < <(find /etc/ssh/sshd_config.d -type f -name '*.conf' -print0)
          bad=0
          for f in "${files[@]}"; do
            [ ! -e "$f" ] && continue
            perm=$(stat -Lc '%a' "$f")
            if [ "$perm" -gt 600 ]; then bad=1; fi
            owner=$(stat -Lc '%U' "$f")
            if [ "$owner" != "root" ]; then bad=1; fi
            group=$(stat -Lc '%G' "$f")
            if [ "$group" != "root" ]; then bad=1; fi
          done
          if [ "$bad" -eq 0 ]; then
            echo "sshd_config_perm_ok"
          else
            echo "sshd_config_perm_bad"
          fi

          bad=0

        tests:
          test_items:
            - flag: "sshd_config_perm_ok"
              set: true
        remediation: |
          chmod u-x,og-rwx /etc/ssh/sshd_config
          chown root:root /etc/ssh/sshd_config
          while IFS= read -r -d '' f; do
            if [ -e "$f" ]; then
              chmod u-x,og-rwx "$f"
              chown root:root "$f"
            fi
          done < <(find /etc/ssh/sshd_config.d -type f -print0)
        scored: true

      - id: 5.1.2
        description: "Ensure permissions on SSH private host key files are configured (Automated)"
        audit: |
          bad=0
          while IFS= read -r -d '' file; do
            # Only check actual private key files (skip pubkeys, moduli, etc.)
            if ssh-keygen -y -P "" -f "$file" >/dev/null 2>&1; then
              owner=$(stat -c '%U' "$file")
              group=$(stat -c '%G' "$file")
              mode=$(stat -c '%a' "$file")
              if [ "$owner" != "root" ]; then
                bad=1
              elif [ "$group" = "root" ]; then
                # Group root → must be 600 or 400
                if [ "$mode" -gt 600 ]; then bad=1; fi
              elif [ "$group" = "ssh_keys" ] || [ "$group" = "_ssh" ]; then
                # Some distros use special group → allow up to 640
                if [ "$mode" -gt 640 ]; then bad=1; fi
              else
                # Unknown group → fail
                bad=1
              fi
            fi
          done < <(find /etc/ssh -type f -name 'ssh_host_*_key' -print0 2>/dev/null)
          if [ "$bad" -eq 0 ]; then
            echo "ssh_private_key_perm_ok"
          else
            echo "ssh_private_key_perm_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_private_key_perm_ok"
              set: true
        remediation: |
          # Fix ownership and permissions on all SSH private host keys
          find /etc/ssh -type f -name 'ssh_host_*_key' -exec chown root:root {} \;
          find /etc/ssh -type f -name 'ssh_host_*_key' -exec chmod 600 {} \;
        scored: true

      - id: 5.1.3
        description: "Ensure permissions on SSH public host key files are configured (Automated)"
        audit: |
          bad=0
          find -L /etc/ssh -xdev -type f -print0 2>/dev/null | while IFS= read -r -d '' file; do
          if ssh-keygen -lf "$file" >/dev/null 2>&1; then
          if file "$file" | grep -Piq '\bopenssh\b.*public key'; then
          mode=$(stat -c '%a' "$file")
          owner=$(stat -c '%U' "$file")
          group=$(stat -c '%G' "$file")
          if [ "$mode" -gt 644 ] || [ "$owner" != "root" ] || [ "$group" != "root" ]; then
          bad=1
          break
          fi
          fi
          fi
          done
          if [ "$bad" -eq 0 ]; then
          echo "ssh_pubkey_perm_ok"
          else
          echo "ssh_pubkey_perm_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_pubkey_perm_ok"
        set: true
        remediation: |
          # Set correct permissions and ownership on all SSH public host key files
          find -L /etc/ssh -xdev -type f -print0 2>/dev/null | while IFS= read -r -d '' file; do
          if ssh-keygen -lf "$file" >/dev/null 2>&1 && file "$file" | grep -Piq '\bopenssh\b.*public key'; then
          chmod 0644 "$file"
          chown root:root "$file"
          fi
          done
        scored: true

      - id: 5.1.4
        description: "Ensure sshd access is configured (Automated)"
        audit: |
          if sshd -T | grep -Pi '^\h*(allow|deny)(users|groups)\h+\H+' >/dev/null; then
            echo "sshd_access_ok"
          else
            echo "sshd_access_bad"
          fi

        tests:
          test_items:
            - flag: "sshd_access_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set one or more of the following options:
          AllowUsers <userlist>
          AllowGroups <grouplist>
          DenyUsers <userlist>
          DenyGroups <grouplist>
          Ensure that the first occurrence of an option takes precedence and that any
          Include or Match directives are correctly ordered.  It is recommended to
          maintain only an allow list (AllowUsers or AllowGroups) for clarity.
        scored: true

      - id: 5.1.5
        description: "Ensure sshd Banner is configured (Automated)"
        audit: |
          if sshd -T | grep -Pi '^banner\h+\/\H+' >/dev/null; then
            echo "sshd_banner_ok"
          else
            echo "sshd_banner_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_banner_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          Banner /etc/issue.net
          Ensure the entry appears above any Include and Match directives.
          Edit the file referenced by the Banner directive to contain the desired policy text
          and remove any instances of \m, \r, \s, \v or references to the OS platform.
          Example:
          # printf '%s\n' "Authorized users only. All activity may be monitored and reported." > "$(sshd -T | awk '$1 == \"banner\" {print $2}')"
        scored: true

      - id: 5.1.6
        description: "Ensure sshd Ciphers are configured (Automated)"
        audit: |
          if ! sshd -T | grep -Pi -- '^ciphers\h+\"?([^#\n\r]+,)?((3des|blowfish|cast128|aes(128|192|256))-cbc|arcfour(128|256)?|rijndael-cbc@lysator\.liu\.se|chacha20-poly1305@openssh\.com)\b'; then
            echo "sshd_ciphers_ok"
          else
            echo "sshd_ciphers_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_ciphers_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and add/modify the Ciphers line to contain a comma separated list of the site unapproved (weak) ciphers preceded with a - above any Include entries:
          Example:
          Ciphers -3des-cbc,aes128-cbc,aes192-cbc,aes256-cbc,chacha20-poly1305@openssh.com
          If CVE-2023-48795 has been addressed and it meets local site policy, chacha20-poly1305@openssh.com may be removed from the list of excluded ciphers.
          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.7
        description: "Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured (Automated)"
        audit: |
          interval="$(sshd -T | awk '/^clientaliveinterval/ {print $2}')"
          countmax="$(sshd -T | awk '/^clientalivecountmax/ {print $2}')"
          if [ -n "$interval" ] && [ -n "$countmax" ] && [ "$interval" -gt 0 ] && [ "$countmax" -gt 0 ]; then
            echo "sshd_clientalive_ok"
          else
            echo "sshd_clientalive_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_clientalive_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          ClientAliveInterval 15
          ClientAliveCountMax 3
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.8
        description: "Ensure sshd DisableForwarding is enabled (Automated)"
        audit: |

          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | grep -Pi '^disableforwarding\s+yes\b' >/dev/null; then
          echo "disableforwarding_ok"
          else
          echo "disableforwarding_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_disableforwarding_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          DisableForwarding yes
          Ensure the setting appears above any Include directives.
        scored: true

      - id: 5.1.9
        description: "Ensure sshd GSSAPIAuthentication is disabled (Automated)"
        audit: |
          if sshd -T | grep -qE '^gssapiauthentication\s+no$'; then
            echo "sshd_gssapiauthentication_ok"
          else
            echo "sshd_gssapiauthentication_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_gssapiauthentication_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          GSSAPIAuthentication no
          Ensure the setting appears above any Include and Match directives.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.10
        description: "Ensure sshd HostbasedAuthentication is disabled (Automated)"
        audit: |
          val="$(sshd -T | awk '/^hostbasedauthentication/ {print $2}')"
          if [ "$val" = "no" ]; then
            echo "sshd_hostbasedauthentication_ok"
          else
            echo "sshd_hostbasedauthentication_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_hostbasedauthentication_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          HostbasedAuthentication no
          Ensure the setting appears before any Include or Match directives.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.11
        description: "Ensure sshd IgnoreRhosts is enabled (Automated)"
        audit: |
          if sshd -T 2>/dev/null | grep -q '^ignorerhosts yes$'; then
            echo "sshd_ignorerhosts_ok"
          else
            echo "sshd_ignorerhosts_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_ignorerhosts_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          IgnoreRhosts yes
          Place the setting above any Include and Match directives. If Include locations are used, add the line to the appropriate file in the Include location.
        scored: true

      - id: 5.1.12
        description: "Ensure sshd KexAlgorithms is configured (Automated)"
        audit: |
          if ! sshd -T | grep -Pi 'kexalgorithms\h+([^#\n\r]+,)?(diffie-hellman-group1-sha1|diffie-hellman-group14-sha1|diffie-hellman-group-exchange-sha1)\b' >/dev/null; then
            echo "sshd_kexalgorithms_ok"
          else
            echo "sshd_kexalgorithms_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_kexalgorithms_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and add/modify the KexAlgorithms line to contain a comma separated list of the site unapproved (weak) KexAlgorithms preceded with a - above any Include entries:
          Example:
          KexAlgorithms -diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.13
        description: "Ensure sshd LoginGraceTime is configured (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^logingracetime/ {print $2}')"
          if [ -n "$val" ] && [ "$val" -ge 1 ] && [ "$val" -le 60 ]; then
            echo "sshd_logingrace_ok"
          else
            echo "sshd_logingrace_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_logingrace_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          LoginGraceTime 60
          If Include directives are used, place the setting in the first included file that is processed, or add it to the main file above any Include entries.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.14
        description: "Ensure sshd LogLevel is configured (Automated)"
        audit: |
          loglevel="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^loglevel/ {print $2}')"
          if [ "$loglevel" = "VERBOSE" ] || [ "$loglevel" = "INFO" ]; then
            echo "sshd_loglevel_ok"
          else
            echo "sshd_loglevel_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_loglevel_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          LogLevel VERBOSE
          # OR
          LogLevel INFO
          Ensure the setting appears above any Include and Match entries.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.15
        description: "Ensure sshd MACs are configured (Automated)"
        audit: |
          if ! sshd -T | grep -Pi 'macs\h+([^#\n\r]+,)?(hmac-md5|hmac-md5-96|hmac-ripemd160|hmac-sha1-96|umac-64@openssh\.com|hmac-md5-etm@openssh\.com|hmac-md5-96-etm@openssh\.com|hmac-ripemd160-etm@openssh\.com|hmac-sha1-96-etm@openssh\.com|umac-64-etm@openssh\.com|umac-128-etm@openssh\.com)\b' >/dev/null; then
            echo "sshd_macs_ok"
          else
            echo "sshd_macs_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_macs_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and add or modify the MACs line to exclude weak MACs:
          MACs -hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-sha1-96,umac-64@openssh.com,hmac-md5-etm@openssh.com,hmac-md5-96-etm@openssh.com,hmac-ripemd160-etm@openssh.com,hmac-sha1-96-etm@openssh.com,umac-64-etm@openssh.com,umac-128-etm@openssh.com
          If CVE-2023-48795 has not been addressed, also exclude the following etm MACs:
          hmac-sha1-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com
          Reload SSH to apply changes:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.16
        description: "Ensure sshd MaxAuthTries is configured (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxauthtries/ {print $2}')"
          if [ -n "$val" ] && [ "$val" -le 4 ]; then
            echo "sshd_maxauthtries_ok"
          else
            echo "sshd_maxauthtries_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxauthtries_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          MaxAuthTries 4
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.17
        description: "Ensure sshd MaxSessions is configured (Automated)"
        audit: |
          val="$(sshd -T | awk '/^maxsessions/ {print $2}')"
          if [ -n "$val" ] && [ "$val" -le 10 ]; then
            if ! grep -Pis '^\h*MaxSessions\h+\"?(1[1-9]|[2-9][0-9]|[1-9][0-9][0-9]+)\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf; then
              echo "sshd_maxsessions_ok"
            else
              echo "sshd_maxsessions_bad"
            fi
          else
            echo "sshd_maxsessions_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxsessions_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config (or an included file) and set:
          MaxSessions 10
          Ensure the setting appears above any Include and Match entries.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.18
        description: "Ensure sshd MaxStartups is configured (Automated)"
        audit: |
          val="$(sshd -T 2>/dev/null | awk '$1 ~ /^maxstartups/ {split($2,a,\":\"); print a[1],a[2],a[3]}' | head -n1)"
          if [ -n "$val" ]; then
            read a1 a2 a3 <<< "$val"
            if [ "$a1" -gt 10 ] || [ "$a2" -gt 30 ] || [ "$a3" -gt 60 ]; then
              echo "sshd_maxstartups_bad"
            else
              echo "sshd_maxstartups_ok"
            fi
          else
            echo "sshd_maxstartups_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxstartups_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          MaxStartups 10:30:60
          Ensure the setting appears above any Include entries.
        scored: true

      - id: 5.1.19
        description: "Ensure sshd PermitEmptyPasswords is disabled (Automated)"
        audit: |
          val="$(sshd -T | awk '/^permitemptypasswords/ {print $2}')"
          if [ "$val" = "no" ]; then
            echo "sshd_permitemptypasswords_ok"
          else
            echo "sshd_permitemptypasswords_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permitemptypasswords_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          PermitEmptyPasswords no
          Ensure the setting appears above any Include and Match entries.
        scored: true

      - id: 5.1.20
        description: "Ensure sshd PermitRootLogin is disabled (Automated)"
        audit: |
          val="$(sshd -T | grep -i '^permitrootlogin' | awk '{print $2}')"
          if [ "$val" = "no" ]; then
            echo "sshd_permitrootlogin_ok"
          else
            echo "sshd_permitrootlogin_bad"
          fi
          if sshd -T 2>/dev/null | grep -Pi '^permitrootlogin\s+no$' >/dev/null; then
        tests:
          test_items:
            - flag: "sshd_permitrootlogin_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          PermitRootLogin no
          Ensure this line appears above any Include or Match directives.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.21
        description: "Ensure sshd PermitUserEnvironment is disabled (Automated)"
        audit: |
          val="$(sshd -T | awk '/^permituserenvironment/ {print $2}')"
          if [ "$val" = "no" ]; then
            echo "sshd_permituserenvironment_ok"
          else
            echo "sshd_permituserenvironment_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permituserenvironment_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          PermitUserEnvironment no
          Ensure the setting appears above any Include directives.
          Reload SSH:
          # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 5.1.22
        description: "Ensure sshd UsePAM is enabled (Automated)"
        audit: |
          val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^usepam/ {print $2}')"
          if [ "$val" = "yes" ]; then
            echo "sshd_usepam_ok"
          else
            echo "sshd_usepam_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_usepam_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set:
          UsePAM yes
          Ensure the setting appears above any Include directives.
        scored: true

  - id: 5.2
    description: "Configure privilege escalation"
    checks:
      - id: 5.2.1
        description: "Ensure sudo is installed (Automated)"
        audit: |
          if dpkg-query -s sudo &>/dev/null || dpkg-query -s sudo-ldap &>/dev/null; then
            echo "sudo_installed_ok"
          else
            echo "sudo_installed_bad"
          fi
        tests:
          test_items:
            - flag: "sudo_installed_ok"
              set: true
        remediation: |
          First determine if LDAP functionality is required. If so, then install sudo-ldap, else install sudo.
          Example:
          # apt install sudo
        scored: true

      - id: 5.2.2
        description: "Ensure sudo commands use pty (Automated)"
        audit: |
          if grep -rPi -- '^\h*Defaults\h+([^#\n\r]+,\h*)?use_pty\b' /etc/sudoers* > /dev/null && ! grep -rPi -- '^\h*Defaults\h+([^#\n\r]+,\h*)?!use_pty\b' /etc/sudoers* > /dev/null; then
            echo "sudo_use_pty_ok"
          else
            echo "sudo_use_pty_bad"
          fi
        tests:
          test_items:
            - flag: "sudo_use_pty_ok"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f <PATH TO FILE> and add the following line:
          Defaults use_pty
          Edit the file /etc/sudoers with visudo and any files in /etc/sudoers.d/ with visudo -f <PATH TO FILE> and remove any occurrence of !use_pty
        scored: true

      - id: 5.2.3
        description: "Ensure sudo log file exists (Automated)"
        audit: |
          if grep -E '^[[:space:]]*Defaults[[:space:]]+[^#]*logfile[[:space:]]*=[[:space:]]*"?/var/log/sudo.log"?' /etc/sudoers /etc/sudoers.d/* 2>/dev/null | grep -q .; then
          echo "sudo_logfile_ok"
          else
          echo "sudo_logfile_bad"
          fi
        tests:
          test_items:
            - flag: "sudo_logfile_ok"
              set: true
        remediation: |
          Edit the file /etc/sudoers or a file in /etc/sudoers.d/ with visudo or visudo -f <PATH TO FILE> and add the following line:
          Defaults logfile="/var/log/sudo.log"
        scored: true

      - id: 5.2.4
        description: "Ensure users must provide password for privilege escalation (Automated)"
        audit: |
          if ! grep -r "^[^#].*NOPASSWD" /etc/sudoers* >/dev/null 2>&1; then
            echo "sudo_nopasswd_ok"
          else
            echo "sudo_nopasswd_bad"
          fi
        tests:
          test_items:
            - flag: "sudo_nopasswd_ok"
              set: true
        remediation: |
          Use visudo to edit the relevant sudoers file:
          # visudo -f /etc/sudoers
          # visudo -f /etc/sudoers.d/<file>
          Remove any line containing the NOPASSWD tag.  Ensure the file syntax is valid before saving.
        scored: true

      - id: 5.2.5
        description: "Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
        audit: |
          if ! grep -r "^[^#].*\\!authenticate" /etc/sudoers* >/dev/null; then
            echo "sudo_authenticate_ok"
          else
            echo "sudo_authenticate_bad"
          fi
        tests:
          test_items:
            - flag: "sudo_authenticate_ok"
              set: true
        remediation: |
          Edit each sudoers file that contains a !authenticate tag using visudo:
          # visudo -f /etc/sudoers
          # visudo -f /etc/sudoers.d/<file>
          Remove any occurrences of !authenticate from the file(s).
          Verify that no lines contain !authenticate:
          # grep -r "^[^#].*\\!authenticate" /etc/sudoers*
          Reload sudo configuration if necessary:
          # systemctl reload-or-try-restart sudo.service
        scored: true

      - id: 5.2.6
        description: "Ensure sudo authentication timeout is configured correctly (Automated)"
        audit: |
          if grep -P 'timestamp_timeout=(?:-1|1[6-9][0-9]*|[2-9][0-9]+)' /etc/sudoers* 2>/dev/null; then
            echo "sudo_timestamp_timeout_bad"
          else
            echo "sudo_timestamp_timeout_ok"
          fi
        tests:
          test_items:
            - flag: "sudo_timestamp_timeout_ok"
              set: true
        remediation: |
          Edit the sudoers file(s) with visudo -f <PATH_TO_FILE> and set the timeout to 15 minutes or less:
          Defaults    env_reset, timestamp_timeout=15
          or
          Defaults    timestamp_timeout=15
          Ensure the entry appears above any Match blocks. No service restart is required for sudo.
        scored: true

      - id: 5.2.7
        description: "Ensure access to the su command is restricted (Automated)"
        audit: |
          line=$(grep -Pi '^auth\s+(required|requisite)\s+pam_wheel\.so\s+use_uid\s+group=' /etc/pam.d/su)
          if [ -z "$line" ]; then
            echo "su_wheel_group_bad"
            exit
          fi
          group=$(echo "$line" | grep -oP 'group=\K[^ \t#]+')
          if [ -z "$group" ]; then
            echo "su_wheel_group_bad"
            exit
          fi
          if ! getent group "$group" >/dev/null; then
            echo "su_wheel_group_bad"
            exit
          fi
          users=$(getent group "$group" | cut -d: -f4)
          if [ -z "$users" ]; then
            echo "su_wheel_group_ok"
          else
            echo "su_wheel_group_bad"
          fi
        tests:
          test_items:
            - flag: "su_wheel_group_ok"
              set: true
        remediation: |
          Create an empty group that will be specified for use of the su command. The group should be named according to site policy.
          Example:
          # groupadd sugroup
          Add the following line to the /etc/pam.d/su file, specifying the empty group:
          auth required pam_wheel.so use_uid group=sugroup
        scored: true

  - id: 5.3
    description: "Pluggable Authentication Modules"
    checks:
      - id: 5.3.1
        description: "Configure PAM software packages"
        type: "skip"
        checks:

      - id: 5.3.1.1
        description: "Ensure latest version of pam is installed (Automated)"
        audit: |
          if dpkg-query -s libpam-runtime 2>/dev/null | grep -q '^Status: install ok installed'; then
            ver=$(dpkg-query -s libpam-runtime | awk '/^Version:/ {print $2}')
            if dpkg --compare-versions "$ver" ge 1.5.3-5; then
              echo "pam_latest_ok"
            else
              echo "pam_latest_bad"
            fi
          else
            echo "pam_latest_bad"
          fi
        tests:
          test_items:
            - flag: "pam_latest_ok"
              set: true
        remediation: |
          # Update to the latest version of PAM
          apt upgrade libpam-runtime
        scored: true

      - id: 5.3.1.2
        description: "Ensure libpam-modules is installed (Automated)"
        audit: |
          if dpkg-query -s libpam-modules 2>/dev/null | grep -q 'install ok installed'; then
            ver=$(dpkg-query -s libpam-modules 2>/dev/null | awk '/^Version:/ {print $2}')
            if dpkg --compare-versions "$ver" ge "1.5.3-5"; then
              echo "libpam_modules_ok"
            else
              echo "libpam_modules_bad"
            fi
          else
            echo "libpam_modules_bad"
          fi
        tests:
          test_items:
            - flag: "libpam_modules_ok"
              set: true
        remediation: |
          If the installed version of libpam-modules is less than 1.5.3-5, upgrade it:
          # apt upgrade libpam-modules
        scored: true

      - id: 5.3.1.3
        description: "Ensure libpam-pwquality is installed (Automated)"
        audit: |
          if dpkg-query -s libpam-pwquality 2>/dev/null | grep -q '^Status: install ok installed'; then
            echo "libpam_pwquality_ok"
          else
            echo "libpam_pwquality_bad"
          fi
        tests:
          test_items:
            - flag: "libpam_pwquality_ok"
              set: true
        remediation: |
          Run the following command to install libpam-pwquality:
          # apt install libpam-pwquality
        scored: true

      - id: 5.3.2
        description: "Configure pam-auth-update profiles"
        type: "skip"
        checks:

      - id: 5.3.2.1
        description: "Ensure pam_unix module is enabled (Automated)"
        audit: |
          if grep -P -- '\bpam_unix\.so\b' /etc/pam.d/common-{account,session,auth,password} > /dev/null; then
            echo "pam_unix_enabled_ok"
          else
            echo "pam_unix_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "pam_unix_enabled_ok"
              set: true
        remediation: |
          Run the following command to enable the pam_unix module:
          # pam-auth-update --enable unix
        scored: true

      - id: 5.3.2.2
        description: "Ensure pam_faillock module is enabled (Automated)"
        audit: |
          if grep -qP '\bpam_faillock\.so\b' /etc/pam.d/common-auth && \
             grep -qP '\bpam_faillock\.so\b' /etc/pam.d/common-account; then
            echo "pam_faillock_enabled_ok"
          else
            echo "pam_faillock_enabled_bad"
          fi

        tests:
          test_items:
            - flag: "pam_faillock_enabled_ok"
              set: true
        remediation: |
          Create two pam-auth-update profiles in /usr/share/pam-configs/:
          1. faillock profile:
             Name: Enable pam_faillock to deny access
             Default: yes
             Priority: 0
             Auth-Type: Primary
             Auth:
                 [default=die] pam_faillock.so authfail
          2. faillock_notify profile:
             Name: Notify of failed login attempts and reset count upon success
             Default: yes
             Priority: 1024
             Auth-Type: Primary
             Auth:
                 requisite pam_faillock.so preauth
             Account-Type: Primary
             Account:
                 required pam_faillock.so
          Example scripts to create the profiles:
          #!/usr/bin/env bash
          {
            arr=('Name: Enable pam_faillock to deny access' 'Default: yes' 'Priority: 0' 'Auth-Type: Primary' 'Auth:' '        [default=die] pam_faillock.so authfail')
            printf '%s\n' "${arr[@]}" > /usr/share/pam-configs/faillock
          }
          #!/usr/bin/env bash
          {
            arr=('Name: Notify of failed login attempts and reset count upon success' 'Default: yes' 'Priority: 1024' 'Auth-Type: Primary' 'Auth:' '        requisite pam_faillock.so preauth' 'Account-Type: Primary' 'Account:' '        required pam_faillock.so')
            printf '%s\n' "${arr[@]}" > /usr/share/pam-configs/faillock_notify
          }
          Enable the profiles:
          # pam-auth-update --enable faillock
          # pam-auth-update --enable faillock_notify
        scored: true

      - id: 5.3.2.3
        description: "Ensure pam_pwquality module is enabled (Automated)"
        audit: |
          if grep -qP '\bpam_pwquality\.so\b' /etc/pam.d/common-password; then
            echo "pam_pwquality_enabled_ok"
          else
            echo "pam_pwquality_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwquality_enabled_ok"
              set: true
        remediation: |
          Verify that pam_pwquality.so is present in /etc/pam.d/common-password.
          If it is missing, enable the pwquality profile with:
          # pam-auth-update pwquality
          If the pwquality profile does not exist, create it in /usr/share/pam-configs/pwquality with the following content:
          Name: Pwquality password strength checking
          Default: yes
          Priority: 1024
          Conflicts: cracklib
          Password-Type: Primary
          Password:
                  requisite                       pam_pwquality.so retry=3
          Then enable it:
          # pam-auth-update --enable pwquality
        scored: true

      - id: 5.3.2.4
        description: "Ensure pam_pwhistory module is enabled (Automated)"
        audit: |
          if grep -P -- '\bpam_pwhistory\.so\b' /etc/pam.d/common-password >/dev/null; then
            echo "pam_pwhistory_ok"
          else
            echo "pam_pwhistory_bad"
          fi

        tests:
          test_items:
            - flag: "pam_pwhistory_ok"
              set: true
        remediation: |
          Verify that the pam_pwhistory module is enabled in the PAM configuration:
          # grep -P -- '\bpam_pwhistory\.so\b' /usr/share/pam-configs/*
          If the profile exists, enable it:
          # pam-auth-update --enable pwhistory
          If the profile does not exist, create it by adding the following lines to /usr/share/pam-configs/pwhistory:
          Name: pwhistory password history checking
          Default: yes
          Priority: 1024
          Password-Type: Primary
          Password: requisite pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
          Then enable the profile:
          # pam-auth-update --enable pwhistory
          After making changes, ensure the PAM configuration is reloaded by restarting the relevant services or rebooting the system.
        scored: true

      - id: 5.3.3
        description: "Configure PAM Arguments"
        type: "skip"
        checks:

      - id: 5.3.3.1
        description: "Configure pam_faillock module"
        type: "skip"
        checks:

      - id: 5.3.3.1.1
        description: "Ensure password failed attempts lockout is configured (Automated)"
        audit: |
          if grep -qP '^\h*deny\h*=\h*[1-5]\b' /etc/security/faillock.conf && \
             ! grep -qP '^\h*auth\h+(requisite|required|sufficient)\h+pam_faillock\.so\h+([^#\n\r]+\h+)?deny\h*=\h*(0|[6-9]|[1-9][0-9]+)\b' /etc/pam.d/common-auth; then
            echo "faillock_lockout_ok"
          else
            echo "faillock_lockout_bad"
          fi
        tests:
          test_items:
            - flag: "faillock_lockout_ok"
              set: true
        remediation: |
          Edit /etc/security/faillock.conf and set:
          deny = 5
          Find any pam_faillock.so lines that contain a deny argument and remove it:
          grep -Pl -- '\bpam_faillock\.so\h+([^#\n\r]+\h+)?deny\b' /usr/share/pam-configs/*
          For each returned file, edit the line and delete the deny=<N> part.
          After changes, reload PAM configuration if necessary.
        scored: true

      - id: 5.3.3.1.2
        description: "Ensure password unlock time is configured (Automated)"
        audit: |

          if grep -Pi -- '^\h*unlock_time\h*=\h*(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/security/faillock.conf >/dev/null && ! grep -Pi -- '^\h*auth\h+(requisite|required|sufficient)\h+pam_faillock\.so\h+([^#\n\r]+\h+)?unlock_time\h*=\h*([1-9]|[1-9][0-9]|[1-8][0-9][0-9])\b' /etc/pam.d/common-auth >/dev/null; then
          echo "unlock_time_ok"
          else
          echo "unlock_time_bad"
          fi
        tests:
          test_items:
            - flag: "password_unlock_time_ok"
              set: true
        remediation: |
          Edit /etc/security/faillock.conf and set:
          unlock_time = 900
          Remove any unlock_time argument from pam_faillock.so lines in PAM configuration files:
          # grep -Pl -- '\bpam_faillock\.so\h+([^#\n\r]+\h+)?unlock_time\b' /usr/share/pam-configs/*
          Edit the returned files and delete the unlock_time=<N> part.
          To reset a locked user, run:
          # faillock --user <USERNAME> --reset
        scored: true

      - id: 5.3.3.1.3
        description: "Ensure password failed attempts lockout includes root account (Automated)"
        audit: |
          if grep -Pi '^\h*even_deny_root\b' /etc/security/faillock.conf >/dev/null; then
            echo "password_failed_attempts_lockout_root_ok"
          elif grep -Pi '^\h*root_unlock_time\s*=\s*(6[0-9]|[7-9][0-9]|[1-9][0-9]{2,})\b' /etc/security/faillock.conf >/dev/null; then
            echo "password_failed_attempts_lockout_root_ok"
          elif grep -Pi '^\h*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+[^#\n\r]*root_unlock_time\s*=\s*(6[0-9]|[7-9][0-9]|[1-9][0-9]{2,})\b' /etc/pam.d/common-auth >/dev/null; then
            echo "password_failed_attempts_lockout_root_ok"
          else
            echo "password_failed_attempts_lockout_root_bad"
          fi
        tests:
          test_items:
            - flag: "password_failed_attempts_lockout_root_ok"
              set: true
        remediation: |
          Edit /etc/security/faillock.conf:
          • Remove or update any line containing root_unlock_time, setting it to 60 or more.
          • Ensure the line even_deny_root is present (add it if missing).
          Run the following to locate pam-configs that may still reference these options:
          grep -Pl -- '\bpam_faillock\.so\h+([^#\n\r]+\h+)?(even_deny_root|root_unlock_time)' /usr/share/pam-configs/*
          Edit any returned files and remove the even_deny_root and root_unlock_time arguments from the pam_faillock.so line(s).
          Reload PAM configuration if necessary (e.g., restart services that use PAM).
        scored: true

      - id: 5.3.3.2
        description: "Configure pam_pwquality module"
        type: "skip"
        checks:

      - id: 5.3.3.2.1
        description: "Ensure password number of changed characters is configured (Automated)"
        audit: |
          if grep -Pq '^\h*difok\h*=\h*([2-9]|[1-9][0-9]+)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf && ! grep -Pq '^\h*password\h+(requisite|required|sufficient)\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?difok\h*=\h*([0-1])\b' /etc/pam.d/common-password; then
            echo "pwquality_difok_ok"
          else
            echo "pwquality_difok_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_difok_ok"
              set: true
        remediation: |
          # Ensure difok is set to 2 or more in a pwquality configuration file
          # Create or modify a file ending in .conf in /etc/security/pwquality.conf.d/
          # or edit /etc/security/pwquality.conf directly.
          # Example:
          #   sudo mkdir -p /etc/security/pwquality.conf.d/
          #   sudo sh -c "printf '\ndifok = 2\n' >> /etc/security/pwquality.conf.d/50-pwdifok.conf"
          #
          # Remove any difok argument from pam_pwquality.so lines in PAM configuration
          # to avoid overriding the pwquality setting.
          # Example:
          #   sudo sed -i '/pam_pwquality\.so/ s/difok=[0-9]\+//' /etc/pam.d/common-password
          #
          # Verify changes:
          #   grep -P '^\h*difok\h*=\h*([2-9]|[1-9][0-9]+)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf
          #   grep -P '^\h*password\h+(requisite|required|sufficient)\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?difok\h*=\h*([0-1])\b' /etc/pam.d/common-password
        scored: true

      - id: 5.3.3.2.2
        description: "Ensure minimum password length is configured (Automated)"
        audit: |
          if grep -qP '^\h*minlen\h*=\h*([0-9]|1[0-3])\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf || \
             grep -qP '^\h*password\h+(requisite|required|sufficient)\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?minlen\h*=\h*([0-9]|1[0-3])\b' /etc/pam.d/system-auth /etc/pam.d/common-password; then
            echo "pwquality_minlen_bad"
          else
            echo "pwquality_minlen_ok"
          fi
        tests:
          test_items:
            - flag: "pwquality_minlen_ok"
              set: true
        remediation: |
          Create or modify a file ending in .conf in the /etc/security/pwquality.conf.d/ directory or the file /etc/security/pwquality.conf and add or modify the following line to set password length of 14 or more characters. Ensure that password length conforms to local site policy:
          # sed -ri 's/^\s*minlen\s*=/# &/' /etc/security/pwquality.conf
          # [ ! -d /etc/security/pwquality.conf.d/ ] && mkdir /etc/security/pwquality.conf.d/
          # printf '\n%s' "minlen = 14" > /etc/security/pwquality.conf.d/50-pwlength.conf
          # grep -Pl -- '\bpam_pwquality\.so\h+([^#\n\r]+\h+)?minlen\b' /usr/share/pam-configs/*
          # Edit any returned files and remove the minlen argument from the pam_pwquality.so line(s)
        scored: true

      - id: 5.3.3.2.3
        description: "Ensure password complexity is configured (Manual)"
        audit: |
          grep -Psi -- '^\h*(minclass|[dulo]credit)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf
        type: "manual"
        remediation: |
          Run the following command to locate any pam_pwquality.so lines that override the desired settings:
          grep -Pl -- '\bpam_pwquality\.so\h+([^#\n\r]+\h+)?(minclass|[dulo]credit)\b' /usr/share/pam-configs/*
          Edit any returned files and remove the minclass, dcredit, ucredit, lcredit, and ocredit arguments from the pam_pwquality.so line(s).
          Create or modify a file ending in .conf in the /etc/security/pwquality.conf.d/ directory or the file /etc/security/pwquality.conf and add or modify the following line(s) to set complexity according to local site policy:
          minclass = _N_
          dcredit = _N_   # Value should be either 0 or a number preceded by a minus (-) symbol
          ucredit = -1    # Value should be either 0 or a number preceded by a minus (-) symbol
          ocredit = -1    # Value should be either 0 or a number preceded by a minus (-) symbol
          lcredit = -1    # Value should be either 0 or a number preceded by a minus (-) symbol
        scored: false

      - id: 5.3.3.2.4
        description: "Ensure password same consecutive characters is configured (Automated)"
        audit: |
          # Check for disallowed maxrepeat values in pwquality configuration files
          if grep -P '^\h*maxrepeat\h*=\h*(0|[4-9]|[1-9][0-9]+)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf >/dev/null; then
            echo "pwquality_maxrepeat_bad"
            exit 0
          fi
          # Ensure at least one valid maxrepeat setting (1-3) exists
          if ! grep -P '^\h*maxrepeat\h*=\h*[1-3]\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf >/dev/null; then
            echo "pwquality_maxrepeat_bad"
            exit 0
          fi
          # Check for disallowed maxrepeat values in PAM configuration
          if grep -P '^\h*password\h+(requisite|required|sufficient)\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?maxrepeat\h*=\h*(0|[4-9]|[1-9][0-9]+)\b' /etc/pam.d/common-password >/dev/null; then
            echo "pwquality_maxrepeat_bad"
            exit 0
          fi
          echo "pwquality_maxrepeat_ok"
        tests:
          test_items:
            - flag: "pwquality_maxrepeat_ok"
              set: true
        remediation: |
          # Ensure a maxrepeat setting of 3 or less (and not 0) is present in /etc/security/pwquality.conf or a file in /etc/security/pwquality.conf.d/.
          # Example: create /etc/security/pwquality.conf.d/50-pwrepeat.conf
          # cat <<EOF > /etc/security/pwquality.conf.d/50-pwrepeat.conf
          # maxrepeat = 3
          # EOF
          # Remove any maxrepeat argument from pam_pwquality.so lines in /etc/pam.d/common-password
          # sed -i '/pam_pwquality\.so/ s/maxrepeat=[^ ]*//' /etc/pam.d/common-password
        scored: true

      - id: 5.3.3.2.5
        description: "Ensure password maximum sequential characters is configured (Automated)"
        audit: |
          if grep -qP '^\h*maxsequence\h*=\h*[1-3]\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf && \
             ! grep -qP '^\h*maxsequence\h*=\h*(0|[4-9]|[1-9][0-9]+)\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf && \
             ! grep -qP '^\h*password\h+(requisite|required|sufficient)\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?maxsequence\h*=\h*(0|[4-9]|[1-9][0-9]+)\b' /etc/pam.d/common-password
          then
            echo "pwquality_maxsequence_ok"
          else
            echo "pwquality_maxsequence_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_maxsequence_ok"
              set: true
        remediation: |
          Create or modify a file ending in .conf in the /etc/security/pwquality.conf.d/ directory or the file /etc/security/pwquality.conf and add or modify the following line to set maxsequence to 3 or less and not 0. Ensure setting conforms to local site policy:
          #!/usr/bin/env bash
          {
             sed -ri 's/^\s*maxsequence\s*=/# &/' /etc/security/pwquality.conf
             [ ! -d /etc/security/pwquality.conf.d/ ] && mkdir /etc/security/pwquality.conf.d/
             printf '\n%s' "maxsequence = 3" > /etc/security/pwquality.conf.d/50-pwmaxsequence.conf
          }
          Run the following command:
          # grep -Pl -- '\bpam_pwquality\.so\h+([^#\n\r]+\h+)?maxsequence\b' /usr/share/pam-configs/*
          Edit any returned files and remove the maxsequence argument from the pam_pwquality.so line(s):
        scored: true

      - id: 5.3.3.2.6
        description: "Ensure password dictionary check is enabled (Automated)"
        audit: |
          if grep -qP '^\h*dictcheck\h*=\h*0\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null || \
             grep -qP '^\h*password\h+(requisite|required|sufficient)\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?dictcheck\h*=\h*0\b' /etc/pam.d/common-password 2>/dev/null; then
            echo "pwquality_dictcheck_bad"
          else
            echo "pwquality_dictcheck_ok"
          fi
        tests:
          test_items:
            - flag: "pwquality_dictcheck_ok"
              set: true
        remediation: |
          Edit any file ending in .conf in the /etc/security/pwquality.conf.d/ directory and/or the file /etc/security/pwquality.conf and comment out or remove any instance of dictcheck = 0:
          # sed -ri 's/^\s*dictcheck\s*=/# &/' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf
          Run the following command to find any pam_pwquality.so lines that still contain dictcheck:
          # grep -Pl -- '\bpam_pwquality\.so\h+([^#\n\r]+\h+)?dictcheck\b' /usr/share/pam-configs/*
          Edit any returned files and remove the dictcheck argument from the pam_pwquality.so line(s)
        scored: true

      - id: 5.3.3.2.7
        description: "Ensure password quality checking is enforced (Automated)"
        audit: |
          if grep -P -q '^\h*enforcing\h*=\h*0\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf || \
             grep -P -q '^\h*password\h+[^#\n\r]+\h+pam_pwquality\.so\h+([^#\n\r]+\h+)?enforcing=0\b' /etc/pam.d/common-password; then
            echo "pwquality_enforcing_bad"
          else
            echo "pwquality_enforcing_ok"
          fi
        tests:
          test_items:
            - flag: "pwquality_enforcing_ok"
              set: true
        remediation: |
          # Find and remove enforcing=0 from pam-configs
          grep -Pl -- '\bpam_pwquality\.so\h+([^#\n\r]+\h+)?enforcing=0\b' /usr/share/pam-configs/*
          # Edit any returned files and remove the enforcing=0 argument from the pam_pwquality.so line(s)
          # Remove or comment out enforcing=0 in pwquality configuration files
          sed -ri 's/^\s*enforcing\s*=\s*0/# &/' /etc/security/pwquality.conf
          sed -ri 's/^\s*enforcing\s*=\s*0/# &/' /etc/security/pwquality.conf.d/*.conf
        scored: true

      - id: 5.3.3.2.8
        description: "Ensure password quality is enforced for the root user (Automated)"
        audit: |
          if grep -Pq '^\h*enforce_for_root\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf 2>/dev/null; then
            echo "pwquality_enforce_for_root_ok"
          else
            echo "pwquality_enforce_for_root_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_enforce_for_root_ok"
              set: true
        remediation: |
          Edit or create a configuration file in /etc/security/pwquality.conf.d (e.g., 50-pwroot.conf) or in /etc/security/pwquality.conf and add the following line:
          enforce_for_root
          Example:
          # mkdir -p /etc/security/pwquality.conf.d
          # printf '\n%s\n' "enforce_for_root" > /etc/security/pwquality.conf.d/50-pwroot.conf
          Ensure the line is not commented out and that no other configuration file overrides it.
        scored: true

      - id: 5.3.3.3
        description: "Configure pam_pwhistory module"
        type: "skip"
        checks:

      - id: 5.3.3.3.1
        description: "Ensure password history remember is configured (Automated)"
        audit: |
          val=$(grep -P '^\h*password\h+[^#\n\r]+\h+pam_pwhistory\.so\h+([^#\n\r]+\h+)?remember=(\d+)\b' /etc/pam.d/common-password | grep -Po 'remember=\K\d+')
          if [ -n "$val" ] && [ "$val" -ge 24 ]; then
            echo "pwhistory_remember_ok"
          else
            echo "pwhistory_remember_bad"
          fi
        tests:
          test_items:
            - flag: "pwhistory_remember_ok"
              set: true
        remediation: |
          Run the following command:
          # awk '/Password-Type:/{ f = 1;next } /-Type:/{ f = 0 } f {if (/pam_pwhistory\.so/) print FILENAME}' /usr/share/pam-configs/*
          Edit any returned files and edit or add the remember= argument, with a value of 24 or more, that meets local site policy to the pam_pwhistory line in the Password section:
          Example File:
          Name: pwhistory password history checking
          Default: yes
          Priority: 1024
          Password-Type: Primary
          Password:
             requisite   pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok # <- **ensure line includes remember=<N>**
          Run the following command to update the files in the /etc/pam.d/ directory:
          # pam-auth-update --enable <MODIFIED_PROFILE_NAME>
          Example:
          # pam-auth-update --enable pwhistory
        scored: true

      - id: 5.3.3.3.2
        description: "Ensure password history is enforced for the root user (Automated)"
        audit: |
          if grep -Psi '^\h*password\h+[^#\n\r]+\h+pam_pwhistory\.so\h+([^#\n\r]+\h+)?enforce_for_root\b' /etc/pam.d/common-password; then
            echo "pwhistory_enforce_for_root_ok"
          else
            echo "pwhistory_enforce_for_root_bad"
          fi
        tests:
          test_items:
            - flag: "pwhistory_enforce_for_root_ok"
              set: true
        remediation: |
          Run the following command to identify PAM configuration files that need modification:
          # awk '/Password-Type:/{ f = 1;next } /-Type:/{ f = 0 } f {if (/pam_pwhistory\.so/) print FILENAME}' /usr/share/pam-configs/*
          Edit each returned file and add the enforce_for_root argument to the pam_pwhistory line in the Password section. For example:
          Name: pwhistory password history checking
          Default: yes
          Priority: 1024
          Password-Type: Primary
          Password:
             requisite   pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
          Then run:
          # pam-auth-update --enable <MODIFIED_PROFILE_NAME>
          Example:
          # pam-auth-update --enable pwhistory
        scored: true

      - id: 5.3.3.3.3
        description: "Ensure pam_pwhistory includes use_authtok (Automated)"
        audit: |
          if grep -qP '^\h*password\h+[^#\n\r]+\h+pam_pwhistory\.so\h+([^#\n\r]+\h+)?use_authtok\b' /etc/pam.d/common-password; then
            echo "pam_pwhistory_use_authtok_ok"
          else
            echo "pam_pwhistory_use_authtok_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwhistory_use_authtok_ok"
              set: true
        remediation: |
          # Identify PAM profiles that use pam_pwhistory
          awk '/Password-Type:/{ f = 1;next } /-Type:/{ f = 0 } f {if (/pam_pwhistory\.so/) print FILENAME}' /usr/share/pam-configs/*
          # Edit each returned file and add the use_authtok argument to the pam_pwhistory line
          # Example edit:
          #   requisite   pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
          # After editing, enable the modified profile
          pam-auth-update --enable <MODIFIED_PROFILE_NAME>
        scored: true

      - id: 5.3.3.4
        description: "Configure pam_unix module"
        type: "skip"
        checks:

      - id: 5.3.3.4.1
        description: "Ensure pam_unix does not include nullok (Automated)"
        audit: |
          if grep -E '^\s*[^#]*pam_unix\.so' /etc/pam.d/common-{password,auth,account,session,session-noninteractive} | grep -q '\bnullok\b'; then
            echo "pam_unix_nullok_bad"
          else
            echo "pam_unix_nullok_ok"
          fi
        tests:
          test_items:
            - flag: "pam_unix_nullok_ok"
              set: true
        remediation: |
          Find and remove nullok from pam_unix lines:
          grep -PH -- '^\h*([^#\n\r]+\h+)?pam_unix\.so\h+([^#\n\r]+\h+)?nullok\b' /usr/share/pam-configs/*
          Edit the returned files and remove the nullok argument from pam_unix.so lines.
          Then enable the updated profile:
          pam-auth-update --enable <EDITED_PROFILE_NAME>
          # Example: pam-auth-update --enable unix
        scored: true

      - id: 5.3.3.4.2
        description: "Ensure pam_unix does not include remember (Automated)"
        audit: |
          if grep -P -q -e '^\h*[^#\n\r]+\h+pam_unix\.so\b.*\bremember=\d+\b' /etc/pam.d/common-{password,auth,account,session,session-noninteractive}; then
            echo "pam_unix_remember_bad"
          else
            echo "pam_unix_remember_ok"
          fi
        tests:
          test_items:
            - flag: "pam_unix_remember_ok"
              set: true
        remediation: |
          # Find pam_unix lines that contain the remember option
          grep -PH -- '^\h*([^#\n\r]+\h+)?pam_unix\.so\h+([^#\n\r]+\h+)?remember\b' /usr/share/pam-configs/*
          # Edit the returned files and remove the remember=<N> argument from any pam_unix.so lines
          # Example edit:
          #   [success=end default=ignore]   pam_unix.so obscure use_authtok try_first_pass yescrypt
          #   [success=end default=ignore]   pam_unix.so obscure yescrypt
          # After editing, enable the updated profile:
          pam-auth-update --enable <EDITED_PROFILE_NAME>
          # Example: pam-auth-update --enable unix
        scored: true

      - id: 5.3.3.4.3
        description: "Ensure pam_unix includes a strong password hashing algorithm (Automated)"
        audit: |
          if grep -PH '^\h*password\h+([^#\n\r]+)\h+pam_unix\.so\h+([^#\n\r]+\h+)?(sha512|yescrypt)\b' /etc/pam.d/common-password >/dev/null; then
            echo "pam_unix_hash_ok"
          else
            echo "pam_unix_hash_bad"
          fi
        tests:
          test_items:
            - flag: "pam_unix_hash_ok"
              set: true
        remediation: |
          # Identify PAM configuration files that contain pam_unix.so in the Password section
          awk '/Password-Type:/{ f = 1;next } /-Type:/{ f = 0 } f {if (/pam_unix\.so/) print FILENAME}' /usr/share/pam-configs/*
          # For each returned file, edit the Password section to include either sha512 or yescrypt
          # Example edit (replace <FILE> with the actual file name):
          #   sed -i 's/\(pam_unix\.so[^\n]*\)/\1 sha512/' <FILE>
          #   # or
          #   sed -i 's/\(pam_unix\.so[^\n]*\)/\1 yescrypt/' <FILE>
          # After editing, enable the modified profile in /etc/pam.d/
          # Replace <MODIFIED_PROFILE_NAME> with the name of the profile you edited
          pam-auth-update --enable <MODIFIED_PROFILE_NAME>
        scored: true

      - id: 5.3.3.4.4
        description: "Ensure pam_unix includes use_authtok (Automated)"
        audit: |
          if grep -PH '^\h*password\h+([^#\n\r]+)\h+pam_unix\.so\h+([^#\n\r]+\h+)?use_authtok\b' /etc/pam.d/common-password | grep -q .; then
            echo "pam_unix_use_authtok_ok"
          else
            echo "pam_unix_use_authtok_bad"
          fi
        tests:
          test_items:
            - flag: "pam_unix_use_authtok_ok"
              set: true
        remediation: |
          Identify PAM configuration files that need updating:
          awk '/Password-Type:/{ f = 1;next } /-Type:/{ f = 0 } f {if (/pam_unix\.so/) print FILENAME}' /usr/share/pam-configs/*
          Edit each returned file and add 'use_authtok' to the pam_unix line in the Password section (under the Password: subsection). Do not add it to the Password-Initial subsection.
          After editing, enable the modified profile:
          pam-auth-update --enable <MODIFIED_PROFILE_NAME>
        scored: true

  - id: 5.4
    description: "User Accounts and Environment"
    checks:
      - id: 5.4.1
        description: "Configure shadow password suite parameters"
        type: "skip"
        checks:

      - id: 5.4.1.1
        description: "Ensure password expiration is configured (Automated)"
        audit: |
          maxdays=$(grep -Pi '^\h*PASS_MAX_DAYS\h+\d+\b' /etc/login.defs | awk '{print $2}')
          if [ -z "$maxdays" ] || [ "$maxdays" -gt 365 ] || [ "$maxdays" -lt 1 ]; then
            echo "pass_max_days_bad"
            exit 0
          fi
          if awk -F: '($2~/^\$.+\$/) {if($5 > 365 || $5 < 1) exit 1}' /etc/shadow; then
            echo "pass_max_days_ok"
          else
            echo "pass_max_days_bad"
          fi
        tests:
          test_items:
            - flag: "pass_max_days_ok"
              set: true
        remediation: |
          Edit /etc/login.defs and set:
          PASS_MAX_DAYS 365
          Modify user parameters for all users with a password set to match:
          # chage --maxdays 365 <user>
          Edit /etc/login.defs and set PASS_MAX_DAYS to a value greater than 0 that follows local site policy:
          Example:
          PASS_MAX_DAYS 365
          Run the following command to modify user parameters for all users with a password set to a maximum age no greater than 365 or less than 1 that follows local site policy:
          # awk -F: '($2~/^\$.+\$/) {if($5 > 365 || $5 < 1)system ("chage --maxdays 365 " $1)}' /etc/shadow
          Warning: If a password has been set at system install or kickstart, the last change date field is not set. In this case, setting PASS_MAX_DAYS will immediately expire the password. One possible solution is to populate the last change date field through a command like:
          chage -d "$(date +%Y-%m-%d)" root
        scored: true

      - id: 5.4.1.2
        description: "Ensure minimum password days is configured (Manual)"
        audit: |
          # Verify PASS_MIN_DAYS is set to a value greater than 0 in /etc/login.defs
          grep -Pi -- '^\h*PASS_MIN_DAYS\h+\d+\b' /etc/login.defs
          # Verify all users have PASS_MIN_DAYS greater than 0
          awk -F: '($2~/^\$.+\$/) {if($4 < 1)print "User: " $1 " PASS_MIN_DAYS: " $4}' /etc/shadow
        type: "manual"
        remediation: |
          Edit /etc/login.defs and set PASS_MIN_DAYS to a value greater than 0 that follows local site policy:
          Example:
          PASS_MIN_DAYS 1
          Run the following command to modify user parameters for all users with a password set to a minimum days greater than zero that follows local site policy:
          # awk -F: '($2~/^\$.+\$/) {if($4 < 1)system ("chage --mindays 1 " $1)}' /etc/shadow
        scored: false

      - id: 5.4.1.3
        description: "Ensure password expiration warning days is configured (Automated)"
        audit: |
          val=$(grep -Pi '^\h*PASS_WARN_AGE\h+\d+\b' /etc/login.defs | awk '{print $2}')
          if [ -z "$val" ] || [ "$val" -lt 7 ]; then
            echo "pass_warn_age_bad"
            exit 0
          fi
          if awk -F: '($2~/^\$.+\$/) {if($6 < 7) exit 1}' /etc/shadow; then
            echo "pass_warn_age_ok"
          else
            echo "pass_warn_age_bad"
          fi
        tests:
          test_items:
            - flag: "pass_warn_age_ok"
              set: true
        remediation: |
          Edit /etc/login.defs and set PASS_WARN_AGE to a value of 7 or more that follows local site policy:
          PASS_WARN_AGE 7
          Run the following command to modify user parameters for all users with a password set to a minimum warning to 7 or more days that follows local site policy:
          # awk -F: '($2~/^\$.+\$/) {if($6 < 7)system ("chage --warndays 7 " $1)}' /etc/shadow
        scored: true

      - id: 5.4.1.4
        description: "Ensure strong password hashing algorithm is configured (Automated)"
        audit: |
          if grep -Pi -- '^\h*ENCRYPT_METHOD\h+(SHA512|yescrypt)\b' /etc/login.defs >/dev/null; then
            echo "encrypt_method_ok"
          else
            echo "encrypt_method_bad"
          fi
        tests:
          test_items:
            - flag: "encrypt_method_ok"
              set: true
        remediation: |
          Edit /etc/login.defs and set the ENCRYPT_METHOD to SHA512 or YESCRYPT:
          ENCRYPT_METHOD <HASHING_ALGORITHM>
          Example:
          ENCRYPT_METHOD YESCRYPT
        scored: true

      - id: 5.4.1.5
        description: "Ensure inactive password lock is configured (Automated)"
        audit: |
          bad=0
          default_inactive=$(useradd -D | awk -F= '/^INACTIVE/ {print $2}')
          if [ -z "$default_inactive" ] || [ "$default_inactive" -lt 0 ] || [ "$default_inactive" -gt 45 ]; then
            bad=1
          fi
          if awk -F: '($2~/^\$.+\$/) {if($7 > 45 || $7 < 0) exit 1}' /etc/shadow; then
            : # no violation
          else
            bad=1
          fi
          if [ "$bad" -eq 1 ]; then
            echo "inactive_password_lock_bad"
          else
            echo "inactive_password_lock_ok"
          fi
        tests:
          test_items:
            - flag: "inactive_password_lock_ok"
              set: true
        remediation: |
          Run the following command to set the default password inactivity period to 45 days or less that meets local site policy:
          # useradd -D -f <N>
          Example:
          # useradd -D -f 45
          Run the following command to modify user parameters for all users with a password set to a inactive age of 45 days or less that follows local site policy:
          # chage --inactive <N> <user>
          Example:
          # awk -F: '($2~/^\$.+\$/) {if($7 > 45 || $7 < 0)system ("chage --inactive 45 " $1)}' /etc/shadow
        scored: true

      - id: 5.4.1.6
        description: "Ensure all users last password change date is in the past (Automated)"
        audit: |
          found_bad=0
          while IFS= read -r l_user; do
            l_change=$(date -d "$(chage --list "$l_user" | grep '^Last password change' | cut -d: -f2 | grep -v 'never$')" +%s)
            if [[ "$l_change" -gt "$(date +%s)" ]]; then
              found_bad=1
              break
            fi
          done < <(awk -F: '$2~/^\$.+\$/{print $1}' /etc/shadow)
          if [ "$found_bad" -eq 1 ]; then
            echo "users_lastpw_future_bad"
          else
            echo "users_lastpw_future_ok"
          fi
        tests:
          test_items:
            - flag: "users_lastpw_future_ok"
              set: true
        remediation: |
          Investigate any users with a password change date in the future and correct them.
          Lock the account, expire the password, or reset the password manually may be appropriate.
          Example commands:
          # chage -d 0 username   # expire password immediately
          # passwd -e username    # force password change at next login
        scored: true

      - id: 5.4.2
        description: "Configure root and system accounts and environment"
        type: "skip"
        checks:

      - id: 5.4.2.1
        description: "Ensure root is the only UID 0 account (Automated)"
        audit: |
          users=$(awk -F: '($3 == 0) {print $1}' /etc/passwd | sort | tr '\n' ',')
          if [ "$users" = "root," ]; then
            echo "root_uid0_ok"
          else
            echo "root_uid0_bad"
          fi
        tests:
          test_items:
            - flag: "root_uid0_ok"
              set: true
        remediation: |
          Run the following command to change the root account UID to 0:
          # usermod -u 0 root
          Modify any users other than root with UID 0 and assign them a new UID.
        scored: true

      - id: 5.4.2.2
        description: "Ensure root is the only GID 0 account (Automated)"
        audit: |
          users=$(awk -F: '($1 !~ /^(sync|shutdown|halt|operator)$/ && $4=="0") {print $1}' /etc/passwd)
          if [ "$users" = "root" ]; then
            echo "root_gid0_ok"
          else
            echo "root_gid0_bad"
          fi
        tests:
          test_items:
            - flag: "root_gid0_ok"
              set: true
        remediation: |
          Run the following command to set the root user's GID to 0:
          # usermod -g 0 root
          Run the following command to set the root group's GID to 0:
          # groupmod -g 0 root
          Remove any users other than the root user with GID 0 or assign them a new GID if appropriate.
        scored: true

      - id: 5.4.2.3
        description: "Ensure group root is the only GID 0 group (Automated)"
        audit: |
          if awk -F: '$3=="0"{print $1}' /etc/group | grep -v '^root$' | grep -q .; then
            echo "root_gid0_only_bad"
          else
            echo "root_gid0_only_ok"
          fi
        tests:
          test_items:
            - flag: "root_gid0_only_ok"
              set: true
        remediation: |
          Run the following command to set the root group's GID to 0:
          # groupmod -g 0 root
          Remove any groups other than the root group with GID 0 or assign them a new GID if appropriate.
        scored: true

      - id: 5.4.2.4
        description: "Ensure root account access is controlled (Automated)"
        audit: |
          status="$(passwd -S root | awk '{print $2}')"
          if [[ "$status" == "P" || "$status" == "L" ]]; then
            echo "root_access_ok"
          else
            echo "root_access_bad"
          fi
        tests:
          test_items:
            - flag: "root_access_ok"
              set: true
        remediation: |
          # Set a password for the root user
          # passwd root
          # OR lock the root user account
          # usermod -L root
        scored: true

      - id: 5.4.2.5
        description: "Ensure root PATH integrity (Automated)"
        audit: |
          !/usr/bin/env bash
          {
          l_output2=""
          l_pmask="0022"
          l_maxperm="$( printf '%o' $(( 0777 & ~$l_pmask )) )"
          l_root_path="$(sudo -Hiu root env | grep '^PATH' | cut -d= -f2)"
          unset a_path_loc && IFS=":" read -ra a_path_loc <<< "$l_root_path"
          grep -q "::" <<< "$l_root_path" && l_output2="$l_output2\n - root's path contains a empty directory (::)"
          grep -Pq ":\h*$" <<< "$l_root_path" && l_output2="$l_output2\n - root's path contains a trailing (:)"
          grep -Pq '(\h+|:)\.(:|\h*$)' <<< "$l_root_path" && l_output2="$l_output2\n - root's path contains current working directory (.)"
          while read -r l_path; do
              if [ -d "$l_path" ]; then
                while read -r l_fmode l_fown; do
                    [ "$l_fown" != "root" ] && l_output2="$l_output2\n - Directory: \"$l_path\" is owned by: \"$l_fown\" should be owned by \"root\""
                    [ $(( $l_fmode & $l_pmask )) -gt 0 ] && l_output2="$l_output2\n - Directory: \"$l_path\" is mode: \"$l_fmode\" and should be mode: \"$l_maxperm\" or more restrictive"
                done <<< "$(stat -Lc '%#a %U' "$l_path")"
              else
                l_output2="$l_output2\n - \"$l_path\" is not a directory"
              fi
          done <<< "$(printf "%s\n" "${a_path_loc[@]}")"
          if [ -z "$l_output2" ]; then
              echo -e "\n- Audit Result:\n  *** PASS ***\n - Root's path is correctly configured\n"
          else
              echo -e "\n- Audit Result:\n  ** FAIL **\n - * Reasons for audit failure * :\n$l_output2\n"
          fi
          }
        tests:
          test_items:
            - flag: "root_path_ok"
              set: true
        remediation: |
          Remove world-writable directories, current directory (.), and non-root-owned entries from root's PATH.
          Recommended safe PATH:
            export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
        scored: true

      - id: 5.4.2.6
        description: "Ensure root user umask is configured (Automated)"
        audit: |
          if ! grep -Psi '^\h*umask\h+(([0-7][0-7][01][0-7]\b|[0-7][0-7][0-7][0-6]\b)|([0-7][01][0-7]\b|[0-7][0-7][0-6]\b)|(u=[rwx]{1,3},)?(((g=[rx]?[rx]?w[rx]?[rx]?\b)(,o=[rwx]{1,3})?)|((g=[wrx]{1,3},)?o=[wrx]{1,3}\b)))' /root/.bash_profile /root/.bashrc >/dev/null; then
            echo "root_umask_ok"
          else
            echo "root_umask_bad"
          fi
        tests:
          test_items:
            - flag: "root_umask_ok"
              set: true
        remediation: |
          Edit /root/.bash_profile and /root/.bashrc and remove, comment out, or update any line with umask to be 0027 or more restrictive.
          For example:
          # umask 0027
          # or
          # umask u=rwx,g=rx,o=
          After making changes, log out and log back in to apply the new umask.
        scored: true

      - id: 5.4.2.7
        description: "Ensure system accounts do not have a valid login shell (Automated)"
        audit: |
          l_valid_shells="^($(awk -F/ '$NF != \"nologin\" {print}' /etc/shells | sed -rn '/^\\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
          uid_min=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)
          bad=$(awk -v pat="$l_valid_shells" -v uid_min="$uid_min" -F: '
            $1 !~ /^(root|halt|sync|shutdown|nfsnobody)$/ &&
            ($3 < uid_min || $3 == 65534) &&
            $NF ~ pat
            {print 1}
          ' /etc/passwd | wc -l)
          if [ "$bad" -gt 0 ]; then
            echo "system_accounts_shell_bad"
          else
            echo "system_accounts_shell_ok"
          fi
        tests:
          test_items:
            - flag: "system_accounts_shell_ok"
              set: true
        remediation: |
          Run the following command to set the shell for any service accounts returned by the audit to nologin:
          # usermod -s $(command -v nologin) <user>
          Example script:
          #!/usr/bin/env bash
          l_valid_shells="^($(awk -F/ '$NF != \"nologin\" {print}' /etc/shells | sed -rn '/^\\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
          awk -v pat="$l_valid_shells" -F: '
            $1 !~ /^(root|halt|sync|shutdown|nfsnobody)$/ &&
            ($3 < uid_min || $3 == 65534) &&
            $NF ~ pat
            {system ("usermod -s \\'$(command -v nologin)\\' " $1)}
          ' uid_min="$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)" /etc/passwd
        scored: true

      - id: 5.4.2.8
        description: "Ensure accounts without a valid login shell are locked (Automated)"
        audit: |
          if awk -v shells="$(awk -F/ '$NF != \"nologin\" {print}' /etc/shells | sed -rn '/^\\//{s,/,\\\\/,g;p}' | paste -s -d '|' -)" -F: '
            ($1 != \"root\" && $(NF) !~ shells) {
              cmd = \"passwd -S \" $1
              cmd | getline status
              close(cmd)
              if (status !~ /^L/) exit 1
            }
            END { exit 0 }
          ' /etc/passwd; then
            echo "accounts_no_shell_locked_ok"
          else
            echo "accounts_no_shell_locked_bad"
          fi
        tests:
          test_items:
            - flag: "accounts_no_shell_locked_ok"
              set: true
        remediation: |
          Run the following command to lock any non-root accounts without a valid login shell returned by the audit:
          # usermod -L <user>
          Example script:
          #!/usr/bin/env bash
          {
             l_valid_shells="^($(awk -F\/ '$NF != \"nologin\" {print}' /etc/shells | sed -rn '/^\\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
             while IFS= read -r l_user; do
                passwd -S "$l_user" | awk '$2 !~ /^L/ {system (\"usermod -L \" $1)}'
             done < <(awk -v pat="$l_valid_shells" -F: '($1 != \"root\" && $(NF) !~ pat) {print $1}' /etc/passwd)
          }
        scored: true

      - id: 5.4.3
        description: "Configure user default environment"
        type: "skip"
        checks:

      - id: 5.4.3.1
        description: "Ensure nologin is not listed in /etc/shells (Automated)"
        audit: |
          if ! grep -Ps '^\h*([^#\n\r]+)?\/nologin\b' /etc/shells >/dev/null; then
            echo "nologin_not_in_shells_ok"
          else
            echo "nologin_not_in_shells_bad"
          fi
        tests:
          test_items:
            - flag: "nologin_not_in_shells_ok"
              set: true
        remediation: |
          Edit /etc/shells and remove any lines that include nologin
        scored: true

      - id: 5.4.3.2
        description: "Ensure default user shell timeout is configured (Automated)"
        audit: |
          files=(/etc/bashrc /etc/profile /etc/profile.d/*.sh)
          found_ok=false
          found_bad=false
          for f in "${files[@]}"; do
            [ ! -f "$f" ] && continue
            if grep -Pq '^\s*TMOUT=(900|[1-8][0-9]{2}|[1-9][0-9]|[1-9])\b' "$f" &&
               grep -Pq '^\s*readonly\s+TMOUT\b' "$f" &&
               grep -Pq '^\s*export\s+TMOUT\b' "$f"; then
              found_ok=true
            fi
            if grep -Pq '^\s*TMOUT=(9[0-9][1-9]|9[1-9][0-9]|0+|[1-9]\d{3,})\b' "$f"; then
              found_bad=true
            fi
          done
          if $found_ok && ! $found_bad; then
            echo "tmout_config_ok"
          else
            echo "tmout_config_bad"
          fi
        tests:
          test_items:
            - flag: "tmout_config_ok"
              set: true
        remediation: |
          Edit /etc/bashrc, /etc/profile, and all *.sh files in /etc/profile.d/ to ensure TMOUT is set to a value no greater than 900, is readonly, and exported. For example:
          TMOUT=900
          readonly TMOUT
          export TMOUT
          Remove any lines setting TMOUT=0 or TMOUT to a value greater than 900.
        scored: true

      - id: 5.4.3.3
        description: "Ensure default user umask is configured (Automated)"
        audit: |
          bad=0
          # Check /etc/profile.d/*.sh
          while IFS= read -r -d '' file; do
            if grep -qE '^\s*umask' "$file"; then
              if ! grep -qE '^\s*umask\s+0?[2-7]7' "$file"; then
                bad=1
              fi
            fi
          done < <(find /etc/profile.d -type f -name '*.sh' -print0)
          # Check other system files
          for file in /etc/profile /etc/bashrc /etc/bash.bashrc /etc/pam.d/postlogin /etc/login.defs /etc/default/login; do
            if [ -f "$file" ] && grep -qE '^\s*umask' "$file"; then
              if ! grep -qE '^\s*umask\s+0?[2-7]7' "$file"; then
                bad=1
              fi
            fi
          done
          if [ "$bad" -eq 0 ]; then
            echo "umask_default_ok"
          else
            echo "umask_default_bad"
          fi
        tests:
          test_items:
            - flag: "umask_default_ok"
              set: true
        remediation: |
          # Set a system‑wide umask of 027 or more restrictive
          # Create or edit a file in /etc/profile.d/ ending in .sh
          # Example:
          # printf '%s\n' "umask 027" > /etc/profile.d/50-systemwide_umask.sh
          #
          # If you prefer to use pam_umask, ensure it is not overridden:
          # Edit /etc/pam.d/postlogin and add:
          # session required pam_umask.so umask=027
          #
          # After making changes, reload the shell environment or reboot.
        scored: true

  - id: 6
    description: "Logging and Auditing"
    checks:
  - id: 6.1
    description: "System Logging"
    checks:
      - id: 6.1.1
        description: "Configure systemd-journald service"
        type: "skip"
        checks:

      - id: 6.1.1.1
        description: "Ensure journald service is enabled and active (Automated)"
        audit: |
          enabled=$(systemctl is-enabled systemd-journald.service 2>/dev/null)
          active=$(systemctl is-active systemd-journald.service 2>/dev/null)
          if [ "$active" = "active" ] && { [ "$enabled" = "enabled" ] || [ "$enabled" = "static" ]; }; then
            echo "journald_enabled_active_ok"
          else
            echo "journald_enabled_active_bad"
          fi
        tests:
          test_items:
            - flag: "journald_enabled_active_ok"
              set: true
        remediation: |
          Run the following commands to unmask and start systemd-journald.service:
          # systemctl unmask systemd-journald.service
          # systemctl start systemd-journald.service
        scored: true

      - id: 6.1.1.2
        description: "Ensure journald log file access is configured (Manual)"
        audit: |
          #!/usr/bin/env bash
          {
             a_output=() a_output2=()
             l_systemd_config_file="/etc/tmpfiles.d/systemd.conf"
             l_analyze_cmd="$(readlink -f /bin/systemd-analyze)"
             f_file_chk()
             {
                l_maxperm="$( printf '%o' $(( 0777 & ~$l_perm_mask )) )"
                if [ $(( $l_mode & $l_perm_mask )) -le 0 ] || [[ "$l_type" = "Directory" && "$l_mode" =~ 275(0|5) ]]; then
                   a_out+=("  - $l_type \"$l_logfile\" access is:" \
                   "    mode: \"$l_mode\", owned by: \"$l_user\", and group owned by: \"$l_group\"")
                else
                   a_out2+=("  - $l_type \"$l_logfile\" access is:" \
                   "    mode: \"$l_mode\", owned by: \"$l_user\", and group owned by: \"$l_group\"" \
                   "    should be mode: \"$l_maxperm\" or more restrictive")
                fi
             }
             while IFS= read -r l_file; do
                l_file="$(tr -d '# ' <<< "$l_file")" a_out=() a_out2=()
                l_logfile_perms_line="$(awk '($1~/^(f|d)$/ && $2~/\/\S+/ && $3~/[0-9]{3,}/){print $2 ":" $3 ":" $4 ":" $5}' "$l_file")"
                while IFS=: read -r l_logfile l_mode l_user l_group; do
                   if [ -d "$l_logfile" ]; then
                      l_perm_mask="0027" l_type="Directory"
                      grep -Psq '^(\/run|\/var\/lib\/systemd)\b' <<< "$l_logfile" && l_perm_mask="0022"
                   else
                      l_perm_mask="0137" l_type="File"
                   fi
                   grep -Psq '^(\/run|\/var\/lib\/systemd)\b' <<< "$l_logfile" && l_perm_mask="0022"
                   f_file_chk
                done <<< "$l_logfile_perms_line"
                [ "${#a_out[@]}" -gt "0" ] && a_output+=(" - File: \"$l_file\" sets:" "${a_out[@]}")
                [ "${#a_out2[@

      - id: 6.1.1.3
        description: "Ensure journald log file rotation is configured (Manual)"
        audit: |
          # Review journald rotation settings
          systemd-analyze cat-config systemd/journald.conf | grep -E '^\s*(SystemMaxUse|SystemKeepFree|RuntimeMaxUse|RuntimeKeepFree|MaxFileSec)\b'
        type: "manual"
        remediation: |
          Edit /etc/systemd/journald.conf or create a drop‑in file in /etc/systemd/journald.conf.d/ with the following [Journal] settings:
          SystemMaxUse=1G
          SystemKeepFree=500M
          RuntimeMaxUse=200M
          RuntimeKeepFree=50M
          MaxFileSec=1month
          Example script to create a drop‑in configuration file:
          #!/usr/bin/env bash
          a_settings=("SystemMaxUse=1G" "SystemKeepFree=500M" "RuntimeMaxUse=200M" "RuntimeKeepFree=50M" "MaxFileSec=1month")
          [ ! -d /etc/systemd/journald.conf.d/ ] && mkdir /etc/systemd/journald.conf.d/
          if grep -Psq '^\h*\[Journal\]' /etc/systemd/journald.conf.d/60-journald.conf; then
              printf '%s\n' "${a_settings[@]}" >> /etc/systemd/journald.conf.d/60-journald.conf
          else
              printf '%s\n' "[Journal]" "${a_settings[@]}" >> /etc/systemd/journald.conf.d/60-journald.conf
          fi
          # Reload journald to apply changes
          systemctl reload-or-restart systemd-journald
        scored: false

      - id: 6.1.1.4
        description: "Ensure only one logging system is in use (Automated)"
        audit: |
          rsyslog_active=$(systemctl is-active --quiet rsyslog && echo 1 || echo 0)
          journald_active=$(systemctl is-active --quiet systemd-journald && echo 1 || echo 0)
          if [ "$rsyslog_active" -eq 1 ] && [ "$journald_active" -eq 1 ]; then
            echo "logging_system_single_bad"
          elif [ "$rsyslog_active" -eq 0 ] && [ "$journald_active" -eq 0 ]; then
            echo "logging_system_single_bad"
          else
            echo "logging_system_single_ok"
          fi
        tests:
          test_items:
            - flag: "logging_system_single_ok"
              set: true
        remediation: |
          Determine whether to use journald or rsyslog based on site requirements.
          If choosing journald:
            systemctl stop rsyslog
            systemctl disable rsyslog
            systemctl enable systemd-journald
            systemctl start systemd-journald
          If choosing rsyslog:
            systemctl stop systemd-journald
            systemctl disable systemd-journald
            systemctl enable rsyslog
            systemctl start rsyslog
          Verify that only the chosen service is active:
            systemctl is-active --quiet rsyslog
            systemctl is-active --quiet systemd-journald
        scored: true

      - id: 6.1.2
        description: "Configure journald"
        type: "skip"
        checks:

      - id: 6.1.2.1
        description: "Configure systemd-journal-remote"
        type: "skip"
        checks:

      - id: 6.1.2.1.1
        description: "Ensure systemd-journal-remote is installed (Automated)"
        audit: |
          if dpkg-query -s systemd-journal-remote &>/dev/null; then
            echo "systemd_journal_remote_ok"
          else
            echo "systemd_journal_remote_bad"
          fi
        tests:
          test_items:
            - flag: "systemd_journal_remote_ok"
              set: true
        remediation: |
          apt install systemd-journal-remote
        scored: true

      - id: 6.1.2.1.2
        description: "Ensure systemd-journal-upload authentication is configured (Manual)"
        audit: |
          # Run the following script to verify systemd-journal-upload authentication is configured:
          # (Script omitted for brevity)
        type: "manual"
        remediation: |
          Edit the /etc/systemd/journal-upload.conf file or a file in /etc/systemd/journal-upload.conf.d ending in .conf and ensure the following lines are set in the [Upload] section per your environment:
          Example settings:
          [Upload]
          URL=192.168.50.42
          ServerKeyFile=/etc/ssl/private/journal-upload.pem
          ServerCertificateFile=/etc/ssl/certs/journal-upload.pem
          TrustedCertificateFile=/etc/ssl/ca/trusted.pem
          Example script to create systemd drop-in configuration file:
          # (script omitted)
          Run the following command to update the parameters in the service:
          # systemctl reload-or-restart systemd-journal-upload
        scored: false

      - id: 6.1.2.1.3
        description: "Ensure systemd-journal-upload is enabled and active (Automated)"
        audit: |
          if systemctl is-enabled systemd-journal-upload.service | grep -q '^enabled$' && systemctl is-active systemd-journal-upload.service | grep -q '^active$'; then
            echo "systemd_journal_upload_ok"
          else
            echo "systemd_journal_upload_bad"
          fi
        tests:
          test_items:
            - flag: "systemd_journal_upload_ok"
              set: true
        remediation: |
          Run the following commands to unmask, enable and start systemd-journal-upload:
          # systemctl unmask systemd-journal-upload.service
          # systemctl --now enable systemd-journal-upload.service
        scored: true

      - id: 6.1.2.1.4
        description: "Ensure systemd-journal-remote service is not in use (Automated)"
        audit: |
          if ! systemctl is-enabled systemd-journal-remote.socket systemd-journal-remote.service | grep -P '^enabled' >/dev/null && ! systemctl is-active systemd-journal-remote.socket systemd-journal-remote.service | grep -P '^active' >/dev/null; then
            echo "systemd_journal_remote_service_ok"
          else
            echo "systemd_journal_remote_service_bad"
          fi
        tests:
          test_items:
            - flag: "systemd_journal_remote_service_ok"
              set: true
        remediation: |
          Run the following commands to stop and mask systemd-journal-remote.socket and systemd-journal-remote.service:
          # systemctl stop systemd-journal-remote.socket systemd-journal-remote.service
          # systemctl mask systemd-journal-remote.socket systemd-journal-remote.service
        scored: true

      - id: 6.1.2.2
        description: "Ensure journald ForwardToSyslog is disabled (Automated)"
        audit: |
          if systemd-analyze cat-config systemd/journald.conf | grep -qP '^\s*ForwardToSyslog\s*=\s*no'; then
            echo "journald_forwardtosyslog_ok"
          else
            echo "journald_forwardtosyslog_bad"
          fi
        tests:
          test_items:
            - flag: "journald_forwardtosyslog_ok"
              set: true
        remediation: |
          Edit /etc/systemd/journald.conf or create a drop‑in file in /etc/systemd/journald.conf.d/ ending in .conf:
          [Journal]
          ForwardToSyslog=no
          Example to create a drop‑in:
          # mkdir -p /etc/systemd/journald.conf.d
          # cat <<EOF > /etc/systemd/journald.conf.d/60-journald.conf
          [Journal]
          ForwardToSyslog=no
          EOF
          Reload the journal service:
          # systemctl reload-or-restart systemd-journald
        scored: true

      - id: 6.1.2.3
        description: "Ensure journald Compress is configured (Automated)"
        audit: |
          files=()
          [ -f /etc/systemd/journald.conf ] && files+=("/etc/systemd/journald.conf")
          for f in /etc/systemd/journald.conf.d/*.conf; do
            [ -f "$f" ] && files+=("$f")
          done
          if [ ${#files[@]} -eq 0 ]; then
            echo "journald_compress_ok"
            exit
          fi
          found=0
          for f in "${files[@]}"; do
            if grep -qP '^\s*Compress\s*=\s*yes' "$f"; then
              found=1
              break
            fi
          done
          if [ "$found" -eq 1 ]; then
            echo "journald_compress_ok"
          else
            echo "journald_compress_bad"
          fi
        tests:
          test_items:
            - flag: "journald_compress_ok"
              set: true
        remediation: |
          Create or edit /etc/systemd/journald.conf or a drop‑in file in /etc/systemd/journald.conf.d/ ending in .conf:
            [Journal]
            Compress=yes
          Example:
            mkdir -p /etc/systemd/journald.conf.d
            cat <<EOF > /etc/systemd/journald.conf.d/60-journald.conf
            [Journal]
            Compress=yes
            EOF
          Reload systemd‑journald:
            systemctl reload-or-restart systemd-journald.service
        scored: true

      - id: 6.1.2.4
        description: "Ensure journald Storage is configured (Automated)"
        audit: |
          if systemd-analyze cat-config systemd/journald.conf | grep -i '^Storage=' | grep -i '^Storage=persistent$' >/dev/null; then
            echo "journald_storage_ok"
          else
            echo "journald_storage_bad"
          fi
        tests:
          test_items:
            - flag: "journald_storage_ok"
              set: true
        remediation: |
          Edit /etc/systemd/journald.conf or create a drop‑in file in /etc/systemd/journald.conf.d/ with:
          [Journal]
          Storage=persistent
          Reload journald:
          # systemctl reload-or-restart systemd-journald
        scored: true

      - id: 6.1.3
        description: "Configure rsyslog"
        type: "skip"
        checks:

      - id: 6.1.3.1
        description: "Ensure rsyslog is installed (Automated)"
        audit: |
          if dpkg-query -s rsyslog &>/dev/null; then
            echo "rsyslog_installed_ok"
          else
            echo "rsyslog_installed_bad"
          fi
        tests:
          test_items:
            - flag: "rsyslog_installed_ok"
              set: true
        remediation: |
          Run the following command to install rsyslog:
          # apt install rsyslog
        scored: true

      - id: 6.1.3.2
        description: "Ensure rsyslog service is enabled and active (Automated)"
        audit: |
          enabled=$(systemctl is-enabled rsyslog 2>/dev/null)
          active=$(systemctl is-active rsyslog.service 2>/dev/null)
          if [ "$enabled" = "enabled" ] && [ "$active" = "active" ]; then
            echo "rsyslog_enabled_active_ok"
          else
            echo "rsyslog_enabled_active_bad"
          fi
        tests:
          test_items:
            - flag: "rsyslog_enabled_active_ok"
              set: true
        remediation: |
          Run the following commands to unmask, enable, and start rsyslog.service:
          # systemctl unmask rsyslog.service
          # systemctl enable rsyslog.service
          # systemctl start rsyslog.service
        scored: true

      - id: 6.1.3.3
        description: "Ensure journald is configured to send logs to rsyslog (Automated)"
        audit: |
          if systemctl is-active --quiet systemd-journald.service && systemctl is-active --quiet rsyslog.service; then
            if systemd-analyze cat-config journald.conf | grep -i '^ForwardToSyslog=' | grep -q '^ForwardToSyslog=yes$'; then
              echo "journald_forwardtosyslog_ok"
            else
              echo "journald_forwardtosyslog_bad"
            fi
          else
            echo "journald_forwardtosyslog_bad"
          fi
        tests:
          test_items:
            - flag: "journald_forwardtosyslog_ok"
              set: true
        remediation: |
          Edit /etc/systemd/journald.conf or create a drop‑in file in /etc/systemd/journald.conf.d/ with:
          [Journal]
          ForwardToSyslog=yes
          Reload systemd-journald:
          # systemctl reload-or-restart systemd-journald.service
          Ensure rsyslog.service is enabled and running:
          # systemctl enable --now rsyslog.service
        scored: true

      - id: 6.1.3.4
        description: "Ensure rsyslog log file creation mode is configured (Automated)"
        audit: |
          files=$(find /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)
          found=false
          ok=true
          while read -r file; do
            while read -r line; do
              mode=$(echo "$line" | awk '{print $2}' | tr -d '#')
              if [[ $mode =~ ^0[0-7]{3}$ ]]; then
                found=true
                if [ "$mode" -gt 0640 ]; then
                  ok=false
                fi
              fi
            done < <(grep -E '^\s*\$FileCreateMode\b' "$file")
          done <<< "$files"
          if ! $found; then
            echo "rsyslog_filecreatemode_bad"
          elif $ok; then
            echo "rsyslog_filecreatemode_ok"
          else
            echo "rsyslog_filecreatemode_bad"
          fi
        tests:
          test_items:
            - flag: "rsyslog_filecreatemode_ok"
              set: true
        remediation: |
          Edit either /etc/rsyslog.conf or a dedicated .conf file in /etc/rsyslog.d/ and set
          $FileCreateMode to 0640 or more restrictive:
          $FileCreateMode 0640
          Example script to create a drop-in configuration file in the default include location:
          #!/usr/bin/env bash
          {
             [ ! -d "/etc/rsyslog.d/" ] && mkdir /etc/rsyslog.d/
             printf '%s\n' "" "\$FileCreateMode 0640" >> /etc/rsyslog.d/60-rsyslog.conf
          }
          Reload the service:
          # systemctl reload-or-restart rsyslog
        scored: true

      - id: 6.1.3.5
        description: "Ensure rsyslog logging is configured (Manual)"
        audit: |
          # Review /etc/rsyslog.conf and /etc/rsyslog.d/*.conf for appropriate logging rules.
          # Run the provided script to list log destinations and verify they match policy.
        type: "manual"
        remediation: |
          Edit the following lines in the configuration file(s) returned by the audit as appropriate for your environment.
          Note: The below configuration is shown for example purposes only. Due care should be given to how the organization wishes to store log data.
          *.emerg                                  :omusrmsg:*
          auth,authpriv.*                          /var/log/secure
          mail.*                                  -/var/log/mail
          mail.info                               -/var/log/mail.info
          mail.warning                            -/var/log/mail.warn
          mail.err                                 /var/log/mail.err
          cron.*                                   /var/log/cron
          *.=warning;*.=err                       -/var/log/warn
          *.crit                                   /var/log/warn
          *.*;mail.none;news.none                 -/var/log/messages
          local0,local1.*                         -/var/log/localmessages
          local2,local3.*                         -/var/log/localmessages
          local4,local5.*                         -/var/log/localmessages
          local6,local7.*                         -/var/log/localmessages
          Run the following command to reload the rsyslogd configuration:
          # systemctl reload-or-restart rsyslog
        scored: false

      - id: 6.1.3.6
        description: "Ensure rsyslog is configured to send logs to a remote log host (Manual)"
        audit: |
          #!/usr/bin/env bash
          {
             l_analyze_cmd="$(readlink -f /bin/systemd-analyze)"
             l_include='\$IncludeConfig'
             a_config_files=("rsyslog.conf")
             while IFS= read -r l_file; do
                l_conf_loc="$(awk '$1~/^\s*'"$l_include"'$/ {print $2}' "$(tr -d '# ' <<< "$l_file")" | tail -n 1)"
                [ -n "$l_conf_loc" ] && break
             done < <($l_analyze_cmd cat-config "${a_config_files[@]}" | tac | grep -Pio '^\h*#\h*\/[^#\n\r\h]+\.conf\b')
             if [ -d "$l_conf_loc" ]; then
                l_dir="$l_conf_loc" l_ext="*"
             elif  grep -Psq '\/\*\.([^#/\n\r]+)?\h*$' <<< "$l_conf_loc" || [ -f "$(readlink -f "$l_conf_loc")" ]; then
                l_dir="$(dirname "$l_conf_loc")" l_ext="$(basename "$l_conf_loc")"
             fi
             while read -r -d $'\0' l_file_name; do
                [ -f "$(readlink -f "$l_file_name")" ] && a_config_files+=("$(readlink -f "$l_file_name")")
             done < <(find -L "$l_dir" -type f -name "$l_ext" -print0 2>/dev/null)
             for l_logfile in "${a_config_files[@]}"; do
                grep -Hs -- "^*.*[^I][^I]*@" "$l_logfile"
             done
          }
        type: "manual"
        remediation: |
          Edit the rsyslog configuration and add the following line (where loghost.example.com is the name of your central log host). The target directive may either be a fully qualified domain name or an IP address.
          Example script to create a drop-in configuration file:
          #!/usr/bin/env bash
          {
             a_parameters=('*.* action(type="omfwd" target="loghost.example.com" port="514" protocol="tcp"'
                           '           action.resumeRetryCount="100"'
                           '           queue.type="LinkedList" queue.size="1000")')
             [ ! -d "/etc/rsyslog.d/" ] && mkdir /etc/rsyslog.d/
             printf '%s\n' "" "${a_parameters[@]}" >> /etc/rsyslog.d/60-rsyslog.conf
          }
          Run the following command to reload rsyslog.service:
          # systemctl reload-or-restart rsyslog.service
        scored: false

      - id: 6.1.3.7
        description: "Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
        audit: |
          if grep -Pi '^\s*module\(load="?imtcp"?\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf >/dev/null || \
             grep -Pi '^\s*input\(type="?imtcp"?\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf >/dev/null || \
             grep -Pi '^\s*\$ModLoad\s+imtcp' /etc/rsyslog.conf /etc/rsyslog.d/*.conf >/dev/null || \
             grep -Pi '^\s*\$InputTCPServerRun' /etc/rsyslog.conf /etc/rsyslog.d/*.conf >/dev/null; then
            echo "rsyslog_remote_input_bad"
          else
            echo "rsyslog_remote_input_ok"
          fi
        tests:
          test_items:
            - flag: "rsyslog_remote_input_ok"
              set: true
        remediation: |
          Edit the rsyslog configuration files (e.g., /etc/rsyslog.conf and any files in /etc/rsyslog.d/).
          Remove or comment out any lines that load the TCP input module, such as:
            module(load="imtcp")
            input(type="imtcp" port="514")
            $ModLoad imtcp
            $InputTCPServerRun
          After making changes, reload the rsyslog service:
            # systemctl reload-or-try-restart rsyslog.service
        scored: true

      - id: 6.1.3.8
        description: "Ensure logrotate is configured (Manual)"
        audit: |
          #!/usr/bin/env bash
          {
             l_analyze_cmd="$(readlink -f /bin/systemd-analyze)"
             l_config_file="/etc/logrotate.conf"
             l_include="$(awk '$1~/^\s*include$/{print$2}' "$l_config_file" 2>/dev/null)"
             [ -d "$l_include" ] && l_include="$l_include/*"
             $l_analyze_cmd cat-config "$l_config_file" $l_include
          }
        type: "manual"
        remediation: |
          Edit /etc/logrotate.conf, or the appropriate configuration file provided by the script in the Audit Procedure, as necessary to ensure logs are rotated according to site policy.
        scored: false

      - id: 6.1.4
        description: "Configure Logfiles"
        type: "skip"
        checks:

      - id: 6.1.4.1
        description: "Ensure access to all logfiles has been configured (Automated)"
        audit: |
          if find -L /var/log -type f \( -perm /0137 -o ! -user root -o ! -group root \) -print -quit | grep -q .; then
            echo "logfiles_perm_bad"
          else
            echo "logfiles_perm_ok"
          fi
        tests:
          test_items:
            - flag: "logfiles_perm_ok"
              set: true
        remediation: |
          # Set permissions to 0640 and ownership to root:root for all log files
          find /var/log -type f -exec chmod 0640 {} +
          find /var/log -type f -exec chown root:root {} +
        scored: true

  - id: 6.2
    description: "System Auditing"
    checks:
      - id: 6.2.1
        description: "Configure auditd Service"
        type: "skip"
        checks:

      - id: 6.2.1.1
        description: "Ensure auditd packages are installed (Automated)"
        audit: |
          if dpkg-query -s auditd &>/dev/null && dpkg-query -s audispd-plugins &>/dev/null; then
            echo "auditd_packages_ok"
          else
            echo "auditd_packages_bad"
          fi
        tests:
          test_items:
            - flag: "auditd_packages_ok"
              set: true
        remediation: |
          Run the following command to install the required packages:
          # apt install auditd audispd-plugins
        scored: true

      - id: 6.2.1.2
        description: "Ensure auditd service is enabled and active (Automated)"
        audit: |
          if systemctl is-enabled auditd | grep -q '^enabled' && systemctl is-active auditd | grep -q '^active'; then
            echo "auditd_service_ok"
          else
            echo "auditd_service_bad"
          fi
        tests:
          test_items:
            - flag: "auditd_service_ok"
              set: true
        remediation: |
          Run the following commands to unmask, enable and start auditd:
          # systemctl unmask auditd
          # systemctl enable auditd
          # systemctl start auditd
        scored: true

      - id: 6.2.1.3
        description: "Ensure auditing for processes that start prior to auditd is enabled (Automated)"
        audit: |
          if ! find /boot -type f -name 'grub.cfg' -exec grep -Ph -- '^\h*linux' {} + | grep -v 'audit=1' >/dev/null; then
            echo "grub_audit_enabled_ok"
          else
            echo "grub_audit_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "grub_audit_enabled_ok"
              set: true
        remediation: |
          Edit /etc/default/grub and add audit=1 to GRUB_CMDLINE_LINUX:
          Example:
          GRUB_CMDLINE_LINUX="audit=1"
          Update the grub2 configuration:
          # update-grub
        scored: true

      - id: 6.2.1.4
        description: "Ensure audit_backlog_limit is sufficient (Automated)"
        audit: |
          if ! find /boot -type f -name 'grub.cfg' -exec grep -Ph -- '^\h*linux' {} + | grep -Pv 'audit_backlog_limit=\d+\b'; then
            echo "audit_backlog_limit_ok"
          else
            echo "audit_backlog_limit_bad"
          fi
        tests:
          test_items:
            - flag: "audit_backlog_limit_ok"
              set: true
        remediation: |
          Edit /etc/default/grub and add audit_backlog_limit=N to GRUB_CMDLINE_LINUX.
          Example:
          GRUB_CMDLINE_LINUX="audit_backlog_limit=8192"
          Then update the grub configuration:
          # update-grub
        scored: true

      - id: 6.2.2
        description: "Configure Data Retention"
        type: "skip"
        checks:

      - id: 6.2.2.1
        description: "Ensure audit log storage size is configured (Automated)"
        audit: |
          if grep -Po '^\h*max_log_file\h*=\h*\d+\b' /etc/audit/auditd.conf >/dev/null; then
            echo "audit_log_size_ok"
          else
            echo "audit_log_size_bad"
          fi
        tests:
          test_items:
            - flag: "audit_log_size_ok"
              set: true
        remediation: |
          Edit /etc/audit/auditd.conf and set:
          max_log_file = <MB>
        scored: true

      - id: 6.2.2.2
        description: "Ensure audit logs are not automatically deleted (Automated)"
        audit: |
          if grep -qE '^max_log_file_action\s*=\s*keep_logs' /etc/audit/auditd.conf; then
            echo "audit_keep_logs_ok"
          else
            echo "audit_keep_logs_bad"
          fi
        tests:
          test_items:
            - flag: "audit_keep_logs_ok"
              set: true
        remediation: |
          Edit /etc/audit/auditd.conf and set:
          max_log_file_action = keep_logs
          Restart auditd to apply changes:
          # systemctl restart auditd.service
        scored: true

      - id: 6.2.2.3
        description: "Ensure system is disabled when audit logs are full (Automated)"
        audit: |
          if grep -qPi '^\h*disk_full_action\h*=\h*(halt|single)\b' /etc/audit/auditd.conf && \
             grep -qPi '^\h*disk_error_action\h*=\h*(syslog|single|halt)\b' /etc/audit/auditd.conf; then
            echo "audit_disk_action_ok"
          else
            echo "audit_disk_action_bad"
          fi
        tests:
          test_items:
            - flag: "audit_disk_action_ok"
              set: true
        remediation: |
          Edit /etc/audit/auditd.conf and set:
          disk_full_action = <halt|single>
          disk_error_action = <syslog|single|halt>
          Example:
          disk_full_action = halt
          disk_error_action = halt
        scored: true

      - id: 6.2.2.4
        description: "Ensure system warns when audit logs are low on space (Automated)"
        audit: |
          space_left=$(grep -P -- '^\h*space_left_action\h*=\h*(email|exec|single|halt)\b' /etc/audit/auditd.conf)
          admin_space_left=$(grep -P -- '^\h*admin_space_left_action\h*=\h*(single|halt)\b' /etc/audit/auditd.conf)
          if [ -n "$space_left" ] && [ -n "$admin_space_left" ]; then
            echo "audit_space_left_action_ok"
          else
            echo "audit_space_left_action_bad"
          fi
        tests:
          test_items:
            - flag: "audit_space_left_action_ok"
              set: true
        remediation: |
          Edit /etc/audit/auditd.conf and set:
          space_left_action = email
          admin_space_left_action = single
          # Ensure a Mail Transfer Agent (MTA) is installed and configured for email notifications
        scored: true

      - id: 6.2.3
        description: "Configure auditd Rules"
        type: "skip"
        checks:

      - id: 6.2.3.1
        description: "Ensure changes to system administration scope (sudoers) is collected (Automated)"
        audit: |
          if grep -qE '^-w /etc/sudoers -p wa -k scope$' /etc/audit/rules.d/*.rules && \
             grep -qE '^-w /etc/sudoers.d -p wa -k scope$' /etc/audit/rules.d/*.rules && \
             auditctl -l | grep -qE '^-w /etc/sudoers -p wa -k scope$' && \
             auditctl -l | grep -qE '^-w /etc/sudoers.d -p wa -k scope$'; then
            echo "scope_ok"
          else
            echo "scope_bad"
          fi
        tests:
          test_items:
            - flag: "scope_ok"
              set: true
        remediation: |
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor scope changes for system administrators. Example:
          # printf "\
          -w /etc/sudoers -p wa -k scope \n\
          -w /etc/sudoers.d -p wa -k scope \n\
          " >> /etc/audit/rules.d/50-scope.rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.2
        description: "Ensure actions as another user are always logged (Automated)"
        audit: |
          if grep -qE '^-a\s+always,exit\s+-F\s+arch=b64\s+-C\s+euid!=uid\s+-F\s+auid!=unset\s+-S\s+execve\s+-k\s+user_emulation' /etc/audit/rules.d/*.rules && \
             grep -qE '^-a\s+always,exit\s+-F\s+arch=b32\s+-C\s+euid!=uid\s+-F\s+auid!=unset\s+-S\s+execve\s+-k\s+user_emulation' /etc/audit/rules.d/*.rules && \
             auditctl -l | grep -qE '^-a\s+always,exit\s+-F\s+arch=b64\s+-S\s+execve\s+-C\s+uid!=euid\s+-F\s+auid!=-1\s+-F\s+key=user_emulation' && \
             auditctl -l | grep -qE '^-a\s+always,exit\s+-F\s+arch=b32\s+-S\s+execve\s+-C\s+uid!=euid\s+-F\s+auid!=-1\s+-F\s+key=user_emulation'; then
            echo "user_emulation_ok"
          else
            echo "user_emulation_bad"
          fi
        tests:
          test_items:
            - flag: "user_emulation_ok"
              set: true
        remediation: |
          Create audit rules
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor elevated privileges.
          Example:
          # printf "\
          -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation\n\
          -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation\n" >> /etc/audit/rules.d/50-user_emulation.rules
          Load audit rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required.
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.3
        description: "Ensure events that modify the sudo log file are collected (Automated)"
        audit: |
          SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,?.*//' -e 's/"//g' -e 's|/|\\/|g')
          if [ -z "$SUDO_LOG_FILE" ]; then
            echo "sudo_log_file_monitor_bad"
          else
            if auditctl -l | awk "/^ *-w/ && /${SUDO_LOG_FILE}/ && /-p *wa/ && (/key= *[!-~]* *$/||/ -k *[!-~]* *$/)"; then
              echo "sudo_log_file_monitor_ok"
            else
              echo "sudo_log_file_monitor_bad"
            fi
          fi
        tests:
          test_items:
            - flag: "sudo_log_file_monitor_ok"
              set: true
        remediation: |
          Edit or create a file in /etc/audit/rules.d/ ending in .rules, e.g. /etc/audit/rules.d/50-sudo.rules, and add:
          # SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,?.*//' -e 's/"//g')
          # [ -n "$SUDO_LOG_FILE" ] && printf "-w ${SUDO_LOG_FILE} -p wa -k sudo_log_file\n" >> /etc/audit/rules.d/50-sudo.rules
          Then load the rules:
          # augenrules --load
          If auditing is locked (-e 2), a reboot may be required to apply the rules.
        scored: true

      - id: 6.2.3.4
        description: "Ensure events that modify date and time information are collected (Automated)"
        audit: |
          if auditctl -l | grep -qE '^-a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change' &&
             auditctl -l | grep -qE '^-a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change' &&
             auditctl -l | grep -qE '^-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change' &&
             auditctl -l | grep -qE '^-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change' &&
             auditctl -l | grep -qE '^-w /etc/localtime -p wa -k time-change'; then
            echo "time_change_rules_ok"
          else
            echo "time_change_rules_bad"
          fi
        tests:
          test_items:
            - flag: "time_change_rules_ok"
              set: true
        remediation: |
          Create audit rules
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor events that modify date and time information. Example:
          # printf "\
          -a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change\n\
          -a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change\n\
          -a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change\n\
          -a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change\n\
          -w /etc/localtime -p wa -k time-change\n" >> /etc/audit/rules.d/50-time-change.rules
          Load audit rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required.
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.5
        description: "Ensure events that modify the system's network environment are collected (Automated)"
        audit: |
          flag="audit_network_env_ok"
          if ! auditctl -l | grep -q ' -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -w /etc/issue -p wa -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -w /etc/issue.net -p wa -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -w /etc/hosts -p wa -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -w /etc/networks -p wa -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -w /etc/network -p wa -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          if ! auditctl -l | grep -q ' -w /etc/netplan -p wa -k system-locale'; then
            flag="audit_network_env_bad"
          fi
          echo "$flag"
        tests:
          test_items:
            - flag: "audit_network_env_ok"
              set: true
        remediation: |
          Create audit rules
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor events that modify the system's network environment. Example:
          # printf "
          -a always,exit -F arch=b

      - id: 6.2.3.6
        description: "Ensure use of privileged commands are collected (Automated)"
        audit: |
          missing=0
          for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
            for PRIVILEGED in $(find "${PARTITION}" -xdev -perm /6000 -type f); do
              if ! auditctl -l | grep -q "${PRIVILEGED}"; then
                missing=1
              fi
            done
          done
          if [ "$missing" -eq 0 ]; then
            echo "privileged_commands_audited_ok"
          else
            echo "privileged_commands_audited_bad"
          fi
        tests:
          test_items:
            - flag: "privileged_commands_audited_ok"
              set: true
        remediation: |
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor the use of privileged commands.
          Example script:
          #!/usr/bin/env bash
          {
            UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
            AUDIT_RULE_FILE="/etc/audit/rules.d/50-privileged.rules"
            NEW_DATA=()
            for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
              readarray -t DATA < <(find "${PARTITION}" -xdev -perm /6000 -type f | awk -v UID_MIN=${UID_MIN} '{print "-a always,exit -F path=" $1 " -F perm=x -F auid>=" UID_MIN " -F auid!=unset -k privileged"}')
              for ENTRY in "${DATA[@]}"; do
                NEW_DATA+=("${ENTRY}")
              done
            done
            readarray &> /dev/null -t OLD_DATA < "${AUDIT_RULE_FILE}"
            COMBINED_DATA=( "${OLD_DATA[@]}" "${NEW_DATA[@]}" )
            printf '%s\n' "${COMBINED_DATA[@]}" | sort -u > "${AUDIT_RULE_FILE}"
          }
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.7
        description: "Ensure unsuccessful file access attempts are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "audit_file_access_bad"
            exit 0
          fi
          patterns=(
            "-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$UID_MIN -F auid!=unset -k access"
            "-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=$UID_MIN -F auid!=unset -k access"
            "-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=$UID_MIN -F auid!=unset -k access"
            "-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=$UID_MIN -F auid!=unset -k access"
          )
          for p in "${patterns[@]}"; do
            if ! grep -qF "$p" /etc/audit/rules.d/*.rules; then
              echo "audit_file_access_bad"
              exit 0
            fi
          done
          for p in "${patterns[@]}"; do
            if ! auditctl -l | grep -qF "$p"; then
              echo "audit_file_access_bad"
              exit 0
            fi
          done
          echo "audit_file_access_ok"
        tests:
          test_items:
            - flag: "audit_file_access_ok"
              set: true
        remediation: |
          Create audit rules:
            Edit or create a file in /etc/audit/rules.d/ ending with .rules, e.g., 50-access.rules, and add:
            -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
            -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
            -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
            -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access
          Load audit rules:
            augenrules --load
          Reboot if required:
            if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.8
        description: "Ensure events that modify user/group information are collected (Automated)"
        audit: |
          count=$(auditctl -l | grep -E '^ -w /etc/(group|passwd|gshadow|shadow|security/opasswd|nsswitch.conf|pam.conf|pam.d) -p wa -k identity$' | wc -l)
          if [ "$count" -eq 8 ]; then
            echo "identity_rules_ok"
          else
            echo "identity_rules_bad"
          fi
        tests:
          test_items:
            - flag: "identity_rules_ok"
              set: true
        remediation: |
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor events that modify user/group information. Example:
          # printf "\
          -w /etc/group -p wa -k identity\n\
          -w /etc/passwd -p wa -k identity\n\
          -w /etc/gshadow -p wa -k identity\n\
          -w /etc/shadow -p wa -k identity\n\
          -w /etc/security/opasswd -p wa -k identity\n\
          -w /etc/nsswitch.conf -p wa -k identity\n\
          -w /etc/pam.conf -p wa -k identity\n\
          -w /etc/pam.d -p wa -k identity\n\
          " >> /etc/audit/rules.d/50-identity.rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.9
        description: "Ensure discretionary access control permission modification events are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "perm_mod_bad"
            exit
          fi
          # Check running configuration
          if auditctl -l | grep -q "key=perm_mod" && auditctl -l | grep -q "arch=b64" && auditctl -l | grep -q "arch=b32" && auditctl -l | grep -q "auid>=$UID_MIN"; then
            # Check on-disk rules
            if grep -R "key=perm_mod" /etc/audit/rules.d/*.rules | grep -q "arch=b64" && grep -R "key=perm_mod" /etc/audit/rules.d/*.rules | grep -q "arch=b32" && grep -R "key=perm_mod" /etc/audit/rules.d/*.rules | grep -q "auid>=$UID_MIN"; then
              echo "perm_mod_ok"
              exit
            fi
          fi
          echo "perm_mod_bad"
        tests:
          test_items:
            - flag: "perm_mod_ok"
              set: true
        remediation: |
          Create or edit a file in /etc/audit/rules.d/ ending with .rules, e.g. 50-perm_mod.rules, containing:
          -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod
          -a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm

      - id: 6.2.3.10
        description: "Ensure successful file system mounts are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "mounts_rule_bad"
            exit 0
          fi
          if auditctl -l | grep -E "^\s*-a\s+always,exit\s+-F\s+arch=b64\s+-S\s+mount\s+-F\s+auid>=$UID_MIN\s+-F\s+auid!=unset\s+-k\s+mounts" >/dev/null && \
             auditctl -l | grep -E "^\s*-a\s+always,exit\s+-F\s+arch=b32\s+-S\s+mount\s+-F\s+auid>=$UID_MIN\s+-F\s+auid!=unset\s+-k\s+mounts" >/dev/null; then
            echo "mounts_rule_ok"
          else
            echo "mounts_rule_bad"
          fi
        tests:
          test_items:
            - flag: "mounts_rule_ok"
              set: true
        remediation: |
          Create audit rules
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor successful file system mounts.
          Example:
          # {
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          [ -n "${UID_MIN}" ] && printf "
          -a always,exit -F arch=b32 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts
          -a always,exit -F arch=b64 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts
          " >> /etc/audit/rules.d/50-mounts.rules || printf "ERROR: Variable 'UID_MIN' is unset.\n"
          }
          Load audit rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.11
        description: "Ensure session initiation information is collected (Automated)"
        audit: |
          if grep -qE '^\\-w /var/run/utmp -p wa -k session$' /etc/audit/rules.d/*.rules && \
             grep -qE '^\\-w /var/log/wtmp -p wa -k session$' /etc/audit/rules.d/*.rules && \
             grep -qE '^\\-w /var/log/btmp -p wa -k session$' /etc/audit/rules.d/*.rules && \
             auditctl -l | grep -qE '^\\-w /var/run/utmp -p wa -k session$' && \
             auditctl -l | grep -qE '^\\-w /var/log/wtmp -p wa -k session$' && \
             auditctl -l | grep -qE '^\\-w /var/log/btmp -p wa -k session$'; then
            echo "session_rules_ok"
          else
            echo "session_rules_bad"
          fi
        tests:
          test_items:
            - flag: "session_rules_ok"
              set: true
        remediation: |
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor session initiation information.
          Example:
          # printf "\
          -w /var/run/utmp -p wa -k session\n\
          -w /var/log/wtmp -p wa -k session\n\
          -w /var/log/btmp -p wa -k session\n" >> /etc/audit/rules.d/50-session.rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required.
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.12
        description: "Ensure login and logout events are collected (Automated)"
        audit: |
          disk_ok=0
          if grep -qE '^ *-w /var/log/lastlog -p wa -k logins$' /etc/audit/rules.d/*.rules; then
            disk_ok=$((disk_ok+1))
          fi
          if grep -qE '^ *-w /var/run/faillock -p wa -k logins$' /etc/audit/rules.d/*.rules; then
            disk_ok=$((disk_ok+1))
          fi
          run_ok=0
          if auditctl -l | grep -qE '^ *-w /var/log/lastlog -p wa -k logins$'; then
            run_ok=$((run_ok+1))
          fi
          if auditctl -l | grep -qE '^ *-w /var/run/faillock -p wa -k logins$'; then
            run_ok=$((run_ok+1))
          fi
          if [ "$disk_ok" -eq 2 ] && [ "$run_ok" -eq 2 ]; then
            echo "audit_login_logout_ok"
          else
            echo "audit_login_logout_bad"
          fi
        tests:
          test_items:
            - flag: "audit_login_logout_ok"
              set: true
        remediation: |
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor login and logout events. Example:
          # printf "\
          -w /var/log/lastlog -p wa -k logins\n\
          -w /var/run/faillock -p wa -k logins\n\
          " >> /etc/audit/rules.d/50-login.rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.13
        description: "Ensure file deletion events by users are collected (Automated)"
        audit: |
          # Get UID_MIN safely
          uid_min=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$uid_min" ]; then
            uid_min=1000   # fallback – almost every distro uses 1000 anyway
          fi
          # Required syscalls in the correct order (CIS accepts both orders)
          syscalls="unlink,unlinkat,rename,renameat|rename,unlink,unlinkat,renameat"
          # === 1. Check on-disk rules in /etc/audit/rules.d/ ===
          on_disk_ok=0
          if grep -E "^-a[[:space:]]+always,exit[[:space:]]+-F[[:space:]]+arch=b64[[:space:]]+-S[[:space:]]+($syscalls)[[:space:]]+-F[[:space:]]+auid>=$uid_min[[:space:]]+-F[[:space:]]+auid!=+(unset|-1|4294967295)[[:space:]]+-k[[:space:]]+.*delete" /etc/audit/rules.d/*.rules >/dev/null 2>&1 \
            && grep -E "^-a[[:space:]]+always,exit[[:space:]]+-F[[:space:]]+arch=b32[[:space:]]+-S[[:space:]]+($syscalls)[[:space:]]+-F[[:space:]]+auid>=$uid_min[[:space:]]+-F[[:space:]]+auid!=+(unset|-1|4294967295)[[:space:]]+-k[[:space:]]+.*delete" /etc/audit/rules.d/*.rules >/dev/null 2>&1; then
            on_disk_ok=1
          fi
          # === 2. Check currently loaded (running) rules ===
          running_ok=0
          if auditctl -l 2>/dev/null | grep -E "^-a[[:space:]]+always,exit[[:space:]]+-F[[:space:]]+arch=b64[[:space:]]+-S[[:space:]]+($syscalls)[[:space:]]+-F[[:space:]]+auid>=$uid_min" | grep -E -- "-F[[:space:]]+auid!=+(unset|-1|4294967295)" | grep -q -- "-k.*delete" \
            && auditctl -l 2>/dev/null | grep -E "^-a[[:space:]]+always,exit[[:space:]]+-F[[:space:]]+arch=b32[[:space:]]+-S[[:space:]]+($syscalls)[[:space:]]+-F[[:space:]]+auid>=$uid_min" | grep -E -- "-F[[:space:]]+auid!=+(unset|-1|4294967295)" | grep -q -- "-k.*delete"; then
            running_ok=1
          fi
          # === Final result ===
          if [ "$on_disk_ok" -eq 1 ] && [ "$running_ok" -eq 1 ]; then
            echo "audit_delete_events_ok"
          else
            echo "audit_delete_events_bad"
          fi
        tests:
          test_items:
            - flag: "audit_delete_events_ok"
              set: true
              compare:
                operator: equal
        remediation: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          [ -z "$UID_MIN" ] && UID_MIN=1000
          cat <<EOF | sudo tee /etc/audit/rules.d/50-delete.rules
          ## File deletion events by users (CIS 6.2.3.13)
          -a always,exit -F arch=b64   -S unlink,unlinkat,rename,renameat -F auid>=$UID_MIN -F auid!=unset -k delete
          -a always,exit -F arch=b32   -S unlink,unlinkat,rename,renameat -F auid>=$UID_MIN -F auid!=unset -k delete
          EOF
          sudo augenrules --load
          echo "Rules added and loaded. Reboot required only if auditctl reports 'enabled 2'."
        scored: true

      - id: 6.2.3.14
        description: "Ensure events that modify the system's Mandatory Access Controls are collected (Automated)"
        audit: |
          if grep -qE '^-w /etc/apparmor/ -p wa -k MAC-policy$' /etc/audit/rules.d/*.rules && \
             grep -qE '^-w /etc/apparmor.d/ -p wa -k MAC-policy$' /etc/audit/rules.d/*.rules && \
             auditctl -l | grep -qE '^-w /etc/apparmor/ -p wa -k MAC-policy$' && \
             auditctl -l | grep -qE '^-w /etc/apparmor.d/ -p wa -k MAC-policy$'; then
            echo "mac_policy_audit_ok"
          else
            echo "mac_policy_audit_bad"
          fi
        tests:
          test_items:
            - flag: "mac_policy_audit_ok"
              set: true
        remediation: |
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor events that modify the system's Mandatory Access Controls. Example:
          # printf "\
          -w /etc/apparmor/ -p wa -k MAC-policy\n\
          -w /etc/apparmor.d/ -p wa -k MAC-policy\n\
          " >> /etc/audit/rules.d/50-MAC-policy.rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.15
        description: "Ensure successful and unsuccessful attempts to use the chcon command are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "chcon_audit_bad"
            exit 0
          fi
          found=0
          if auditctl -l | awk "/^ *-a *always,exit/ && /-F *path=\/usr\/bin\/chcon/ && /-F *perm=x/ && /-F *auid>=$UID_MIN/ && /-F *auid!=unset/ && /-k *perm_chng/ {print}" | grep -q .; then
            found=1
          fi
          if [ $found -eq 0 ]; then
            for f in /etc/audit/rules.d/*.rules; do
              [ -f "$f" ] || continue
              if grep -qE "^-a\s+always,exit\s+-F\s+path=\/usr\/bin\/chcon\s+-F\s+perm=x\s+-F\s+auid>=$UID_MIN\s+-F\s+auid!=unset\s+-k\s+perm_chng" "$f"; then
                found=1
                break
              fi
            done
          fi
          if [ $found -eq 1 ]; then
            echo "chcon_audit_ok"
          else
            echo "chcon_audit_bad"
          fi
        tests:
          test_items:
            - flag: "chcon_audit_ok"
              set: true
        remediation: |
          Create or edit a file in /etc/audit/rules.d/ ending in .rules, e.g., 50-chcon.rules, with the following content:
          # UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          # [ -n "$UID_MIN" ] && printf "-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng\n" >> /etc/audit/rules.d/50-chcon.rules
          Load the audit rules:
          augenrules --load
          Check if a reboot is required to load the rules:
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.16
        description: "Ensure successful and unsuccessful attempts to use the setfacl command are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "setfacl_audit_rule_bad"
            exit 0
          fi
          if auditctl -l | grep -qE "\-a\s+always,exit\s+-F\s+path=\/usr\/bin\/setfacl\s+-F\s+perm=x\s+-F\s+auid>=$UID_MIN\s+-F\s+auid!=unset\s+-k\s+perm_chng"; then
            echo "setfacl_audit_rule_ok"
          else
            echo "setfacl_audit_rule_bad"
          fi
        tests:
          test_items:
            - flag: "setfacl_audit_rule_ok"
              set: true
        remediation: |
          Create or edit a file in /etc/audit/rules.d/ ending in .rules, e.g. 50-setfacl.rules, with:
          -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng
          Load audit rules:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.17
        description: "Ensure successful and unsuccessful attempts to use the chacl command are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "chacl_audit_bad"
            exit 0
          fi
          # Check running audit rules
          running=$(auditctl -l | awk "/^ *-a *always,exit/ && /-F *path=\/usr\/bin\/chacl/ && /-F *perm=x/ && /-F *auid>=$UID_MIN/ && /-F *auid!=unset/ {print}")
          # Check on‑disk audit rules
          disk=$(awk "/^ *-a *always,exit/ && /-F *path=\/usr\/bin\/chacl/ && /-F *perm=x/ && /-F *auid>=$UID_MIN/ && /-F *auid!=unset/ {print}" /etc/audit/rules.d/*.rules)
          if [ -n "$running" ] && [ -n "$disk" ]; then
            echo "chacl_audit_ok"
          else
            echo "chacl_audit_bad"
          fi
        tests:
          test_items:
            - flag: "chacl_audit_ok"
              set: true
        remediation: |
          Create audit rules:
          Edit or create a file in /etc/audit/rules.d/ ending in .rules, e.g. /etc/audit/rules.d/50-perm_chcl.rules, with the following content:
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          [ -n "$UID_MIN" ] && printf " -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=$UID_MIN -F auid!=unset -k perm_chng\n" >> /etc/audit/rules.d/50-perm_chcl.rules
          Load audit rules:
          augenrules --load
          Check if a reboot is required:
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.18
        description: "Ensure successful and unsuccessful attempts to use the usermod command are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -z "$UID_MIN" ]; then
            echo "usermod_audit_bad"
            exit 0
          fi
          rule_present=0
          if auditctl -l | grep -E "^-a\s+always,exit\s+-F\s+path=/usr/sbin/usermod\s+-F\s+perm=x\s+-F\s+auid>=$UID_MIN\s+-F\s+auid!=unset\s+-k\s+usermod" >/dev/null; then
            rule_present=1
          fi
          file_present=0
          if grep -E "^-a\s+always,exit\s+-F\s+path=/usr/sbin/usermod\s+-F\s+perm=x\s+-F\s+auid>=$UID_MIN\s+-F\s+auid!=unset\s+-k\s+usermod" /etc/audit/rules.d/*.rules >/dev/null; then
            file_present=1
          fi
          if [ $rule_present -eq 1 ] && [ $file_present -eq 1 ]; then
            echo "usermod_audit_ok"
          else
            echo "usermod_audit_bad"
          fi
        tests:
          test_items:
            - flag: "usermod_audit_ok"
              set: true
        remediation: |
          # Create audit rule file
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "$UID_MIN" ]; then
            printf "-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=$UID_MIN -F auid!=unset -k usermod\n" >> /etc/audit/rules.d/50-usermod.rules
          else
            echo "ERROR: Variable 'UID_MIN' is unset."
          fi
          # Load audit rules
          augenrules --load
          # Check if reboot is required
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
            echo "Reboot required to load rules"
          fi
        scored: true

      - id: 6.2.3.19
        description: "Ensure kernel module loading unloading and modification is collected (Automated)"
        audit: |
          #!/usr/bin/env bash
          ok=true
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          [ -z "$UID_MIN" ] && UID_MIN=1000
          # On-disk rules
          if ! grep -qE "^-a\\s+always,exit\\s+-F\\s+arch=b[64]\\s+-S\\s+(init_module|finit_module|delete_module|create_module|query_module)\\s+-F\\s+auid>=$UID_MIN\\s+-F\\s+auid!=unset\\s+-k\\s+kernel_modules" /etc/audit/rules.d/*.rules; then
            ok=false
          fi
          if ! grep -qE "^-a\\s+always,exit\\s+-F\\s+path=/usr/bin/kmod\\s+-F\\s+perm=x\\s+-F\\s+auid>=$UID_MIN\\s+-F\\s+auid!=unset\\s+-k\\s+kernel_modules" /etc/audit/rules.d/*.rules; then
            ok=false
          fi
          # Running rules
          if ! auditctl -l | grep -qE "^-a\\s+always,exit\\s+-F\\s+arch=b[64]\\s+-S\\s+(init_module|finit_module|delete_module|create_module|query_module)\\s+-F\\s+auid>=$UID_MIN\\s+-F\\s+auid!=unset\\s+-k\\s+kernel_modules"; then
            ok=false
          fi
          if ! auditctl -l | grep -qE "^-a\\s+always,exit\\s+-F\\s+path=/usr/bin/kmod\\s+-F\\s+perm=x\\s+-F\\s+auid>=$UID_MIN\\s+-F\\s+auid!=unset\\s+-k\\s+kernel_modules"; then
            ok=false
          fi
          # Symlink audit
          for l_file in /usr/sbin/lsmod /usr/sbin/rmmod /usr/sbin/insmod /usr/sbin/modinfo /usr/sbin/modprobe /usr/sbin/depmod; do
            if [ "$(readlink -f "$l_file")" != "$(readlink -f /bin/kmod)" ]; then
              ok=false
            fi
          done
          if $ok; then
            echo "kernel_module_audit_ok"
          else
            echo "kernel_module_audit_bad"
          fi
        tests:
          test_items:
            - flag: "kernel_module_audit_ok"
              set: true
        remediation: |
          Create audit rules
          Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with the relevant rules to monitor kernel module modification. Example:
          #!/usr/bin/env bash
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          [ -n "$UID_MIN" ] && printf "
          -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=$UID_MIN -F auid!=unset -k kernel_modules
          -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=$UID_MIN -F auid!=unset -k kernel_modules
          " >> /etc/audit/rules.d/50-kernel_modules.rules || printf "ERROR: Variable 'UID_MIN' is unset.\n"
          Load audit rules
          Merge and load the rules into active configuration:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.20
        description: "Ensure the audit configuration is immutable (Automated)"
        audit: |
          if grep -Ph -- '^\h*-e\h+2\b' /etc/audit/rules.d/*.rules | tail -1 | grep -q '^-\e 2$'; then
            echo "audit_immutable_ok"
          else
            echo "audit_immutable_bad"
          fi
        tests:
          test_items:
            - flag: "audit_immutable_ok"
              set: true
        remediation: |
          Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line:
          -e 2
          Example:
          # printf '\n%s' "-e 2" >> /etc/audit/rules.d/99-finalize.rules
          Load audit rules:
          # augenrules --load
          Check if reboot is required:
          # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true

      - id: 6.2.3.21
        description: "Ensure the running and on disk configuration is the same (Manual)"
        audit: |
          # Verify audit rule alignment
          augenrules --check
        type: "manual"
        remediation: |
          If the rules are not aligned across all three areas, run the following command to merge and load all rules:
          # augenrules --load
          Check if reboot is required:
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: false

      - id: 6.2.4
        description: "Configure auditd File Access"
        type: "skip"
        checks:

      - id: 6.2.4.1
        description: "Ensure audit log files mode is configured (Automated)"
        audit: |
          #!/bin/bash

          # Extract audit log directory
          log_file=$(awk -F= '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)
          log_dir=$(dirname "$log_file")

          # If directory doesn't exist → fail
          [ -d "$log_dir" ] || { echo "audit_log_mode_bad"; exit 1; }

          bad_found=0

          # Check each file individually
          for f in "$log_dir"/*; do
            [ -f "$f" ] || continue

            perm=$(stat -Lc '%a' "$f")

            # Must be ≤ 640 (CIS standard)
            if [ "$perm" -gt 640 ]; then
              bad_found=1
              break
            fi
          done

          if [ $bad_found -eq 0 ]; then
            echo "audit_log_mode_ok"
          else
            echo "audit_log_mode_bad"
          fi
        tests:
          test_items:
            - flag: "audit_log_mode_ok"
              set: true
        remediation: |
          # Fix audit log file permissions to 640
          log_dir=$(dirname $(awk -F= '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
          find "$log_dir" -type f -exec chmod 640 {} \;
        scored: true


      - id: 6.2.4.2
        description: "Ensure audit log files owner is configured (Automated)"
        audit: |
          #!/bin/bash

          # Read log_file path from auditd config
          log_file=$(awk -F= '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)
          log_dir=$(dirname "$log_file")

          # Directory must exist
          [ -d "$log_dir" ] || { echo "audit_log_files_owner_bad"; exit 1; }

          bad_owner=0

          # Check each file in the directory
          for f in "$log_dir"/*; do
            [ -f "$f" ] || continue

            owner=$(stat -Lc '%U' "$f")

            # Owner must be "root"
            if [ "$owner" != "root" ]; then
              bad_owner=1
              break
            fi
          done

          if [ "$bad_owner" -eq 0 ]; then
            echo "audit_log_files_owner_ok"
          else
            echo "audit_log_files_owner_bad"
          fi
        tests:
          test_items:
            - flag: "audit_log_files_owner_ok"
              set: true
        remediation: |
          # Fix audit log file owner to root
          log_file=$(awk -F= '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)
          log_dir=$(dirname "$log_file")
          find "$log_dir" -type f ! -user root -exec chown root {} \;
        scored: true


      - id: 6.2.4.3
        description: "Ensure audit log files group owner is configured (Automated)"
        audit: |
          log_group_ok=false
          if grep -Piws -- '^\h*log_group\h*=\h*\H+\b' /etc/audit/auditd.conf | grep -Pvi -- '(adm|root)'; then
            log_group_ok=true
          fi
          log_files_ok=false
          if [ -e /etc/audit/auditd.conf ]; then
            l_fpath="$(dirname "$(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)")"
            if find -L "$l_fpath" -not -path "$l_fpath"/lost+found -type f \( ! -group root -a ! -group adm \) -print | grep -q .; then
              log_files_ok=true
            fi
          fi
          if $log_group_ok && $log_files_ok; then
            echo "log_group_ok"
            echo "log_files_group_ok"
          else
            if ! $log_group_ok; then echo "log_group_bad"; fi
            if ! $log_files_ok; then echo "log_files_group_bad"; fi
          fi
        tests:
          test_items:
            - flag: "log_group_ok"
              set: true
            - flag: "log_files_group_ok"
              set: true
        remediation: |
          Run the following command to configure the audit log files to be group owned by adm:
          # find $(dirname $(awk -F"=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)) -type f \( ! -group adm -a ! -group root \) -exec chgrp adm {} +
          Run the following command to set the log_group parameter in the audit configuration file to log_group = adm:
          # sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?.*$/log_group = adm\1/' /etc/audit/auditd.conf
          Run the following command to restart the audit daemon to reload the configuration file:
          # systemctl restart auditd
        scored: true

      - id: 6.2.4.4
        description: "Ensure the audit log file directory mode is configured (Automated)"
        audit: |
          #!/bin/bash

          # Ensure auditd config exists
          [ -f /etc/audit/auditd.conf ] || { echo "audit_log_dir_mode_bad"; exit 1; }

          # Extract log_file and directory
          log_file=$(awk -F= '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)
          log_dir=$(dirname "$log_file")

          # Directory must exist
          [ -d "$log_dir" ] || { echo "audit_log_dir_mode_bad"; exit 1; }

          # Get permissions as octal
          perm=$(stat -Lc '%a' "$log_dir")

          # CIS requirement: directory must be 0750 or more restrictive
          # i.e., perm ≤ 750
          if [ "$perm" -le 750 ]; then
            echo "audit_log_dir_mode_ok"
          else
            echo "audit_log_dir_mode_bad"
          fi
        tests:
          test_items:
            - flag: "audit_log_dir_mode_ok"
              set: true
        remediation: |
          # Set directory permissions to 0750 (or stricter)
          log_file=$(awk -F= '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs)
          log_dir=$(dirname "$log_file")
          chmod 0750 "$log_dir"
        scored: true


      - id: 6.2.4.5
        description: "Ensure audit configuration files mode is configured (Automated)"
        audit: |
          if find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -printf '%p %m\n' | \
             awk '{if ($2 > 0640) print $1}' | grep -q .; then
            echo "audit_config_mode_bad"
          else
            echo "audit_config_mode_ok"
          fi
        tests:
          test_items:
            - flag: "audit_config_mode_ok"
              set: true
        remediation: |
          Run the following command to remove more permissive mode than 0640 from the audit configuration files:
          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec chmod u-x,g-wx,o-rwx {} +
        scored: true

      - id: 6.2.4.6
        description: "Ensure audit configuration files owner is configured (Automated)"
        audit: |
          if ! find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -print -quit; then
            echo "audit_config_owner_ok"
          else
            echo "audit_config_owner_bad"
          fi
        tests:
          test_items:
            - flag: "audit_config_owner_ok"
              set: true
        remediation: |
          Run the following command to change ownership to root user:
          # find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -exec chown root {} +
        scored: true

      - id: 6.2.4.7
        description: "Ensure audit configuration files group owner is configured (Automated)"
        audit: |
          if find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root | grep -q .; then
            echo "audit_config_group_bad"
          else
            echo "audit_config_group_ok"
          fi
        tests:
          test_items:
            - flag: "audit_config_group_ok"
              set: true
        remediation: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root -exec chgrp root {} +
        scored: true

      - id: 6.2.4.8
        description: "Ensure audit tools mode is configured (Automated)"
        audit: |
          mode1=$(stat -Lc '%#a' /sbin/auditctl)
          mode2=$(stat -Lc '%#a' /sbin/aureport)
          mode3=$(stat -Lc '%#a' /sbin/ausearch)
          mode4=$(stat -Lc '%#a' /sbin/autrace)
          mode5=$(stat -Lc '%#a' /sbin/auditd)
          mode6=$(stat -Lc '%#a' /sbin/augenrules)
          if [ "$mode1" -le 0755 ] && [ "$mode2" -le 0755 ] && [ "$mode3" -le 0755 ] && [ "$mode4" -le 0755 ] && [ "$mode5" -le 0755 ] && [ "$mode6" -le 0755 ]; then
            echo "audit_tools_mode_ok"
          else
            echo "audit_tools_mode_bad"
          fi
        tests:
          test_items:
            - flag: "audit_tools_mode_ok"
              set: true
        remediation: |
          chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
        scored: true

      - id: 6.2.4.9
        description: "Ensure audit tools owner is configured (Automated)"
        audit: |
          bad=0
          # List of all audit tools to check
          tools="/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules"
          # Loop through each tool silently
          for tool in $tools; do
            # Skip if file doesn't exist (that's fine per CIS)
            [ ! -f "$tool" ] && continue
            # Get owner (works on GNU and BSD stat)
            owner=$(stat -c %U "$tool" 2>/dev/null || stat -f %Su "$tool" 2>/dev/null)
            # If owner is NOT root → flag as bad
            if [ "$owner" != "root" ] && [ "$owner" != "0" ]; then
              bad=1
              break
            fi
          done
          # Output result
          if [ "$bad" -eq 0 ]; then
            echo "audit_tools_owner_ok"
          else
            echo "audit_tools_owner_bad"
          fi
        tests:
          test_items:
            - flag: "audit_tools_owner_ok"
              set: true
        remediation: |
          Run this to fix ownership (only if tools exist):
            sudo chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
          # If auditd is not installed yet:
          sudo apt update && sudo apt install auditd -y   # Ubuntu/Debian
          # OR
          sudo yum install audit -y                       # RHEL/CentOS/Alma
        scored: true

      - id: 6.2.4.10
        description: "Ensure audit tools group owner is configured (Automated)"
        audit: |
          if ! stat -Lc "%n %G" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | awk '$2 != "root" {print}' | grep -q .; then
            echo "audit_tools_group_ok"
          else
            echo "audit_tools_group_bad"
          fi
        tests:
          test_items:
            - flag: "audit_tools_group_ok"
              set: true
        remediation: |
          Run the following command to change group ownership to the group root:
          # chgrp root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
        scored: true

  - id: 6.3
    description: "Configure Integrity Checking"
    checks:
      - id: 6.3.1
        description: "Ensure AIDE is installed (Automated)"
        audit: |
          if dpkg-query -s aide &>/dev/null && dpkg-query -s aide-common &>/dev/null; then
            echo "aide_installed_ok"
          else
            echo "aide_installed_bad"
          fi
        tests:
          test_items:
            - flag: "aide_installed_ok"
              set: true
        remediation: |
          Install AIDE using the appropriate package manager or manual installation:
          # apt install aide aide-common
          Configure AIDE as appropriate for your environment. Consult the AIDE documentation for options.
          Run the following commands to initialize AIDE:
          # aideinit
          # mv /var/lib/aide/aide.db.new /var/lib/aide/aide.db
        scored: true

      - id: 6.3.2
        description: "Ensure filesystem integrity is regularly checked (Automated)"
        audit: |
          timer_status=$(systemctl list-unit-files | awk '$1~/^dailyaidecheck\.timer$/ {print $2}')
          service_status=$(systemctl list-unit-files | awk '$1~/^dailyaidecheck\.service$/ {print $2}')
          timer_active=$(systemctl is-active dailyaidecheck.timer)
          if [ "$timer_status" = "enabled" ] && \
             { [ "$service_status" = "static" ] || [ "$service_status" = "enabled" ]; } && \
             [ "$timer_active" = "active" ]; then
            echo "dailyaidecheck_ok"
          else
            echo "dailyaidecheck_bad"
          fi
        tests:
          test_items:
            - flag: "dailyaidecheck_ok"
              set: true
        remediation: |
          Run the following command to unmask dailyaidecheck.timer and dailyaidecheck.service:
          # systemctl unmask dailyaidecheck.timer dailyaidecheck.service
          Run the following command to enable and start dailyaidecheck.timer:
          # systemctl --now enable dailyaidecheck.timer
        scored: true

      - id: 6.3.3
        description: "Ensure cryptographic mechanisms are used to protect the integrity of audit tools (Automated)"
        audit: |
          aide_cmd="$(whereis aide | awk '{print $2}')"
          if [ -z "$aide_cmd" ] || ! command -v "$aide_cmd" &>/dev/null; then
            echo "aide_audit_tools_bad"
            exit
          fi
          tool_dir="$(readlink -f /sbin)"
          items="p i n u g s b acl xattrs sha512"
          audit_files="auditctl auditd ausearch aureport autrace augenrules"
          conf_files=$(find -L /etc -type f -name 'aide.conf')
          fail=0
          for file in $audit_files; do
            if [ -f "$tool_dir/$file" ]; then
              out=$("$aide_cmd" --config "$conf_files" -p f:"$tool_dir/$file")
              for opt in $items; do
                if ! grep -qP "(\h+|\+)${opt}(\h+|\+)" <<< "$out"; then
                  fail=1
                  break
                fi
              done
            else
              fail=1
            fi
            [ $fail -eq 1 ] && break
          done
          if [ $fail -eq 0 ]; then
            echo "aide_audit_tools_ok"
          else
            echo "aide_audit_tools_bad"
          fi
        tests:
          test_items:
            - flag: "aide_audit_tools_ok"
              set: true
        remediation: |
          Run the following command to determine the absolute path to the non-symlinked version of the audit tools:
          # readlink -f /sbin
          The output will be either /usr/sbin or /sbin. Ensure the correct path is used.
          Edit /etc/aide/aide.conf and add or update the following selection lines, replacing <PATH> with the correct path returned above:
          # Audit Tools
          <PATH>/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512
          <PATH>/auditd p+i+n+u+g+s+b+acl+xattrs+sha512
          <PATH>/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512
          <PATH>/aureport p+i+n+u+g+s+b+acl+xattrs+sha512
          <PATH>/autrace p+i+n+u+g+s+b+acl+xattrs+sha512
          <PATH>/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512
          If /etc/aide/aide.conf includes a @@x_include statement, ensure that the included directory and any executable config files are owned by the current user or root and are not group- or world-writable.
        scored: true

  - id: 7
    description: "System Maintenance"
    checks:
  - id: 7.1
    description: "System File Permissions"
    checks:
      - id: 7.1.1
        description: "Ensure permissions on /etc/passwd are configured (Automated)"
        audit: |
          mode=$(stat -Lc %a /etc/passwd)
          uid=$(stat -Lc %u /etc/passwd)
          gid=$(stat -Lc %g /etc/passwd)
          if [ "$mode" -le 644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "passwd_perm_ok"
          else
            echo "passwd_perm_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perm_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/passwd:
          # chmod u-x,go-wx /etc/passwd
          # chown root:root /etc/passwd
        scored: true

      - id: 7.1.2
        description: "Ensure permissions on /etc/passwd- are configured (Automated)"
        audit: |
          perm=$(stat -Lc '%a' /etc/passwd-)
          uid=$(stat -Lc '%u' /etc/passwd-)
          gid=$(stat -Lc '%g' /etc/passwd-)
          if [ "$perm" -le 0644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "passwd_backup_perm_ok"
          else
            echo "passwd_backup_perm_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_backup_perm_ok"
              set: true
        remediation: |
          chmod u-x,go-wx /etc/passwd-
          chown root:root /etc/passwd-
        scored: true

      - id: 7.1.3
        description: "Ensure permissions on /etc/group are configured (Automated)"
        audit: |
          perm=$(stat -Lc '%a' /etc/group)
          uid=$(stat -Lc '%u' /etc/group)
          gid=$(stat -Lc '%g' /etc/group)
          if [ "$perm" -le 0644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "group_perm_ok"
          else
            echo "group_perm_bad"
          fi
          mode=$(stat -Lc '%a' /etc/group)

        tests:
          test_items:
            - flag: "group_perm_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group:
          # chmod u-x,go-wx /etc/group
          # chown root:root /etc/group
        scored: true

      - id: 7.1.4
        description: "Ensure permissions on /etc/group- are configured (Automated)"
        audit: |
          #!/bin/bash

          perm=$(stat -Lc '%a' /etc/group- 2>/dev/null)
          uid=$(stat -Lc '%u' /etc/group- 2>/dev/null)
          gid=$(stat -Lc '%g' /etc/group- 2>/dev/null)

          # 420 decimal = 0644 permissions (CIS requirement)
          if [ "$perm" -le 644 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "group_perm_ok"
          else
            echo "group_perm_bad"
          fi
        tests:
          test_items:
            - flag: "group_perm_ok"
              set: true
        remediation: |
          # Fix ownership
          chown root:root /etc/group-
          # Fix permissions
          chmod 644 /etc/group-
        scored: true


      - id: 7.1.5
        description: "Ensure permissions on /etc/shadow are configured (Automated)"
        audit: |
          mode=$(stat -Lc '%a' /etc/shadow)
          uid=$(stat -Lc '%u' /etc/shadow)
          gid_name=$(stat -Lc '%G' /etc/shadow)
          if [ "$mode" -le 640 ] && [ "$uid" -eq 0 ] && { [ "$gid_name" = "root" ] || [ "$gid_name" = "shadow" ]; }; then
            echo "shadow_perm_ok"
          else
            echo "shadow_perm_bad"
          fi
        tests:
          test_items:
            - flag: "shadow_perm_ok"
              set: true
        remediation: |
          Run one of the following commands to set ownership of /etc/shadow to root and group to either root or shadow:
          # chown root:shadow /etc/shadow
          # OR
          # chown root:root /etc/shadow
          Run the following command to remove excess permissions from /etc/shadow:
          # chmod u-x,g-wx,o-rwx /etc/shadow
        scored: true


      - id: 7.1.6
        description: "Ensure permissions on /etc/shadow- are configured (Automated)"
        audit: |
          #!/bin/bash

          # Get stat values safely without awk regex errors
          mode=$(stat -Lc '%a' /etc/shadow- 2>/dev/null)
          uid=$(stat -Lc '%u' /etc/shadow- 2>/dev/null)
          gid=$(stat -Lc '%g' /etc/shadow- 2>/dev/null)
          gid_name=$(stat -Lc '%G' /etc/shadow- 2>/dev/null)

          # Check permissions
          if [ "$mode" -le 640 ] && [ "$uid" -eq 0 ] && { [ "$gid" -eq 0 ] || [ "$gid_name" = "shadow" ]; }; then
            echo "shadow_perm_ok"
          else
            echo "shadow_perm_bad"
          fi
        tests:
          test_items:
            - flag: "shadow_perm_ok"
              set: true
        remediation: |
          # Set correct ownership (either root:shadow or root:root)
          chown root:shadow /etc/shadow- 2>/dev/null || chown root:root /etc/shadow-

          # Fix permissions
          chmod 640 /etc/shadow-
        scored: true

      - id: 7.1.7
        description: "Ensure permissions on /etc/gshadow are configured (Automated)"
        audit: |
          perm=$(stat -Lc '%a' /etc/gshadow)
          uid=$(stat -Lc '%u' /etc/gshadow)
          gid=$(stat -Lc '%g' /etc/gshadow)
          shadow_gid=$(getent group shadow | cut -d: -f3)
          if [ "$perm" -le 640 ] && [ "$uid" -eq 0 ] && { [ "$gid" -eq 0 ] || [ "$gid" -eq "$shadow_gid" ]; }; then
            echo "gshadow_perm_ok"
          else
            echo "gshadow_perm_bad"
          fi
        tests:
          test_items:
            - flag: "gshadow_perm_ok"
              set: true
        remediation: |
          Run one of the following commands to set ownership of /etc/gshadow to root and group to either root or shadow:
          # chown root:shadow /etc/gshadow
          # OR
          # chown root:root /etc/gshadow
          Run the following command to remove excess permissions from /etc/gshadow:
          # chmod u-x,g-wx,o-rwx /etc/gshadow
        scored: true

      - id: 7.1.8
        description: "Ensure permissions on /etc/gshadow- are configured (Automated)"
        audit: |
          mode=$(stat -c "%a" /etc/gshadow-)
          uid=$(stat -c "%u" /etc/gshadow-)
          gid=$(stat -c "%g" /etc/gshadow-)
          group=$(stat -c "%G" /etc/gshadow-)
          if [ "$mode" -le 640 ] && [ "$uid" -eq 0 ] && { [ "$gid" -eq 0 ] || [ "$group" = "shadow" ]; }; then
            echo "gshadow_perm_ok"
          else
            echo "gshadow_perm_bad"
          fi
        tests:
          test_items:
            - flag: "gshadow_perm_ok"
              set: true
        remediation: |
          Run one of the following commands to set ownership of /etc/gshadow- to root and group to either root or shadow:
          # chown root:shadow /etc/gshadow-
          # OR
          # chown root:root /etc/gshadow-
          Run the following command to remove excess permissions from /etc/gshadow-:
          # chmod u-x,g-wx,o-rwx /etc/gshadow-
        scored: true

      - id: 7.1.9
        description: "Ensure permissions on /etc/shells are configured (Automated)"
        audit: |
          mode=$(stat -L -c '%a' /etc/shells)
          uid=$(stat -L -c '%u' /etc/shells)
          gid=$(stat -L -c '%g' /etc/shells)
          dec_mode=$(printf "%d" "0$mode")
          if [ "$dec_mode" -le 420 ] && [ "$uid" -eq 0 ] && [ "$gid" -eq 0 ]; then
            echo "shells_perm_ok"
          else
            echo "shells_perm_bad"
          fi
        tests:
          test_items:
            - flag: "shells_perm_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/shells:
          # chmod u-x,go-wx /etc/shells
          # chown root:root /etc/shells
        scored: true

      - id: 7.1.10
        description: "Ensure permissions on /etc/security/opasswd are configured (Automated)"
        audit: |
          bad=0
          for f in /etc/security/opasswd /etc/security/opasswd.old; do
            if [ -e "$f" ]; then
              perm=$(stat -Lc '%a' "$f")
              uid=$(stat -Lc '%u' "$f")
              gid=$(stat -Lc '%g' "$f")
              if [ "$perm" -gt 600 ] || [ "$uid" -ne 0 ] || [ "$gid" -ne 0 ]; then
                bad=1
                break
              fi
            fi
          done
          if [ "$bad" -eq 0 ]; then
            echo "opasswd_perm_ok"
          else
            echo "opasswd_perm_bad"
          fi
        tests:
          test_items:
            - flag: "opasswd_perm_ok"
              set: true
        remediation: |
          # Remove excess permissions, set owner, and set group on /etc/security/opasswd and /etc/security/opasswd.old if they exist
          [ -e "/etc/security/opasswd" ] && chmod u-x,go-rwx /etc/security/opasswd
          [ -e "/etc/security/opasswd" ] && chown root:root /etc/security/opasswd
          [ -e "/etc/security/opasswd.old" ] && chmod u-x,go-rwx /etc/security/opasswd.old
          [ -e "/etc/security/opasswd.old" ] && chown root:root /etc/security/opasswd.old
        scored: true

      - id: 7.1.11
        description: "Ensure world writable files and directories are secured (Automated)"
        audit: |
          #!/bin/bash
          ww_files=$(find / -xdev -type f -perm -0002 -print -quit 2>/dev/null)
          ww_dirs=$(find / -xdev -type d -perm -0002 ! -perm -1000 -print -quit 2>/dev/null)

          if [ -n "$ww_files" ] || [ -n "$ww_dirs" ]; then
            echo "world_writable_bad"
          else
            echo "world_writable_ok"
          fi
        tests:
          test_items:
            - flag: "world_writable_ok"
              set: true
        remediation: |
          find / -xdev -type f -perm -0002 -exec chmod o-w {} \;
          find / -xdev -type d -perm -0002 ! -perm -1000 -exec chmod a+t {} \;
        scored: true


      - id: 7.1.12
        description: "Ensure no files or directories without an owner and a group exist (Automated)"
        audit: |
          #!/bin/bash
          found=0
          # Get list of real mountpoints (excluding pseudo and container paths)
          findmnt -D -o TARGET -n 2>/dev/null | \
          grep -vE '^/run/user/|^/proc/|^/sys/fs/cgroup/memory/|^/var/.*/private/|^/var/lib/containerd|^/var/lib/kubelet/pods|^/var/lib/kubelet/plugins' | \
          while IFS= read -r mount; do
            if find "$mount" -xdev \( -nouser -o -nogroup \) -print -quit >/dev/null 2>&1; then
              found=1
              break
            fi
          done
          [ "$found" -eq 0 ] && echo "unowned_or_ungrouped_ok" || echo "unowned_or_ungrouped_bad"
        tests:
          test_items:
            - flag: "unowned_or_ungrouped_ok"
              set: true
        remediation: |
          Locate files without owner/group:
            find / -xdev \( -nouser -o -nogroup \) 2>/dev/null

          Then assign proper ownership:
            chown user:group /path/to/file-or-dir
        scored: true

      - id: 7.1.13
        description: "Ensure SUID and SGID files are reviewed (Manual)"
        audit: |
          # List SUID files
          find / -xdev -type f -perm -4000 -print
          # List SGID files
          find / -xdev -type f -perm -2000 -print
        type: "manual"
        remediation: |
          Ensure that no rogue SUID or SGID programs have been introduced into the system.
          Review the files returned by the audit and confirm the integrity of these binaries.
          If any unauthorized or modified binaries are found, remove or replace them with the correct package-provided versions.
        scored: false

  - id: 7.2
    description: "Local User and Group Settings"
    checks:
      - id: 7.2.1
        description: "Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
        audit: |
          output=$(awk -F: '($2 != "x") {print $1}' /etc/passwd)

          if [ -z "$output" ]; then
            echo "passwd_shadow_ok"
          else
            echo "passwd_shadow_bad"
          fi

        tests:
          test_items:
            - flag: "passwd_shadow_ok"
              set: true
        remediation: |
          Run the following command to set accounts to use shadowed passwords and migrate passwords in /etc/passwd to /etc/shadow:
          # pwconv
          Investigate any accounts that appear in the audit output to determine if they are in use and whether they need to be forced off.
        scored: true

      - id: 7.2.2
        description: "Ensure /etc/shadow password fields are not empty (Automated)"
        audit: |
          if awk -F: '($2 == "") { exit 1 }' /etc/shadow; then
            echo "shadow_empty_ok"
          else
            echo "shadow_empty_bad"
          fi
        tests:
          test_items:
            - flag: "shadow_empty_ok"
              set: true
        remediation: |
          If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:
          # passwd -l <username>
          Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off.
        scored: true

      - id: 7.2.3
        description: "Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
        audit: |
          #!/bin/bash
          passwd_gids=$(awk -F: '{print $4}' /etc/passwd | sort -u)
          group_gids=$(awk -F: '{print $3}' /etc/group | sort -u)

          missing=$(comm -23 <(echo "$passwd_gids") <(echo "$group_gids") 2>/dev/null)

          if [ -z "$missing" ]; then
            echo "passwd_gid_in_group_ok"
          else
            echo "passwd_gid_in_group_bad"
          fi

        tests:
          test_items:
            - flag: "passwd_gid_in_group_ok"
              set: true

        remediation: |
          Analyze the output of the Audit step above and perform the appropriate action to correct any discrepancies found.

        scored: true

      - id: 7.2.4
        description: "Ensure shadow group is empty (Automated)"
        audit: |
          if ! awk -F: '($1=="shadow") {print $NF}' /etc/group | grep -q .; then
            if ! awk -F: -v gid="$(getent group shadow | awk -F: '{print $3}')" '$4==gid {print $1}' /etc/passwd | grep -q .; then
              echo "shadow_group_empty_ok"
            else
              echo "shadow_group_empty_bad"
            fi
          else
            echo "shadow_group_empty_bad"
          fi
        tests:
          test_items:
            - flag: "shadow_group_empty_ok"
              set: true
        remediation: |
          Run the following command to remove all users from the shadow group:
          # sed -ri 's/(^shadow:[^:]*:[^:]*:)([^:]+$)/\1/' /etc/group
          Change the primary group of any users with shadow as their primary group:
          # usermod -g <primary group> <user>
        scored: true

      - id: 7.2.5
        description: "Ensure no duplicate UIDs exist (Automated)"
        audit: |
          if grep -qE '^[[:space:]]*[2-9][0-9]*' <(cut -f3 -d":" /etc/passwd | sort -n | uniq -c); then
            echo "duplicate_uid_bad"
          else
            echo "duplicate_uid_ok"
          fi
        tests:
          test_items:
            - flag: "duplicate_uid_ok"
              set: true
        remediation: |
          Based on the results of the audit script, establish unique UIDs and review all files owned
          by the shared UIDs to determine which UID they are supposed to belong to.
        scored: true

      - id: 7.2.6
        description: "Ensure no duplicate GIDs exist (Automated)"
        audit: |
          #!/bin/bash
          if cut -d: -f3 /etc/group | sort -n | uniq -c | awk '$1 > 1 {print $2 " (count: "$1")"}' | grep -q .; then
            echo "duplicate_gids_bad"
          else
            echo "duplicate_gids_ok"
          fi
        tests:
          test_items:
            - flag: "duplicate_gids_ok"
              set: true
        remediation: |
          # Find duplicate GIDs
          echo "Duplicate GIDs found:"
          cut -d: -f3 /etc/group | sort -n | uniq -c | awk '$1 > 1 {print "GID " $2 " appears " $1 " times"}'

          echo -e "\nFix example:"
          echo "   groupmod -g NEW_GID duplicate_group_name"
          echo "   find / -gid OLD_GID -exec chgrp NEW_GID {} +   # update file ownership"

        scored: true
      - id: 7.2.7
        description: "Ensure no duplicate user names exist (Automated)"
        audit: |
          #!/bin/bash
          if cut -d: -f1 /etc/passwd | sort | uniq -d | grep -q .; then
            echo "duplicate_user_bad"
          else
            echo "duplicate_user_ok"
          fi

        tests:
          test_items:
            - flag: "duplicate_user_ok"
              set: true

        remediation: |
          echo "Duplicate usernames found:"
          cut -d: -f1 /etc/passwd | sort | uniq -d

          echo -e "\nFix with:"
          echo "   usermod -l newusername old-duplicate-name"

        scored: true

      - id: 7.2.8
        description: "Ensure no duplicate group names exist (Automated)"
        audit: |
          if [ -n "$(cut -f1 -d':' /etc/group | sort | uniq -d)" ]; then
            echo "group_duplicates_bad"
          else
            echo "group_duplicates_ok"
          fi
        tests:
          test_items:
            - flag: "group_duplicates_ok"
              set: true
        remediation: |
          Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.
        scored: true

      - id: 7.2.9
        description: "Ensure local interactive user home directories are configured (Automated)"
        audit: |
          #!/bin/bash
          ok=true

          # Safe way — no here-string, works with /bin/sh too
          awk -F: '$NF !~ /nologin|false|sync|shutdown|halt/ {print $1 " " $6}' /etc/passwd | \
          while read -r user home; do
            [ -d "$home" ] || ok=false
            [ "$(stat -c %U "$home" 2>/dev/null)" = "$user" ] || ok=false
            mode=$(stat -c %a "$home" 2>/dev/null || echo 755)
            if [ $(( 0${mode} & 027 )) -ne 0 ]; then
              ok=false
            fi
            $ok || break
          done

          $ok && echo "home_dirs_ok" || echo "home_dirs_bad"

        tests:
          test_items:
            - flag: "home_dirs_ok"
              set: true

        remediation: |
          #!/bin/bash
          awk -F: '$NF !~ /nologin|false|sync|shutdown|halt/ {print $1 " " $6}' /etc/passwd | \
          while read -r user home; do
            [ ! -d "$home" ] && mkdir -p "$home"
            chown "$user:$user" "$home"
            chmod 750 "$home"
            echo "Fixed: $home → $user:$user 750"
          done
          echo "All home directories now CIS 7.2.9 compliant"

        scored: true
      - id: 7.2.10
        description: "Ensure local interactive user dot files access is configured (Automated)"
        audit: |
          #!/bin/bash
          ok=true
          users=$(awk -F: '($NF ~ /^\/bin\/bash|\/bin\/sh|\/usr\/bin\/zsh|\/bin\/ksh|\/usr\/bin\/dash/ && $7 !~ /nologin/){print $1}' /etc/passwd)
          for u in $users; do
            home=$(eval echo ~$u)
            [ -d "$home" ] || continue
            for f in .forward .rhost; do
              [ -e "$home/$f" ] && ok=false && break 2
            done
            [ -e "$home/.netrc" ] && [ "$(stat -c %a "$home/.netrc")" -gt 600 ] && ok=false && break
            [ -e "$home/.bash_history" ] && [ "$(stat -c %a "$home/.bash_history")" -gt 600 ] && ok=false && break

            while IFS= read -r -d '' file; do
              base=$(basename "$file")
              case "$base" in .forward|.rhost|.netrc|.bash_history) continue ;; esac
              mode=$(stat -c %a "$file")
              [ "$mode" -gt 644 ] && ok=false && break 2
              [ "$(stat -c %U "$file")" != "$u" ] && ok=false && break 2
              [ "$(stat -c %G "$file")" != "$(id -gn "$u")" ] && ok=false && break 2
            done < <(find "$home" -maxdepth 1 -type f -name '.*' -print0 2>/dev/null)
          done
          $ok && echo "user_dot_files_ok" || echo "user_dot_files_bad"
        tests:
          test_items:
            - flag: "user_dot_files_ok"
              set: true
        remediation: |
          find /home -maxdepth 2 -type f \( -name .forward -o -name .rhost \) -exec rm -f {} +
          find /home -maxdepth 2 -type f \( -name .netrc -o -name .bash_history \) -exec chmod 600 {} +
          find /home -maxdepth 2 -type f -name '.*' ! -name .forward ! -name .rhost ! -name .netrc ! -name .bash_history | while read -r file; do
            user=$(stat -c %U "$file")
            group=$(stat -c %G "$file")
            primary=$(id -gn "$user")
            chmod 644 "$file"
            chown "$user" "$file"
            chgrp "$primary" "$file"
          done
        scored: true
