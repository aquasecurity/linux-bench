---
controls:
version: "Amazon Linux 2"
id: 1
description: "Initial Setup"
type: "master"
groups:
  - id: 1.1
    description: "Filesystem"
    checks:
      - id: 1.1.1
        description: "Configure Filesystem Kernel Modules"
        type: "skip"
        checks:
      - id: 1.1.1.1
        description: "Ensure cramfs kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v cramfs | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null
          | grep -Pq '^\s*blacklist\s+cramfs\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^cramfs"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/cramfs.conf`
          and add the following lines:
          install cramfs /bin/false
          blacklist cramfs
          Run the following command to unload the `cramfs` module:
          # modprobe -r cramfs
        scored: true
      - id: 1.1.1.2
        description: "Ensure freevxfs kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v freevxfs | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+freevxfs\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^freevxfs"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/freevxfs.conf` and add the following lines:
          install freevxfs /bin/false
          blacklist freevxfs
          Run the following command to unload the `freevxfs` module:
          # modprobe -r freevxfs
        scored: true

      - id: 1.1.1.3
        description: "Ensure hfs kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v hfs | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+hfs\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^hfs"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/hfs.conf` and add the following lines:
          install hfs /bin/false
          blacklist hfs
          Run the following command to unload the `hfs` module:
          # modprobe -r hfs
        scored: true

      - id: 1.1.1.4
        description: "Ensure hfsplus kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v hfsplus | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+hfsplus\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^hfsplus"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/hfsplus.conf` and add the following lines:
          install hfsplus /bin/false
          blacklist hfsplus
          Run the following command to unload the `hfsplus` module:
          # modprobe -r hfsplus
        scored: true

      - id: 1.1.1.5
        description: "Ensure jffs2 kernel module is not available (Automated)"
        audit: |
          out="$(modprobe -n -v jffs2 2>/dev/null)";
          deny="$(modprobe --showconfig 2>/dev/null | grep -P '^\s*blacklist\s+jffs2\b')";
          loaded="$(lsmod | grep -w jffs2 || true)";

          [[ "$out" =~ "install /bin/false" || "$out" =~ "install /bin/true" ]] &&
          [[ -n "$deny" ]] &&
          [[ -z "$loaded" ]] && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/jffs2.conf` and add the following lines:
          install jffs2 /bin/false
          blacklist jffs2
          Run the following command to unload the `jffs2` module:
          # modprobe -r jffs2
        scored: true

      - id: 1.1.1.6
        description: "Ensure squashfs kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v squashfs | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+squashfs\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^squashfs"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/squashfs.conf` and add the following lines:
          install squashfs /bin/false
          blacklist squashfs
          Run the following command to unload the `squashfs` module:
          # modprobe -r squashfs
        scored: true


      - id: 1.1.1.7
        description: "Ensure udf kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v udf | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+udf\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^udf"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          # Note: Do not disable on systems that require UDF (e.g., Microsoft Azure).
          Edit or create the file `/etc/modprobe.d/udf.conf` and add the following lines:
          install udf /bin/false
          blacklist udf
          Run the following command to unload the `udf` module:
          # modprobe -r udf
        scored: true

      - id: 1.1.1.8
        description: "Ensure usb-storage kernel module is not available (Automated)"
        audit: |
          if modprobe -n -v usb-storage | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+usb-storage\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^usb_storage"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          # Note: Disabling this will block all USB storage devices. If device use is required,
          # consider a policy-based tool such as USBGuard instead of disabling the module.
          Edit or create the file `/etc/modprobe.d/usb-storage.conf` and add the following lines:
          install usb-storage /bin/false
          blacklist usb-storage
          Run the following command to unload the `usb-storage` module:
          # modprobe -r usb-storage
        scored: true


      - id: 1.1.2
        description: "Configure Filesystem Partitions"
        type: "skip"
        checks:
      - id: 1.1.2.1
        description: "Configure /tmp"
        type: "skip"
        checks:
      - id: 1.1.2.1.1
        description: "Ensure /tmp is a separate partition (Automated)"
        audit: |
          if findmnt -nk /tmp > /dev/null; then
            echo "tmp_mounted"
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "tmp_mounted"
              set: true
        remediation: |
          Ensure that /tmp is mounted at boot time by doing the following:

          1. Unmask the tmp.mount unit (if applicable):
             # systemctl unmask tmp.mount

          2. Edit `/etc/fstab` to include one of the following entries:

             Option A: Using tmpfs (RAM-based):
             tmpfs	/tmp	tmpfs	defaults,rw,nosuid,nodev,noexec,relatime,size=2G	0 0

             Option B: Using a dedicated disk or volume:
             <device> /tmp <fstype> defaults,nodev,nosuid,noexec 0 0

          3. Then enable and start the mount unit if needed:
             # systemctl enable tmp.mount
             # systemctl start tmp.mount
        scored: true
      - id: 1.1.2.1.2
        description: "Ensure nodev option set on /tmp partition (Automated)"
        audit: |
          if findmnt -nk /tmp > /dev/null; then
            echo "tmp_mounted"
            if findmnt -kn /tmp | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          - IF - a separate partition exists for /tmp.
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/tmp` partition.
          Example entry in `/etc/fstab`:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/tmp` partition with the configured options:
          # mount -o remount /tmp

        scored: true

      - id: 1.1.2.1.3
        description: "Ensure nosuid option set on /tmp partition (Automated)"
        audit: |
          if findmnt -nk /tmp > /dev/null; then
            echo "tmp_mounted"
            if findmnt -kn /tmp | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          - IF - a separate partition exists for /tmp.
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/tmp` partition with the configured options:
          # mount -o remount /tmp
        scored: true


      - id: 1.1.2.1.4
        description: "Ensure noexec option set on /tmp partition (Automated)"
        audit: |
          if findmnt -nk /tmp > /dev/null; then
            echo "tmp_mounted"
            if findmnt -kn /tmp | grep -v noexec; then
              echo "noexec_missing"
            else
              echo "noexec_ok"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          - IF - a separate partition exists for /tmp.
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/tmp` partition with the configured options:
          # mount -o remount /tmp

        scored: true

      - id: 1.1.2.2
        description: "Configure /dev/shm"
        type: "skip"
        checks:
      - id: 1.1.2.2.1
        description: "Ensure /dev/shm is a separate partition (Automated)"
        audit: "findmnt -kn /dev/shm"
        tests:
          test_items:
            - flag: "/dev/shm"
              set: true
        remediation: |
          Modify `/etc/fstab` to mount `/dev/shm` as a separate `tmpfs` filesystem with appropriate options.

          Example entry in `/etc/fstab`:
          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0

          Then mount or remount the `/dev/shm` partition:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.2
        description: "Ensure nodev option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm > /dev/null; then
            echo "/dev/shm_mounted"
            if findmnt -kn /dev/shm | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "/dev/shm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include the `nodev` option for `/dev/shm`. Example entry:

          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0

          Then remount the filesystem with the updated options:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.3
        description: "Ensure nosuid option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm > /dev/null; then
            echo "/dev/shm_mounted"
            if findmnt -kn /dev/shm | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "/dev/shm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include the `nosuid` option for `/dev/shm`. Example entry:
          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime  0 0
          Then remount the filesystem with:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.4
        description: "Ensure noexec option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm > /dev/null; then
            echo "/dev/shm_mounted"
            if findmnt -kn /dev/shm | grep -v noexec; then
              echo "noexec_missing"
            else
              echo "noexec_ok"
            fi
          else
            echo "/dev/shm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include the `noexec` option for `/dev/shm`. Example entry:

          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime  0 0

          Then remount the filesystem with:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.3
        description: "Configure /home"
        type: "skip"
        checks:
      - id: 1.1.2.3.1
        description: "Ensure separate partition exists for /home (Automated)"
        audit: "findmnt -nk /home"
        tests:
          test_items:
            - flag: "/home"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/home`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/home` content to a temporary location.
          3. Mount the new partition at `/home`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.2.3.2
        description: "Ensure nodev option set on /home partition (Automated)"
        audit: |
          if findmnt -nk /home > /dev/null; then
            echo "home_mounted"
            if findmnt -nk /home | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/home` partition.

          Example entry in `/etc/fstab`:
          <device> /home <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/home` partition with the configured options:
          # mount -o remount /home
        scored: true

      - id: 1.1.2.3.3
        description: "Ensure nosuid option set on /home partition (Automated)"
        audit: |
          if findmnt -nk /home > /dev/null; then
            echo "home_mounted"
            if findmnt -nk /home | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "home_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/home` partition.

          Example entry in `/etc/fstab`:
          <device> /home <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/home` partition with the configured options:
          # mount -o remount /home
        scored: true

      - id: 1.1.2.4
        description: "Configure /var"
        type: "skip"
        checks:
      - id: 1.1.2.4.1
        description: "Ensure separate partition exists for /var (Automated)"
        audit: "findmnt -nk /var"
        tests:
          test_items:
            - flag: "/var"
              set: true
        remediation: |
          For new installations, create a custom partition layout during setup and assign a separate partition for /var.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Copy existing data from /var to the new partition.
          3. Update `/etc/fstab` to mount the new partition at /var.
          4. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.2.4.2
        description: "Ensure nodev option set on /var partition (Automated)"
        audit: |
          if findmnt -nk /var > /dev/null; then
            echo "var_mounted"
            if findmnt -nk /var | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "var_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var` partition.

          Example entry in `/etc/fstab`:
          <device> /var <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var` partition with the configured options:
          # mount -o remount /var
        scored: true

      - id: 1.1.2.4.3
        description: "Ensure nosuid option set on /var partition (Automated)"
        audit: |
          if findmnt -nk /var > /dev/null; then
            echo "var_mounted"
            if findmnt -nk /var | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "var_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var` partition.

          Example entry in `/etc/fstab`:
          <device> /var <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var` partition with the configured options:
          # mount -o remount /var
        scored: true


      - id: 1.1.2.5
        description: "Configure /var/tmp"
        type: "skip"
        checks:
      - id: 1.1.2.5.1
        description: "Ensure separate partition exists for /var/tmp (Automated)"
        audit: "findmnt -nk /var/tmp"
        tests:
          test_items:
            - flag: "/var/tmp"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/var/tmp`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/var/tmp` content to a temporary location.
          3. Mount the new partition at `/var/tmp`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.2.5.2
        description: "Ensure nodev option set on /var/tmp partition (Automated)"
        audit: |
          if findmnt -nk /var/tmp > /dev/null; then
            echo "var/tmp_mounted"
            if findmnt -nk /var/tmp | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "var/tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/tmp` partition with the configured options:
          # mount -o remount /var/tmp
        scored: true

      - id: 1.1.2.5.3
        description: "Ensure nosuid option set on /var/tmp partition (Automated)"
        audit: |
          if findmnt -nk /var/tmp > /dev/null; then
            echo "var/tmp_mounted"
            if findmnt -nk /var/tmp | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "var/tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/tmp` partition with the configured options:
          # mount -o remount /var/tmp
        scored: true
      - id: 1.1.2.5.4
        description: "Ensure noexec option set on /var/tmp partition (Automated)"
        audit: |
          if findmnt -nk /var/tmp > /dev/null; then
            echo "var/tmp_mounted"
            if findmnt -nk /var/tmp | grep -v noexec; then
              echo "noexec_missing"
            else
              echo "noexec_ok"
            fi
          else
            echo "var/tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/var/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/tmp` partition with the configured options:
          # mount -o remount /var/tmp
        scored: true


      - id: 1.1.2.6
        description: "Configure /var/log"
        type: "skip"
        checks:
      - id: 1.1.2.6.1
        description: "Ensure separate partition exists for /var/log (Automated)"
        audit: "findmnt -nk /var/log"
        tests:
          test_items:
            - flag: "/var/log"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/var/log`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/var/log` content to a temporary location.
          3. Mount the new partition at `/var/log`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true
      - id: 1.1.2.6.2
        description: "Ensure nodev option set on /var/log partition (Automated)"
        audit: |
          if findmnt -nk /var/log > /dev/null; then
            echo "/var/log_mounted"
            if findmnt -nk /var/log | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "/var/log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var/log` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log` partition with the configured options:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.2.6.3
        description: "Ensure nosuid option set on /var/log partition (Automated)"
        audit: |
          if findmnt -nk /var/log > /dev/null; then
            echo "/var/log_mounted"
            if findmnt -nk /var/log | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "/var/log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var/log` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log` partition with the configured options:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.2.6.4
        description: "Ensure noexec option set on /var/log partition (Automated)"
        audit: |
          if findmnt -nk /var/log > /dev/null; then
            echo "/var/log_mounted"
            if findmnt -nk /var/log | grep -v noexec; then
              echo "noexec_missing"
            else
              echo "noexec_ok"
            fi
          else
            echo "/var/log_not_mounted"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/var/log` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log` partition with the configured options:
          # mount -o remount /var/log
        scored: true


      - id: 1.1.2.7
        description: "Configure /var/log/audit"
        type: "skip"
        checks:
      - id: 1.1.2.7.1
        description: "Ensure separate partition exists for /var/log/audit (Automated)"
        audit: "findmnt -nk /var/log/audit"
        tests:
          test_items:
            - flag: "/var/log/audit"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/var/log/audit`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/var/log/audit` content to a temporary location.
          3. Mount the new partition at `/var/log/audit`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.2.7.2
        description: "Ensure nodev option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -nk /var/log/audit > /dev/null; then
            echo "/var/log/audit_mounted"
            if findmnt -nk /var/log/audit | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "/var/log/audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var/log/audit` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log/audit` partition with the configured options:
          # mount -o remount /var/log/audit
        scored: true

      - id: 1.1.2.7.3
        description: "Ensure nosuid option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -nk /var/log/audit > /dev/null; then
            echo "/var/log/audit_mounted"
            if findmnt -nk /var/log/audit | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "/var/log/audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var/log/audit` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log/audit` partition with the configured options:
          # mount -o remount /var/log/audit
        scored: true

      - id: 1.1.2.7.4
        description: "Ensure noexec option set on /var/log/audit partition (Automated)"
        audit: |
          if findmnt -nk /var/log/audit > /dev/null; then
            echo "/var/log/audit_mounted"
            if findmnt -nk /var/log/audit | grep -v noexec; then
              echo "noexec_missing"
            else
              echo "noexec_ok"
            fi
          else
            echo "/var/log/audit_not_mounted"
          fi
        tests:
          test_items:
            - flag: "noexec_ok"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/var/log/audit` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log/audit` partition with the configured options:
          # mount -o remount /var/log/audit
        scored: true

  - id: 1.2
    description: "Configure Software and Patch Management"
    checks:
      - id: 1.2.1
        description: "Ensure GPG keys are configured (Manual)"
        type: manual
        remediation: |
          Update your package manager GPG keys in accordance with site policy.
        scored: false

      - id: 1.2.2
        description: "Ensure gpgcheck is globally activated (Automated)"
        audit: |
          # Check global configuration in /etc/yum.conf
          if grep -P '^\s*gpgcheck\s*=\s*1\b' /etc/yum.conf >/dev/null; then
            echo "global_gpgcheck_ok"
          else
            echo "global_gpgcheck_bad"
          fi

          # Check repository-specific configurations in /etc/yum.repos.d/
          if ! grep -Prs '^\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|[a-zA-Z_]+)\b' /etc/yum.repos.d/ >/dev/null; then
            echo "repo_gpgcheck_ok"
          else
            echo "repo_gpgcheck_bad"
          fi
        tests:
          test_items:
            - flag: "global_gpgcheck_ok"
              set: true
            - flag: "repo_gpgcheck_ok"
              set: true
        remediation: |
          # Set gpgcheck=1 in /etc/yum.conf
          sed -i 's/^\s*gpgcheck\s*=.*/gpgcheck=1/' /etc/yum.conf

          # Set gpgcheck=1 in all .repo files under /etc/yum.repos.d/
          find /etc/yum.repos.d/ -name "*.repo" -exec sed -ri 's/^\s*gpgcheck\s*=.*/gpgcheck=1/' {} \;
        scored: true

      - id: 1.2.3
        description: "Ensure repo_gpgcheck is globally activated (Manual)"
        audit: |
          # Check global configuration in /etc/yum.conf
          if grep -P '^\s*repo_gpgcheck\s*=\s*1\b' /etc/yum.conf >/dev/null; then
            echo "global_repo_gpgcheck_ok"
          else
            echo "global_repo_gpgcheck_bad"
          fi

          # Check per-repository configurations excluding known unsupported repos (e.g., fedoraproject.org)
          REPO_URL="fedoraproject.org"
          failing_repos=0
          for repo in $(grep -l "repo_gpgcheck=0" /etc/yum.repos.d/* 2>/dev/null); do
            if ! grep "${REPO_URL}" "${repo}" &>/dev/null; then
              echo "repo_repo_gpgcheck_bad: ${repo}"
              failing_repos=1
            fi
          done
          if [ $failing_repos -eq 0 ]; then
            echo "repo_repo_gpgcheck_ok"
          fi
        tests:
          test_items:
            - flag: "global_repo_gpgcheck_ok"
              set: true
            - flag: "repo_repo_gpgcheck_ok"
              set: true
        remediation: |
          # Global configuration
          Edit `/etc/yum.conf` and ensure the following is set under the [main] section:
          repo_gpgcheck=1

          # Per-repository configuration
          Verify the repository supports `repo_gpgcheck`. For supported repositories, edit the `.repo` files under `/etc/yum.repos.d/` and set:
          repo_gpgcheck=1
        scored: true

      - id: 1.2.4
        description: "Ensure repo_gpgcheck is globally activated (Manual)"
        type: manual
        remediation: |
          Edit /etc/dnf/dnf.conf and set repo_gpgcheck=1 in the [main] section.
          Example:
          [main]
            # repo_gpgcheck=1
            Per repository configuration
            First check that the particular repository support GPG checking on the repodata.
            Edit any failing files in /etc/yum.repos.d/* and set all instances starting with repo_gpgcheck to 1.
        scored: false

      - id: 1.2.5
        description: "Ensure updates, patches, and additional security software are installed (Manual)"
        audit: |
          # Check if there are available updates
          if yum check-update >/dev/null 2>&1; then
            if [ $? -eq 100 ]; then
              echo "updates_available"
            else
              echo "no_updates"
            fi
          else
            echo "yum_check_failed"
          fi

          # Check if a system reboot is required
          if needs-restarting -r >/dev/null 2>&1; then
            echo "no_reboot_required"
          else
            echo "reboot_required"
          fi
        tests:
          test_items:
            - flag: "no_updates"
              set: true
            - flag: "no_reboot_required"
              set: true
        remediation: |
          # Update all packages on the system according to site policy:
          yum update -y

          # After updating, verify if a reboot is required:
          needs-restarting -r

          # If required, schedule or perform a reboot to complete the update process.
        scored: true


  - id: 1.3
    description: "Configure Secure Boot Settings"
    checks:
      - id: 1.3.1
        description: "Ensure authentication required for single user mode (Automated)"
        audit: |
          # Check rescue.service configuration
          if grep -Pq 'ExecStart=-/bin/sh\s+-c\s+"/sbin/sulogin;\s+/usr/bin/systemctl\s+--fail\s+--no-block\s+default"' /usr/lib/systemd/system/rescue.service; then
            echo "rescue_service_ok"
          else
            echo "rescue_service_bad"
          fi

          # Check emergency.service configuration
          if grep -Pq 'ExecStart=-/bin/sh\s+-c\s+"/sbin/sulogin;\s+/usr/bin/systemctl\s+--fail\s+--no-block\s+default"' /usr/lib/systemd/system/emergency.service; then
            echo "emergency_service_ok"
          else
            echo "emergency_service_bad"
          fi
        tests:
          test_items:
            - flag: "rescue_service_ok"
              set: true
            - flag: "emergency_service_ok"
              set: true
        remediation: |
          # Edit /usr/lib/systemd/system/rescue.service and /usr/lib/systemd/system/emergency.service
          # Ensure ExecStart is set to:
          ExecStart=-/bin/sh -c "/sbin/sulogin; /usr/bin/systemctl --fail --no-block default"

          # After modification, reload the systemd daemon to apply changes:
          systemctl daemon-reexec
        scored: true


  - id: 1.4
    description: "Configure Additional Process Hardening"
    checks:
      - id: 1.4.1
        description: "Ensure address space layout randomization (ASLR) is enabled (Automated)"
        audit: |
          # Check running configuration
          if [ "$(sysctl -n kernel.randomize_va_space 2>/dev/null)" -eq 2 ]; then
            echo "runtime_aslr_ok"
          else
            echo "runtime_aslr_bad"
          fi

          # Check persistent configuration in /etc/sysctl.conf and /etc/sysctl.d/*.conf
          if grep -Pqs '^\s*kernel\.randomize_va_space\s*=\s*2\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
            echo "persistent_aslr_ok"
          else
            echo "persistent_aslr_bad"
          fi
        tests:
          test_items:
            - flag: "runtime_aslr_ok"
              set: true
            - flag: "persistent_aslr_ok"
              set: true
        remediation: |
          # Set ASLR in persistent configuration
          printf '%s\n' "kernel.randomize_va_space = 2" >> /etc/sysctl.d/60-kernel_sysctl.conf

          # Apply setting to running configuration
          sysctl -w kernel.randomize_va_space=2
        scored: true

      - id: 1.4.2
        description: "Ensure ptrace_scope is restricted (Automated)"
        audit: |
          # Check running configuration
          if [ "$(sysctl -n kernel.yama.ptrace_scope 2>/dev/null)" -eq 1 ]; then
            echo "runtime_ptrace_ok"
          else
            echo "runtime_ptrace_bad"
          fi

          # Check persistent configuration in /etc/sysctl.conf and /etc/sysctl.d/*.conf
          if grep -Pqs '^\s*kernel\.yama\.ptrace_scope\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
            echo "persistent_ptrace_ok"
          else
            echo "persistent_ptrace_bad"
          fi
        tests:
          test_items:
            - flag: "runtime_ptrace_ok"
              set: true
            - flag: "persistent_ptrace_ok"
              set: true
        remediation: |
          # Set ptrace_scope in persistent configuration
          printf '%s\n' "kernel.yama.ptrace_scope = 1" >> /etc/sysctl.d/60-kernel_sysctl.conf

          # Apply setting to running configuration
          sysctl -w kernel.yama.ptrace_scope=1
        scored: true

      - id: 1.4.3
        description: "Ensure core dump backtraces are disabled (Automated)"
        audit: |
          if grep -Piq '^\s*ProcessSizeMax\s*=\s*0\b' /etc/systemd/coredump.conf; then
            echo "core_dump_disabled"
          else
            echo "core_dump_enabled"
          fi
        tests:
          test_items:
            - flag: "core_dump_disabled"
              set: true
        remediation: |
          # Create or edit /etc/systemd/coredump.conf and set:
          ProcessSizeMax=0

          # Example:
          echo "ProcessSizeMax=0" >> /etc/systemd/coredump.conf

          # Reload systemd configuration to apply changes:
          systemctl daemon-reexec
        scored: true

      - id: 1.4.4
        description: "Ensure core dump storage are disabled (Automated)"
        audit: |
          grep -Pi -- '^\h*Storage\b' /etc/systemd/coredump.conf
        tests:
          test_items:
            - flag: "Storage=none"
              set: true
        remediation: |
          Create or edit the file /etc/systemd/coredump.conf and edit or add the following line:
            Storage=none
        scored: true


  - id: 1.5
    description: "Mandatory Access Control"
    checks:
      - id: 1.5.1
        description: "Configure SELinux"
        type: "skip"
        checks:
      - id: 1.5.1.1
        description: "Ensure SELinux is installed (Automated)"
        audit: 'rpm -q libselinux'
        tests:
          test_items:
            - flag: "package libselinux is not installed"
              set: false
        remediation: |
          Install SELinux using the appropriate package manager or manual installation:
          # dnf install libselinux
          # apt-get install libselinux1
          # zypper install libselinux1
        scored: true

      - id: 1.5.1.2
        description: "Ensure SELinux is not disabled in bootloader configuration (Automated)"
        audit: |
          # Check that boot entries do NOT set selinux=0 or enforcing=0
          if grubby --info=ALL 2>/dev/null | grep -Po '(selinux|enforcing)=0\b' >/dev/null; then
            echo "boot_args_bad"
          else
            echo "boot_args_ok"
          fi

          # Check that /etc/default/grub does NOT set selinux=0 or enforcing=0
          if grep -Psi '^\s*GRUB_CMDLINE_LINUX(_DEFAULT)?="([^#\n\r]+\s+)?(selinux|enforcing)=[^1\n\r]\d*\b' /etc/default/grub >/dev/null; then
            echo "default_grub_bad"
          else
            echo "default_grub_ok"
          fi
        tests:
          test_items:
            - flag: "boot_args_ok"
              set: true
            - flag: "default_grub_ok"
              set: true
        remediation: |
          # Remove disabling arguments from all boot entries
          grubby --update-kernel ALL --remove-args "selinux=0 enforcing=0"

          # Clean /etc/default/grub of disabling arguments
          sed -ri 's/\s*(selinux|enforcing)=0\s*//g' /etc/default/grub

          # Rebuild grub configuration (BIOS)
          if [ -d /boot/grub2 ]; then
            grub2-mkconfig -o /boot/grub2/grub.cfg
          fi

          # Rebuild grub configuration (UEFI)
          if [ -d /boot/efi/EFI ]; then
            grub2-mkconfig -o /boot/efi/EFI/$(ls /boot/efi/EFI | head -n1)/grub.cfg
          fi
        scored: true

      - id: 1.5.1.3
        description: "Ensure SELinux policy is configured (Automated)"
        audit: |
          # Check SELINUXTYPE setting in configuration file
          if grep -Pq '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config; then
            echo "selinux_config_ok"
          else
            echo "selinux_config_bad"
          fi

          # Check loaded SELinux policy
          if sestatus 2>/dev/null | grep -Pq 'Loaded policy name:\s+(targeted|mls)\b'; then
            echo "selinux_loaded_policy_ok"
          else
            echo "selinux_loaded_policy_bad"
          fi
        tests:
          test_items:
            - flag: "selinux_config_ok"
              set: true
            - flag: "selinux_loaded_policy_ok"
              set: true
        remediation: |
          # Edit /etc/selinux/config to ensure SELINUXTYPE is set to targeted or mls
          sed -ri 's/^\s*SELINUXTYPE=.*/SELINUXTYPE=targeted/' /etc/selinux/config

          # To apply the change, reboot or reload SELinux policy
          # Example to reload without reboot:
          setenforce 1
        scored: true

      - id: 1.5.1.4
        description: "Ensure the SELinux mode is not disabled (Automated)"
        audit: |
          runtime_mode=$(getenforce)
          if [ "$runtime_mode" = "Enforcing" ] || [ "$runtime_mode" = "Permissive" ]; then
            echo "runtime_ok"
          else
            echo "runtime_fail"
          fi

          grep -Ei '^\s*SELINUX=(enforcing|permissive)' /etc/selinux/config || echo "persistent_missing"
        tests:
          bin_op: and
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "persistent_missing"
              set: false
        remediation: |
          Run one of the following commands to set SELinux's running mode:
          To set SELinux mode to Enforcing:
          # setenforce 1
          -OR-
          To set SELinux mode to Permissive:
          # setenforce 0
          Edit the /etc/selinux/config file to set the SELINUX parameter:
          For Enforcing mode:
          SELINUX=enforcing
          -OR-
          For Permissive mode:
          SELINUX=permissive
        scored: true


      - id: 1.5.1.5
        description: "Ensure the SELinux mode is enforcing (Automated)"
        audit: |
          runtime_mode=$(getenforce)
          if [ "$runtime_mode" = "Enforcing" ]; then
            echo "runtime_ok"
          else
            echo "runtime_fail"
          fi

          grep -i '^SELINUX=enforcing' /etc/selinux/config || echo "persistent_missing"
        tests:
          bin_op: and
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "SELINUX=enforcing"
              set: true
        remediation: |
          Set SELinux to enforcing in the config file
          # sed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config
          Set SELinux to enforcing mode immediately
          # setenforce 1
        scored: true

      - id: 1.5.1.6
        description: "Ensure no unconfined services exist (Automated)"
        audit: |
          ps -eZ | grep unconfined_service_t
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Investigate any unconfined processes found during the audit action. They may need to have an existing security context assigned to them or a policy built for them.
        scored: false

      - id: 1.5.1.7
        description: "Ensure the MCS Translation Service (mcstrans) is not installed (Automated)"
        audit: |
          rpm -q mcstrans
        tests:
          test_items:
            - flag: "package mcstrans is not installed"
              set: true
        remediation: |
          Run the following command to uninstall mcstrans:

          # dnf remove mcstrans
        scored: true

      - id: 1.5.1.8
        description: "Ensure SETroubleshoot is not installed (Automated)"
        audit: |
          rpm -q setroubleshoot
        tests:
          test_items:
            - flag: "package setroubleshoot is not installed"
              set: true
        remediation: |
          Run the following command to uninstall setroubleshoot:
          # dnf remove setroubleshoot
        scored: true


  - id: 1.6
    description: "Configure Command Line Warning Banners"
    checks:
      - id: 1.6.1
        description: "Ensure message of the day is configured properly (Manual)"
        type: manual
        remediation: |
          Edit the /etc/motd file according to your organization's site policy.
          Ensure there are no escape sequences such as \m, \r, \s, or \v.
          You can manually remove them using:
            # sed -i -E 's/\\[mrsv]//g' /etc/motd
        scored: false


      - id: 1.6.2
        description: "Ensure local login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/issue to include a proper warning banner based on your site's policy.
          Example:

          # echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue
        scored: true

      - id: 1.6.3
        description: "Ensure remote login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue.net
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/issue.net file with the appropriate contents according to your site policy, remove any instances of \m , \r , \s , \v or references to the OS platform

          # echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue.ne
        scored: true

      - id: 1.6.4
        description: "Ensure access to /etc/motd is configured (Automated)"
        audit: |
          if [ -e /etc/motd ]; then
            perms=$(stat -Lc '%a' /etc/motd)
            owner=$(stat -Lc '%u' /etc/motd)
            group=$(stat -Lc '%g' /etc/motd)
            if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "motd_access_ok"
            else
              echo "motd_access_bad"
            fi
          else
            echo "motd_not_exist"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "motd_access_ok"
              set: true
            - flag: "motd_not_exist"
              set: true
        remediation: |
          # If /etc/motd exists, set owner and permissions
          if [ -e /etc/motd ]; then
            chown root:root $(readlink -e /etc/motd)
            chmod u-x,go-wx $(readlink -e /etc/motd)
          fi

          # Alternatively, remove /etc/motd if not required
          # rm /etc/motd
        scored: true

      - id: 1.6.5
        description: "Ensure access to /etc/issue is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue)
          owner=$(stat -Lc '%u' /etc/issue)
          group=$(stat -Lc '%g' /etc/issue)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_access_ok"
          else
            echo "issue_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue
          chown root:root $(readlink -e /etc/issue)
          chmod u-x,go-wx $(readlink -e /etc/issue)
        scored: true

      - id: 1.6.6
        description: "Ensure access to /etc/issue.net is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue.net)
          owner=$(stat -Lc '%u' /etc/issue.net)
          group=$(stat -Lc '%g' /etc/issue.net)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_net_access_ok"
          else
            echo "issue_net_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_net_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue.net
          chown root:root $(readlink -e /etc/issue.net)
          chmod u-x,go-wx $(readlink -e /etc/issue.net)
        scored: true

  - id: 2
    description: "Services"
  - id: 2.1
    description: "Configure Time Synchronization"
    checks:
      - id: 2.1.1
        description: "Ensure time synchronization is in use (Automated)"
        audit: "rpm -q chrony"
        tests:
          test_items:
            - flag: "package chrony is not installed"
              set: false
        remediation: |
          Run the following command to install chrony:

          # dnf install chrony
        scored: true

      - id: 2.1.2
        description: "Ensure chrony is configured (Automated)"
        audit: |
          grep -Prs -- '^\h*(server|pool)\h+[^#\n\r]+' /etc/chrony.d
        tests:
          bin_op: or
          test_items:
            - flag: "server"
              set: true
            - flag: "pool"
              set: true
        remediation: |
          # Add or edit server or pool lines to a .conf file under /etc/chrony.d/
          # Example:
          echo "server <remote-server>" >> /etc/chrony.d/time-sync.conf

          # Restart chronyd to apply changes
          systemctl restart chronyd
        scored: true

      - id: 2.1.3
        description: "Ensure chrony is not run as the root user (Automated)"
        audit: |
          if grep -Psi '^\h*OPTIONS="?[\h]*-u\h+root\b' /etc/sysconfig/chronyd >/dev/null; then
            echo "chrony_root_bad"
          else
            echo "chrony_root_ok"
          fi
        tests:
          test_items:
            - flag: "chrony_root_ok"
              set: true
        remediation: |
          # Edit /etc/sysconfig/chronyd and ensure OPTIONS is set to run as the chrony user
          sed -ri 's/^\s*OPTIONS=.*/OPTIONS="-u chrony"/' /etc/sysconfig/chronyd || echo 'OPTIONS="-u chrony"' >> /etc/sysconfig/chronyd

          # Reload chronyd configuration
          systemctl try-reload-or-restart chronyd.service
        scored: true


  - id: 2.2
    description: "Configure Special Purpose Services"
    checks:
      - id: 2.2.1
        description: "Ensure autofs services are not in use (Automated)"
        audit: |
          # Check if autofs package is installed
          if ! rpm -q autofs >/dev/null 2>&1; then
            echo "autofs_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled autofs.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active autofs.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If autofs is not required by any approved dependency, stop and remove it:
          systemctl stop autofs.service 2>/dev/null || true
          yum remove -y autofs

          # If autofs is required as a dependency, stop and mask the service instead:
          # systemctl stop autofs.service
          # systemctl mask autofs.service
        scored: true

      - id: 2.2.2
        description: "Ensure avahi daemon services are not in use (Automated)"
        audit: |
          # Check if avahi package is installed
          if ! rpm -q avahi >/dev/null 2>&1; then
            echo "avahi_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled avahi-daemon.service avahi-daemon.socket 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active avahi-daemon.service avahi-daemon.socket 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If avahi is not required by any approved dependency, stop and remove it:
          systemctl stop avahi-daemon.socket avahi-daemon.service 2>/dev/null || true
          yum remove -y avahi

          # If avahi is required as a dependency, stop and mask the service and socket instead:
          # systemctl stop avahi-daemon.socket avahi-daemon.service
          # systemctl mask avahi-daemon.socket avahi-daemon.service
        scored: true

      - id: 2.2.3
        description: "Ensure dhcp server services are not in use (Automated)"
        audit: |
          # Check if dhcp server package is installed
          if ! rpm -q dhcp >/dev/null 2>&1; then
            echo "dhcp_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled dhcpd.service dhcpd6.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active dhcpd.service dhcpd6.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If DHCP server is not required, stop and remove the package:
          systemctl stop dhcpd.service dhcpd6.service 2>/dev/null || true
          yum remove -y dhcp

          # If DHCP server is required as a dependency, stop and mask the services instead:
          # systemctl stop dhcpd.service dhcpd6.service
          # systemctl mask dhcpd.service dhcpd6.service
        scored: true

      - id: 2.2.4
        description: "Ensure dns server services are not in use (Automated)"
        audit: |
          # Check if bind package is installed
          if ! rpm -q bind >/dev/null 2>&1; then
            echo "bind_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled named.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active named.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If DNS server is not required, stop service and remove package:
          systemctl stop named.service 2>/dev/null || true
          yum remove -y bind

          # If DNS server is required as a dependency, stop and mask service instead:
          # systemctl stop named.service
          # systemctl mask named.service
        scored: true

      - id: 2.2.5
        description: "Ensure dnsmasq services are not in use (Automated)"
        audit: |
          # Check if dnsmasq package is installed
          if ! rpm -q dnsmasq >/dev/null 2>&1; then
            echo "dnsmasq_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled dnsmasq.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active dnsmasq.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If dnsmasq is not required, stop service and remove package:
          systemctl stop dnsmasq.service 2>/dev/null || true
          yum remove -y dnsmasq

          # If dnsmasq is required as a dependency, stop and mask service instead:
          # systemctl stop dnsmasq.service
          # systemctl mask dnsmasq.service
        scored: true

      - id: 2.2.6
        description: "Ensure samba file server services are not in use (Automated)"
        audit: |
          # Check if samba package is installed
          if ! rpm -q samba >/dev/null 2>&1; then
            echo "samba_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled smb.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active smb.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If Samba is not required, stop service and remove package:
          systemctl stop smb.service 2>/dev/null || true
          yum remove -y samba

          # If Samba is required as a dependency, stop and mask service instead:
          # systemctl stop smb.service
          # systemctl mask smb.service
        scored: true

      - id: 2.2.7
        description: "Ensure ftp server services are not in use (Automated)"
        audit: |
          # Check if vsftpd package is installed
          if ! rpm -q vsftpd >/dev/null 2>&1; then
            echo "vsftpd_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled vsftpd.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active vsftpd.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If FTP server is not required, stop service and remove package:
          systemctl stop vsftpd.service 2>/dev/null || true
          yum remove -y vsftpd

          # If FTP server is required as a dependency, stop and mask service instead:
          # systemctl stop vsftpd.service
          # systemctl mask vsftpd.service

          # Note: Audit and remove or disable other FTP server packages if not required.
        scored: true

      - id: 2.2.8
        description: "Ensure message access server services are not in use (Automated)"
        audit: |
          # Check if dovecot and cyrus-imapd packages are installed
          if ! rpm -q dovecot cyrus-imapd >/dev/null 2>&1; then
            echo "imap_pop_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled dovecot.socket dovecot.service cyrus-imapd.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active dovecot.socket dovecot.service cyrus-imapd.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If IMAP/POP3 servers are not required, stop services/sockets and remove packages:
          systemctl stop dovecot.socket dovecot.service cyrus-imapd.service 2>/dev/null || true
          yum remove -y dovecot cyrus-imapd

          # If required as dependencies, stop and mask the services instead:
          # systemctl stop dovecot.socket dovecot.service cyrus-imapd.service
          # systemctl mask dovecot.socket dovecot.service cyrus-imapd.service
        scored: true

      - id: 2.2.9
        description: "Ensure network file system services are not in use (Automated)"
        audit: |
          # Check if nfs-utils package is installed
          if ! rpm -q nfs-utils >/dev/null 2>&1; then
            echo "nfs_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled nfs-server.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active nfs-server.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If NFS server is not required, stop service and remove package:
          systemctl stop nfs-server.service 2>/dev/null || true
          yum remove -y nfs-utils

          # If NFS is required as a dependency, stop and mask service instead:
          # systemctl stop nfs-server.service
          # systemctl mask nfs-server.service
        scored: true

      - id: 2.2.10
        description: "Ensure nis server services are not in use (Automated)"
        audit: |
          # Check if ypserv package is installed
          if ! rpm -q ypserv >/dev/null 2>&1; then
            echo "nis_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled ypserv.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active ypserv.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If NIS server is not required, stop service and remove package:
          systemctl stop ypserv.service 2>/dev/null || true
          yum remove -y ypserv

          # If NIS server is required as a dependency, stop and mask service instead:
          # systemctl stop ypserv.service
          # systemctl mask ypserv.service
        scored: true

      - id: 2.2.11
        description: "Ensure print server services are not in use (Automated)"
        audit: |
          # Check if cups package is installed
          if ! rpm -q cups >/dev/null 2>&1; then
            echo "cups_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled cups.socket cups.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active cups.socket cups.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If print server is not required, stop services and remove package:
          systemctl stop cups.socket cups.service 2>/dev/null || true
          yum remove -y cups

          # If CUPS is required as a dependency, stop and mask services and socket instead:
          # systemctl stop cups.socket cups.service
          # systemctl mask cups.socket cups.service
        scored: true

      - id: 2.2.12
        description: "Ensure rpcbind services are not in use (Automated)"
        audit: |
          # Check if rpcbind package is installed
          if ! rpm -q rpcbind >/dev/null 2>&1; then
            echo "rpcbind_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled rpcbind.socket rpcbind.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active rpcbind.socket rpcbind.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If rpcbind is not required, stop services and remove package:
          systemctl stop rpcbind.socket rpcbind.service 2>/dev/null || true
          yum remove -y rpcbind

          # If rpcbind is required as a dependency, stop and mask services and socket instead:
          # systemctl stop rpcbind.socket rpcbind.service
          # systemctl mask rpcbind.socket rpcbind.service
        scored: true

      - id: 2.2.13
        description: "Ensure rsync services are not in use (Automated)"
        audit: |
          # Check if rsync package is installed
          if ! rpm -q rsync >/dev/null 2>&1; then
            echo "rsync_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled rsyncd.socket rsyncd.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active rsyncd.socket rsyncd.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If rsync is not required, stop services and remove package:
          systemctl stop rsyncd.socket rsyncd.service 2>/dev/null || true
          yum remove -y rsync

          # If rsync is required as a dependency, stop and mask services and socket instead:
          # systemctl stop rsyncd.socket rsyncd.service
          # systemctl mask rsyncd.socket rsyncd.service
        scored: true

      - id: 2.2.14
        description: "Ensure snmp services are not in use (Automated)"
        audit: |
          # Check if net-snmp package is installed
          if ! rpm -q net-snmp >/dev/null 2>&1; then
            echo "snmp_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled snmpd.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active snmpd.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If SNMP service is not required, stop service and remove package:
          systemctl stop snmpd.service 2>/dev/null || true
          yum remove -y net-snmp

          # If SNMP is required as a dependency, stop and mask the service instead:
          # systemctl stop snmpd.service
          # systemctl mask snmpd.service

          # If SNMP must be used, configure SNMP v3 with authentication and encryption, and disable SNMP v1/v2.
        scored: true

      - id: 2.2.15
        description: "Ensure telnet server services are not in use (Automated)"
        audit: |
          # Check if telnet-server package is installed
          if ! rpm -q telnet-server >/dev/null 2>&1; then
            echo "telnet_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled telnet.socket 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active telnet.socket 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If Telnet server is not required, stop socket and remove package:
          systemctl stop telnet.socket 2>/dev/null || true
          yum remove -y telnet-server

          # If Telnet server is required as a dependency, stop and mask socket instead:
          # systemctl stop telnet.socket
          # systemctl mask telnet.socket

          # Use SSH instead of Telnet for secure, encrypted remote connections.
        scored: true

      - id: 2.2.16
        description: "Ensure tftp server services are not in use (Automated)"
        audit: |
          # Check if tftp-server package is installed
          if ! rpm -q tftp-server >/dev/null 2>&1; then
            echo "tftp_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled tftp.socket tftp.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active tftp.socket tftp.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If TFTP server is not required, stop services/sockets and remove package:
          systemctl stop tftp.socket tftp.service 2>/dev/null || true
          yum remove -y tftp-server

          # If TFTP server is required as a dependency, stop and mask services and sockets instead:
          # systemctl stop tftp.socket tftp.service
          # systemctl mask tftp.socket tftp.service

          # Consider secure alternatives if file transfer functionality is required.
        scored: true

      - id: 2.2.17
        description: "Ensure web proxy server services are not in use (Automated)"
        audit: |
          # Check if squid package is installed
          if ! rpm -q squid >/dev/null 2>&1; then
            echo "squid_not_installed"
            echo "not_installed_or_disabled"
          else
           if systemctl is-enabled squid.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active squid.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If Squid proxy is not required, stop service and remove package:
          systemctl stop squid.service 2>/dev/null || true
          yum remove -y squid

          # If Squid is required as a dependency, stop and mask the service instead:
          # systemctl stop squid.service
          # systemctl mask squid.service

          # Review and remove any other HTTP proxy services if not required.
        scored: true

      - id: 2.2.18
        description: "Ensure web server services are not in use (Automated)"
        audit: |
          # Check if httpd and nginx packages are installed
          if ! rpm -q httpd nginx >/dev/null 2>&1; then
            echo "web_server_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled httpd.socket httpd.service nginx.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active httpd.socket httpd.service nginx.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If web servers are not required, stop services/sockets and remove packages:
          systemctl stop httpd.socket httpd.service nginx.service 2>/dev/null || true
          yum remove -y httpd nginx

          # If required as dependencies, stop and mask the services and sockets instead:
          # systemctl stop httpd.socket httpd.service nginx.service
          # systemctl mask httpd.socket httpd.service nginx.service

          # Audit and remove or disable any other web server packages if not required.
        scored: true

      - id: 2.2.19
        description: "Ensure xinetd services are not in use (Automated)"
        audit: |
          # Check if xinetd package is installed
          if ! rpm -q xinetd >/dev/null 2>&1; then
            echo "xinetd_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled xinetd.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active xinetd.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If xinetd is not required, stop service and remove package:
          systemctl stop xinetd.service 2>/dev/null || true
          yum remove -y xinetd

          # If xinetd is required as a dependency, stop and mask the service instead:
          # systemctl stop xinetd.service
          # systemctl mask xinetd.service
        scored: true

      - id: 2.2.20
        description: "Ensure X window server services are not in use (Automated)"
        audit: |
          # Check if X Windows Server package is installed
          if ! rpm -q xorg-x11-server-common >/dev/null 2>&1; then
            echo "xwindows_not_installed"
          else
            echo "xwindows_installed"
          fi
        tests:
          test_items:
            - flag: "xwindows_not_installed"
              set: true
        remediation: |
          # If X Windows Server is not required, remove the package:
          yum remove -y xorg-x11-server-common

          # If a Graphical Desktop Manager is required by site policy, do not remove this package.
          # Consider using headless Java packages if Java dependencies on X11 fonts exist.
        scored: true

      - id: 2.2.21
        description: "Ensure mail transfer agents are configured for local-only mode (Automated)"
        audit: |
          if ! ss -plntu | grep -P -- ':(25|465|587)\b' | grep -Pv '\h+(127\.0\.0\.1|\[?::1\]?):(25|465|587)\b' >/dev/null; then
            echo "mta_local_only"
          fi
        tests:
          test_items:
            - flag: "mta_local_only"
              set: true
        remediation: |
          # For Postfix, edit /etc/postfix/main.cf and set:
          inet_interfaces = loopback-only

          # Restart postfix to apply changes
          systemctl restart postfix

          # For other MTAs such as sendmail, refer to vendor documentation to restrict to loopback-only mode.
        scored: true

      - id: 2.2.22
        description: "Ensure only approved services are listening on a network interface (Manual)"
        audit: "ss -plntu"
        type: manual
        remediation: |
          Run the following commands to stop the service and remove the package containing
          the service:
          # systemctl stop <service_name>.socket <service_name>.service
          # yum remove <package_name>
          -OR- If required packages have a dependency:
          Run the following commands to stop and mask the service and socket:
          # systemctl stop <service_name>.socket <service_name>.service
          # systemctl mask <service_name>.socket <service_name>.service
          Note: replace <service_name> with the appropriate service name.
        scored: false


  - id: 2.3
    description: "Configure Service Clients"
    checks:
      - id: 2.3.1
        description: "Ensure ftp client is not installed (Automated)"
        audit: "rpm -q ftp"
        tests:
          test_items:
            - flag: "package ftp is not installed"
              set: true
        remediation: |
          Run the following command to remove ftp:

          # dnf remove ftp
        scored: true

      - id: 2.3.2
        description: "Ensure ldap client is not installed (Automated)"
        audit: "rpm -q openldap-clients"
        tests:
          test_items:
            - flag: "package openldap-clients is not installed"
              set: true
        remediation: |
          Run the following command to remove openldap-clients:

          # dnf remove openldap-clients
        scored: true

      - id: 2.3.3
        description: "Ensure nis client is not installed (Automated)"
        audit: "rpm -q ypbind"
        tests:
          test_items:
            - flag: "package ypbind is not installed"
              set: true
        remediation: |
          Run the following command to remove ypbind:

          # dnf remove ypbind
        scored: true

      - id: 2.3.4
        description: "Ensure telnet client is not installed (Automated)"
        audit: "rpm -q telnet"
        tests:
          test_items:
            - flag: "package telnet is not installed"
              set: true
        remediation: |
          Run the following command to remove telnet:

          # dnf remove telnet
        scored: true

      - id: 2.3.5
        description: "Ensure tftp client is not installed (Automated)"
        audit: "rpm -q tftp"
        tests:
          test_items:
            - flag: "package tftp is not installed"
              set: true
        remediation: |
          Run the following command to remove tftp:

          # dnf remove tftp
        scored: true


  - id: 3
    description: "Network"
  - id: 3.1
    description: "Configure Network Devices"
    checks:
      - id: 3.1.1
        description: "Ensure IPv6 status is identified (Manual)"
        type: manual
        audit: |
          grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable && echo -e "\n - IPv6 is enabled\n" || echo -e "\n - IPv6 is not enabled\n"
        remediation: |
          # If IPv6 is required:
          # Ensure IPv6 is enabled by removing any settings that disable it from /etc/sysctl.conf or GRUB
          # Otherwise, if not required:
          # Add or confirm the following lines are present to disable IPv6:
          echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.conf
          echo "net.ipv6.conf.default.disable_ipv6 = 1" >> /etc/sysctl.conf
          sysctl -p

          # Or add `ipv6.disable=1` to GRUB_CMDLINE_LINUX in /etc/default/grub and update GRUB:
          # grub2-mkconfig -o /boot/grub2/grub.cfg
        scored: false

      - id: 3.1.2
        description: "Ensure wireless interfaces are disabled (Automated)"
        audit: |
          # Detect wireless NIC drivers (kernel modules)
          drivers=$(for driverdir in $(find /sys/class/net/*/ -type d -name wireless 2>/dev/null | xargs -r -0 dirname); do
                      readlink -f "$driverdir/device/driver/module" 2>/dev/null | xargs -r basename
                    done | sort -u)

          if [ -z "$drivers" ]; then
            echo "no_wireless_nics"
          else
            any_loadable=0
            any_loaded=0
            any_not_blacklisted=0

            for m in $drivers; do
              # install line should block loading
              if ! modprobe -n -v "$m" 2>/dev/null | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
                any_loadable=1
              fi

              # module must not be currently loaded
              if lsmod | grep -q "^${m//-/_}\b"; then
                any_loaded=1
              fi

              # module must be blacklisted
              if ! modprobe --showconfig 2>/dev/null | grep -Pq "^\s*blacklist\s+${m//-/_}\b"; then
                any_not_blacklisted=1
              fi
            done

            if [ $any_loadable -eq 0 ] && [ $any_loaded -eq 0 ] && [ $any_not_blacklisted -eq 0 ]; then
              echo "wireless_modules_disabled"
            else
              [ $any_loadable -ne 0 ] && echo "wireless_module_loadable"
              [ $any_loaded -ne 0 ] && echo "wireless_module_loaded"
              [ $any_not_blacklisted -ne 0 ] && echo "wireless_module_not_blacklisted"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "no_wireless_nics"
              set: true
            - flag: "wireless_modules_disabled"
              set: true
        remediation: |
          # Disable detected wireless drivers (kernel modules)
          drivers=$(for driverdir in $(find /sys/class/net/*/ -type d -name wireless 2>/dev/null | xargs -r -0 dirname); do
                      readlink -f "$driverdir/device/driver/module" 2>/dev/null | xargs -r basename
                    done | sort -u)

          for m in $drivers; do
            # Prevent loading via install line
            if ! modprobe -n -v "$m" 2>/dev/null | grep -Eq '^\s*install\s+/bin/(false|true)\b'; then
              echo "install $m /bin/false" >> "/etc/modprobe.d/${m}.conf"
            fi
            # Unload if currently loaded
            if lsmod | grep -q "^${m//-/_}\b"; then
              modprobe -r "$m" 2>/dev/null || true
            fi
            # Blacklist the module
            if ! modprobe --showconfig 2>/dev/null | grep -Pq "^\s*blacklist\s+${m//-/_}\b"; then
              echo "blacklist $m" >> "/etc/modprobe.d/${m}.conf"
            fi
          done
        scored: true

      - id: 3.1.3
        description: "Ensure bluetooth services are not in use (Automated)"
        audit: |
          # Check if bluez package is installed
          if ! rpm -q bluez >/dev/null 2>&1; then
            echo "bluez_not_installed"
            echo "not_installed_or_disabled"
          else
            if systemctl is-enabled bluetooth.service 2>/dev/null | grep -vq '^enabled$' \
               && systemctl is-active bluetooth.service 2>/dev/null | grep -vq '^active$'; then
              echo "not_installed_or_disabled"
            fi
          fi
        tests:
          test_items:
            - flag: "not_installed_or_disabled"
              set: true
        remediation: |
          # If Bluetooth is not required, stop service and remove package:
          systemctl stop bluetooth.service 2>/dev/null || true
          yum remove -y bluez

          # If Bluetooth is required as a dependency, stop and mask the service instead:
          # systemctl stop bluetooth.service
          # systemctl mask bluetooth.service

          # Note: A reboot may be required.
        scored: true


  - id: 3.2
    description: "Configure Network Kernel Modules"
    checks:
      - id: 3.2.1
        description: "Ensure dccp kernel module is not available (Automated)"
        audit: |
          # Module should be set non-loadable
          if modprobe -n -v dccp 2>/dev/null | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          # Module should be blacklisted
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+dccp\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          # Module must not be loaded
          if ! lsmod | grep -q "^dccp"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          # Create or update /etc/modprobe.d/dccp.conf with:
          install dccp /bin/false
          blacklist dccp

          # Unload the module if it is currently loaded:
          # modprobe -r dccp
        scored: true

      - id: 3.2.2
        description: "Ensure tipc kernel module is not available (Automated)"
        audit: |
          # Module should be set non-loadable
          if modprobe -n -v tipc 2>/dev/null | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          # Module should be blacklisted
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+tipc\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          # Module must not be loaded
          if ! lsmod | grep -q "^tipc"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          # Create or update /etc/modprobe.d/tipc.conf with:
          install tipc /bin/false
          blacklist tipc

          # Unload the module if it is currently loaded:
          # modprobe -r tipc
        scored: true

      - id: 3.2.3
        description: "Ensure rds kernel module is not available (Automated)"
        audit: |
          # Module should be set non-loadable
          if modprobe -n -v rds 2>/dev/null | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          # Module should be blacklisted
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+rds\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          # Module must not be loaded
          if ! lsmod | grep -q "^rds"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          # Create or update /etc/modprobe.d/rds.conf with:
          install rds /bin/false
          blacklist rds

          # Unload the module if it is currently loaded:
          # modprobe -r rds
        scored: true

      - id: 3.2.4
        description: "Ensure sctp kernel module is not available (Automated)"
        audit: |
          # Module should be set non-loadable
          if modprobe -n -v sctp 2>/dev/null | grep -Eq 'install /bin/(false|true)'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          # Module should be blacklisted
          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+sctp\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          # Module must not be loaded
          if ! lsmod | grep -q "^sctp"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          # Create or update /etc/modprobe.d/sctp.conf with:
          install sctp /bin/false
          blacklist sctp

          # Unload the module if it is currently loaded:
          # modprobe -r sctp
        scored: true

  - id: 3.3
    description: "Configure Network Kernel Parameters"
    checks:
      - id: 3.3.1
        description: "Ensure IP forwarding is disabled (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.ip_forward 2>/dev/null)" -eq 0 ]; then
            echo "ipv4_forwarding_ok"
          else
            echo "ipv4_forwarding_bad"
          fi

          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            if [ "$(sysctl -n net.ipv6.conf.all.forwarding 2>/dev/null)" -eq 0 ]; then
              echo "ipv6_forwarded_pass"
            else
              echo "ipv6_forwarding_bad"
            fi
          else
            # IPv6 disabled entirely
            echo "ipv6_forwarded_pass"
          fi
        tests:
          test_items:
            - flag: "ipv4_forwarding_ok"
              set: true
            - flag: "ipv6_forwarded_pass"
              set: true
        remediation: |
          # Disable IPv4 forwarding
          printf '%s\n' "net.ipv4.ip_forward = 0" >> /etc/sysctl.d/60-netipv4_sysctl.conf
          sysctl -w net.ipv4.ip_forward=0
          sysctl -w net.ipv4.route.flush=1

          # Disable IPv6 forwarding if IPv6 is enabled
          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            printf '%s\n' "net.ipv6.conf.all.forwarding = 0" >> /etc/sysctl.d/60-netipv6_sysctl.conf
            sysctl -w net.ipv6.conf.all.forwarding=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true

      - id: 3.3.2
        description: "Ensure packet redirect sending is disabled (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.conf.all.send_redirects 2>/dev/null)" -eq 0 ]; then
            echo "all_send_redirects_ok"
          else
            echo "all_send_redirects_bad"
          fi

          # Check net.ipv4.conf.default.send_redirects
          if [ "$(sysctl -n net.ipv4.conf.default.send_redirects 2>/dev/null)" -eq 0 ]; then
            echo "default_send_redirects_ok"
          else
            echo "default_send_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "all_send_redirects_ok"
              set: true
            - flag: "default_send_redirects_ok"
              set: true
        remediation: |
          # Set packet redirect sending to disabled in persistent configuration
          printf '%s\n' "net.ipv4.conf.all.send_redirects = 0" \
                        "net.ipv4.conf.default.send_redirects = 0" \
                        >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply changes to running configuration
          sysctl -w net.ipv4.conf.all.send_redirects=0
          sysctl -w net.ipv4.conf.default.send_redirects=0
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.3
        description: "Ensure bogus ICMP responses are ignored (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.icmp_ignore_bogus_error_responses 2>/dev/null)" -eq 1 ]; then
            echo "icmp_ignore_bogus_ok"
          else
            echo "icmp_ignore_bogus_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_ignore_bogus_ok"
              set: true
        remediation: |
          # Set bogus ICMP response ignore to enabled in persistent configuration
          printf '%s\n' "net.ipv4.icmp_ignore_bogus_error_responses = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply changes to running configuration
          sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.4
        description: "Ensure broadcast ICMP requests are ignored (Automated)"
        audit: |
          # Check if broadcast ICMP requests are ignored
          if [ "$(sysctl -n net.ipv4.icmp_echo_ignore_broadcasts 2>/dev/null)" -eq 1 ]; then
            echo "icmp_broadcast_ignore_ok"
          else
            echo "icmp_broadcast_ignore_bad"
          fi
        tests:
          test_items:
            - flag: "icmp_broadcast_ignore_ok"
              set: true
        remediation: |
          # Set broadcast ICMP request ignore to enabled in persistent configuration
          printf '%s\n' "net.ipv4.icmp_echo_ignore_broadcasts = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply changes to running configuration
          sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.5
        description: "Ensure ICMP redirects are not accepted (Automated)"
        audit: |
          ipv4_all_ok=0
          ipv4_default_ok=0

          if [ "$(sysctl -n net.ipv4.conf.all.accept_redirects 2>/dev/null)" -eq 0 ]; then
            ipv4_all_ok=1
          else
            echo "ipv4_all_redirects_bad"
          fi

          if [ "$(sysctl -n net.ipv4.conf.default.accept_redirects 2>/dev/null)" -eq 0 ]; then
            ipv4_default_ok=1
          else
            echo "ipv4_default_redirects_bad"
          fi

          if [ $ipv4_all_ok -eq 1 ] && [ $ipv4_default_ok -eq 1 ]; then
            echo "ipv4_redirects_pass"
          fi

          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_all_ok=0
            ipv6_default_ok=0

            if [ "$(sysctl -n net.ipv6.conf.all.accept_redirects 2>/dev/null)" -eq 0 ]; then
              ipv6_all_ok=1
          else
              echo "ipv6_all_redirects_bad"
            fi

            if [ "$(sysctl -n net.ipv6.conf.default.accept_redirects 2>/dev/null)" -eq 0 ]; then
              ipv6_default_ok=1
            else
              echo "ipv6_default_redirects_bad"
            fi

            if [ $ipv6_all_ok -eq 1 ] && [ $ipv6_default_ok -eq 1 ]; then
              echo "ipv6_redirects_pass"
            fi
          else
            # IPv6 disabled entirely is considered pass for this control
            echo "ipv6_redirects_pass"
          fi
        tests:
          test_items:
            - flag: "ipv4_redirects_pass"
              set: true
            - flag: "ipv6_redirects_pass"
              set: true
        remediation: |
          # Disable IPv4 ICMP redirects
          printf '%s\n' "net.ipv4.conf.all.accept_redirects = 0" \
                        "net.ipv4.conf.default.accept_redirects = 0" \
                        >> /etc/sysctl.d/60-netipv4_sysctl.conf
          sysctl -w net.ipv4.conf.all.accept_redirects=0
          sysctl -w net.ipv4.conf.default.accept_redirects=0
          sysctl -w net.ipv4.route.flush=1

          # Disable IPv6 ICMP redirects if IPv6 is enabled
          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            printf '%s\n' "net.ipv6.conf.all.accept_redirects = 0" \
                          "net.ipv6.conf.default.accept_redirects = 0" \
                          >> /etc/sysctl.d/60-netipv6_sysctl.conf
            sysctl -w net.ipv6.conf.all.accept_redirects=0
            sysctl -w net.ipv6.conf.default.accept_redirects=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true

      - id: 3.3.6
        description: "Ensure secure ICMP redirects are not accepted (Automated)"
        audit: |
          # Check IPv4 secure redirects for all
          if [ "$(sysctl -n net.ipv4.conf.all.secure_redirects 2>/dev/null)" -eq 0 ]; then
            echo "ipv4_all_secure_redirects_ok"
          else
            echo "ipv4_all_secure_redirects_bad"
          fi

          # Check IPv4 secure redirects for default
          if [ "$(sysctl -n net.ipv4.conf.default.secure_redirects 2>/dev/null)" -eq 0 ]; then
            echo "ipv4_default_secure_redirects_ok"
          else
            echo "ipv4_default_secure_redirects_bad"
          fi
        tests:
          test_items:
            - flag: "ipv4_all_secure_redirects_ok"
              set: true
            - flag: "ipv4_default_secure_redirects_ok"
              set: true
        remediation: |
          # Disable secure ICMP redirects in persistent configuration
          printf '%s\n' "net.ipv4.conf.all.secure_redirects = 0" \
                        "net.ipv4.conf.default.secure_redirects = 0" \
                        >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply settings to running configuration
          sysctl -w net.ipv4.conf.all.secure_redirects=0
          sysctl -w net.ipv4.conf.default.secure_redirects=0
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.7
        description: "Ensure reverse path filtering is enabled (Automated)"
        audit: |
          # Check reverse path filtering for all
          if [ "$(sysctl -n net.ipv4.conf.all.rp_filter 2>/dev/null)" -eq 1 ]; then
            echo "rp_filter_all_ok"
          else
            echo "rp_filter_all_bad"
          fi

          # Check reverse path filtering for default
          if [ "$(sysctl -n net.ipv4.conf.default.rp_filter 2>/dev/null)" -eq 1 ]; then
            echo "rp_filter_default_ok"
          else
            echo "rp_filter_default_bad"
          fi
        tests:
          test_items:
            - flag: "rp_filter_all_ok"
              set: true
            - flag: "rp_filter_default_ok"
              set: true
        remediation: |
          # Enable reverse path filtering in persistent configuration
          printf '%s\n' "net.ipv4.conf.all.rp_filter = 1" \
                        "net.ipv4.conf.default.rp_filter = 1" \
                        >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply changes to running configuration
          sysctl -w net.ipv4.conf.all.rp_filter=1
          sysctl -w net.ipv4.conf.default.rp_filter=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.8
        description: "Ensure source routed packets are not accepted (Automated)"
        audit: |
          ipv4_all_ok=0
          ipv4_default_ok=0

          if [ "$(sysctl -n net.ipv4.conf.all.accept_source_route 2>/dev/null)" -eq 0 ]; then
            ipv4_all_ok=1
          else
            echo "ipv4_all_source_route_bad"
          fi

          if [ "$(sysctl -n net.ipv4.conf.default.accept_source_route 2>/dev/null)" -eq 0 ]; then
            ipv4_default_ok=1
          else
            echo "ipv4_default_source_route_bad"
          fi

          if [ $ipv4_all_ok -eq 1 ] && [ $ipv4_default_ok -eq 1 ]; then
            echo "ipv4_all_source_route_pass"
          fi

          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_all_ok=0
            ipv6_default_ok=0

            if [ "$(sysctl -n net.ipv6.conf.all.accept_source_route 2>/dev/null)" -eq 0 ]; then
              ipv6_all_ok=1
            else
              echo "ipv6_all_source_route_bad"
            fi

            if [ "$(sysctl -n net.ipv6.conf.default.accept_source_route 2>/dev/null)" -eq 0 ]; then
              ipv6_default_ok=1
            else
              echo "ipv6_default_source_route_bad"
            fi

            if [ $ipv6_all_ok -eq 1 ] && [ $ipv6_default_ok -eq 1 ]; then
              echo "ipv6_all_source_route_pass"
            fi
          else
            # IPv6 disabled entirely is treated as pass
            echo "ipv6_all_source_route_pass"
          fi
        tests:
          test_items:
            - flag: "ipv4_all_source_route_pass"
              set: true
            - flag: "ipv6_all_source_route_pass"
              set: true
        remediation: |
          # Disable source routed packets for IPv4
          printf '%s\n' "net.ipv4.conf.all.accept_source_route = 0" \
                        "net.ipv4.conf.default.accept_source_route = 0" \
                        >> /etc/sysctl.d/60-netipv4_sysctl.conf
          sysctl -w net.ipv4.conf.all.accept_source_route=0
          sysctl -w net.ipv4.conf.default.accept_source_route=0
          sysctl -w net.ipv4.route.flush=1

          # Disable source routed packets for IPv6 if enabled
          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            printf '%s\n' "net.ipv6.conf.all.accept_source_route = 0" \
                          "net.ipv6.conf.default.accept_source_route = 0" \
                          >> /etc/sysctl.d/60-netipv6_sysctl.conf
            sysctl -w net.ipv6.conf.all.accept_source_route=0
            sysctl -w net.ipv6.conf.default.accept_source_route=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true

      - id: 3.3.9
        description: "Ensure suspicious packets are logged (Automated)"
        audit: |
          # Check logging of martian packets for all
          if [ "$(sysctl -n net.ipv4.conf.all.log_martians 2>/dev/null)" -eq 1 ]; then
            echo "log_martians_all_ok"
          else
            echo "log_martians_all_bad"
          fi

          # Check logging of martian packets for default
          if [ "$(sysctl -n net.ipv4.conf.default.log_martians 2>/dev/null)" -eq 1 ]; then
            echo "log_martians_default_ok"
          else
            echo "log_martians_default_bad"
          fi
        tests:
          test_items:
            - flag: "log_martians_all_ok"
              set: true
            - flag: "log_martians_default_ok"
              set: true
        remediation: |
          # Enable logging of suspicious (martian) packets in persistent configuration
          printf '%s\n' "net.ipv4.conf.all.log_martians = 1" \
                        "net.ipv4.conf.default.log_martians = 1" \
                        >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply changes to running configuration
          sysctl -w net.ipv4.conf.all.log_martians=1
          sysctl -w net.ipv4.conf.default.log_martians=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.10
        description: "Ensure TCP SYN cookies is enabled (Automated)"
        audit: |
          # Check if TCP SYN cookies are enabled
          if [ "$(sysctl -n net.ipv4.tcp_syncookies 2>/dev/null)" -eq 1 ]; then
            echo "tcp_syncookies_ok"
          else
            echo "tcp_syncookies_bad"
          fi
        tests:
          test_items:
            - flag: "tcp_syncookies_ok"
              set: true
        remediation: |
          # Enable TCP SYN cookies in persistent configuration
          printf '%s\n' "net.ipv4.tcp_syncookies = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          # Apply changes to running configuration
          sysctl -w net.ipv4.tcp_syncookies=1
          sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.11
        description: "Ensure IPv6 router advertisements are not accepted (Automated)"
        audit: |
          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_all_ok=0
            ipv6_default_ok=0

            if [ "$(sysctl -n net.ipv6.conf.all.accept_ra 2>/dev/null)" -eq 0 ]; then
              ipv6_all_ok=1
            else
              echo "ipv6_all_accept_ra_bad"
            fi

            # Check net.ipv6.conf.default.accept_ra
            if [ "$(sysctl -n net.ipv6.conf.default.accept_ra 2>/dev/null)" -eq 0 ]; then
              ipv6_default_ok=1
            else
              echo "ipv6_default_accept_ra_bad"
            fi

            # If both are OK, print consolidated flag
            if [ $ipv6_all_ok -eq 1 ] && [ $ipv6_default_ok -eq 1 ]; then
              echo "ipv6_pass"
            fi
          else
            echo "ipv6_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ipv6_pass"
              set: true
            - flag: "ipv6_disabled"
              set: true
        remediation: |
          # Apply only if IPv6 is enabled
          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            # Update persistent configuration
            printf '%s\n' "net.ipv6.conf.all.accept_ra = 0" \
                          "net.ipv6.conf.default.accept_ra = 0" \
                          >> /etc/sysctl.d/60-netipv6_sysctl.conf

            # Apply changes to running configuration
            sysctl -w net.ipv6.conf.all.accept_ra=0
            sysctl -w net.ipv6.conf.default.accept_ra=0
            sysctl -w net.ipv6.route.flush=1
          fi
        scored: true


  - id: 3.4
    description: "Configure Host Based Firewall"
    checks:
      - id: 3.4.1
        description: "Configure firewall utility"
        type: "skip"
        checks:
      - id: 3.4.1.1
        description: "Ensure iptables is installed (Automated)"
        audit: "rpm -q iptables"
        tests:
          test_items:
            - flag: "package iptables is not installed"
              set: false
        remediation: |
          Run the following command to install iptables

          # dnf install iptables
        scored: true

      - id: 3.4.1.2
        description: "Ensure a single firewall configuration utility is in use (Automated)"
        audit: |
          #!/usr/bin/env bash
          set -euo pipefail

          status() { systemctl "$1" "$2" 2>/dev/null | grep -q '^enabled$|^active$'; }

          # Package presence
          rpm -q firewalld         &>/dev/null && FW_PKG=installed        || FW_PKG=absent
          rpm -q nftables          &>/dev/null && NFT_PKG=installed       || NFT_PKG=absent
          rpm -q iptables-services &>/dev/null && IPT_PKG=installed       || IPT_PKG=absent

          status is-enabled firewalld.service && FW_EN=enabled || FW_EN=disabled
          status is-active  firewalld.service && FW_AC=active  || FW_AC=inactive

          status is-enabled nftables.service && NFT_EN=enabled || NFT_EN=disabled
          status is-active  nftables.service && NFT_AC=active  || NFT_AC=inactive

          status is-enabled iptables.service && IPT4_EN=enabled || IPT4_EN=disabled
          status is-active  iptables.service && IPT4_AC=active  || IPT4_AC=inactive

          if grep -Pqs '^\s*0\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            status is-enabled ip6tables.service && IPT6_EN=enabled || IPT6_EN=disabled
            status is-active  ip6tables.service && IPT6_AC=active  || IPT6_AC=inactive
          else
            IPT6_EN=disabled
            IPT6_AC=inactive
          fi

          in_use_firewalld=0
          in_use_nftables=0
          in_use_iptables=0

          [[ "$FW_EN"  == enabled && "$FW_AC"  == active  ]] && in_use_firewalld=1
          [[ "$NFT_EN" == enabled && "$NFT_AC" == active  ]] && in_use_nftables=1
          if { [[ "$IPT4_EN" == enabled && "$IPT4_AC" == active ]]; } || \
             { [[ "$IPT6_EN" == enabled && "$IPT6_AC" == active ]]; }; then
            in_use_iptables=1
          fi

          in_use_total=$(( in_use_firewalld + in_use_nftables + in_use_iptables ))

          if [ "$in_use_total" -eq 1 ]; then
            echo "single_firewall_ok"
          else
            echo "single_firewall_bad"
            echo " - Exactly one firewall utility must be enabled and active; detected count: $in_use_total"
            echo " - In use flags -> firewalld=$in_use_firewalld nftables=$in_use_nftables iptables=$in_use_iptables"
          fi
        tests:
          test_items:
            - flag: "single_firewall_ok"
              set: true
        remediation: |
          Choose ONE firewall utility and ensure others are removed or hard-disabled (masked).

          OPTION 1  firewalld
            # Prefer removing other stacks
            yum remove nftables iptables-services
            # If removal is not allowed, stop & mask other stacks
            systemctl stop nftables.service iptables.service ip6tables.service
            systemctl mask nftables.service iptables.service ip6tables.service
            # Ensure firewalld is enabled/active
            systemctl enable --now firewalld.service

          OPTION 2  nftables
            yum remove firewalld iptables-services
            # Or stop & mask firewalld/iptables
            systemctl stop firewalld.service iptables.service ip6tables.service
            systemctl mask firewalld.service iptables.service ip6tables.service
            systemctl enable --now nftables.service

          OPTION 3  iptables
            yum remove firewalld nftables
            # Or stop & mask firewalld/nftables
            systemctl stop firewalld.service nftables.service
            systemctl mask firewalld.service nftables.service
            systemctl enable --now iptables.service
            # (Enable ip6tables.service too if IPv6 is enabled)

          After applying your choice, re-run the audit and confirm it prints `single_firewall_ok`.
        scored: true

      - id: 3.4.2
        description: "Configure firewalld"
        type: "skip"
        checks:
      - id: 3.4.2.1
        description: "Ensure firewalld is installed (Automated)"
        audit: |
          rpm -q firewalld iptables
        tests:
          bin_op: and
          test_items:
            - flag: "package firewalld is not installed"
              set: false
            - flag: "package iptables is not installed"
              set: false
        remediation: |
          Run the following command to install FirewallD and iptables:
             # yum install firewalld iptables
        scored: true

      - id: 3.4.2.2
        description: "Ensure firewalld service is enabled and running (Automated)"
        audit: |
          # Check if firewalld is enabled
          if systemctl is-enabled firewalld 2>/dev/null | grep -q '^enabled$'; then
            echo "firewalld_enabled"
          else
            echo "firewalld_disabled"
          fi

          # Check if firewalld is running
          if firewall-cmd --state 2>/dev/null | grep -q '^running$'; then
            echo "firewalld_running"
          else
            echo "firewalld_not_running"
          fi
        tests:
          test_items:
            - flag: "firewalld_enabled"
              set: true
            - flag: "firewalld_running"
              set: true
        remediation: |
          # Unmask firewalld if needed
          systemctl unmask firewalld

          # Enable and start firewalld
          systemctl --now enable firewalld
        scored: true

      - id: 3.4.2.3
        description: "Ensure firewalld drops unnecessary services and ports (Manual)"
        audit: |
          systemctl is-enabled firewalld.service | grep -q 'enabled' && firewall-cmd --list-all --
          zone="$(firewall-cmd --list-all | awk '/\(active\)/ { print $1 }')" | grep -P --
          '^\h*(services:|ports:)'
        type: manual
        remediation: |
          If Firewalld is in use on the system:
            Run the following command to remove an unnecessary service:
            # firewall-cmd --remove-service=<service>
            Example:
            # firewall-cmd --remove-service=cockpit
            Run the following command to remove an unnecessary port:
            # firewall-cmd --remove-port=<port-number>/<port-type>
            Example:
            # firewall-cmd --remove-port=25/tcp
            Run the following command to make new settings persistent:
              # firewall-cmd --runtime-to-permanent
        scored: false

      - id: 3.4.2.4
        description: "Ensure network interfaces are assigned to appropriate zone (Manual)"
        audit: |
          find /sys/class/net/* -maxdepth 1 | awk -F"/" '{print $NF}' | while read -r netint; do ["$netint" != "lo" ] && firewall-cmd --get-active-zones | grep -B1 $netint; done
        type: manual
        remediation: |
          Run the following command to assign an interface to the approprate zone.
          # firewall-cmd --zone=<Zone NAME> --change-interface=<INTERFACE NAME>
          Example:
          # firewall-cmd --zone=customezone --change-interface=eth0
        scored: false

      - id: 3.4.3
        description: "Configure nftables"
        type: "skip"
        checks:
      - id: 3.4.3.1
        description: "Ensure nftables is installed (Automated)"
        audit: |
          rpm -q nftables
        tests:
          test_items:
            - flag: "package nftables is not installed"
              set: false
        remediation: |
          Run the following command to install nftables and iptables:
             # yum install nftables
        scored: true

      - id: 3.4.3.2
        description: "Ensure iptables are flushed with nftables (Manual)"
        audit: |
          # Check iptables rules
          if iptables -L 2>/dev/null | grep -E 'Chain'; then
            echo "iptables_rules_exist"
          else
            echo "iptables_rules_empty"
          fi

          # Check ip6tables rules
          if ip6tables -L 2>/dev/null | grep -E 'Chain'; then
            echo "ip6tables_rules_exist"
          else
            echo "ip6tables_rules_empty"
          fi
        tests:
          test_items:
            - flag: "iptables_rules_empty"
              set: true
            - flag: "ip6tables_rules_empty"
              set: true
        remediation: |
          # Flush all iptables rules
          iptables -F

          # Flush all ip6tables rules
          ip6tables -F
        scored: true

      - id: 3.4.3.3
        description: "Ensure an nftables table exists (Automated)"
        audit: |
          # Check if any nftables table exists
          if nft list tables 2>/dev/null | grep -q '^table'; then
            echo "nft_table_exists"
          else
            echo "nft_no_tables"
          fi
        tests:
          test_items:
            - flag: "nft_table_exists"
              set: true
        remediation: |
          # Create a new nftables table (example: filter table for both IPv4 and IPv6)
          nft create table inet filter
        scored: true

      - id: 3.4.3.4
        description: "Ensure nftables base chains exist (Automated)"
        audit: |
          # Verify base chains with hooks for input, forward, and output exist
          have_input=$(nft list ruleset 2>/dev/null | grep -q 'hook input' && echo yes || echo no)
          have_forward=$(nft list ruleset 2>/dev/null | grep -q 'hook forward' && echo yes || echo no)
          have_output=$(nft list ruleset 2>/dev/null | grep -q 'hook output' && echo yes || echo no)

          if [ "$have_input" = "yes" ] && [ "$have_forward" = "yes" ] && [ "$have_output" = "yes" ]; then
            echo "nft_base_chains_present"
          else
            echo "nft_base_chains_missing"
          fi
        tests:
          test_items:
            - flag: "nft_base_chains_present"
              set: true
        remediation: |
          # Create base chains (replace <table> with your nftables table name, e.g., "filter")
          nft create chain inet <table> input   '{ type filter hook input   priority 0; }'
          nft create chain inet <table> forward '{ type filter hook forward priority 0; }'
          nft create chain inet <table> output  '{ type filter hook output  priority 0; }'

          # NOTE: If you plan to set a default drop policy on these chains, first add allow rules
          # for required access (e.g., SSH) to avoid locking yourself out:
          #   nft add rule inet <table> input tcp dport 22 ct state new,established accept
          #   nft add rule inet <table> output ct state established accept
        scored: true

      - id: 3.4.3.5
        description: "Ensure nftables loopback traffic is configured (Automated)"
        audit: |
          # Verify IPv4 loopback is accepted on lo and blocked on other interfaces
          nft list ruleset | awk '/hook input/,/}/' | grep -q 'iif "lo" accept' \
            && echo "nft_lo_accept_present" || echo "nft_lo_accept_missing"

          nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip saddr 127\.0\.0\.0/8 .* drop' \
            && echo "nft_ipv4_lo_drop_present" || echo "nft_ipv4_lo_drop_missing"

          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable; then
            if nft list ruleset | awk '/hook input/,/}/' | grep -q 'ip6 saddr ::1 .* drop'; then
              echo "nft_ipv6_lo_drop_pass"
            else
              echo "nft_ipv6_lo_drop_missing"
            fi
          else
            echo "nft_ipv6_lo_drop_pass"
          fi
        tests:
          test_items:
            - flag: "nft_lo_accept_present"
              set: true
            - flag: "nft_ipv4_lo_drop_present"
              set: true
            - flag: "nft_ipv6_lo_drop_pass"
              set: true
        remediation: |
          # NOTE: Replace 'filter' with your nftables table name if different.
          # 1) Allow loopback interface traffic
          nft add rule inet filter input iif lo accept

          # 2) Drop traffic claiming to be from 127.0.0.0/8 that does not arrive on lo (anti-spoof)
          nft add rule inet filter input ip saddr 127.0.0.0/8 counter drop

          # 3) If IPv6 is enabled, drop traffic claiming to be from ::1 that does not arrive on lo
          #    (anti-spoof)
          if ! grep -Pqs '^\h*1\b' /sys/module/ipv6/parameters/disable; then
            nft add rule inet filter input ip6 saddr ::1 counter drop
          fi

          # TIP: Place the 'iif lo accept' rule before the drop rules to avoid breaking local services.
        scored: true

      - id: 3.4.3.6
        description: "Ensure nftables outbound and established connections are configured (Manual)"
        audit: |
          nft list ruleset | awk '/hook input/,/}/' | grep -E 'ip protocol (tcp|udp|icmp) ct state'
        type: manual
        remediation: |
          Configure nftables in accordance with site policy. The following commands will
          implement a policy to allow all outbound connections and all established connections:
            # nft add rule inet filter input ip protocol tcp ct state established accept
            # nft add rule inet filter input ip protocol udp ct state established accept
            # nft add rule inet filter input ip protocol icmp ct state established accept
            # nft add rule inet filter output ip protocol tcp ct state new,related,established accept
            # nft add rule inet filter output ip protocol udp ct state new,related,established accept
            # nft add rule inet filter output ip protocol icmp ct state new,related,established accept
        scored: false

      - id: 3.4.3.7
        description: "Ensure nftables default deny firewall policy (Automated)"
        audit: |
          # Check if base chains for input, forward, and output have default DROP policy
          nft list ruleset 2>/dev/null | grep -q 'hook input .* policy drop;' \
            && echo "nft_input_drop_policy" || echo "nft_input_accept_policy"

          nft list ruleset 2>/dev/null | grep -q 'hook forward .* policy drop;' \
            && echo "nft_forward_drop_policy" || echo "nft_forward_accept_policy"

          nft list ruleset 2>/dev/null | grep -q 'hook output .* policy drop;' \
            && echo "nft_output_drop_policy" || echo "nft_output_accept_policy"
        tests:
          test_items:
            - flag: "nft_input_drop_policy"
              set: true
            - flag: "nft_forward_drop_policy"
              set: true
            - flag: "nft_output_drop_policy"
              set: true
        remediation: |
          # IMPORTANT: Before applying drop policy, allow SSH and other required services to prevent lockout.
          # Example allow rule for SSH:
          # nft add rule inet filter input tcp dport 22 ct state new,established accept
          # nft add rule inet filter output ct state established accept

          # Set default DROP policy for input, forward, and output base chains
          nft chain inet filter input   { policy drop; }
          nft chain inet filter forward { policy drop; }
          nft chain inet filter output  { policy drop; }
        scored: true

      - id: 3.4.3.8
        description: "Ensure nftables service is enabled and active (Automated)"
        audit: |
          # Check if nftables service is enabled
          if systemctl is-enabled nftables.service 2>/dev/null | grep -q '^enabled$'; then
            echo "nftables_service_enabled"
          else
            echo "nftables_service_disabled"
          fi

          # Check if nftables service is active
          if systemctl is-active nftables.service 2>/dev/null | grep -q '^active$'; then
            echo "nftables_service_active"
          else
            echo "nftables_service_inactive"
          fi
        tests:
          test_items:
            - flag: "nftables_service_enabled"
              set: true
            - flag: "nftables_service_active"
              set: true
        remediation: |
          # Unmask the nftables service if masked
          systemctl unmask nftables.service

          # Enable and start the nftables service
          systemctl --now enable nftables.service
        scored: true

      - id: 3.4.3.9
        description: "Ensure nftables rules are permanent (Automated)"
        audit: |
          main_conf=""
          for f in /etc/sysconfig/nftables.conf /etc/nftables.conf; do
            [ -f "$f" ] && { main_conf="$f"; break; }
          done

          if [ -z "$main_conf" ]; then
            echo "nft_rules_file_missing"
            exit 0
          fi

          # Collect included files; if none, check the main file itself
          includes=$(awk '$1 ~ /^include$/ { gsub(/[";]/,"",$2); print $2 }' "$main_conf")
          [ -z "$includes" ] && includes="$main_conf"

          # Expand any globs
          all_files=""
          for path in $includes; do
            for p in $path; do [ -f "$p" ] && all_files="$all_files $p"; done
          done
          [ -z "$all_files" ] && { echo "nft_rules_file_missing"; exit 0; }

          found_input=0
          found_forward=0
          found_output=0

          for f in $all_files; do
            awk '/hook input/,/}/'   "$f" | grep -q 'hook input'   && found_input=1
            awk '/hook forward/,/}/' "$f" | grep -q 'hook forward' && found_forward=1
            awk '/hook output/,/}/'  "$f" | grep -q 'hook output'  && found_output=1
          done

          [ $found_input -eq 1 ]   || echo "nft_persistent_input_missing"
          [ $found_forward -eq 1 ] || echo "nft_persistent_forward_missing"
          [ $found_output -eq 1 ]  || echo "nft_persistent_output_missing"

          if [ $found_input -eq 1 ] && [ $found_forward -eq 1 ] && [ $found_output -eq 1 ]; then
            echo "nft_persistent_ok"
          fi
        tests:
          test_items:
            - flag: "nft_persistent_ok"
              set: true
        remediation: |
          # Edit /etc/sysconfig/nftables.conf to include your nftables rules file:
          # Example:
          # include "/etc/nftables/nftables.rules"

          # Ensure the referenced rules file contains base chains for input, forward, and output
          # with appropriate policies and rules according to local site policy.

          # Example input chain:
          # chain input {
          #   type filter hook input priority 0; policy drop;
          #   iif "lo" accept
          #   ip saddr 127.0.0.0/8 counter drop
          #   ip6 saddr ::1 counter drop
          #   tcp dport ssh accept
          #   ip protocol tcp ct state established accept
          #   ip protocol udp ct state established accept
          #   ip protocol icmp ct state established accept
          # }

          # Example forward chain:
          # chain forward {
          #   type filter hook forward priority 0; policy drop;
          # }

          # Example output chain:
          # chain output {
          #   type filter hook output priority 0; policy drop;
          #   ip protocol tcp ct state established,related,new accept
          #   ip protocol udp ct state established,related,new accept
          #   ip protocol icmp ct state established,related,new accept
          # }
        scored: true
      - id: 3.4.4
        description: "Configure iptables"
        type: "skip"
        checks:
      - id: 3.4.4.1
        description: "Configure iptables software"
        type: "skip"
        checks:
      - id: 3.4.4.1.1
        description: "Ensure iptables packages are installed (Automated)"
        audit: "rpm -q iptables iptables-services"
        tests:
          bin_op: and
          test_items:
            - flag: "package iptables is not installed"
              set: false
            - flag: "package iptables-services is not installed"
              set: false
        remediation: |
          Run the following command to install iptables and iptables-services
            # yum install iptables iptables-services
        scored: true

      - id: 3.4.4.2
        description: "Configure iptables"
        type: "skip"
        checks:
      - id: 3.4.4.2.1
        description: "Ensure iptables loopback traffic is configured (Automated)"
        audit: |
          # Check INPUT chain for loopback accept rule
          if iptables -C INPUT -i lo -j ACCEPT 2>/dev/null; then
            echo "iptables_input_lo_accept_ok"
          else
            echo "iptables_input_lo_accept_missing"
          fi

          # Check OUTPUT chain for loopback accept rule
          if iptables -C OUTPUT -o lo -j ACCEPT 2>/dev/null; then
            echo "iptables_output_lo_accept_ok"
          else
            echo "iptables_output_lo_accept_missing"
          fi

          # Check INPUT chain for dropping spoofed loopback traffic from other interfaces
          if iptables -C INPUT -s 127.0.0.0/8 -j DROP 2>/dev/null; then
            echo "iptables_input_lo_drop_ok"
          else
            echo "iptables_input_lo_drop_missing"
          fi
        tests:
          test_items:
            - flag: "iptables_input_lo_accept_ok"
              set: true
            - flag: "iptables_output_lo_accept_ok"
              set: true
            - flag: "iptables_input_lo_drop_ok"
              set: true
        remediation: |
          # Allow loopback interface traffic
          iptables -A INPUT -i lo -j ACCEPT
          iptables -A OUTPUT -o lo -j ACCEPT

          # Drop traffic claiming to be from loopback network that does not arrive on lo
          iptables -A INPUT -s 127.0.0.0/8 -j DROP
        scored: true

      - id: 3.4.4.2.2
        description: "Ensure iptables outbound and established connections are configured (Manual)"
        audit: |
          iptables -L -v -n
        type: manual
        remediation: |
          Configure iptables in accordance with site policy. The following commands will
          implement a policy to allow all outbound connections and all established connections:
            # iptables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
            # iptables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
            # iptables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT
            # iptables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
            # iptables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
            # iptables -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT
        scored: true

      - id: 3.4.4.2.3
        description: "Ensure iptables rules exist for all open ports (Automated)"
        audit: |
          # List open TCP/UDP ports listening on non-loopback interfaces
          open_ports=$(ss -4tuln | awk 'NR>1 && $4 !~ /127\.0\.0\.1/ {split($4,a,":"); print a[2], $1}' | sort -u)

          for entry in $open_ports; do
            port=$(echo $entry | cut -d',' -f1)
            proto=$(echo $entry | cut -d',' -f2)
            if iptables -L INPUT -v -n | grep -Eq "$proto.*dpt:$port"; then
              echo "iptables_rule_for_${proto}_${port}_ok"
            else
              echo "iptables_rule_for_${proto}_${port}_missing"
            fi
          done
        tests:
          test_items:
            # Example for SSH, adjust according to your systems open ports
            - flag: "iptables_rule_for_tcp_22_ok"
              set: true
        remediation: |
          # For each missing open port rule, add an iptables ACCEPT rule.
          # Replace <protocol> and <port> with actual values from your audit.
          iptables -A INPUT -p <protocol> --dport <port> -m state --state NEW -j ACCEPT

          # Example for SSH:
          # iptables -A INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT
        scored: true

      - id: 3.4.4.2.4
        description: "Ensure iptables default deny firewall policy (Automated)"
        audit: |
          # Check default policy for INPUT chain
          if iptables -S INPUT 2>/dev/null | grep -Eq '^-P INPUT (DROP|REJECT)$'; then
            echo "iptables_input_policy_deny_ok"
          else
            echo "iptables_input_policy_deny_bad"
          fi

          # Check default policy for OUTPUT chain
          if iptables -S OUTPUT 2>/dev/null | grep -Eq '^-P OUTPUT (DROP|REJECT)$'; then
            echo "iptables_output_policy_deny_ok"
          else
            echo "iptables_output_policy_deny_bad"
          fi

          # Check default policy for FORWARD chain
          if iptables -S FORWARD 2>/dev/null | grep -Eq '^-P FORWARD (DROP|REJECT)$'; then
            echo "iptables_forward_policy_deny_ok"
          else
            echo "iptables_forward_policy_deny_bad"
          fi
        tests:
          test_items:
            - flag: "iptables_input_policy_deny_ok"
              set: true
            - flag: "iptables_output_policy_deny_ok"
              set: true
            - flag: "iptables_forward_policy_deny_ok"
              set: true
        remediation: |
          # Set default policy to DROP for all main chains
          iptables -P INPUT DROP
          iptables -P OUTPUT DROP
          iptables -P FORWARD DROP
        scored: true

      - id: 3.4.4.2.5
        description: "Ensure iptables rules are saved (Automated)"
        audit: |
          if [ -f /etc/sysconfig/iptables ] && [ -s /etc/sysconfig/iptables ]; then
            if grep -q '^COMMIT' /etc/sysconfig/iptables; then
              echo "iptables_rules_saved_ok"
            else
              echo "iptables_rules_saved_no_commit"
            fi
          else
            echo "iptables_rules_saved_missing_or_empty"
          fi
        tests:
          test_items:
            - flag: "iptables_rules_saved_ok"
              set: true
        remediation: |
          # Review the current running iptables configuration
          iptables -L

          # If the ruleset is correct and complete, save it to /etc/sysconfig/iptables
          service iptables save
        scored: true

      - id: 3.4.4.2.6
        description: "Ensure iptables service is enabled and active (Automated)"
        audit: |
          # Check if iptables service is enabled
          if systemctl is-enabled iptables.service 2>/dev/null | grep -q '^enabled$'; then
            echo "iptables_service_enabled"
          else
            echo "iptables_service_disabled"
          fi

          # Check if iptables service is active
          if systemctl is-active iptables.service 2>/dev/null | grep -q '^active$'; then
            echo "iptables_service_active"
          else
            echo "iptables_service_inactive"
          fi
        tests:
          test_items:
            - flag: "iptables_service_enabled"
              set: true
            - flag: "iptables_service_active"
              set: true
        remediation: |
          # Unmask iptables service in case it has been masked
          systemctl unmask iptables.service

          # Enable and start iptables service
          systemctl --now enable iptables.service
        scored: true

      - id: 3.4.4.3
        description: "Configure ip6tables"
        type: "skip"
        checks:
      - id: 3.4.4.3.1
        description: "Ensure ip6tables loopback traffic is configured (Automated)"
        audit: |
          # Check if IPv6 is enabled
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            input_lo_ok=0
            output_lo_ok=0
            drop_lo_ok=0

            # Check INPUT chain for loopback accept rule
            if ip6tables -C INPUT -i lo -j ACCEPT 2>/dev/null; then
              input_lo_ok=1
            else
              echo "ip6tables_input_lo_accept_missing"
            fi

            # Check OUTPUT chain for loopback accept rule
            if ip6tables -C OUTPUT -o lo -j ACCEPT 2>/dev/null; then
              output_lo_ok=1
            else
              echo "ip6tables_output_lo_accept_missing"
            fi

            # Check INPUT chain for dropping spoofed loopback traffic from other interfaces
            if ip6tables -C INPUT -s ::1 -j DROP 2>/dev/null; then
              drop_lo_ok=1
            else
              echo "ip6tables_input_lo_drop_missing"
            fi

            # If all three are present, print consolidated pass flag
            if [ $input_lo_ok -eq 1 ] && [ $output_lo_ok -eq 1 ] && [ $drop_lo_ok -eq 1 ]; then
              echo "ip6tables_lo_accept_pass"
            fi
          else
            echo "ipv6_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ip6tables_lo_accept_pass"
              set: true
            - flag: "ipv6_disabled"
              set: true
        remediation: |
          # If IPv6 is enabled, configure loopback traffic rules
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            ip6tables -A INPUT -i lo -j ACCEPT
            ip6tables -A OUTPUT -o lo -j ACCEPT
            ip6tables -A INPUT -s ::1 -j DROP
          fi
        scored: true

      - id: 3.4.4.3.2
        description: "Ensure ip6tables outbound and established connections are configured (Manual)"
        audit: "ip6tables -L -v -n"
        type: manual
        remediation: |
          Configure iptables in accordance with site policy. The following commands will
          implement a policy to allow all outbound connections and all established connections:
            # ip6tables -A OUTPUT -p tcp -m state --state NEW,ESTABLISHED -j ACCEPT
            # ip6tables -A OUTPUT -p udp -m state --state NEW,ESTABLISHED -j ACCEPT
            # ip6tables -A OUTPUT -p icmp -m state --state NEW,ESTABLISHED -j ACCEPT
            # ip6tables -A INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT
            # ip6tables -A INPUT -p udp -m state --state ESTABLISHED -j ACCEPT
            # ip6tables -A INPUT -p icmp -m state --state ESTABLISHED -j ACCEPT
        scored: false

      - id: 3.4.4.3.3
        description: "Ensure ip6tables firewall rules exist for all open ports (Automated)"
        audit: |
          # Check if IPv6 is enabled
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            # Get list of open IPv6 ports (excluding localhost-only)
            ss -6tuln | awk 'NR>1 && $5 !~ /\[::1\]/ {split($5,a,":"); print a[length(a)] "," $1}' | sort -u |
            while IFS=, read -r port proto; do
              if ip6tables -L INPUT -v -n | grep -Eq "$proto.*dpt:$port"; then
                echo "ip6tables_rule_for_${proto}_${port}_ok"
              else
                echo "ip6tables_rule_for_${proto}_${port}_missing"
              fi
            done
          else
            echo "ipv6_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ipv6_disabled"
              set: true
            - flag: "ip6tables_rule_for_tcp_22_ok"
              set: true
        remediation: |
          # If IPv6 is enabled, for each missing open port rule add an ACCEPT rule
          # Replace <protocol> and <port> with actual values found in audit
          ip6tables -A INPUT -p <protocol> --dport <port> -m state --state NEW -j ACCEPT

          # Example for SSH over IPv6:
          # ip6tables -A INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT
        scored: true

      - id: 3.4.4.3.4
        description: "Ensure ip6tables default deny firewall policy (Automated)"
        audit: |
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            input_ok=0
            output_ok=0
            forward_ok=0

            if ip6tables -S INPUT 2>/dev/null | grep -Eq '^-P INPUT (DROP|REJECT)$'; then
              input_ok=1
            fi
            if ip6tables -S OUTPUT 2>/dev/null | grep -Eq '^-P OUTPUT (DROP|REJECT)$'; then
              output_ok=1
            fi
            if ip6tables -S FORWARD 2>/dev/null | grep -Eq '^-P FORWARD (DROP|REJECT)$'; then
              forward_ok=1
            fi

            if [ $input_ok -eq 1 ] && [ $output_ok -eq 1 ] && [ $forward_ok -eq 1 ]; then
              echo "ip6tables_default_policy_pass"
            else
              echo "ip6tables_default_policy_fail"
            fi
          else
            echo "ipv6_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ip6tables_default_policy_pass"
              set: true
            - flag: "ipv6_disabled"
              set: true
        remediation: |
          # If IPv6 is enabled, set default policy to DROP for all main chains
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            ip6tables -P INPUT DROP
            ip6tables -P OUTPUT DROP
            ip6tables -P FORWARD DROP
          fi
        scored: true

      - id: 3.4.4.3.5
        description: "Ensure ip6tables rules are saved (Automated)"
        audit: |
          # Check if IPv6 is enabled
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            # Verify /etc/sysconfig/ip6tables exists and is not empty
            if [ -s /etc/sysconfig/ip6tables ]; then
              echo "ip6tables_rules_saved"
            else
              echo "ip6tables_rules_not_saved"
            fi
          else
            echo "ipv6_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ip6tables_rules_saved"
              set: true
            - flag: "ipv6_disabled"
              set: true
        remediation: |
          # If IPv6 is enabled, review current ip6tables configuration
          ip6tables -L

          # If rules are correct and complete, save them to /etc/sysconfig/ip6tables
          service ip6tables save
        scored: true

      - id: 3.4.4.3.6
        description: "Ensure ip6tables is enabled and active (Automated)"
        audit: |
          # Check if IPv6 is enabled
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            svc_enabled=0
            svc_active=0

            # Check if ip6tables service is enabled
            if systemctl is-enabled ip6tables.service 2>/dev/null | grep -q '^enabled$'; then
              svc_enabled=1
            else
              echo "ip6tables_service_disabled"
            fi

            # Check if ip6tables service is active
            if systemctl is-active ip6tables.service 2>/dev/null | grep -q '^active$'; then
              svc_active=1
            else
              echo "ip6tables_service_inactive"
            fi

            # Pass only if both conditions are met
            if [ $svc_enabled -eq 1 ] && [ $svc_active -eq 1 ]; then
              echo "ip6tables_service_pass"
            fi
          else
            echo "ipv6_disabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ip6tables_service_pass"
              set: true
            - flag: "ipv6_disabled"
              set: true
        remediation: |
          # If IPv6 is enabled, unmask, enable, and start the ip6tables service
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
            systemctl unmask ip6tables.service
            systemctl --now enable ip6tables.service
          fi
        scored: true

  - id: 4
    description: "Access, Authentication and Authorization"
    checks:
  - id: 4.1
    description: "Configure job schedulers"
    checks:
      - id: 4.1.1
        description: "Configure cron"
        type: "skip"
        checks:
      - id: 4.1.1.1
        description: "Ensure cron daemon is enabled and active (Automated)"
        audit: |
          # Check if crond service is enabled
          if systemctl is-enabled crond 2>/dev/null | grep -q '^enabled$'; then
            echo "crond_service_enabled"
          else
            echo "crond_service_disabled"
          fi

          # Check if crond service is active
          if systemctl is-active crond 2>/dev/null | grep -q '^active$'; then
            echo "crond_service_active"
          else
            echo "crond_service_inactive"
          fi
        tests:
          test_items:
            - flag: "crond_service_enabled"
              set: true
            - flag: "crond_service_active"
              set: true
        remediation: |
          # Unmask the cron service in case it is masked
          systemctl unmask crond

          # Enable and start the cron service
          systemctl --now enable crond
        scored: true

      - id: 4.1.1.2
        description: "Ensure permissions on /etc/crontab are configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/crontab)
          owner=$(stat -Lc '%u' /etc/crontab)
          group=$(stat -Lc '%g' /etc/crontab)

          if [ "$perms" -le 600 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "crontab_perms_ok"
          else
            echo "crontab_perms_bad"
          fi
        tests:
          test_items:
            - flag: "crontab_perms_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/crontab
          chown root:root /etc/crontab
          chmod og-rwx /etc/crontab
        scored: true

      - id: 4.1.1.3
        description: "Ensure permissions on /etc/cron.hourly are configured (Automated)"
        audit: |
          if stat -L /etc/cron.hourly | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_hourly_permission_ok"
          else
            echo "cron_hourly_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_hourly_permission_ok"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/cron.hourly
          chown root:root /etc/cron.hourly
          chmod og-rwx /etc/cron.hourly
        scored: true

      - id: 4.1.1.4
        description: "Ensure permissions on /etc/cron.daily are configured (Automated)"
        audit: |
          if stat -L /etc/cron.daily | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_daily_permission_ok"
          else
          echo "cron_daily_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_daily_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.daily :

            # chown root:root /etc/cron.daily

            # chmod og-rwx /etc/cron.daily
        scored: true

      - id: 4.1.1.5
        description: "Ensure permissions on /etc/cron.weekly are configured (Automated)"
        audit: |
          if stat -L /etc/cron.weekly | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_weekly_permission_ok"
          else
          echo "cron_weekly_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_weekly_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.weekly :

            # chown root:root /etc/cron.weekly

            # chmod og-rwx /etc/cron.weekly
        scored: true

      - id: 4.1.1.6
        description: "Ensure permissions on /etc/cron.monthly are configured (Automated)"
        audit: |
          if stat -L /etc/cron.monthly | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_monthly_permission_ok"
          else
          echo "cron_monthly_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_monthly_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.monthly :

            # chown root:root /etc/cron.monthly

            # chmod og-rwx /etc/cron.monthly
        scored: true

      - id: 4.1.1.7
        description: "Ensure permissions on /etc/cron.d are configured (Automated)"
        audit: |
          if stat -L /etc/cron.d | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_d_permission_ok"
          else
          echo "cron_d_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_d_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.d :

            # chown root:root /etc/cron.d

            # chmod og-rwx /etc/cron.d
        scored: true

      - id: 4.1.1.8
        description: "Ensure crontab is restricted to authorized users (Automated)"
        audit: |
          perm_ok() {
            # ok if perms are <= 0640 (u<=6, g<=4, o==0) and owned by root:root
            local f="$1"
            [ -e "$f" ] || return 1
            local p o g
            p="$(stat -Lc %a "$f")" || return 1
            o="$(stat -Lc %U "$f")" || return 1
            g="$(stat -Lc %G "$f")" || return 1
            [[ "$p" =~ ^[0-6][0-4]0$ ]] && [ "$o" = "root" ] && [ "$g" = "root" ]
          }
          if [ -e /etc/cron.allow ] && perm_ok /etc/cron.allow && { [ ! -e /etc/cron.deny ] || perm_ok /etc/cron.deny; }; then
            echo "crontab_restricted_ok"
          else
            echo "crontab_restricted_bad"
          fi
        tests:
          test_items:
            - flag: "crontab_restricted_ok"
              set: true
        remediation: |
          # Ensure /etc/cron.allow exists and is root:root with 0640 or more restrictive
          [ ! -e "/etc/cron.allow" ] && touch /etc/cron.allow
          chown root:root /etc/cron.allow
          chmod u-x,g-wx,o-rwx /etc/cron.allow

          # If /etc/cron.deny exists, ensure root:root with 0640 or more restrictive
          if [ -e "/etc/cron.deny" ]; then
            chown root:root /etc/cron.deny
            chmod u-x,g-wx,o-rwx /etc/cron.deny
          fi
        scored: true

      - id: 4.1.2
        description: "Configure at"
        type: "skip"
        checks:
      - id: 4.1.2.1
        description: "Ensure at is restricted to authorized users (Automated)"
        audit: |
          if [ -e /etc/at.allow ] && stat -L /etc/at.allow | grep -qE 'Access:\s+\(0640/-rw-r-----\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*(root|daemon)\)'; then
            if [ ! -e /etc/at.deny ] || stat -L /etc/at.deny | grep -qE 'Access:\s+\(0640/-rw-r-----\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*(root|daemon)\)'; then
              echo "at_authorized_users_ok"
            else
              echo "at_authorized_users_bad"
            fi
          else
            echo "at_authorized_users_bad"
          fi
        tests:
          test_items:
            - flag: "at_authorized_users_ok"
              set: true
        remediation: |
          IF the 'at' utility is installed on the system:

          Run the following commands to configure ownership and permissions:

             if getent group daemon >/dev/null 2>&1; then g="daemon"; else g="root"; fi

             [ ! -e /etc/at.allow ] && touch /etc/at.allow
             chown root:$g /etc/at.allow
             chmod 640 /etc/at.allow

             if [ -e /etc/at.deny ]; then
               chown root:$g /etc/at.deny
               chmod 640 /etc/at.deny
             fi
        scored: true

  - id: 4.2
    description: "Configure SSH Server"
    checks:
      - id: 4.2.1
        description: "Ensure permissions on /etc/ssh/sshd_config are configured (Automated)"
        audit: |
          if [ -e /etc/ssh/sshd_config ] && stat -L /etc/ssh/sshd_config | grep -qE 'Access:\s+\(0600/-rw-------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            if [ ! -d /etc/ssh/sshd_config.d ] || ! find /etc/ssh/sshd_config.d -type f -name "*.conf" \
              ! -exec stat -L {} \; | grep -qvE 'Access:\s+\(0600/-rw-------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
              echo "sshd_config_permissions_ok"
            else
              echo "sshd_config_permissions_bad"
            fi
          else
            echo "sshd_config_permissions_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_config_permissions_ok"
              set: true
        remediation: |
          Set ownership and permissions on /etc/ssh/sshd_config
          chmod u-x,og-rwx /etc/ssh/sshd_config
          chown root:root /etc/ssh/sshd_config

           Set ownership and permissions on any .conf files in /etc/ssh/sshd_config.d
          if [ -d /etc/ssh/sshd_config.d ]; then
            find /etc/ssh/sshd_config.d -type f -name '*.conf' -exec chmod u-x,og-rwx {} \; -exec chown root:root {} \;
          fi
        scored: true

      - id: 4.2.2
        description: "Ensure permissions on SSH private host key files are configured (Automated)"
        audit: |
          if ls /etc/ssh/ssh_host_*_key >/dev/null 2>&1; then
            if ! stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/ssh/ssh_host_*_key \
              | grep -Ev '^(Access:\s+\(([0-7])00/.*\)\s+Owner:\s+\(root\)\s+Group:\s+\(root\))$|^(Access:\s+\(([0-7])[04]0/.*\)\s+Owner:\s+\(root\)\s+Group:\s+\((ssh_keys|_?ssh)\))$' >/dev/null; then
              echo "ssh_hostkeys_permissions_ok"
            else
              echo "ssh_hostkeys_permissions_bad"
            fi
          else
            echo "ssh_hostkeys_permissions_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_hostkeys_permissions_ok"
              set: true
        remediation: |
          If a dedicated ssh host-keys group exists, allow group-read (0640). Otherwise lock to 0600 with group root.
          if getent group ssh_keys >/dev/null 2>&1; then
            find /etc/ssh -maxdepth 1 -type f -name 'ssh_host_*_key' -exec chown root:ssh_keys {} \; -exec chmod u-x,go-rwx {} \; -exec chmod g+r {} \;
          elif getent group _ssh >/dev/null 2>&1; then
            find /etc/ssh -maxdepth 1 -type f -name 'ssh_host_*_key' -exec chown root:_ssh {} \; -exec chmod u-x,go-rwx {} \; -exec chmod g+r {} \;
          else
            find /etc/ssh -maxdepth 1 -type f -name 'ssh_host_*_key' -exec chown root:root {} \; -exec chmod u-x,go-rwx {} \;
          fi
        scored: true

      - id: 4.2.3
        description: "Ensure permissions on SSH public host key files are configured (Automated)"
        audit: |
          if ls /etc/ssh/ssh_host_*_key.pub >/dev/null 2>&1; then
            stat -Lc '%n^%a^%U^%G' /etc/ssh/ssh_host_*_key.pub \
              | awk -F'^' '($3!="root" || $4!="root" || $2>644){bad=1} END{print bad?"ssh_pubkey_permissions_bad":"ssh_pubkey_permissions_ok"}'
          else
            echo "ssh_pubkey_permissions_bad"
          fi
        tests:
          test_items:
            - flag: "ssh_pubkey_permissions_ok"
              set: true
        remediation: |
          Set correct owner/group and restrict permissions on SSH public host keys
          if ls /etc/ssh/ssh_host_*_key.pub >/dev/null 2>&1; then
            chown root:root /etc/ssh/ssh_host_*_key.pub
            chmod u-x,go-wx /etc/ssh/ssh_host_*_key.pub
          fi
        scored: true

      - id: 4.2.4
        description: "Ensure sshd access is configured (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Pi '^\s*(allow|deny)(users|groups)\s+\S+' >/dev/null; then
            echo "sshd_access_controls_configured"
          else
            echo "sshd_access_controls_missing"
          fi
        tests:
          test_items:
            - flag: "sshd_access_controls_configured"
              set: true
        remediation: |
          Configure at least one of the following (above any Match blocks) in /etc/ssh/sshd_config:
             AllowUsers <user1> <user2> ...
             AllowGroups <group1> <group2> ...
             DenyUsers  <user1> <user2> ...
             DenyGroups <group1> <group2> ...

           Then reload sshd:
          systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.5
        description: "Ensure sshd Banner is configured (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Pi '^banner\s+/[^ ]+' >/dev/null && \
             ! grep -Pi '^\s*Banner\s+"?none\b' /etc/ssh/sshd_config >/dev/null; then
            echo "sshd_banner_configured"
          else
            echo "sshd_banner_not_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_banner_configured"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set the Banner parameter above any Match entries:
             Banner /etc/issue.net

           Ensure /etc/issue.net contains your site's legal notice.

           Then reload sshd to apply changes:
          systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.6
        description: "Ensure sshd Ciphers are configured (Automated)"
        audit: |
          sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | cut -d ' ' -f1)" | grep -Pi '^ciphers\h+\"?([^#\n\r]+,)?((3des|blowfish|cast128|aes(128|192|256))- cbc|arcfour(128|256)?|rijndael-cbc@lysator\.liu\.se)\b'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/ssh/sshd_config and configure only strong ciphers.
           Recommended:
             Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr

           Remove any weak ciphers such as:
             3des-cbc, aes*-cbc, arcfour, blowfish-cbc, cast128-cbc, rijndael-cbc@lysator.liu.se

           Then reload sshd:
          systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.7
        description: "Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured (Automated)"
        audit: |
          interval="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^clientaliveinterval/ {print $2}')"
          countmax="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^clientalivecountmax/ {print $2}')"

          fail=0

          # Interval must be >0
          if [ -n "$interval" ] && [ "$interval" -gt 0 ]; then
            echo "sshd_clientaliveinterval_ok"
          else
            echo "sshd_clientaliveinterval_bad"
            fail=1
          fi

          # CountMax must be >0
          if [ -n "$countmax" ] && [ "$countmax" -gt 0 ]; then
            echo "sshd_clientalivecountmax_ok"
          else
            echo "sshd_clientalivecountmax_bad"
            fail=1
          fi

          if [ $fail -eq 0 ]; then
            echo "sshd_clientalive_ok"
          fi
        tests:
          test_items:
            - flag: "sshd_clientalive_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the parameters above any Match entries:
            ClientAliveInterval 15
            ClientAliveCountMax 3

          Adjust values according to your site policy to prevent resource exhaustion.

          Then reload sshd to apply changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.8
        description: "Ensure sshd DisableForwarding is enabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*disableforwarding\s+yes$'; then
            echo "sshd_disableforwarding_ok"
          else
            echo "sshd_disableforwarding_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_disableforwarding_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the following parameter above any Match entries:
            DisableForwarding yes

          Then reload the SSH daemon to apply the changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.9
        description: "Ensure sshd GSSAPIAuthentication is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*gssapiauthentication\s+no$' && \
             ! grep -Psi '^\s*GSSAPIAuthentication\s+"?yes\b' /etc/ssh/sshd_config >/dev/null; then
            echo "sshd_gssapi_disabled_ok"
          else
            echo "sshd_gssapi_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_gssapi_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the following parameter above any Match entries:
            GSSAPIAuthentication no

          Then reload the SSH daemon to apply the changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.10
        description: "Ensure sshd HostbasedAuthentication is disabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*hostbasedauthentication\s+no$' && \
             ! grep -Psi '^\s*HostbasedAuthentication\s+"?yes\b' /etc/ssh/sshd_config >/dev/null; then
            echo "sshd_hostbased_disabled_ok"
          else
            echo "sshd_hostbased_disabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_hostbased_disabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the following parameter above any Match entries:
            HostbasedAuthentication no

          Then reload the SSH daemon to apply the changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.11
        description: "Ensure sshd IgnoreRhosts is enabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq '^\s*ignorerhosts\s+yes$'; then
            echo "sshd_ignorerhosts_enabled_ok"
          else
            echo "sshd_ignorerhosts_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_ignorerhosts_enabled_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the following parameter above any Match entries:
            IgnoreRhosts yes

          Then reload the SSH daemon to apply the changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.12
        description: "Ensure sshd KexAlgorithms is configured (Automated)"
        audit: |
          if ! sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
              | grep -Piq 'kexalgorithms\s+([^#\n\r]+,)?(diffie-hellman-group1-sha1|diffie-hellman-group14-sha1|diffie-hellman-group-exchange-sha1)\b'; then
            echo "sshd_kexalgorithms_ok"
          else
            echo "sshd_kexalgorithms_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_kexalgorithms_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and configure the KexAlgorithms parameter to use only strong, site-approved algorithms.
          For example:
            KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256

          Remove any weak algorithms:
            diffie-hellman-group1-sha1
            diffie-hellman-group14-sha1
            diffie-hellman-group-exchange-sha1

          After making changes, reload the SSH daemon:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.13
        description: "Ensure sshd LoginGraceTime is configured (Automated)"
        audit: |
          lg_time=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | grep -i '^logingracetime' | awk '{print $2}')
          if [ -n "$lg_time" ] && [ "$lg_time" -ge 1 ] && [ "$lg_time" -le 60 ]; then
            echo "sshd_logingracetime_ok"
          else
            echo "sshd_logingracetime_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_logingracetime_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the LoginGraceTime parameter to a value between 1 and 60 seconds, based on site policy:
            LoginGraceTime 60

          Then reload the SSH daemon:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.14
        description: "Ensure sshd LogLevel is configured (Automated)"
        audit: |
          log_level=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^loglevel/ {print $2}')
          if [ "$log_level" = "INFO" ] || [ "$log_level" = "VERBOSE" ]; then
            echo "sshd_loglevel_ok"
          else
            echo "sshd_loglevel_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_loglevel_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and set the LogLevel parameter to either INFO or VERBOSE above any Match entries:

            LogLevel VERBOSE
          or:
            LogLevel INFO

          Then reload the SSH daemon to apply changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.15
        description: "Ensure sshd MACs are configured (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null \
            | grep -Piq 'macs\s+([^#\n\r]+,)?(hmac-md5|hmac-md5-96|hmac-ripemd160|hmac-sha1-96|umac-64@openssh\.com|hmac-md5-etm@openssh\.com|hmac-md5-96-etm@openssh\.com|hmac-ripemd160-etm@openssh\.com|hmac-sha1-etm@openssh\.com|hmac-sha1-96-etm@openssh\.com|umac-64-etm@openssh\.com)' ; then
            echo "sshd_macs_bad"
          else
            echo "sshd_macs_ok"
          fi
        tests:
          test_items:
            - flag: "sshd_macs_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and configure only strong MAC algorithms.
          Example (recommended strong set):
            MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256

          Then reload sshd to apply changes:
            # systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.16
        description: "Ensure sshd MaxAuthTries is configured (Automated)"
        audit: |
          mat_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxauthtries\>/ {print $2}')"
          if [ -n "$mat_val" ] && [ "$mat_val" -le 4 ] && \
             ! grep -Pis '^\s*MaxAuthTries\s+"?([5-9]|[1-9][0-9]+)\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_maxauthtries_ok"
          else
            echo "sshd_maxauthtries_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxauthtries_ok"
              set: true
        remediation: |
           Set MaxAuthTries to 4 or fewer (above any Match blocks) in /etc/ssh/sshd_config, e.g.:
             MaxAuthTries 4

           Then reload sshd to apply:
             systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.17
        description: "Ensure sshd MaxSessions is configured (Automated)"
        audit: |
          ms_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxsessions\>/ {print $2}')"
          if [ -n "$ms_val" ] && [ "$ms_val" -le 10 ] && \
             ! grep -Pis '^\s*MaxSessions\s+"?(1[1-9]|[2-9][0-9]|[1-9][0-9]{2,})\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_maxsessions_ok"
          else
            echo "sshd_maxsessions_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxsessions_ok"
              set: true
        remediation: |
           Set MaxSessions to 10 or fewer (place above any Match blocks) in /etc/ssh/sshd_config, e.g.:
             MaxSessions 10

           Then reload sshd to apply:
             systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.18
        description: "Ensure sshd MaxStartups is configured (Automated)"
        audit: |
          msu_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^maxstartups\>/ {print $2}')"
          if [ -n "$msu_val" ]; then
            # Extract values in the format "start:rate:full"
            start=$(echo "$msu_val" | cut -d: -f1)
            rate=$(echo "$msu_val" | cut -d: -f2)
            full=$(echo "$msu_val" | cut -d: -f3)

            if [ "$start" -le 10 ] && [ "$rate" -le 30 ] && [ "$full" -le 60 ]; then
              echo "sshd_maxstartups_ok"
            else
              echo "sshd_maxstartups_bad"
            fi
          else
            echo "sshd_maxstartups_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_maxstartups_ok"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set MaxStartups to 10:30:60 or more restrictive, e.g.:
            MaxStartups 10:30:60

          Place the setting above any Match blocks, then reload sshd to apply:
            systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.19
        description: "Ensure sshd PermitEmptyPasswords is disabled (Automated)"
        audit: |
          pep_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^permitemptypasswords\>/ {print $2}')"
          if [ "$pep_val" = "no" ] && \
             ! grep -Psi '^\s*PermitEmptyPasswords\s+"?yes\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_permitemptypasswords_ok"
          else
            echo "sshd_permitemptypasswords_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permitemptypasswords_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set PermitEmptyPasswords to "no" above any Match blocks, e.g.:
            PermitEmptyPasswords no

          Then reload sshd to apply:
            systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.20
        description: "Ensure sshd PermitRootLogin is disabled (Automated)"
        audit: |
          prl_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^permitrootlogin\>/ {print $2}')"
          if [ "$prl_val" = "no" ] && \
             ! grep -Psi '^\s*PermitRootLogin\s+"?(yes|prohibit-password|forced-commands-only)\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_permitrootlogin_ok"
          else
            echo "sshd_permitrootlogin_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permitrootlogin_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set PermitRootLogin to "no" above any Match blocks, e.g.:
            PermitRootLogin no

          Then reload sshd to apply:
            systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.21
        description: "Ensure sshd PermitUserEnvironment is disabled (Automated)"
        audit: |
          pue_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^permituserenvironment\>/ {print $2}')"
          if [ "$pue_val" = "no" ] && \
             ! grep -Psi '^\s*PermitUserEnvironment\s+"?yes\b' /etc/ssh/sshd_config >/dev/null 2>&1; then
            echo "sshd_permituserenvironment_ok"
          else
            echo "sshd_permituserenvironment_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_permituserenvironment_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set PermitUserEnvironment to "no" above any Match blocks, e.g.:
            PermitUserEnvironment no

          Then reload sshd to apply:
            systemctl reload-or-try-restart sshd.service
        scored: true

      - id: 4.2.22
        description: "Ensure sshd UsePAM is enabled (Automated)"
        audit: |
          up_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | awk '/^usepam\>/ {print $2}')"
          if [ "$up_val" = "yes" ]; then
            echo "sshd_usepam_ok"
          else
            echo "sshd_usepam_bad"
          fi
        tests:
          test_items:
            - flag: "sshd_usepam_ok"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set UsePAM to "yes" above any Match blocks, e.g.:
            UsePAM yes

          Then reload sshd to apply:
            systemctl reload-or-try-restart sshd.service
        scored: true

  - id: 4.3
    description: "Configure privilege escalation"
    checks:
      - id: 4.3.1
        description: "Ensure sudo is installed (Automated)"
        audit: "rpm -q sudo"
        tests:
          test_items:
            - flag: "package sudo is not installed"
              set: false
        remediation: |
          Run the following command to install sudo

          # yum install sudo
        scored: true

      - id: 4.3.2
        description: "Ensure sudo commands use pty (Automated)"
        audit: |
          grep -rPi '^\h*Defaults\h+([^#\n\r]+,)?use_pty(,\h*\h+\h*)*\h*(#.*)?$' /etc/sudoers*
        tests:
          test_items:
            - flag: "use_pty"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f <PATH_TO_FILE> and add the following line:

          Defaults use_pty
          Note:

          sudo will read each file in /etc/sudoers.d, skipping file names that end in ~ or contain a . character to avoid causing problems with package manager or editor temporary/backup files.
          Files are parsed in sorted lexical order. That is, /etc/sudoers.d/01_first will be parsed before /etc/sudoers.d/10_second.
          Be aware that because the sorting is lexical, not numeric, /etc/sudoers.d/1_whoops would be loaded after /etc/sudoers.d/10_second.
          Using a consistent number of leading zeroes in the file names can be used to avoid such problems.
        scored: true

      - id: 4.3.3
        description: "Ensure sudo log file exists (Automated)"
        audit: |
          grep -rPsi "^\h*Defaults\h+([^#]+,\h*)?logfile\h*=\h*(\"|\')?\H+(\"|\')?(,\h*\H+\h*)*\h*(#.*)?$" /etc/sudoers*
        tests:
          test_items:
            - flag: "logfile"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f <PATH_TO_FILE> and add the following line:

          Defaults logfile="/var/log/sudo.log"

          Note:

          sudo will read each file in /etc/sudoers.d, skipping file names that end in ~ or contain a . character to avoid causing problems with package manager or editor temporary/backup files.
          Files are parsed in sorted lexical order. That is, /etc/sudoers.d/01_first will be parsed before /etc/sudoers.d/10_second.
          Be aware that because the sorting is lexical, not numeric, /etc/sudoers.d/1_whoops would be loaded after /etc/sudoers.d/10_second.
          Using a consistent number of leading zeroes in the file names can be used to avoid such problems.
        scored: true

      - id: 4.3.4
        description: "Ensure users must provide password for escalation (Automated)"
        audit: |
          if grep -r "^[^#].*NOPASSWD" /etc/sudoers* 2>/dev/null | grep -vE '^\s*#' >/dev/null; then
            echo "sudo_nopasswd_bad"
          else
            echo "sudo_nopasswd_ok"
          fi
        tests:
          test_items:
            - flag: "sudo_nopasswd_ok"
              set: true
        remediation: |
          Edit the relevant sudoers file(s) using visudo (or visudo -f <PATH TO FILE>)
          and remove any lines that contain the NOPASSWD tag.

          Example of an insecure entry to remove:
            %admin ALL=(ALL) NOPASSWD: ALL

          Ensure users are required to enter their password for privilege escalation.
        scored: true

      - id: 4.3.5
        description: "Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
        audit: |
          grep -r "^[^#].*\!authenticate" /etc/sudoers /etc/sudoers.d 2>/dev/null
        tests:
          test_items:
            - flag: "!authenticate"
              set: false
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with:

          visudo -f <PATH_TO_FILE>

          Remove any line that includes the `!authenticate` tag to ensure users must re-authenticate for privilege escalation.

          Example of what to **remove**:

            %admin ALL=(ALL) NOPASSWD: ALL, !authenticate

          Note:

          Improper editing of sudoers files can lock you out of sudo access. Always use visudo to validate syntax.
        scored: true

      - id: 4.3.6
        description: "Ensure sudo authentication timeout is configured correctly (Automated)"
        audit: |
          timeout=$(grep -roP "timestamp_timeout=\K-?[0-9]+" /etc/sudoers* 2>/dev/null | head -n 1)

          if [ -z "$timeout" ]; then
            timeout=$(sudo -V | grep -i "Authentication timestamp timeout:" | awk -F ':' '{print $2}' | awk '{print int($1)}')
          fi

          if [ -z "$timeout" ]; then
            echo "timestamp timeout: not set"
          elif [ "$timeout" -le 15 ] && [ "$timeout" -ge 0 ]; then
            echo "timestamp timeout: ok"
          else
            echo "timestamp timeout: bad"
          fi
        tests:
          test_items:
            - flag: "timestamp timeout: ok"
              set: true
        remediation: |
          Edit the file /etc/sudoers or a file in /etc/sudoers.d/ using visudo:

            visudo -f /etc/sudoers
            OR
            visudo -f /etc/sudoers.d/<filename>

          Set the timeout value to 15 minutes or less using one of the following:

            Defaults    timestamp_timeout=15
            OR
            Defaults    env_reset, timestamp_timeout=15

          Note:
          - A value of `-1` disables the timeout and is **non-compliant**.
          - Always use `visudo` to avoid syntax errors that may lock you out.
        scored: true


      - id: 4.3.7
        description: "Ensure access to the su command is restricted (Automated)"
        audit: |
          su_line="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_wheel\.so\s+([^#\n\r]+\s+)?(use_uid|group=\S+)\s+([^#\n\r]+\s+)?(use_uid|group=\S+)\b' /etc/pam.d/su 2>/dev/null)"
          if [ -n "$su_line" ]; then
            su_group="$(echo "$su_line" | grep -oP 'group=\K\S+')"
            if [ -n "$su_group" ]; then
              group_users="$(getent group "$su_group" | awk -F: '{print $4}')"
              if [ -z "$group_users" ]; then
                echo "su_restricted_ok"
              else
                echo "su_group_not_empty"
              fi
            else
              echo "su_group_missing"
            fi
          else
            echo "su_not_restricted"
          fi
        tests:
          test_items:
            - flag: "su_restricted_ok"
              set: true
        remediation: |
          Create an empty group (named according to site policy) to restrict the use of the su command, e.g.:
            groupadd sugroup

          Then configure /etc/pam.d/su to require membership in this empty group:
            auth required pam_wheel.so use_uid group=sugroup

          Ensure that the designated group remains empty (no users assigned).
        scored: true


  - id: 4.4
    description: "Configure Pluggable Authentication Modules"
    checks:
      - id: 4.4.1
        description: "Configure PAM software packages"
        type: "skip"
        checks:
      - id: 4.4.1.1
        description: "Ensure latest version of pam is installed (Automated)"
        audit: |
          baseline="1.1.8-23"
          if rpm -q pam >/dev/null 2>&1; then
            current="$(rpm -q --qf '%{VERSION}-%{RELEASE}\n' pam 2>/dev/null)"
            if [ "$(printf '%s\n%s\n' "$baseline" "$current" | sort -V | tail -n1)" = "$current" ]; then
              echo "pam_version_ok"
            else
              echo "pam_version_outdated"
            fi
          else
            echo "pam_not_installed"
          fi
        tests:
          test_items:
            - flag: "pam_version_ok"
              set: true
        remediation: |
          Update PAM to the latest available version using the package manager, e.g.:
            yum upgrade pam

          Ensure that the version installed is pam-1.3.1-25 or later.
        scored: true

      - id: 4.4.1.2
        description: "Ensure libpwquality is installed (Automated)"
        audit: "rpm -q libpwquality"
        tests:
          test_items:
            - flag: "package libpwquality is not installed"
              set: false
        remediation: |
          Run the following command to install libpwquality

          # yum install libpwquality
        scored: true

      - id: 4.4.2
        description: "Configure pluggable module arguments"
        type: "skip"
        checks:
      - id: 4.4.2.1
        description: "Configure pam_faillock module"
        type: "skip"
        checks:
      - id: 4.4.2.1.1
        description: "Ensure pam_faillock module is enabled (Automated)"
        audit: |
          # Check that pam_faillock.so is present in both system-auth and password-auth
          faillock_system_auth="$(grep -P '\bpam_faillock.so\b' /etc/pam.d/system-auth 2>/dev/null)"
          faillock_password_auth="$(grep -P '\bpam_faillock.so\b' /etc/pam.d/password-auth 2>/dev/null)"

          if echo "$faillock_system_auth" | grep -q 'auth.*pam_faillock.so'; then
            if echo "$faillock_password_auth" | grep -q 'auth.*pam_faillock.so'; then
              if echo "$faillock_system_auth" | grep -q 'account.*pam_faillock.so' && \
                 echo "$faillock_password_auth" | grep -q 'account.*pam_faillock.so'; then
                echo "pam_faillock_ok"
              else
                echo "pam_faillock_missing_account"
              fi
            else
              echo "pam_faillock_missing_password_auth"
            fi
          else
            echo "pam_faillock_missing_system_auth"
          fi
        tests:
          test_items:
            - flag: "pam_faillock_ok"
              set: true
        remediation: |
          Edit the files /etc/pam.d/system-auth and /etc/pam.d/password-auth and ensure
          the following lines are present in the correct order:

          In the *auth* section (order matters):
            auth required pam_env.so
            auth required pam_faillock.so preauth silent audit deny=5 unlock_time=900 even_deny_root
            auth sufficient pam_unix.so try_first_pass
            auth [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900 even_deny_root
            auth requisite pam_succeed_if.so uid >= 1000 quiet_success
            auth required pam_deny.so

          In the *account* section:
            account required pam_faillock.so
            account required pam_unix.so
            account sufficient pam_localuser.so
            account sufficient pam_succeed_if.so uid < 1000 quiet
            account required pam_permit.so

           Ensure ordering is correct, otherwise you may lock yourself out.
        scored: true

      - id: 4.4.2.1.2
        description: "Ensure password failed attempts lockout is configured (Automated)"
        audit: |
          # Check pam_faillock deny values (must be between 1 and 5)
          faillock_deny_system="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+(preauth|authfail)\s+.*deny=[1-5]\b' /etc/pam.d/system-auth 2>/dev/null)"
          faillock_deny_password="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+(preauth|authfail)\s+.*deny=[1-5]\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$faillock_deny_system" ] && [ -n "$faillock_deny_password" ]; then
            echo "pam_faillock_deny_ok"
          else
            echo "pam_faillock_deny_bad"
          fi
        tests:
          test_items:
            - flag: "pam_faillock_deny_ok"
              set: true
        remediation: |
          Edit the files /etc/pam.d/system-auth and /etc/pam.d/password-auth to configure
          account lockout after no more than 5 failed attempts. Ensure the following lines
          exist in the *auth* section:

            auth required pam_env.so
            auth required pam_faillock.so preauth silent audit deny=5 unlock_time=900 even_deny_root
            auth sufficient pam_unix.so try_first_pass
            auth [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900 even_deny_root
            auth requisite pam_succeed_if.so uid >= 1000 quiet_success
            auth required pam_deny.so

           Ensure that:
          - The `deny` parameter is set to **5 or fewer**.
          - The preauth line is directly under `pam_env.so`.
          - The authfail line is the last `auth` line before `pam_succeed_if.so`.

          If a user is locked out due to failed attempts, they can be unlocked with:
            faillock --user <USERNAME> --reset
        scored: true

      - id: 4.4.2.1.3
        description: "Ensure password unlock time is configured (Automated)"
        audit: |
          # Check pam_faillock unlock_time values (must be 0 or >=900)
          faillock_unlock_system="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+(preauth|authfail)\s+.*unlock_time=(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/pam.d/system-auth 2>/dev/null)"
          faillock_unlock_password="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+(preauth|authfail)\s+.*unlock_time=(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$faillock_unlock_system" ] && [ -n "$faillock_unlock_password" ]; then
            echo "pam_faillock_unlocktime_ok"
          else
            echo "pam_faillock_unlocktime_bad"
          fi
        tests:
          test_items:
            - flag: "pam_faillock_unlocktime_ok"
              set: true
        remediation: |
          Edit the files /etc/pam.d/system-auth and /etc/pam.d/password-auth to configure
          account unlock time of **0 (never)** or **900 seconds (15 minutes) or greater**.
          Ensure the following lines are present in the *auth* section:

            auth required pam_env.so
            auth required pam_faillock.so preauth silent audit deny=5 unlock_time=900 even_deny_root
            auth sufficient pam_unix.so try_first_pass
            auth [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900 even_deny_root
            auth requisite pam_succeed_if.so uid >= 1000 quiet_success
            auth required pam_deny.so

           Ordering is critical:
            - The *preauth* line must be immediately under `pam_env.so`.
            - The *authfail* line must be the last `auth` line before `pam_succeed_if.so`.

          If a user is locked due to failed attempts, unlock with:
            faillock --user <USERNAME> --reset
        scored: true

      - id: 4.4.2.1.4
        description: "Ensure password failed attempts lockout includes root account (Automated)"
        audit: |
          # Verify pam_faillock root lockout is enforced via even_deny_root and/or root_unlock_time>=60
          check_file() {
            f="/etc/pam.d/$1"
            preauth_line="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+[^#\n\r]*\bpreauth\b[^#\n\r]*' "$f" 2>/dev/null)"
            authfail_line="$(grep -Pi '^\s*auth\s+[^#\n\r]+\s+pam_faillock\.so\s+[^#\n\r]*\bauthfail\b[^#\n\r]*' "$f" 2>/dev/null)"

            [ -z "$preauth_line" ] && echo "faillock_preauth_missing_$1" && return 1
            [ -z "$authfail_line" ] && echo "faillock_authfail_missing_$1" && return 1

            pre_edr=0; pre_rut=0; af_edr=0; af_rut=0
            echo "$preauth_line" | grep -Pq '\beven_deny_root\b' && pre_edr=1
            echo "$preauth_line" | grep -Pq '\broot_unlock_time=([6-9][0-9]|[1-9][0-9]{2,})\b' && pre_rut=1
            echo "$authfail_line" | grep -Pq '\beven_deny_root\b' && af_edr=1
            echo "$authfail_line" | grep -Pq '\broot_unlock_time=([6-9][0-9]|[1-9][0-9]{2,})\b' && af_rut=1

            # same options on both lines AND at least one of the options is present
            if [ $pre_edr -eq $af_edr ] && [ $pre_rut -eq $af_rut ] && { [ $pre_edr -eq 1 ] || [ $pre_rut -eq 1 ]; }; then
              echo "faillock_root_ok_$1"
              return 0
            else
              echo "faillock_root_inconsistent_$1"
              return 1
            fi
          }

          ok=0
          check_file system-auth || ok=1
          check_file password-auth || ok=1

          if [ $ok -eq 0 ]; then
            echo "pam_faillock_root_ok"
          else
            echo "pam_faillock_root_bad"
          fi
        tests:
          test_items:
            - flag: "pam_faillock_root_ok"
              set: true
        remediation: |
          Edit /etc/pam.d/system-auth and /etc/pam.d/password-auth to include **the same option(s) on both pam_faillock lines**:

          In the *auth* section (order matters):
            auth required pam_env.so
            auth required pam_faillock.so preauth silent audit deny=5 unlock_time=900 even_deny_root
            auth sufficient pam_unix.so try_first_pass
            auth [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900 even_deny_root
            auth requisite pam_succeed_if.so uid >= 1000 quiet_success
            auth required pam_deny.so

          Notes:
          - You may use `root_unlock_time=<n>` **(>=60 seconds)** instead of, or in addition to, `even_deny_root`.
          - Whatever you choose, ensure the **same option(s)** appear on both the *preauth* and *authfail* pam_faillock lines in both files.
          -  Ordering is critical: the *preauth* line goes under `pam_env.so`; the *authfail* line is the last `auth` line before `pam_succeed_if.so`.

          If a user (including root) is locked out and policy allows, you can unlock with:
            faillock --user <USERNAME> --reset
        scored: true

      - id: 4.4.2.2
        description: "Configure pam_pwquality module"
        type: "skip"
        checks:
      - id: 4.4.2.2.1
        description: "Ensure pam_pwquality module is enabled (Automated)"
        audit: |
          # Verify pam_pwquality.so is present in both system-auth and password-auth
          pwq_system_auth="$(grep -P '^\s*password\s+requisite\s+pam_pwquality\.so\b' /etc/pam.d/system-auth 2>/dev/null)"
          pwq_password_auth="$(grep -P '^\s*password\s+requisite\s+pam_pwquality\.so\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$pwq_system_auth" ] && [ -n "$pwq_password_auth" ]; then
            echo "pam_pwquality_ok"
          else
            echo "pam_pwquality_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwquality_ok"
              set: true
        remediation: |
          Edit the files /etc/pam.d/system-auth and /etc/pam.d/password-auth to enable pam_pwquality.
          Add the following line to the *password* section (order matters, it should be the first password rule):

            password requisite pam_pwquality.so try_first_pass local_users_only retry=3

          Example *password* section:
            password requisite pam_pwquality.so try_first_pass local_users_only retry=3
            password required pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok
            password required pam_deny.so

           Note: `use_authtok` should exist on all password lines except the pam_pwquality line
          and the final pam_deny.so line.
        scored: true

      - id: 4.4.2.2.2
        description: "Ensure password number of changed characters is configured (Automated)"
        audit: |
          # Verify pwquality difok is set to 2 or more in /etc/security/pwquality.conf
          conf_val="$(
            awk -F= '
              tolower($1) ~ /^[[:space:]]*difok[[:space:]]*$/ {
                gsub(/[[:space:]]*/, "", $2); v=$2
              }
              END { if (v != "") print v }
            ' /etc/security/pwquality.conf 2>/dev/null
          )"

          # Check PAM files do NOT set difok to 0 or 1 (module args override config)
          pam_bad="$(grep -Psi '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\b[^#\n\r]*\bdifok\s*=\s*([01])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$conf_val" ] && [ "$conf_val" -ge 2 ] && [ -z "$pam_bad" ]; then
            echo "pwquality_difok_ok"
          else
            echo "pwquality_difok_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_difok_ok"
              set: true
        remediation: |
          Configure difok in /etc/security/pwquality.conf to 2 or more, and remove any difok set to 0 or 1 from pam_pwquality module arguments.

          Set in pwquality.conf (preferred location):
            # ensure difok is configured once, at 2 or higher
            difok = 2

          Optionally, to update via commands:
            sed -ri 's/^\s*difok\s*=/# &/' /etc/security/pwquality.conf
            printf '\n%s\n' 'difok = 2' >> /etc/security/pwquality.conf

          Remove weak difok overrides from PAM stacks:
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+difok\s*=\s*(0|1)(.*$)/\1\3/' "$f"
            done

          Notes:
          - Settings should be defined in one place for clarity; module args override /etc/security/pwquality.conf.
          - Default value is difok = 1; set to 2 or more to comply with policy.
        scored: true

      - id: 4.4.2.2.3
        description: "Ensure password length is configured (Automated)"
        audit: |
          # Verify pwquality minlen is set to 14 or more in /etc/security/pwquality.conf
          conf_val="$(
            awk -F= '
              tolower($1) ~ /^[[:space:]]*minlen[[:space:]]*$/ {
                gsub(/[[:space:]]*/, "", $2); v=$2
              }
              END { if (v != "") print v }
            ' /etc/security/pwquality.conf 2>/dev/null
          )"

          # Check PAM files do NOT set minlen less than 14
          pam_bad="$(grep -Psi '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\b[^#\n\r]*\bminlen\s*=\s*([0-9]|1[0-3])\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$conf_val" ] && [ "$conf_val" -ge 14 ] && [ -z "$pam_bad" ]; then
            echo "pwquality_minlen_ok"
          else
            echo "pwquality_minlen_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_minlen_ok"
              set: true
        remediation: |
          Configure minimum password length in /etc/security/pwquality.conf to 14 or more:

            minlen = 14

          Example commands:
            sed -ri 's/^\s*minlen\s*=/# &/' /etc/security/pwquality.conf
            printf '\n%s\n' 'minlen = 14' >> /etc/security/pwquality.conf

          Remove weak minlen overrides from PAM module arguments:
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+minlen\s*=\s*[0-9]+(.*$)/\1\2/' "$f"
            done

          Notes:
          - Configure in only one place for clarity; /etc/security/pwquality.conf is preferred.
          - Default is minlen = 8, must be set to 14 or more to comply.
        scored: true

      - id: 4.4.2.2.4
        description: "Ensure password complexity is configured (Manual)"
        type: manual
        remediation: |
          Configure password complexity in /etc/security/pwquality.conf.
          Add or update the following lines (per site policy):

            minclass = 4
            dcredit = -1
            ucredit = -1
            ocredit = -1
            lcredit = -1

          Example commands:
            printf '\n%s\n' "minclass = 4" >> /etc/security/pwquality.conf
            printf '%s\n' "dcredit = -1" "ucredit = -1" "ocredit = -1" "lcredit = -1" >> /etc/security/pwquality.conf

          Remove any complexity options from pam_pwquality module arguments in PAM stack:
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+minclass\s*=\s*\S+(.*$)/\1\2/' "$f"
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+dcredit\s*=\s*\S+(.*$)/\1\2/' "$f"
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+ucredit\s*=\s*\S+(.*$)/\1\2/' "$f"
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+lcredit\s*=\s*\S+(.*$)/\1\2/' "$f"
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+ocredit\s*=\s*\S+(.*$)/\1\2/' "$f"
            done

          Notes:
          - Configure in only one place for clarity; /etc/security/pwquality.conf is recommended.
          - Default values: minclass=0, dcredit=0, ucredit=0, ocredit=0, lcredit=0.
          - Strong policy requires minclass  4 and negative credits for each character type (-1 enforces at least one).
        scored: false

      - id: 4.4.2.2.5
        description: "Ensure password same consecutive characters is configured (Automated)"
        audit: |
          # Verify pwquality maxrepeat is set to 1..3 (not 0) in /etc/security/pwquality.conf
          conf_val="$(
            awk -F= '
              tolower($1) ~ /^[[:space:]]*maxrepeat[[:space:]]*$/ {
                gsub(/[[:space:]]*/, "", $2); v=$2
              }
              END { if (v != "") print v }
            ' /etc/security/pwquality.conf 2>/dev/null
          )"

          # Ensure PAM module args do NOT override with 0 or >=4
          pam_bad="$(grep -Psi '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\b[^#\n\r]*\bmaxrepeat\s*=\s*(0|[4-9]|[1-9][0-9]+)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$conf_val" ] && [ "$conf_val" -ge 1 ] && [ "$conf_val" -le 3 ] && [ -z "$pam_bad" ]; then
            echo "pwquality_maxrepeat_ok"
          else
            echo "pwquality_maxrepeat_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_maxrepeat_ok"
              set: true
        remediation: |
          Configure maxrepeat in /etc/security/pwquality.conf to 3 or less (but not 0),
          and remove any pam_pwquality module overrides:

          Set in pwquality.conf (preferred):
            maxrepeat = 3

          Example commands:
            sed -ri 's/^\s*maxrepeat\s*=/# &/' /etc/security/pwquality.conf
            printf '\n%s\n' 'maxrepeat = 3' >> /etc/security/pwquality.conf

          Remove overrides from PAM stacks:
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+maxrepeat\s*=\s*\S+(.*$)/\1\2/' "$f"
            done

          Notes:
          - Configure settings in only one place for clarity; /etc/security/pwquality.conf is recommended.
          - Default is maxrepeat = 0; policy requires a value between 1 and 3.
        scored: true

      - id: 4.4.2.2.6
        description: "Ensure password maximum sequential characters is configured (Automated)"
        audit: |
          # Verify pwquality maxsequence is set to 1..3 (not 0) in /etc/security/pwquality.conf
          conf_val="$(
            awk -F= '
              tolower($1) ~ /^[[:space:]]*maxsequence[[:space:]]*$/ {
                gsub(/[[:space:]]*/, "", $2); v=$2
              }
              END { if (v != "") print v }
            ' /etc/security/pwquality.conf 2>/dev/null
          )"
          pam_bad="$(grep -Psi '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\b[^#\n\r]*\bmaxsequence\s*=\s*(0|[4-9]|[1-9][0-9]+)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$conf_val" ] && [ "$conf_val" -ge 1 ] && [ "$conf_val" -le 3 ] && [ -z "$pam_bad" ]; then
            echo "pwquality_maxsequence_ok"
          else
            echo "pwquality_maxsequence_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_maxsequence_ok"
              set: true
        remediation: |
          Configure maxsequence in /etc/security/pwquality.conf to 3 or less (but not 0),
          and remove any pam_pwquality module overrides:

          Set in pwquality.conf (preferred):
            maxsequence = 3

          Example commands:
            sed -ri 's/^\s*maxsequence\s*=/# &/' /etc/security/pwquality.conf
            printf '\n%s\n' 'maxsequence = 3' >> /etc/security/pwquality.conf

          Remove overrides from PAM stacks:
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+maxsequence\s*=\s*\S+(.*$)/\1\2/' "$f"
            done

          Notes:
          - Configure settings in only one place for clarity; /etc/security/pwquality.conf is recommended.
          - Default is maxsequence = 0; policy requires a value between 1 and 3.
        scored: true

      - id: 4.4.2.2.7
        description: "Ensure password dictionary check is enabled (Automated)"
        audit: |
          # Ensure dictcheck is not disabled (dictcheck=0) in pwquality.conf
          conf_bad="$(grep -Psi '^\s*dictcheck\s*=\s*0\b' /etc/security/pwquality.conf 2>/dev/null)"

          # Ensure PAM module arguments do not override dictcheck with 0
          pam_bad="$(grep -Psi '^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so\b[^#\n\r]*\bdictcheck\s*=\s*0\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"

          if [ -z "$conf_bad" ] && [ -z "$pam_bad" ]; then
            echo "pwquality_dictcheck_ok"
          else
            echo "pwquality_dictcheck_bad"
          fi
        tests:
          test_items:
            - flag: "pwquality_dictcheck_ok"
              set: true
        remediation: |
          Ensure that the password dictionary check is enabled:

          In /etc/security/pwquality.conf, comment out or remove any instance of:
            dictcheck = 0

          Example:
            sed -ri 's/^\s*dictcheck\s*=/# &/' /etc/security/pwquality.conf

          Also remove any dictcheck arguments from pam_pwquality module lines in PAM files:
            for f in /etc/pam.d/system-auth /etc/pam.d/password-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwquality\.so.*)\s+dictcheck\s*=\s*\S+(.*$)/\1\2/' "$f"
            done

          Notes:
          - Module arguments override pwquality.conf, so ensure no `dictcheck=0` is set in PAM files.
          - Default value: dictcheck = 1 (enabled).
        scored: true

      - id: 4.4.2.3
        description: "Configure pam_pwhistory module"
        type: "skip"
        checks:
      - id: 4.4.2.3.1
        description: "Ensure pam_pwhistory module is enabled (Automated)"
        audit: |
          # Verify pam_pwhistory.so is enabled in both system-auth and password-auth
          pwh_system_auth="$(grep -P '^\s*password\s+required\s+pam_pwhistory\.so\b' /etc/pam.d/system-auth 2>/dev/null)"
          pwh_password_auth="$(grep -P '^\s*password\s+required\s+pam_pwhistory\.so\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$pwh_system_auth" ] && [ -n "$pwh_password_auth" ]; then
            echo "pam_pwhistory_enabled_ok"
          else
            echo "pam_pwhistory_enabled_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwhistory_enabled_ok"
              set: true
        remediation: |
          Enable pam_pwhistory in both PAM stacks and place it after pam_pwquality:

          In /etc/pam.d/system-auth and /etc/pam.d/password-auth (password section):
            password requisite pam_pwquality.so try_first_pass local_users_only retry=3
            password required pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok
            password required pam_deny.so

          Notes:
          - Keep pam_pwhistory as "required".
          - `use_authtok` should exist on all password lines except the first entry (pam_pwquality) and the final pam_deny.so line.
        scored: true

      - id: 4.4.2.3.2
        description: "Ensure password history remember is configured (Automated)"
        audit: |
          # Verify pam_pwhistory.so is configured with remember=24 or more in both PAM stacks
          pwh_system_auth="$(grep -Pi '^\s*password\s+(required|requisite)\s+pam_pwhistory\.so\b[^#\n\r]*\bremember=(2[4-9]|[3-9][0-9]|[1-9][0-9]{2,})\b' /etc/pam.d/system-auth 2>/dev/null)"
          pwh_password_auth="$(grep -Pi '^\s*password\s+(required|requisite)\s+pam_pwhistory\.so\b[^#\n\r]*\bremember=(2[4-9]|[3-9][0-9]|[1-9][0-9]{2,})\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$pwh_system_auth" ] && [ -n "$pwh_password_auth" ]; then
            echo "pam_pwhistory_remember_ok"
          else
            echo "pam_pwhistory_remember_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwhistory_remember_ok"
              set: true
        remediation: |
          Configure pam_pwhistory with remember set to 24 or more:

          In /etc/pam.d/system-auth and /etc/pam.d/password-auth (password section):
            password requisite pam_pwquality.so try_first_pass local_users_only retry=3
            password required pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok
            password required pam_deny.so

          Notes:
          - `remember=24` is the CIS Benchmark minimum; adjust higher if site policy requires.
          - Keep pam_pwhistory as "required".
          - `use_authtok` should be present on all password lines except pam_pwquality and pam_deny.so.
        scored: true

      - id: 4.4.2.3.3
        description: "Ensure password history is enforced for the root user (Automated)"
        audit: |
          # Verify pam_pwhistory.so has enforce_for_root in both PAM stacks
          pwh_system_auth="$(grep -Pi '^\s*password\s+(required|requisite)\s+pam_pwhistory\.so\b[^#\n\r]*\benforce_for_root\b' /etc/pam.d/system-auth 2>/dev/null)"
          pwh_password_auth="$(grep -Pi '^\s*password\s+(required|requisite)\s+pam_pwhistory\.so\b[^#\n\r]*\benforce_for_root\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$pwh_system_auth" ] && [ -n "$pwh_password_auth" ]; then
            echo "pam_pwhistory_enforce_root_ok"
          else
            echo "pam_pwhistory_enforce_root_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwhistory_enforce_root_ok"
              set: true
        remediation: |
          Configure pam_pwhistory to enforce history for root in both PAM stacks:

          In /etc/pam.d/system-auth and /etc/pam.d/password-auth (password section):
            password requisite pam_pwquality.so try_first_pass local_users_only retry=3
            password required  pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok
            password required  pam_deny.so

          Notes:
          - Keep pam_pwhistory as "required".
          - `use_authtok` should be on all password lines except the first (pam_pwquality) and the final pam_deny.so line.
        scored: true

      - id: 4.4.2.3.4
        description: "Ensure pam_pwhistory includes use_authtok (Automated)"
        audit: |
          # Verify pam_pwhistory.so lines include use_authtok in both PAM stacks
          pwh_system_auth="$(grep -Pi '^\s*password\s+[^#\n\r]+\s+pam_pwhistory\.so\b[^#\n\r]*\buse_authtok\b' /etc/pam.d/system-auth 2>/dev/null)"
          pwh_password_auth="$(grep -Pi '^\s*password\s+[^#\n\r]+\s+pam_pwhistory\.so\b[^#\n\r]*\buse_authtok\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$pwh_system_auth" ] && [ -n "$pwh_password_auth" ]; then
            echo "pam_pwhistory_useauthtok_ok"
          else
            echo "pam_pwhistory_useauthtok_bad"
          fi
        tests:
          test_items:
            - flag: "pam_pwhistory_useauthtok_ok"
              set: true
        remediation: |
          Ensure pam_pwhistory uses the use_authtok option in both PAM stacks.

          In /etc/pam.d/system-auth and /etc/pam.d/password-auth (password section):
            password requisite pam_pwquality.so try_first_pass local_users_only retry=3
            password required  pam_pwhistory.so remember=24 enforce_for_root try_first_pass use_authtok
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok
            password required  pam_deny.so

          Notes:
          - The `use_authtok` option must be present on pam_pwhistory lines.
          - It should also exist on all password lines except the first entry (pam_pwquality) and the final pam_deny.so line.
        scored: true

      - id: 4.4.2.4
        description: "Configure pam_unix module"
        type: "skip"
        checks:
      - id: 4.4.2.4.1
        description: "Ensure pam_unix does not include nullok (Automated)"
        audit: |
          # Fail if any pam_unix line includes the 'nullok' option in system-auth or password-auth
          if grep -Psi '^\s*(auth|account|password|session)\s+(requisite|required|sufficient)\s+pam_unix\.so\b[^#\n\r]*\bnullok\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null; then
            echo "pam_unix_nullok_bad"
          else
            echo "pam_unix_nullok_ok"
          fi
        tests:
          test_items:
            - flag: "pam_unix_nullok_ok"
              set: true
        remediation: |
          Remove the 'nullok' option from any pam_unix.so lines in:
            /etc/pam.d/system-auth
            /etc/pam.d/password-auth

          Example compliant lines:
            auth     sufficient pam_unix.so try_first_pass
            account  required   pam_unix.so
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok
            session  required   pam_unix.so
        scored: true

      - id: 4.4.2.4.2
        description: "Ensure pam_unix does not include remember (Automated)"
        audit: |
          # Fail if any pam_unix.so password lines include a remember option
          if grep -Psi '^\s*password\s+[^#\n\r]+\s+pam_unix\.so\b[^#\n\r]*\bremember=\d+\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null; then
            echo "pam_unix_remember_bad"
          else
            echo "pam_unix_remember_ok"
          fi
        tests:
          test_items:
            - flag: "pam_unix_remember_ok"
              set: true
        remediation: |
          Remove the 'remember=n' option from pam_unix.so lines in:
            /etc/pam.d/system-auth
            /etc/pam.d/password-auth

          Example compliant password line:
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok

          Notes:
          - pam_pwhistory should be used for password reuse restrictions instead of pam_unix remember.
          - This ensures password history is enforced with modern hash algorithms (e.g., sha512).
        scored: true

      - id: 4.4.2.4.3
        description: "Ensure pam_unix includes a strong password hashing algorithm (Automated)"
        audit: |
          # Verify pam_unix.so password lines use sha512 and do not use weak algorithms
          weak_algos="$(grep -Psi '^\s*password\s+[^#\n\r]+\s+pam_unix\.so\b[^#\n\r]*\b(md5|bigcrypt|sha256|blowfish)\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"
          strong_algos="$(grep -Psi '^\s*password\s+[^#\n\r]+\s+pam_unix\.so\b[^#\n\r]*\bsha512\b' /etc/pam.d/system-auth /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$strong_algos" ] && [ -z "$weak_algos" ]; then
            echo "pam_unix_hashing_ok"
          else
            echo "pam_unix_hashing_bad"
          fi
        tests:
          test_items:
            - flag: "pam_unix_hashing_ok"
              set: true
        remediation: |
          Ensure pam_unix uses sha512 and no weaker algorithms:

          In /etc/pam.d/system-auth and /etc/pam.d/password-auth (password section):
            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok

          Remove any weak algorithms (md5, bigcrypt, sha256, blowfish) if present.

          Notes:
          - This affects only local accounts.
          - Existing user passwords created under weaker algorithms should be expired so that users are forced to reset them with sha512.
            Example:
              passwd -e <username>
        scored: true

      - id: 4.4.2.4.4
        description: "Ensure pam_unix includes use_authtok (Automated)"
        audit: |
          # Verify pam_unix.so password lines include use_authtok in both PAM stacks
          unix_system_auth="$(grep -Pi '^\s*password\s+[^#\n\r]+\s+pam_unix\.so\b[^#\n\r]*\buse_authtok\b' /etc/pam.d/system-auth 2>/dev/null)"
          unix_password_auth="$(grep -Pi '^\s*password\s+[^#\n\r]+\s+pam_unix\.so\b[^#\n\r]*\buse_authtok\b' /etc/pam.d/password-auth 2>/dev/null)"

          if [ -n "$unix_system_auth" ] && [ -n "$unix_password_auth" ]; then
            echo "pam_unix_useauthtok_ok"
          else
            echo "pam_unix_useauthtok_bad"
          fi
        tests:
          test_items:
            - flag: "pam_unix_useauthtok_ok"
              set: true
        remediation: |
          Edit /etc/pam.d/system-auth and /etc/pam.d/password-auth to ensure pam_unix
          password lines include the use_authtok option. Example:

            password sufficient pam_unix.so sha512 shadow try_first_pass use_authtok

          Notes:
          - The use_authtok option ensures that pam_unix reuses the password already
            validated by previous modules in the stack.
          - It should be present on all password lines except pam_pwquality and pam_deny.so.
        scored: true

  - id: 4.5
    description: "User Accounts and Environment"
    checks:
      - id: 4.5.1
        description: "Configure shadow password suite parameters"
        type: "skip"
        checks:
      - id: 4.5.1.1
        description: "Ensure strong password hashing algorithm is configured (Automated)"
        audit: |
          # Verify strong hashing algorithm (sha512 or yescrypt) in libuser and login.defs
          libuser_ok="$(grep -Pi '^\s*crypt_style\s*=\s*(sha512|yescrypt)\b' /etc/libuser.conf 2>/dev/null)"
          login_ok="$(grep -Pi '^\s*ENCRYPT_METHOD\s+(SHA512|yescrypt)\b' /etc/login.defs 2>/dev/null)"

          if [ -n "$libuser_ok" ] && [ -n "$login_ok" ]; then
            echo "strong_hashing_ok"
          else
            echo "strong_hashing_bad"
          fi
        tests:
          test_items:
            - flag: "strong_hashing_ok"
              set: true
        remediation: |
          Configure a strong hashing algorithm consistently (sha512 or yescrypt).

          Edit /etc/libuser.conf:
            crypt_style = sha512

          Edit /etc/login.defs:
            ENCRYPT_METHOD SHA512

          Notes:
          - yescrypt is acceptable if supported by your distribution; if chosen, use it in both files.
          - Changes affect only passwords created/changed after the update. Consider expiring local user passwords to force rehash on next login.
            Example:
              awk -F: -v min_uid="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)" '($3>=min_uid && $1!="nfsnobody"){print $1}' /etc/passwd | xargs -n1 passwd -e
        scored: true

      - id: 4.5.1.2
        description: "Ensure password expiration is 365 days or less (Automated)"
        audit: |
          val="$(awk '/^\s*PASS_MAX_DAYS/ && $1 == "PASS_MAX_DAYS" {print $2}' /etc/login.defs)"
          if [ -n "$val" ] && [ "$val" -le 365 ]; then
            echo "PASS_MAX_DAYS_OK:$val"
          else
            echo "PASS_MAX_DAYS_BAD:${val:-unset}"
          fi
        tests:
          test_items:
            - flag: "PASS_MAX_DAYS_OK"
              set: true
        remediation: |
          1. Set system-wide password max age in `/etc/login.defs`:
             ```
             PASS_MAX_DAYS 365
             ```

          2. Apply to all users with existing passwords:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $5 > 365) { print $1 }' /etc/shadow); do
               chage --maxdays 365 "$user"
             done
             ```
        scored: true

      - id: 4.5.1.3
        description: "Ensure password expiration warning days is 7 or more (Automated)"
        audit: |
          val="$(awk '/^\s*PASS_WARN_AGE/ && $1 == "PASS_WARN_AGE" {print $2}' /etc/login.defs)"
          if [ -n "$val" ] && [ "$val" -ge 7 ]; then
            echo "PASS_WARN_AGE_OK:$val"
          else
            echo "PASS_WARN_AGE_BAD:${val:-unset}"
          fi
        tests:
          test_items:
            - flag: "PASS_WARN_AGE_OK"
              set: true
        remediation: |
          1. Set global warning age in `/etc/login.defs`:
             ```
             PASS_WARN_AGE 7
             ```

          2. Fix user-specific values:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $6 < 7) { print $1 }' /etc/shadow); do
               chage --warndays 7 "$user"
             done
             ```
        scored: true

      - id: 4.5.1.4
        description: "Ensure inactive password lock is 30 days or less (Automated)"
        audit: |
          useradd -D | grep INACTIVE
        tests:
          test_items:
            - flag: "INACTIVE"
              compare:
                op: lte
                value: 30
            - flag: "INACTIVE"
              compare:
                op: gte
                value: 0
        remediation: |
          1. Set default inactive days to 30:
             ```
             useradd -D -f 30
             ```

          2. Set inactive days for existing users:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && ($7 == "" || $7 ~ /^-1$|^3[1-9]$|^[4-9][0-9]+$|^[1-9][0-9]{2,}$/)) { print $1 }' /etc/shadow); do
               chage --inactive 30 "$user"
             done
             ```
        scored: true

      - id: 4.5.1.5
        description: "Ensure all users last password change date is in the past (Automated)"
        audit: |
          bad=0
          while IFS=: read -r user pw _; do
            case "$pw" in
              '!'*|'*'|x|X|'') continue ;;
            esac
            last_change_str="$(chage --list "$user" 2>/dev/null | awk -F': ' '/^Last password change/{print $2}')"
            [ -z "$last_change_str" ] && continue
            echo "$last_change_str" | grep -qi 'never$' && continue
            # Compare seconds since epoch
            lc_epoch="$(date -d "$last_change_str" +%s 2>/dev/null || echo 0)"
            now_epoch="$(date +%s)"
            if [ "$lc_epoch" -gt "$now_epoch" ]; then
              echo "future_password_change_user: $user ($last_change_str)"
              bad=1
            fi
          done < /etc/shadow

          if [ "$bad" -eq 0 ]; then
            echo "password_change_dates_ok"
          else
            echo "password_change_dates_bad"
          fi
        tests:
          test_items:
            - flag: "password_change_dates_ok"
              set: true
        remediation: |
          Investigate any user(s) reported with a future "Last password change" date and correct them.

          Options (per account):
            # Force immediate password change at next login (recommended)
            passwd -e <username>
            # or equivalently
            chage -d 0 <username>

            # If you must set the date explicitly to today
            chage -d "$(date +%Y-%m-%d)" <username>

            # If the account appears compromised or incorrect, you may lock it first
            usermod -L <username>

          After correction, re-run the audit to confirm no users are reported.
        scored: true

      - id: 4.5.2
        description: "Configure root and system accounts and environment"
        type: "skip"
        checks:
      - id: 4.5.2.1
        description: "Ensure default group for the root account is GID 0 (Automated)"
        audit: |
          # Verify root user's primary group ID (GID) is 0
          root_gid="$(awk -F: '$1=="root"{print $4}' /etc/passwd 2>/dev/null)"
          if [ "$root_gid" = "0" ]; then
            echo "root_gid0_ok"
          else
            echo "root_gid0_bad (current_gid=$root_gid)"
          fi
        tests:
          test_items:
            - flag: "root_gid0_ok"
              set: true
        remediation: |
          Set the root user's primary group to GID 0:
            usermod -g 0 root

          (Optional) Confirm:
            awk -F: '$1=="root"{print $1":"$4}' /etc/passwd
        scored: true

      - id: 4.5.2.2
        description: "Ensure root user umask is configured (Automated)"
        audit: |
          # Verify root's umask is set to 027 (or more restrictive) in shell config files
          bad_umask="$(grep -Psi '^\s*umask\s+' /root/.bash_profile /root/.bashrc 2>/dev/null | grep -Pv 'umask\s+(0[0-7][0-7][0-6]|0[0-7][0-6]|[0-7][0-7][0-6])\b')"

          if [ -z "$bad_umask" ]; then
            echo "root_umask_ok"
          else
            echo "root_umask_bad"
          fi
        tests:
          test_items:
            - flag: "root_umask_ok"
              set: true
        remediation: |
          Edit /root/.bash_profile and /root/.bashrc to set the root umask to 027 (or more restrictive).

          Example secure umask values:
            umask 027
            # or symbolic equivalent
            umask u=rwx,g=rx,o=

          Steps:
            1. Remove or comment out any existing umask lines with weaker values.
            2. Add or update to the secure value (027 or stricter).
            3. Ensure the setting is consistent across both /root/.bash_profile and /root/.bashrc.

          Result:
            - New directories created by root  drwxr-x---
            - New files created by root      rw-r-----
        scored: true

      - id: 4.5.2.3
        description: "Ensure system accounts are secured (Automated)"
        audit: |
          # Check for system accounts (UID < UID_MIN or UID=65534) with interactive shells
          sys_accounts="$(awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'$(awk "/^\s*UID_MIN/{print \$2}" /etc/login.defs)') || $3==65534) && $7!~/^(\/usr)?\/sbin\/nologin$/ {print $1}' /etc/passwd)"

          # Check for accounts with nologin shell but unlocked passwords
          bad_disabled="$(awk -F: '/nologin/ {print $1}' /etc/passwd | xargs -r -I{} passwd -S {} 2>/dev/null | awk '($2!="L" && $2!="LK"){print $1}')"

          if [ -z "$sys_accounts" ] && [ -z "$bad_disabled" ]; then
            echo "system_accounts_secured_ok"
          else
            echo "system_accounts_secured_bad"
            [ -n "$sys_accounts" ] && echo "Accounts with interactive shells: $sys_accounts"
            [ -n "$bad_disabled" ] && echo "Accounts with nologin shell but not locked: $bad_disabled"
          fi
        tests:
          test_items:
            - flag: "system_accounts_secured_ok"
              set: true
        remediation: |
          Secure system accounts as follows:

          1. For system accounts with interactive shells, set them to nologin:
             usermod -s $(command -v nologin) <user>

          2. For accounts with nologin shell but unlocked passwords, lock them:
             usermod -L <user>

          Example bulk operations:
            # Set all system accounts to nologin (excluding root, halt, sync, shutdown, nfsnobody)
            awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'$(awk "/^\s*UID_MIN/{print \$2}" /etc/login.defs)') || $3==65534) {print $1}' /etc/passwd | while read user; do
              usermod -s $(command -v nologin) "$user"
            done

            # Lock all accounts already using nologin
            awk -F: '/nologin/ {print $1}' /etc/passwd | while read user; do
              usermod -L "$user"
            done
        scored: true

      - id: 4.5.2.4
        description: "Ensure root password is set (Automated)"
        audit: |
          # Check root account password status
          if passwd -S root 2>/dev/null | grep -Poi 'Password\s+set\b' >/dev/null; then
            echo "root_password_set_ok"
          else
            echo "root_password_set_bad"
          fi
        tests:
          test_items:
            - flag: "root_password_set_ok"
              set: true
        remediation: |
          Set a strong password for the root account:

            passwd root

          Notes:
          - This will prompt for a new root password and confirmation.
          - Ensure the password follows site policy (complexity, length, and rotation requirements).
          - Be aware that any automated processes relying on a passwordless root login will fail after remediation.
        scored: true

      - id: 4.5.3
        description: "Configure user default environment"
        type: "skip"
        checks:
      - id: 4.5.3.1
        description: "Ensure nologin is not listed in /etc/shells (Automated)"
        audit: |
          # Verify that nologin is not listed in /etc/shells
          if grep -qE '/nologin\b' /etc/shells 2>/dev/null; then
            echo "nologin_in_shells_bad"
          else
            echo "nologin_in_shells_ok"
          fi
        tests:
          test_items:
            - flag: "nologin_in_shells_ok"
              set: true
        remediation: |
          Edit /etc/shells and remove any lines containing 'nologin'.

          Example:
            vi /etc/shells
            # Remove entries such as:
            /sbin/nologin
            /usr/sbin/nologin

          After remediation, verify with:
            grep '/nologin\b' /etc/shells
          (no results should be returned).
        scored: true

      - id: 4.5.3.2
        description: "Ensure default user shell timeout is configured (Automated)"
        audit: |
          BRC=""
          [ -f /etc/bashrc ] && BRC="/etc/bashrc"

          output1=""
          for f in "$BRC" /etc/profile /etc/profile.d/*.sh ; do
            if grep -Pq '^\s*([^#]+\s+)?TMOUT=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9])\b' "$f" 2>/dev/null &&
               grep -Pq '^\s*([^#]+;\s*)?readonly\s+TMOUT(\s+|\s*;|\s*$|=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9]))\b' "$f" 2>/dev/null &&
               grep -Pq '^\s*([^#]+;\s*)?export\s+TMOUT(\s+|\s*;|\s*$|=(900|[1-8][0-9][0-9]|[1-9][0-9]|[1-9]))\b' "$f" 2>/dev/null; then
              output1="$f"
              break
            fi
          done

          output2="$(grep -Ps '^\s*([^#]+\s+)?TMOUT=(9[0-9][1-9]|9[1-9][0-9]|0+|[1-9][0-9]{3,})\b' /etc/profile /etc/profile.d/*.sh $BRC 2>/dev/null)"

          if [ -n "$output1" ] && [ -z "$output2" ]; then
            echo "tmout_ok"
          else
            echo "tmout_bad"
            [ -z "$output1" ] && echo "TMOUT not configured correctly"
            [ -n "$output2" ] && echo "Invalid TMOUT found: $output2"
          fi
        tests:
          test_items:
            - flag: "tmout_ok"
              set: true
        remediation: |
          Configure TMOUT to 900 seconds or less, set it readonly, and export it in one of:
            - /etc/profile
            - /etc/bashrc
            - A new file in /etc/profile.d/*.sh

          Example configuration (preferred multi-line):
            TMOUT=900
            readonly TMOUT
            export TMOUT

          Or as a single line:
            readonly TMOUT=900 ; export TMOUT

          Steps:
            1. Review /etc/bashrc, /etc/profile, and /etc/profile.d/*.sh for existing TMOUT entries.
            2. Remove or comment out weak/incorrect entries (0 or >900).
            3. Add correct TMOUT settings as shown above.
        scored: true

      - id: 4.5.3.3
        description: "Ensure default user umask is configured (Automated)"
        audit: |
          # Verify default umask is 027 or more restrictive in global config locations
          check_file() {
            f="$1"
            if [ -f "$f" ]; then
              if grep -Psiq '^\s*umask\s+0?[0-7][0-7][0-7]\b' "$f"; then
                val=$(grep -Psi '^\s*umask\s+0?[0-7][0-7][0-7]\b' "$f" | awk '{print $2}' | tail -n1)
                if [ "$val" -le 027 ] || [ "$val" -eq 077 ]; then
                  echo "umask_ok_in_$f"
                else
                  echo "umask_bad_in_$f"
                  bad=1
                fi
              fi
            fi
          }

          bad=0
          for file in /etc/profile /etc/bashrc /etc/bash.bashrc /etc/login.defs /etc/default/login; do
            check_file "$file"
          done
          find /etc/profile.d/ -type f -name '*.sh' -print0 2>/dev/null | while IFS= read -r -d '' f; do
            check_file "$f"
          done

          # Check PAM postlogin for pam_umask settings
          if grep -Psiq '^\s*session\s+[^#\n\r]+\s+pam_umask\.so\b.*umask=(0[0-2][0-7]|027|077)\b' /etc/pam.d/postlogin 2>/dev/null; then
            echo "pam_umask_ok"
          else
            if grep -Psiq '^\s*session\s+[^#\n\r]+\s+pam_umask\.so' /etc/pam.d/postlogin 2>/dev/null; then
              echo "pam_umask_bad"
              bad=1
            fi
          fi

          # Final result
          if [ $bad -eq 0 ]; then
            echo "umask_ok"
          else
            echo "umask_bad"
          fi
        tests:
          test_items:
            - flag: "umask_ok"
              set: true
        remediation: |
          Set default umask to 027 (or more restrictive) across system-wide config files.

          Recommended configuration method:
            printf '%s\n' "umask 027" > /etc/profile.d/50-systemwide_umask.sh

          Alternatively, update existing files:
            - /etc/profile
            - /etc/bashrc
            - /etc/bash.bashrc
            - /etc/login.defs
            - /etc/default/login
            - /etc/profile.d/*.sh

          Ensure entries look like:
        scored: true

  - id: 5
    description: "Logging and Auditing"
    checks:
  - id: 5.1
    description: "Configure Logging"
    checks:
      - id: 5.1.1
        description: "Configure rsyslog"
        type: "skip"
        checks:
      - id: 5.1.1.1
        description: "Ensure rsyslog is installed (Automated)"
        audit: "rpm -q rsyslog"
        tests:
          test_items:
            - flag: "package rsyslog is not installed"
              set: false
        remediation: |
          Install the rsyslog package if it is not already installed:

          # yum install rsyslog
        scored: true

      - id: 5.1.1.2
        description: "Ensure rsyslog service is enabled (Manual)"
        audit: "systemctl is-enabled rsyslog"
        tests:
          test_items:
            - flag: "enabled"
        remediation: |
          Run the following command to enable rsyslog:

          # systemctl --now enable rsyslog
        scored: false

      - id: 5.1.1.3
        description: "Ensure journald is configured to send logs to rsyslog (Manual)"
        type: manual
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:

            ForwardToSyslog=yes
          Restart the service:

            # systemctl restart rsyslog
        scored: false

      - id: 5.1.1.4
        description: "Ensure rsyslog default file permissions are configured (Automated)"
        audit: |
          grep -Ps '^\h*\$FileCreateMode\h+0[0,2,4,6][0,2,4]0\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null
        tests:
          test_items:
            - flag: "0640"
              set: true
        remediation: |
          Edit either /etc/rsyslog.conf or a dedicated .conf file in /etc/rsyslog.d/ and set $FileCreateMode to 0640 or more restrictive:

            $FileCreateMode 0640
          Restart the service:

          # systemctl restart rsyslog
        scored: true

      - id: 5.1.1.5
        description: "Ensure logging is configured (Manual)"
        type: manual
        audit: "ls -l /var/log/"
        remediation: |
          Edit the following lines in the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files as appropriate for your environment.

          Run the following command to reload the rsyslogd configuration:

          # systemctl restart rsyslog
        scored: false

      - id: 5.1.1.6
        description: "Ensure rsyslog is configured to send logs to a remote log host (Manual)"
        type: manual
        audit: |
          grep -E '^\s*([^#]+\s+)?action\(([^#]+\s+)?\btarget=\"?[^#"]+\"?\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        remediation: |
          Edit the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files and add the following line (where loghost.example.com is the name of your central log host). The target directive may either be a fully qualified domain name or an IP address.

            *.* action(type="omfwd" target="192.168.2.100" port="514" protocol="tcp"
            action.resumeRetryCount="100"
            queue.type="LinkedList" queue.size="1000")
          Run the following command to reload the rsyslogd configuration:

          # systemctl restart rsyslog

        scored: false

      - id: 5.1.1.7
        description: "Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
        audit: |
          grep -Ps -- '^\h*module\(load="imtcp"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -Ps -- '^\h*input\(type="imtcp" port="514"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -s '^\s*\$ModLoad imtcp' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -s '^\s*\$InputTCPServerRun' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/rsyslog.conf and all /etc/rsyslog.d/*.conf files to remove any configuration lines that enable receiving logs from remote clients:

          Remove any of the following lines if present:
            - module(load="imtcp")
            - input(type="imtcp" port="514")
            - $ModLoad imtcp
            - $InputTCPServerRun

          After making changes, restart the rsyslog service:
            systemctl restart rsyslog
        scored: true

      - id: 5.1.2
        description: "Configure journald"
        type: "skip"
        checks:
      - id: 5.1.2.1
        description: "Ensure journald is configured to send logs to a remote log host"
        type: "skip"
        checks:
      - id: 5.1.2.1.1
        description: "Ensure systemd-journal-remote is installed (Manual)"
        audit: "rpm -q systemd-journal-remote"
        tests:
          test_items:
            - flag: "package systemd-journal-remote is not installed"
              set: false
        remediation: |
          Run the following command to install systemd-journal-remote:

          # yum install systemd-journal-remote
        scored: false

      - id: 5.1.2.1.2
        description: "Ensure systemd-journal-remote is configured (Manual)"
        type: manual
        audit: |
          grep -P "^ *URL=|^ *ServerKeyFile=|^ *ServerCertificateFile=|^ *TrustedCertificateFile=" /etc/systemd/journal-upload.conf
        remediation: |
          Edit the /etc/systemd/journal-upload.conf file and ensure the following lines are set per your environment:

              URL=192.168.50.42
              ServerKeyFile=/etc/ssl/private/journal-upload.pem
              ServerCertificateFile=/etc/ssl/certs/journal-upload.pem
              TrustedCertificateFile=/etc/ssl/ca/trusted.pem
            Restart the service:

            # systemctl restart systemd-journal-upload
        scored: false

      - id: 5.1.2.1.3
        description: "Ensure systemd-journal-remote is enabled (Manual)"
        audit: "systemctl is-enabled systemd-journal-upload.service"
        tests:
          test_items:
            - flag: "enabled"
              set: true
        remediation: |
          Run the following command to enable systemd-journal-remote:

          # systemctl --now enable systemd-journal-upload.service
        scored: false

      - id: 5.1.2.1.4
        description: "Ensure journald is not configured to receive logs from a remote client (Automated)"
        audit: |
          systemctl is-enabled systemd-journal-remote.socket
        tests:
          test_items:
            - flag: "masked"
              set: true
        remediation: |
          Run the following command to disable systemd-journal-remote.socket:

          # systemctl --now mask systemd-journal-remote.socket
        scored: true

      - id: 5.1.2.2
        description: "Ensure journald service is enabled (Automated)"
        audit: "systemctl is-enabled systemd-journald.service"
        tests:
          test_items:
            - flag: "static"
              set: true
        remediation: |
          By default the systemd-journald service does not have an [Install] section and thus cannot be enabled / disabled. It is meant to be referenced as Requires or Wants by other unit files. As such, if the status of systemd-journald is not static, investigate why.
        scored: true

      - id: 5.1.2.3
        description: "Ensure journald is configured to compress large log files (Automated)"
        audit: |
          grep -E ^\s*Compress /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "yes"
              set: true
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:

          Compress=yes
          Restart the service:

          # systemctl restart systemd-journald.service
        scored: true

      - id: 5.1.2.4
        description: "Ensure journald is configured to write logfiles to persistent disk (Automated)"
        audit: |
          grep -E ^\s*Storage /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "persistent"
              set: true
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:

            Storage=persistent
          Restart the service:

            # systemctl restart systemd-journald.service
        scored: true

      - id: 5.1.2.5
        description: "Ensure journald is not configured to send logs to rsyslog (Manual)"
        audit: |
          grep ^\s*ForwardToSyslog /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/systemd/journald.conf file and ensure that ForwardToSyslog=yes is removed.

          Restart the service:

          # systemctl restart systemd-journald.service
        scored: false

      - id: 5.1.2.6
        description: "Ensure journald log rotation is configured per site policy (Manual)"
        type: manual
        remediation: |
          Review /etc/systemd/journald.conf and verify logs are rotated according to site policy. The settings should be carefully understood as there are specific edge cases and prioritization of parameters.
          The specific parameters for log rotation are:
            SystemMaxUse=
            SystemKeepFree=
            RuntimeMaxUse=
            RuntimeKeepFree=
            MaxFileSec=
        scored: false

      - id: 5.1.3
        description: "Ensure logrotate is configured (Manual)"
        type: manual
        remediation: |
          Edit /etc/logrotate.conf and /etc/logrotate.d/* to ensure logs are rotated
          according to site policy.
        scored: false

      - id: 5.1.4
        description: "Ensure all logfiles have appropriate access configured (Automated)"
        audit: |
          insecure=0
          find /var/log -type f -exec stat --format '%n %U %G %a' {} \; | \
          while read -r file owner group perms; do
            if [[ "$perms" =~ ^[0-7]{3}$ ]]; then
              if [[ "$perms" -gt 640 ]] || [[ "$owner" != "root" && "$owner" != "syslog" ]] || [[ "$group" != "adm" && "$group" != "root" ]]; then
                echo "  $file has insecure permission or ownership => $perms $owner:$group"
                insecure=1
              fi
            fi
          done
          # Emit the flag for the test harness
          if [ "${insecure:-0}" -eq 0 ]; then
            echo "logfiles_ok"
          else
            echo "logfiles_bad"
          fi
        tests:
          test_items:
            - flag: "logfiles_ok"
              set: true
        remediation: |
          Adjust ownership and permissions on log files that were flagged, e.g.:
            chown root:adm <logfile>
            chmod 640 <logfile>

          Notes:
          - Owners allowed: root or syslog
          - Groups allowed: root or adm
          - Permissions: 640 or more restrictive
        scored: true

  - id: 5.2
    description: "Configure System Accounting (auditd)"
    checks:
      - id: 5.2.1
        description: "Ensure auditing is enabled"
        type: "skip"
        checks:
      - id: 5.2.1.1
        description: "Ensure auditd is installed (Automated)"
        audit: "rpm -q audit audit-libs"
        tests:
          test_items:
            - flag: "package audit is not installed"
              set: false
            - flag: "package audit-libs is not installed"
              set: false
        remediation: |
            Install the audit package if it is not already installed:

            # dnf install audit
        scored: true

      - id: 5.2.1.2
        description: "Ensure auditing for processes that start prior to auditd is enabled (Automated)"
        audit: |
          audit_param1="$(grubby --info=ALL 2>/dev/null | grep -Po '\baudit=1\b' | sort -u)"
          audit_param2="$(grep -Psoi '^\s*GRUB_CMDLINE_LINUX=\"([^#\n\r]+\s+)?audit=1\b' /etc/default/grub 2>/dev/null)"

          if [ -n "$audit_param1" ] && [ -n "$audit_param2" ]; then
            echo "audit_prior_ok"
          else
            echo "audit_prior_bad"
          fi
        tests:
          test_items:
            - flag: "audit_prior_ok"
              set: true
        remediation: |
          Enable auditing for processes that start prior to auditd by ensuring audit=1 is set.

          1. Update all kernels via grubby:
             grubby --update-kernel ALL --args 'audit=1'

          2. Edit /etc/default/grub and ensure the GRUB_CMDLINE_LINUX line includes audit=1:
             Example:
               GRUB_CMDLINE_LINUX="quiet audit=1"

          3. Rebuild the grub configuration (if required by distribution):
             grub2-mkconfig -o /boot/grub2/grub.cfg   # (BIOS systems)
             grub2-mkconfig -o /boot/efi/EFI/<distro>/grub.cfg   # (UEFI systems)

          Notes:
          - Other kernel boot parameters may also be present; do not remove them, just append audit=1.
          - This ensures that all processes, even those that start before auditd, are auditable.
        scored: true

      - id: 5.2.1.3
        description: "Ensure audit_backlog_limit is sufficient (Automated)"
        audit: |
          grubby --info=ALL | grep -Po '\baudit_backlog_limit=\K\d+' | awk '{ if ($1 >= 8192) { print "PASS" } else { print "FAIL" } }'
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          Run the following command to add audit_backlog_limit=<BACKLOG SIZE> to
          GRUB_CMDLINE_LINUX:
          # grubby --update-kernel ALL --args 'audit_backlog_limit=<BACKLOG SIZE>'
          Example:
          # grubby --update-kernel ALL --args 'audit_backlog_limit=8192'
            Edit /etc/default/grub and add audit_backlog_limit=<BACKLOG SIZE> to the
          GRUB_CMDLINE_LINUX= line between the opening and closing double quotes:
          Example:
            GRUB_CMDLINE_LINUX="quiet audit_backlog_limit=8192"
          Note: Other parameters may also be listed
        scored: true

      - id: 5.2.1.4
        description: "Ensure auditd service is enabled (Automated)"
        audit: |
          systemctl is-enabled auditd
        tests:
          test_items:
            - flag: "enabled"
              set: true
        remediation: |
          Run the following command to enable auditd:

          # systemctl --now enable auditd
        scored: true

      - id: 5.2.2
        description: "Configure Data Retention"
        type: "skip"
        checks:
      - id: 5.2.2.1
        description: "Ensure audit log storage size is configured (Automated)"
        audit: |
          grep -P '^\s*max_log_file\s*=\s*\d+' /etc/audit/auditd.conf
        tests:
          test_items:
            - flag: "max_log_file"
              compare:
                op: gt
                value: 0
        remediation: |
          Edit the file `/etc/audit/auditd.conf` and set the `max_log_file` parameter
          according to your site's policy. The value is specified in megabytes (MB).

          Example:
          max_log_file = 100

          After modifying the file, restart the audit daemon:

          systemctl restart auditd
        scored: true

      - id: 5.2.2.2
        description: "Ensure audit logs are not automatically deleted (Automated)"
        audit: |
          grep max_log_file_action /etc/audit/auditd.conf
        tests:
          test_items:
            - flag: "keep_logs"
              set: true
        remediation: |
          Set the following parameter in /etc/audit/auditd.conf:

          max_log_file_action = keep_logs
        scored: true

      - id: 5.2.2.3
        description: "Ensure system is disabled when audit logs are full (Automated)"
        audit: |
          full_action="$(grep -Pi '^\s*disk_full_action\s*=\s*(halt|single)\b' /etc/audit/auditd.conf 2>/dev/null)"
          error_action="$(grep -Pi '^\s*disk_error_action\s*=\s*(syslog|single|halt)\b' /etc/audit/auditd.conf 2>/dev/null)"

          if [ -n "$full_action" ] && [ -n "$error_action" ]; then
            echo "audit_disk_action_ok"
          else
            echo "audit_disk_action_bad"
          fi
        tests:
          test_items:
            - flag: "audit_disk_action_ok"
              set: true
        remediation: |
          Edit /etc/audit/auditd.conf and configure the following settings according to site policy:

            disk_full_action = halt    # or single
            disk_error_action = halt   # or single, or syslog

          Example (high-security environment):
            disk_full_action = halt
            disk_error_action = halt

          After modification, restart auditd:
            systemctl restart auditd

          Notes:
          - `disk_full_action` must be either `halt` or `single`
          - `disk_error_action` must be one of `syslog`, `single`, or `halt`
          - Choosing `halt` or `single` may affect system availability when audit storage fails, but ensures log integrity.
        scored: true

      - id: 5.2.2.4
        description: "Ensure system warns when audit logs are low on space (Automated)"
        audit: |
          space_action="$(grep -Pi '^\s*space_left_action\s*=\s*(email|exec|single|halt)\b' /etc/audit/auditd.conf 2>/dev/null)"
          admin_space_action="$(grep -Pi '^\s*admin_space_left_action\s*=\s*(single|halt)\b' /etc/audit/auditd.conf 2>/dev/null)"

          if [ -n "$space_action" ] && [ -n "$admin_space_action" ]; then
            echo "audit_lowspace_ok"
          else
            echo "audit_lowspace_bad"
          fi
        tests:
          test_items:
            - flag: "audit_lowspace_ok"
              set: true
        remediation: |
          Configure auditd to warn or restrict when log storage is low.

          In /etc/audit/auditd.conf set:

            space_left_action = email   # or exec, single, halt
            admin_space_left_action = single   # or halt

          Example configuration:
            space_left_action = email
            admin_space_left_action = single

          Notes:
          - If using `email`, ensure a Mail Transfer Agent (MTA) is installed and properly configured.
          - `admin_space_left_action` should be either `single` (enter single-user mode) or `halt` (shut down system).
          - After changes, restart auditd:
              systemctl restart auditd
        scored: true

      - id: 5.2.3
        description: "Configure auditd rules"
        type: "skip"
        checks:
      - id: 5.2.3.1
        description: "Ensure changes to system administration scope (sudoers) is collected (Automated)"
        audit: |
          awk '/^ *-w/ \
          && /\/etc\/sudoers/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules

          awk '/^ *-w/ \
          && /\/etc\/sudoers.d/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
        tests:
          test_items:
            - flag: "-w /etc/sudoers -p wa -k scope"
              compare:
                op: has
                value: "scope"
        remediation: |
          echo "[+] Adding sudoers scope monitoring rules..."
          printf "
          -w /etc/sudoers -p wa -k scope
          -w /etc/sudoers.d -p wa -k scope
          " >> /etc/audit/rules.d/50-scope.rules

              echo "[  ] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to fully enforce the new audit rules."
          fi
        scored: true


      - id: 5.2.3.2
        description: "Ensure actions as another user are always logged (Automated)"
        audit: |
          awk '/^ *-a *always,exit/ \
          && / -F *arch=b(32|64)/ \
          && (/ -F *auid!=unset/ || / -F *auid!=-1/ || / -F *auid!=4294967295/) \
          && (/ -C *euid!=uid/ || / -C *uid!=euid/) \
          && / -S *execve/ \
          && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
        tests:
          test_items:
            - flag: "-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation"
              compare:
                op: has
                value: "user_emulation"
        remediation: |
          echo "[+] Adding user emulation audit rule..."
          printf "
          -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          " >> /etc/audit/rules.d/50-user_emulation.rules

              echo "[  ] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to fully enforce the new audit rules."
          fi
        scored: true


      - id: 5.2.3.3
        description: "Ensure events that modify the sudo log file are collected (Automated)"
        audit: |
          SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//' -e 's/,.*//' -e 's/\"//g')

          if [ -n "$SUDO_LOG_FILE" ]; then
            awk "/^ *-w/ && /$SUDO_LOG_FILE/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules
          else
            echo "ERROR: Could not determine sudo log file from sudoers config."
          fi
        tests:
          test_items:
            - flag: "-w /var/log/sudo.log -p wa -k sudo_log_file"
              compare:
                op: has
                value: "/var/log/sudo.log"
        remediation: |
          echo "[+] Adding sudo log audit rule..."
          SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//' -e 's/,.*//' -e 's/\"//g')

          if [ -n "$SUDO_LOG_FILE" ]; then
            echo "-w $SUDO_LOG_FILE -p wa -k sudo_log_file" >> /etc/audit/rules.d/50-sudo.rules
          else
            echo "ERROR: SUDO_LOG_FILE not found, skipping rule addition."
          fi

          echo "[] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
            echo "Reboot required to apply sudo log audit rules completely."
          fi
        scored: true

      - id: 5.2.3.4
        description: "Ensure events that modify date and time information are collected (Automated)"
        audit: |
          # Check audit rules on disk
          # On-disk rules
          disk_rules="$(
          awk '/^-a[[:space:]]*always,exit/ \
          && /-F[[:space:]]*arch=b(32|64)/ \
          && /-S/ \
          && (/adjtimex/ || /settimeofday/ || /clock_settime/) \
          && /(-F[[:space:]]*key=| -k[[:space:]]*)/ {print}' \
          /etc/audit/rules.d/*.rules 2>/dev/null
          )'

          disk_localtime="$(
          awk '/^-w/ \
          && /\/etc\/localtime/ \
          && /-p[[:space:]]*wa/ \
          && /(-F[[:space:]]*key=| -k[[:space:]]*)/ {print}' \
          /etc/audit/rules.d/*.rules 2>/dev/null
          )'

          # Loaded rules
          live_rules="$(
          auditctl -l 2>/dev/null | awk '/^-a[[:space:]]*always,exit/ \
          && /-F[[:space:]]*arch=b(32|64)/ \
          && /-S/ \
          && (/adjtimex/ || /settimeofday/ || /clock_settime/) \
          && /(-F[[:space:]]*key=| -k[[:space:]]*)/ {print}'
          )'

          live_localtime="$(
          auditctl -l 2>/dev/null | awk '/^-w/ \
          && /\/etc\/localtime/ \
          && /-p[[:space:]]*wa/ \
          && /(-F[[:space:]]*key=| -k[[:space:]]*)/ {print}'
          )'


          if [ -n "$disk_rules" ] && [ -n "$disk_localtime" ] && [ -n "$live_rules" ] && [ -n "$live_localtime" ]; then
            echo "audit_timechange_ok"
          else
            echo "audit_timechange_bad"
            [ -z "$disk_rules" ] && echo " Missing syscall rules on disk"
            [ -z "$disk_localtime" ] && echo " Missing /etc/localtime watch on disk"
            [ -z "$live_rules" ] && echo " Missing syscall rules in running config"
            [ -z "$live_localtime" ] && echo " Missing /etc/localtime watch in running config"
          fi
        tests:
          test_items:
            - flag: "audit_timechange_ok"
              set: true
        remediation: |
          Configure audit rules to capture changes to system date and time.

          Create or edit /etc/audit/rules.d/50-time-change.rules and add:

            -a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
            -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime -k time-change
            -w /etc/localtime -p wa -k time-change

          On 32-bit only systems, also include `stime` in the b32 rule:
            -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change

          Load the updated rules:
            augenrules --load

          If auditing is locked (`auditctl -s | grep enabled=2`), a reboot may be required for rules to take effect.
        scored: true


      - id: 5.2.3.5
        description: "Ensure events that modify the system's network environment are collected (Automated)"
        audit: |
          check_rules() {
            auditctl -l 2>/dev/null
            cat /etc/audit/rules.d/*.rules 2>/dev/null
          }

          out="$(check_rules)"

          if echo "$out" | grep -Eq -- '-a always,exit -F arch=b(32|64) .* -S (sethostname|setdomainname) .* (-k|key=)'; then
            if echo "$out" | grep -Eq -- '-w (/etc/issue|/etc/issue.net|/etc/hosts|/etc/sysconfig/network|/etc/sysconfig/network-scripts) .* -p wa .* (-k|key=)'; then
              echo "audit_netenv_ok"
            else
              echo "audit_netenv_bad"
            fi
          else
            echo "audit_netenv_bad"
          fi
        tests:
          test_items:
            - flag: "audit_netenv_ok"
              set: true
        remediation: |
          echo "[+] Writing audit rules for system-locale (network-related changes)..."
          cat << 'EOF' > /etc/audit/rules.d/50-system_local.rules
          -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
          -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
          -w /etc/issue -p wa -k system-locale
          -w /etc/issue.net -p wa -k system-locale
          -w /etc/hosts -p wa -k system-locale
          -w /etc/sysconfig/network -p wa -k system-locale
          -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
          EOF

          echo "[] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to apply system-locale audit rules completely."
          fi
        scored: true


      - id: 5.2.3.6
        description: "Ensure use of privileged commands are collected (Automated)"
        audit: |
          for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
            for PRIVILEGED in $(find "${PARTITION}" -xdev -perm /6000 -type f); do
              grep -qr "${PRIVILEGED}" /etc/audit/rules.d \
              && echo "OK: '${PRIVILEGED}' found in audit rules." \
              || echo "Warning: '${PRIVILEGED}' not found in audit rules."
            done
          done
        tests:
          test_items:
            - flag: "OK:"
              set: true
        remediation: |
          echo "[+] Adding privileged command audit rules..."
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          AUDIT_RULE_FILE="/etc/audit/rules.d/50-privileged.rules"
          NEW_DATA=()
          for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
            readarray -t DATA < <(find "${PARTITION}" -xdev -perm /6000 -type f | awk -v UID_MIN=${UID_MIN} '{print "-a always,exit -F path=" $1 " -F perm=x -F auid>="UID_MIN" -F auid!=unset -k privileged"}')
            for ENTRY in "${DATA[@]}"; do
              NEW_DATA+=("${ENTRY}")
            done
          done
          readarray -t OLD_DATA < "${AUDIT_RULE_FILE}" 2>/dev/null || OLD_DATA=()
          COMBINED_DATA=( "${OLD_DATA[@]}" "${NEW_DATA[@]}" )
          printf '%s\n' "${COMBINED_DATA[@]}" | sort -u > "${AUDIT_RULE_FILE}"

          echo "[] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
            echo "Reboot required to fully apply privileged command audit rules."
          fi
        scored: true


      - id: 5.2.3.7
        description: "Ensure unsuccessful file access attempts are collected (Automated)"
        audit: |
          # 5.2.3.7  audit
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          [ -z "$UID_MIN" ] && { echo "ERROR: UID_MIN not found in /etc/login.defs"; exit 0; }

          need_ok() {
            # $1=source cmd, $2=arch (b64/b32), $3=exit (-EACCES/-EPERM)
            # Succeeds if there exists at least one rule line for this arch+exit with the right auid/key
            # and at least one of the target syscalls listed in -S (any grouping is fine).
            src="$1"
            arch="$2"
            ex="$3"
            eval "$src" | awk -v min="$UID_MIN" -v a="$arch" -v ex="$ex" '
              # Must be an always,exit rule for the arch
              $0 ~ /(^|[[:space:]])-a[[:space:]]+always,exit([[:space:]]|$)/ &&
              $0 ~ ("(^|[[:space:]])-F[[:space:]]+arch=" a "([[:space:]]|$)") &&
              # Must have auid filters and a key
              $0 ~ /(^|[[:space:]])(-F[[:space:]]+auid!=unset|-F[[:space:]]+auid!=-1|-F[[:space:]]+auid!=4294967295)([[:space:]]|$)/ &&
              $0 ~ ("(^|[[:space:]])-F[[:space:]]+auid>=" min "([[:space:]]|$)") &&
              $0 ~ ("(^|[[:space:]])-F[[:space:]]+exit=" ex "([[:space:]]|$)") &&
              $0 ~ /(^|[[:space:]])-S[[:space:]]+/ &&
              # Accept if the rule references at least one of the required syscalls
              $0 ~ /(^|[[:space:]])-S[[:space:]]+([^#]*\b(creat|open|openat|truncate|ftruncate)\b)/ &&
              $0 ~ /(^|[[:space:]])(-k[[:space:]]+\S+|-F[[:space:]]+key=\S+)([[:space:]]|$)/
            ' | grep -q .
          }

          disk_src='cat /etc/audit/rules.d/*.rules 2>/dev/null'
          live_src='auditctl -l 2>/dev/null'

          disk_ok=1; live_ok=1

          # Require both exit codes for b64 and b32
          for ex in -EACCES -EPERM; do
            need_ok "$disk_src" b64 "$ex" || { echo " disk_missing_b64_${ex#-}"; disk_ok=0; }
            need_ok "$live_src" b64 "$ex" || { echo " live_missing_b64_${ex#-}"; live_ok=0; }
            need_ok "$disk_src" b32 "$ex" || { echo " disk_missing_b32_${ex#-}"; disk_ok=0; }
            need_ok "$live_src" b32 "$ex" || { echo " live_missing_b32_${ex#-}"; live_ok=0; }
          done

          if [ $disk_ok -eq 1 ] && [ $live_ok -eq 1 ]; then
            echo "audit_unsuccessful_file_access_ok"
          else
            echo "audit_unsuccessful_file_access_bad"
          fi
        tests:
          test_items:
            - flag: "audit_unsuccessful_file_access_ok"
              set: true
        remediation: |
          Configure audit rules to log unsuccessful file access attempts.

          Create or edit /etc/audit/rules.d/50-access.rules and add:

            -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -k access
            -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=1000 -F auid!=unset -k access
            -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -k access
            -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=1000 -F auid!=unset -k access

          Replace `1000` with the actual UID_MIN value from /etc/login.defs if different.

          Load the updated rules:
            augenrules --load

          If auditing is locked (`auditctl -s | grep enabled=2`), a reboot will be required for rules to take effect.
        scored: true

      - id: 5.2.3.8
        description: "Ensure events that modify user/group information are collected (Automated)"
        audit: |
          if awk '/^ *-w/ \
            &&(/\/etc\/group/ || /\/etc\/passwd/ || /\/etc\/gshadow/ || /\/etc\/shadow/ || /\/etc\/security\/opasswd/) \
            &&/ +-p *wa/ \
            &&(/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | grep -q "identity"; then
              echo "identity_rules_present"
          else
              echo "identity_rules_missing"
          fi
        tests:
          test_items:
            - flag: "identity_rules_present"
              set: true
        remediation: |
          Add the following lines to /etc/audit/rules.d/50-identity.rules:

            -w /etc/group -p wa -k identity
            -w /etc/passwd -p wa -k identity
            -w /etc/gshadow -p wa -k identity
            -w /etc/shadow -p wa -k identity
            -w /etc/security/opasswd -p wa -k identity

          Then reload audit rules:
            # augenrules --load

          Optionally, verify if a reboot is needed:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.9
        description: "Ensure discretionary access control permission modification events are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "$UID_MIN" ]; then
            awk "/^-a always,exit/ \
              && /-F arch=b(32|64)/ \
              && /-F auid>=$UID_MIN/ \
              && (/auid!=unset/ || /auid!=-1/ || /auid!=4294967295/) \
              && /-S/ \
              && (/chmod/ || /fchmod/ || /fchmodat/ || /chown/ || /fchown/ || /fchownat/ || /lchown/ || /setxattr/ || /lsetxattr/ || /fsetxattr/ || /removexattr/ || /lremovexattr/ || /fremovexattr/) \
              && (/ key= *[!-~]*$/ || / -k *[!-~]*$/)" /etc/audit/rules.d/*.rules | grep -q "perm_mod" && echo "perm_mod_rules_present" || echo "perm_mod_rules_missing"
          else
            echo "UID_MIN not set in /etc/login.defs"
          fi
        tests:
          test_items:
            - flag: "perm_mod_rules_present"
              set: true
        remediation: |
          Add the following lines to a file like /etc/audit/rules.d/50-perm_mod.rules:

            -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b32 -S chown,fchown,lchown,fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod

          Then reload the audit rules:
            # augenrules --load

          Optionally check if a reboot is needed:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.10
        description: "Ensure successful file system mounts are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "$UID_MIN" ]; then
            RULES=$(awk "/^-a always,exit/ && /-F arch=b(32|64)/ && /-S mount/ && /-F auid>=$UID_MIN/ && (/auid!=unset/ || /auid!=-1/ || /auid!=4294967295/) && /-k mounts/" /etc/audit/rules.d/*.rules || true)
            if echo "$RULES" | grep -q "mount"; then
              echo "mount_audit_rules_present"
            else
              echo "mount_audit_rules_missing"
            fi
          else
            echo "UID_MIN not set in /etc/login.defs"
          fi
        tests:
          test_items:
            - flag: "mount_audit_rules_present"
              set: true
        remediation: |
          Add the following lines to a rules file, such as /etc/audit/rules.d/50-mounts.rules:

            -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=unset -k mounts
            -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=unset -k mounts

          Then reload the audit rules:
            # augenrules --load

          Optionally check if a reboot is needed:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.11
        description: "Ensure session initiation information is collected (Automated)"
        audit: |
          RULE1=$(grep -P -- "^-w\s+/var/run/utmp\s+-p\s+wa\s+-k\s+session" /etc/audit/rules.d/*.rules || true)
          RULE2=$(grep -P -- "^-w\s+/var/log/wtmp\s+-p\s+wa\s+-k\s+session" /etc/audit/rules.d/*.rules || true)
          RULE3=$(grep -P -- "^-w\s+/var/log/btmp\s+-p\s+wa\s+-k\s+session" /etc/audit/rules.d/*.rules || true)

          if [ -n "$RULE1" ] && [ -n "$RULE2" ] && [ -n "$RULE3" ]; then
            echo "session_audit_rules_present"
          else
            echo "session_audit_rules_missing"
          fi
        tests:
          test_items:
            - flag: "session_audit_rules_present"
              set: true
        remediation: |
          Create or edit the audit rules file `/etc/audit/rules.d/50-session.rules` and add the following lines:
            -w /var/run/utmp -p wa -k session
            -w /var/log/wtmp -p wa -k session
            -w /var/log/btmp -p wa -k session

          Then load the rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.12
        description: "Ensure login and logout events are collected (Automated)"
        audit: |
          RULE1=$(grep -P -- "^-w\s+/var/log/lastlog\s+-p\s+wa\s+-k\s+logins" /etc/audit/rules.d/*.rules || true)
          RULE2=$(grep -P -- "^-w\s+/var/run/faillock\s+-p\s+wa\s+-k\s+logins" /etc/audit/rules.d/*.rules || true)

          if [ -n "$RULE1" ] && [ -n "$RULE2" ]; then
            echo "login_logout_audit_rules_present"
          else
            echo "login_logout_audit_rules_missing"
          fi
        tests:
          test_items:
            - flag: "login_logout_audit_rules_present"
              set: true
        remediation: |
          Create or edit the audit rules file `/etc/audit/rules.d/50-login.rules` and add the following lines:
            -w /var/log/lastlog -p wa -k logins
            -w /var/run/faillock -p wa -k logins

          Then load the rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.13
        description: "Ensure file deletion events by users are collected (Automated)"
        audit: |
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          if [ -z "$UID_MIN" ]; then
            echo "ERROR: UID_MIN not found in /etc/login.defs"
            exit 0
          fi

          have_rule() {
            src="$1"; arch="$2"
            eval "$src" | awk -v min="$UID_MIN" -v a="$arch" '
              $0 ~ /(^|[[:space:]])-a[[:space:]]+always,exit([[:space:]]|$)/ &&
              $0 ~ ("(^|[[:space:]])-F[[:space:]]+arch=" a "([[:space:]]|$)") &&
              $0 ~ /(^|[[:space:]])(-F[[:space:]]+auid!=unset|-F[[:space:]]+auid!=-1|-F[[:space:]]+auid!=4294967295)([[:space:]]|$)/ &&
              $0 ~ ("(^|[[:space:]])-F[[:space:]]+auid>=" min "([[:space:]]|$)") &&
              $0 ~ /(^|[[:space:]])-S[[:space:]]+/ &&
              $0 ~ /(^|[[:space:]])-S[[:space:]]+([^#]*\b(unlink|unlinkat|rename|renameat)\b)/ &&
              $0 ~ /(^|[[:space:]])(-k[[:space:]]+\S+|-F[[:space:]]+key=\S+)([[:space:]]|$)/
            ' | grep -q .
          }

          disk_src='cat /etc/audit/rules.d/*.rules 2>/dev/null'
          live_src='auditctl -l 2>/dev/null'

          disk_ok=1; live_ok=1

          # Require both arches present on disk and in the running config
          have_rule "$disk_src" b64 || { echo " disk_missing_b64_delete_rules"; disk_ok=0; }
          have_rule "$disk_src" b32 || { echo " disk_missing_b32_delete_rules"; disk_ok=0; }
          have_rule "$live_src" b64 || { echo " live_missing_b64_delete_rules"; live_ok=0; }
          have_rule "$live_src" b32 || { echo " live_missing_b32_delete_rules"; live_ok=0; }

          if [ $disk_ok -eq 1 ] && [ $live_ok -eq 1 ]; then
            echo "audit_filedelete_ok"
          else
            echo "audit_filedelete_bad"
          fi
        tests:
          test_items:
            - flag: "audit_filedelete_ok"
              set: true
        remediation: |
          Configure audit rules to capture file deletion events by non-privileged users.

          Create or edit /etc/audit/rules.d/50-delete.rules and add:

            -a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=unset -k delete
            -a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=unset -k delete

          (Replace 1000 with the value of UID_MIN from /etc/login.defs if different.)

          Load the updated rules:
            augenrules --load

          If auditing is locked (`auditctl -s | grep enabled=2`), a system reboot will be required for rules to take effect.

          Notes:
          - This rule ensures all file deletions (unlink, unlinkat) and renames (rename, renameat) by non-privileged users are logged.
          - For performance, all syscalls are placed on one line as recommended by audit.rules(7).
        scored: true


      - id: 5.2.3.14
        description: "Ensure events that modify the system's Mandatory Access Controls are collected (Automated)"
        audit: |
          ETC_SELINUX=$(grep -P -- '^\s*-w\s+/etc/selinux\s+-p\s+wa\s+(-k\s+MAC-policy|key=MAC-policy)' /etc/audit/rules.d/*.rules || true)
          SHARE_SELINUX=$(grep -P -- '^\s*-w\s+/usr/share/selinux\s+-p\s+wa\s+(-k\s+MAC-policy|key=MAC-policy)' /etc/audit/rules.d/*.rules || true)

          if [ -n "$ETC_SELINUX" ] && [ -n "$SHARE_SELINUX" ]; then
            echo "selinux_mac_policy_audit_rules_present"
          else
            echo "mac_policy_audit_rules_missing"
          fi
        tests:
          test_items:
            - flag: "selinux_mac_policy_audit_rules_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-MAC-policy.rules` and add the following lines:

            -w /etc/selinux -p wa -k MAC-policy
            -w /usr/share/selinux -p wa -k MAC-policy

          Then reload the audit rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.15
        description: "Ensure successful and unsuccessful attempts to use the chcon command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/chcon\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k perm_chng" /etc/audit/rules.d/*.rules; then
              echo "chcon_audit_rule_present"
            else
              echo "chcon_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "chcon_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-perm_chng.rules` and add the following line:

            -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.16
        description: "Ensure successful and unsuccessful attempts to use the setfacl command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/setfacl\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k perm_chng" /etc/audit/rules.d/*.rules; then
              echo "setfacl_audit_rule_present"
            else
              echo "setfacl_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "setfacl_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-perm_chng.rules` and add the following line:

            -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.17
        description: "Ensure successful and unsuccessful attempts to use the chacl command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/chacl\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k perm_chng" /etc/audit/rules.d/*.rules; then
              echo "chacl_audit_rule_present"
            else
              echo "chacl_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "chacl_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-perm_chng.rules` and add the following line:

            -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.18
        description: "Ensure successful and unsuccessful attempts to use the usermod command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/sbin/usermod\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k usermod" /etc/audit/rules.d/*.rules; then
              echo "usermod_audit_rule_present"
            else
              echo "usermod_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "usermod_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-usermod.rules` and add the following line:

            -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -k usermod

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true

      - id: 5.2.3.19
        description: "Ensure kernel module loading, unloading and modification is collected (Automated)"
        audit: |
          UID_MIN="$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"
          if [ -z "$UID_MIN" ]; then
            echo "ERROR: UID_MIN not found in /etc/login.defs"; exit 0
          fi

          disk_rules_text="$(cat /etc/audit/rules.d/*.rules 2>/dev/null)"
          live_rules_text="$(auditctl -l 2>/dev/null)"

          has_syscalls_arch_grep() {  # $1=rules_text  $2=b64|b32
            local text="$1" arch="$2" ok=0
            for sc in init_module finit_module delete_module create_module query_module; do
              echo "$text" | grep -Eq \
                "^-a[[:space:]]+always,exit.*-F[[:space:]]+arch=${arch}.*-S[[:space:]]*[^#]*\b${sc}\b.*-F[[:space:]]+auid>=${UID_MIN}.*(-F[[:space:]]+auid!=unset|-F[[:space:]]+auid!=-1|-F[[:space:]]+auid!=4294967295).*(-k[[:space:]]+\S+|-F[[:space:]]+key=\S+)" \
                || return 1
              ok=1
            done
            [ $ok -eq 1 ]
          }

          has_kmod_exec_grep() {  # $1=rules_text
            echo "$1" | grep -Eq \
              "^-a[[:space:]]+always,exit.*-F[[:space:]]+path=/usr/bin/kmod.*-F[[:space:]]+perm=x.*-F[[:space:]]+auid>=${UID_MIN}.*(-F[[:space:]]+auid!=unset|-F[[:space:]]+auid!=-1|-F[[:space:]]+auid!=4294967295).*(-k[[:space:]]+\S+|-F[[:space:]]+key=\S+)"
          }

          disk_ok=1; live_ok=1

          # On-disk checks
          has_syscalls_arch_grep "$disk_rules_text" b64 || { echo " disk_missing_syscalls_b64"; disk_ok=0; }
          has_syscalls_arch_grep "$disk_rules_text" b32 || { echo " disk_missing_syscalls_b32"; disk_ok=0; }
          has_kmod_exec_grep     "$disk_rules_text"     || { echo " disk_missing_kmod_exec_rule"; disk_ok=0; }

          # Loaded checks
          has_syscalls_arch_grep "$live_rules_text" b64 || { echo " live_missing_syscalls_b64"; live_ok=0; }
          has_syscalls_arch_grep "$live_rules_text" b32 || { echo " live_missing_syscalls_b32"; live_ok=0; }
          has_kmod_exec_grep     "$live_rules_text"     || { echo " live_missing_kmod_exec_rule"; live_ok=0; }

          # Final flag for your YAML tests
          if [ $disk_ok -eq 1 ] && [ $live_ok -eq 1 ]; then
            echo "audit_kernel_modules_ok"
          else
            echo "audit_kernel_modules_bad"
          fi
        tests:
          test_items:
            - flag: "audit_kernel_modules_ok"
              set: true
        remediation: |
          Configure audit rules to capture kernel module load/unload/modify events.

          Create or edit /etc/audit/rules.d/50-kernel_modules.rules and add:

            -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=1000 -F auid!=unset -k kernel_modules
            -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -k kernel_modules

          (Replace 1000 with the value of UID_MIN from /etc/login.defs if different.)

          Load the updated rules:
            augenrules --load

          Check symlinks for kmod-related tools:
            ls -l /usr/sbin/lsmod /usr/sbin/rmmod /usr/sbin/insmod /usr/sbin/modinfo /usr/sbin/modprobe /usr/sbin/depmod | grep -v " -> ../bin/kmod"

          Ensure all symlinks point to ../bin/kmod. Investigate any anomalies.

          Notes:
          - These rules audit both direct syscalls and executions of the kmod tool.
          - If auditing is locked (`auditctl -s | grep enabled=2`), a system reboot may be required to apply changes.
        scored: true

      - id: 5.2.3.20
        description: "Ensure the audit configuration is immutable (Automated)"
        audit: |
          if grep -Ph -- '^\h*-e\h+2\b' /etc/audit/rules.d/*.rules | grep -q -- '-e 2'; then
            echo "audit_config_immutable"
          else
            echo "immutable_setting_missing"
          fi
        tests:
          test_items:
            - flag: "audit_config_immutable"
              set: true
        remediation: |
          Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line:
            -e 2

          Then reload the rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true


      - id: 5.2.3.21
        description: "Ensure the running and on disk configuration is the same (Manual)"
        type: manual
        audit: |
          gaugenrules --check
        remediation: |
          If the rules are not aligned across all three () areas, run the following command to merge and load all rules:

          # augenrules --load
          Check if reboot is required.

          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true

      - id: 5.2.4
        description: "Configure auditd file access"
        type: "skip"
        checks:
      - id: 5.2.4.1
        description: "Ensure the audit log directory is 0750 or more restrictive (Automated)"
        audit: |
          audit_log_dir="$(dirname $(awk -F= '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf 2>/dev/null))"
          if [ -d "$audit_log_dir" ]; then
            perms="$(stat -Lc '%a' "$audit_log_dir" 2>/dev/null)"
            if echo "$perms" | grep -Pvq '^([0,5,7][0,5]0)$'; then
              echo "audit_log_dir_bad ($audit_log_dir has $perms)"
            else
              echo "audit_log_dir_ok"
            fi
          else
            echo "audit_log_dir_missing"
          fi
        tests:
          test_items:
            - flag: "audit_log_dir_ok"
              set: true
        remediation: |
          Set the audit log directory to 0750 or more restrictive:

            chmod g-w,o-rwx "$(dirname $(awk -F= '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf))"

          Example:
            # If audit logs are stored under /var/log/audit:
            chmod 0750 /var/log/audit

          Notes:
          - Default value is 750
          - Ensures group has no write permission and others have no access
        scored: true

      - id: 5.2.4.2
        description: "Ensure audit log files are mode 0640 or less permissive (Automated)"
        audit: |
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            find "$log_dir" -type f \
            \( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \) \
          -exec echo "bad_perms_found: {}" \;
          fi
        tests:
          test_items:
            - flag: bad_perms_found
              set: false
        remediation: |
          Run the following command to fix permissions of audit log files:

          ```sh
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            find "$log_dir" -type f \
              \( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \) \
              -exec chmod u-x,g-wx,o-rwx {} +
          fi
          ```

          This ensures audit log files are readable and/or writable only by authorized users/groups.
        scored: true

      - id: 5.2.4.3
        description: "Ensure only authorized users own audit log files (Automated)"
        audit: |
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            find "$log_dir" -type f ! -user root -exec echo "bad_owner_found: {}" \;
          fi
        tests:
          test_items:
            - flag: bad_owner_found
              set: false
        remediation: |
          Run the following command to configure the audit log files to be owned by the root user:

          [ -f /etc/audit/auditd.conf ] && find "$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" -type f ! -user root -exec chown root {} +
        scored: true

      - id: 5.2.4.4
        description: "Ensure only authorized groups are assigned ownership of audit log files (Automated)"
        audit: |
          grep -Piw -- '^\h*log_group\h*=\h*(adm|root)\b' /etc/audit/auditd.conf || echo "invalid_log_group_found"
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            stat -c "%n %G" "$log_dir"/* | grep -Pv '^\h*\H+\h+(adm|root)\b' && echo "bad_group_owner_found"
          fi
        tests:
          test_items:
            - flag: invalid_log_group_found
              set: false
            - flag: bad_group_owner_found
              set: false
        remediation: |
          1. Update audit log files group ownership:
             find $(dirname $(awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf | xargs)) -type f \( ! -group adm -a ! -group root \) -exec chgrp adm {} +

          2. Update audit log directory group:
             chgrp adm /var/log/audit/

          3. Set the correct group in audit config:
             sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?.*$/log_group = adm\1/' /etc/audit/auditd.conf

          4. Restart auditd to apply:
             systemctl restart auditd
        scored: true

      - id: 5.2.4.5
        description: "Ensure audit configuration files are 640 or more restrictive (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) \
          -exec stat -Lc "%n %a" {} + | \
          grep -Pv -- '^\h*\H+\h*([0,2,4,6][0,4]0)\h*$' && echo "audit_config_perms_weak"
        tests:
          test_items:
            - flag: audit_config_perms_weak
              set: false
        remediation: |
          Run the following command to correct the file permissions:

            find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec chmod u-x,g-wx,o-rwx {} +

          This ensures all audit configuration files are set to **0640 or stricter**, protecting audit rules from unauthorized access or tampering.
        scored: true

      - id: 5.2.4.6
        description: "Ensure audit configuration files are owned by root (Automated)"
        audit: |
          if find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root | grep -q .; then
            echo "audit_config_not_owned_by_root"
          else
            echo "audit_config_ok"
          fi
        tests:
          test_items:
            - flag: "audit_config_ok"
              set: true
        remediation: |
          Run the following command to change the ownership of audit configuration files to the root user:

            find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -exec chown root {} +

          This ensures audit configurations are protected from unauthorized modification.
        scored: true


      - id: 5.2.4.7
        description: "Ensure audit configuration files belong to group root (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to change the group ownership of audit configuration files to root:

            find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root -exec chgrp root {} +

          This ensures only authorized groups can modify critical audit configurations.
        scored: true

      - id: 5.2.4.8
        description: "Ensure audit tools are 755 or more restrictive (Automated)"
        audit: |
          stat -c "%n %a" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules 2>/dev/null | \
          grep -Pv -- '^\h*\H+\h+([0-7][0,1,4,5][0,1,4,5])\h*$' && echo "audit_tools_bad_perms"
        tests:
          test_items:
            - flag: audit_tools_bad_perms
              set: false
        remediation: |
          Run the following command to correct the permissions of audit tools:

            chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules

          This ensures only authorized users can modify or execute audit utilities.
        scored: true

      - id: 5.2.4.9
        description: "Ensure audit tools are owned by root (Automated)"
        audit: |
          audit_tools=(/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules)
          incorrect_ownership_found=false

          for tool in "${audit_tools[@]}"; do
            if [ -e "$tool" ]; then
              owner=$(stat -c '%U' "$tool")
              if [ "$owner" != "root" ]; then
                echo "$tool is not owned by root"
                incorrect_ownership_found=true
              fi
            else
              echo "$tool not found"
            fi
          done

          if ! $incorrect_ownership_found; then
            echo "audit_tools_owned_by_root"
          fi
        tests:
          test_items:
            - flag: "audit_tools_owned_by_root"
              compare:
                op: has
                value: "audit_tools_owned_by_root"
        remediation: |
          Run the following command to ensure audit tools are owned by root:
          # chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
        scored: true


      - id: 5.2.4.10
        description: "Ensure audit tools belong to group root (Automated)"
        audit: |
          stat -c "%n %a %U %G" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules 2>/dev/null | \
          grep -Pv -- '^\h*\H+\h+([0-7][0,1,4,5][0,1,4,5])\h+root\h+root\h*$' && echo "audit_tools_wrong_group"
        tests:
          test_items:
            - flag: audit_tools_wrong_group
              set: false
        remediation: |
          Run the following commands to correct group and permissions of audit tools:

            chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
            chown root:root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules

          This ensures audit tools are owned and grouped under root with restrictive access.
        scored: true

  - id: 5.3
    description: "Configure Integrity Checking"
    checks:
      - id: 5.3.1
        description: "Ensure AIDE is installed (Automated)"
        audit: "rpm -q aide"
        tests:
          test_items:
            - flag: "package aide is not installed"
              set: false
        remediation: |
          Run the following command to install aide:
          # yum install aide
            Configure aide as appropriate for your environment. Consult the aide documentation for
            options.
          Initialize aide:
          Run the following commands:
            # aide --init
            # mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
        scored: true

      - id: 5.3.2
        description: "Ensure filesystem integrity is regularly checked (Automated)"
        audit: |
          cron_hits="$(grep -Ers '^([^#]+\s+)?(\/usr\/s?bin\/|^\s*)aide(\.wrapper)?\s(--?\S+\s)*(--(check|update)|\$AIDEARGS)\b' /etc/cron.* /etc/crontab /var/spool/cron/ 2>/dev/null)"

          svc_enabled="$(systemctl is-enabled aidecheck.service 2>/dev/null || true)"
          tmr_enabled="$(systemctl is-enabled aidecheck.timer 2>/dev/null || true)"
          tmr_active="$(systemctl is-active  aidecheck.timer  2>/dev/null || true)"

          if [ -n "$cron_hits" ] || { [ "$svc_enabled" = "enabled" ] && [ "$tmr_enabled" = "enabled" ] && [ "$tmr_active" = "active" ]; }; then
            echo "aide_schedule_ok"
          else
            echo "aide_schedule_bad"
            [ -z "$cron_hits" ] && echo " No compliant cron entry found for aide check/update"
            if [ "$svc_enabled" != "enabled" ] || [ "$tmr_enabled" != "enabled" ] || [ "$tmr_active" != "active" ]; then
              echo " aidecheck.service/timer not enabled and running"
            fi
          fi
        tests:
          test_items:
            - flag: "aide_schedule_ok"
              set: true
        remediation: |
          Choose ONE scheduling method, per site policy.

          Option A  Cron (example: daily at 05:00):
            crontab -u root -e
            # Add:
            0 5 * * * /usr/sbin/aide --check

          Option B  systemd timer:
            # /etc/systemd/system/aidecheck.service
            [Unit]
            Description=Aide Check
            [Service]
            Type=simple
            ExecStart=/usr/sbin/aide --check
            [Install]
            WantedBy=multi-user.target

            # /etc/systemd/system/aidecheck.timer
            [Unit]
            Description=Aide check every day at 5AM
            [Timer]
            OnCalendar=*-*-* 05:00:00
            Unit=aidecheck.service
            [Install]
            WantedBy=multi-user.target

            # Permissions and enablement
            chown root:root /etc/systemd/system/aidecheck.*
            chmod 0644 /etc/systemd/system/aidecheck.*
            systemctl daemon-reload
            systemctl enable aidecheck.service
            systemctl --now enable aidecheck.timer
        scored: true


  - id: 6
    description: "System Maintenance"
    checks:
  - id: 6.1
    description: "System File Permissions"
    checks:
      - id: 6.1.1
        description: "Ensure permissions on /etc/passwd are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          # Set secure ownership and permissions on /etc/passwd
          chown root:root /etc/passwd
          chmod u-x,go-wx /etc/passwd   # yields 0644
        scored: true

      - id: 6.1.2
        description: "Ensure permissions on /etc/passwd- are configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd- 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/passwd-:

          chmod u-x,go-wx /etc/passwd-
          chown root:root /etc/passwd-
        scored: true


      - id: 6.1.3
        description: "Ensure permissions on /etc/group are configured (Automated)"
        audit: |
          mode_str="$(stat -Lc '%a' /etc/group 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group:

          chmod u-x,go-wx /etc/group
          chown root:root /etc/group
        scored: true


      - id: 6.1.4
        description: "Ensure permissions on /etc/group- are configured (Automated)"
        audit: |
          # Expect: group <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/group- 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group-:

          chmod u-x,go-wx /etc/group-
          chown root:root /etc/group-
        scored: true

      - id: 6.1.5
        description: "Ensure permissions on /etc/shadow are configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          # Correct ownership and permissions for /etc/shadow
          chown root:root /etc/shadow
          chmod 0000 /etc/shadow
        scored: true

      - id: 6.1.6
        description: "Ensure permissions on /etc/shadow- are configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow-:

          # chown root:root /etc/shadow-
          # chmod 0000 /etc/shadow-
        scored: true

      - id: 6.1.7
        description: "Ensure permissions on /etc/gshadow are configured (Automated)"
        audit: |
          # Expected: /etc/gshadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/gshadow ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow:

          # chown root:root /etc/gshadow
          # chmod 0000 /etc/gshadow
        scored: true

      - id: 6.1.8
        description: "Ensure permissions on /etc/gshadow- are configured (Automated)"
        audit: |
          # Expected: /etc/gshadow- owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/gshadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow-:

          # chown root:root /etc/gshadow-
          # chmod 0000 /etc/gshadow-
        scored: true

      - id: 6.1.9
        description: "Ensure permissions on /etc/shells are configured (Automated)"
        audit: |
          mode_str="$(stat -Lc '%a' /etc/shells 2>/dev/null)" || { echo "shells_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/shells)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "shells_perms_ok"
          else
            echo "shells_perms_bad"
          fi
        tests:
          test_items:
            - flag: "shells_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/shells:

          chmod u-x,go-wx /etc/shells
          chown root:root /etc/shells
        scored: true

      - id: 6.1.10
        description: "Ensure permissions on /etc/security/opasswd are configured (Automated)"
        audit: |
          check_file() {
            f="$1"
            if [ -e "$f" ]; then
              mode_str="$(stat -Lc '%a' "$f" 2>/dev/null)"
              uid_gid="$(stat -Lc '%u %g' "$f" 2>/dev/null)"
              mode=$(( 8#$mode_str ))

              # mode must be <= 0600 (no group/other access) and owned by root:root
              if [ "$uid_gid" = "0 0" ] && [ $(((mode | 0600) == 0600)) -eq 1 ] && [ $(((mode & 07000) == 0)) -eq 1 ]; then
                echo "opasswd_ok_$f"
                echo "opasswd_pass_$f"
              else
                echo "opasswd_bad_$f"
              fi
            else
              echo "opasswd_missing_$f"
              echo "opasswd_pass_$f"
            fi
          }

          check_file /etc/security/opasswd
          check_file /etc/security/opasswd.old
        tests:
          test_items:
            - flag: "opasswd_pass_/etc/security/opasswd"
              set: true
            - flag: "opasswd_pass_/etc/security/opasswd.old"
              set: true
        remediation: |
          # Fix ownership and permissions for opasswd files (if present)
          [ -e "/etc/security/opasswd" ] && chown root:root /etc/security/opasswd && chmod 600 /etc/security/opasswd
          [ -e "/etc/security/opasswd.old" ] && chown root:root /etc/security/opasswd.old && chmod 600 /etc/security/opasswd.old
        scored: true

      - id: 6.1.11
        description: "Ensure world writable files and directories are secured (Automated)"
        audit: |
          echo "Checking for world-writable files (excluding system paths)..."
          find / -xdev \
            -path /run/user -prune -o \
            -path /proc -prune -o \
            -path /sys -prune -o \
            -path /snap -prune -o \
            -path /var/lib/containerd -prune -o \
            -path /var/lib/kubelet/pods -prune -o \
            -type f -perm -0002 -print

          echo "Checking for world-writable directories without sticky bit (excluding system paths)..."
          find / -xdev \
            -path /run/user -prune -o \
            -path /proc -prune -o \
            -path /sys -prune -o \
            -path /snap -prune -o \
            -path /var/lib/containerd -prune -o \
            -path /var/lib/kubelet/pods -prune -o \
            -type d -perm -0002 ! -perm -1000 -print
        tests:
          test_items:
            - flag: "Checking for world-writable files"
              set: true
            - flag: "Checking for world-writable directories without sticky bit"
              set: true
        remediation: |
          # Secure world-writable files by removing "other write":
          chmod o-w <filename>

          # Secure world-writable directories by setting the sticky bit:
          chmod a+t <directory>

          # Bulk fix (use with caution; review results first):
          find / -xdev -type f -perm -0002 -exec chmod o-w {} +
          find / -xdev -type d -perm -0002 ! -perm -1000 -exec chmod a+t {} +
        scored: true

      - id: 6.1.12
        description: "Ensure no unowned or ungrouped files or directories exist (Automated)"
        audit: |
          # Check for unowned files/dirs (no loops)
          nouser_first="$(find / -xdev \
            -path /proc -prune -o -path /sys -prune -o -path /run/user -prune -o \
            -path /var/lib/containerd -prune -o -path /var/lib/kubelet/pods -prune -o \
            \( -type f -o -type d \) -nouser -print -quit 2>/dev/null)"
          if [ -z "$nouser_first" ]; then
            echo "nouser_ok"
          else
            echo "nouser_bad"
            find / -xdev \
              -path /proc -prune -o -path /sys -prune -o -path /run/user -prune -o \
              -path /var/lib/containerd -prune -o -path /var/lib/kubelet/pods -prune -o \
              \( -type f -o -type d \) -nouser -print 2>/dev/null
          fi

          # Check for ungrouped files/dirs (no loops)
          nogroup_first="$(find / -xdev \
            -path /proc -prune -o -path /sys -prune -o -path /run/user -prune -o \
            -path /var/lib/containerd -prune -o -path /var/lib/kubelet/pods -prune -o \
            \( -type f -o -type d \) -nogroup -print -quit 2>/dev/null)"
          if [ -z "$nogroup_first" ]; then
            echo "nogroup_ok"
          else
            echo "nogroup_bad"
            find / -xdev \
              -path /proc -prune -o -path /sys -prune -o -path /run/user -prune -o \
              -path /var/lib/containerd -prune -o -path /var/lib/kubelet/pods -prune -o \
              \( -type f -o -type d \) -nogroup -print 2>/dev/null
          fi
        tests:
          test_items:
            - flag: "nouser_ok"
              set: true
            - flag: "nogroup_ok"
              set: true
        remediation: |
          Identify and correct ownership on any listed paths.

          Examples:
            # Set appropriate owner (replace <user> as per policy)
            chown <user>:<group> "/path/to/file_or_dir"

            # If only group is missing:
            chgrp <group> "/path/to/file_or_dir"

          Bulk (review first; use with caution):
            # List all unowned
            find / -xdev \( -type f -o -type d \) -nouser -print
            # List all ungrouped
            find / -xdev \( -type f -o -type d \) -nogroup -print

          Notes:
          - Choose valid users/groups per site policy; avoid assigning to system accounts unless appropriate.
          - Some mount points and virtual filesystems are excluded to reduce noise.
        scored: true

      - id: 6.1.13
        description: "Ensure SUID and SGID files are reviewed (Manual)"
        type: manual
        audit: |
          echo "Searching for SUID and SGID files (this may take a while)..."
          find / -xdev \
            -path /run/user -prune -o \
            -type f \( -perm -4000 -o -perm -2000 \) -print 2>/dev/null
          echo ""
          echo "  Review the above list of SUID/SGID files and verify they are expected and legitimate."
        remediation: |
          Manually review all SUID and SGID files found in the audit step to ensure no rogue or
          unexpected programs are present on the system.

          - Validate against package checksums to ensure binaries have not been replaced.
          - Remove SUID/SGID bit from any unauthorized or unnecessary file:

            chmod u-s <file>   # removes SUID
            chmod g-s <file>   # removes SGID

          - If a file is not needed at all, remove it:

            rm <file>

           Note:
          - This control is **manual** because administrators must decide which SUID/SGID files are legitimate.
          - Common expected SUID/SGID binaries include: `/usr/bin/passwd`, `/usr/bin/sudo`,
            `/usr/bin/chsh`, `/usr/bin/newgrp`, `/bin/mount`, `/bin/umount`, etc.
        scored: false

      - id: 6.1.14
        description: "Audit system file permissions (Manual)"
        type: manual
        remediation: |
          Review the output from the audit step. For each reported file, confirm whether the
          change is expected per site policy (e.g., hardening steps) or indicates drift/compromise.

          Helpful commands:
            # Which package owns a file
            rpm -qf <path>

            # Verify a specific package
            rpm -V <package>

            # Package info (version, vendor, build, etc.)
            rpm -qi <package>

          After correcting ownership/permissions or reinstalling the package where appropriate,
          re-run the audit until output is clean or document/accept the risk per policy.

          Notes:
          - This control is manual and unscored due to policy-driven interpretation and volume of results.
          - The verify flags used focus on permission/ownership/capabilities-related drift:
              --nomtime --nosize --nomd5 --nolinkto --noconfig --noghost
        scored: false


  - id: 6.2
    description: "Local User and Group Settings"
    checks:
      - id: 6.2.1
        description: "Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
        audit: |
          awk -F: '($2 != "x" ) { print $1 " is not set to shadowed passwords "}' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set accounts to use shadowed passwords:

          # sed -e 's/^\([a-zA-Z0-9_]*\):[^:]*:/\1:x:/' -i /etc/passwd
            Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off.
        scored: true
      - id: 6.2.2
        description: "Ensure /etc/shadow password fields are not empty (Automated)"
        audit: |
          awk -F: '($2 == "" ) { print $1 " does not have a password "}' /etc/shadow
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:

          # passwd -l <username>
            Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off.
        scored: true


      - id: 6.2.3
        description: "Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
        audit: |
          #!/usr/bin/env bash
          findings="$(awk -F: '
            FNR==NR { grp[$3]=1; next }
            {
              gid=$4
              if (gid != "" && !(gid in grp) && !(gid in seen)) {
                print "Group " gid " is referenced by /etc/passwd but does not exist in /etc/group"
                seen[gid]=1
              }
            }
          ' /etc/group /etc/passwd)"

          if [ -z "$findings" ]; then
            echo "passwd_groups_ok"
          else
            echo "passwd_groups_bad"
            printf "%s\n" "$findings"
          fi
        tests:
          test_items:
            - flag: "passwd_groups_ok"
              set: true
        remediation: |
          Investigate each reported GID and correct discrepancies so every GID in /etc/passwd
          exists in /etc/group.

          Typical fixes (examples):
            # Create the missing group with the specific GID:
            groupadd -g <GID> <groupname>

            # OR change the users primary group to an existing, appropriate group:
            usermod -g <existing_group> <username>

          After changes, re-run the audit to confirm no findings remain.
        scored: true


      - id: 6.2.4
        description: "Ensure no duplicate UIDs exist (Automated)"
        audit: |
          #!/usr/bin/env bash
          dups="$(awk -F: '
            {
              uid=$3; user=$1
              users[uid] = (uid in users ? users[uid]" "user : user)
              count[uid]++
            }
            END {
              for (u in count)
                if (count[u] > 1)
                  printf("Duplicate UID: \"%s\" Users: \"%s\"\n", u, users[u])
            }
          ' /etc/passwd)"

          if [ -z "$dups" ]; then
            echo "uid_duplicates_ok"
          else
            echo "uid_duplicates_bad"
            printf "%s\n" "$dups"
          fi
        tests:
          test_items:
            - flag: "uid_duplicates_ok"
              set: true
        remediation: |
          Assign unique UIDs and fix ownerships where duplicates are found.

          Steps (example workflow):
            # 1) Inspect duplicates (from audit output) and pick the correct UID per user/policy.

            # 2) Change a user's UID to a unique value:
            usermod -u <NEW_UNIQUE_UID> <username>

            # 3) Update file ownerships on local filesystems for that user:
            find / -xdev -uid <OLD_UID> -exec chown <username> {} +

            # 4) If the user's primary group also needs correction, adjust as appropriate:
            # usermod -g <groupname> <username>

          Re-run the audit to confirm no duplicate UIDs remain.
        scored: true


      - id: 6.2.5
        description: "Ensure no duplicate GIDs exist (Automated)"
        audit: |
          awk -F: '
            { cnt[$3]++; names[$3] = names[$3] ? names[$3] " " $1 : $1 }
            END {
              for (gid in cnt)
                if (cnt[gid] > 1)
                  printf "Duplicate GID: \"%s\" Groups: \"%s\"\n", gid, names[gid]
            }
          ' /etc/group
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to.
        scored: true

      - id: 6.2.6
        description: "Ensure no duplicate user names exist (Automated)"
        audit: |
          awk -F: '
            { c[$1]++; uids[$1] = uids[$1] ? uids[$1] " " $3 : $3 }
            END {
              for (user in c)
                if (c[user] > 1)
                  printf "Duplicate User: \"%s\" UIDs: \"%s\"\n", user, uids[user]
            }
          ' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs.
        scored: true

      - id: 6.2.7
        description: "Ensure no duplicate group names exist (Automated)"
        audit: |
          awk -F: '
            { c[$1]++; gids[$1] = gids[$1] ? gids[$1] " " $3 : $3 }
            END {
              for (g in c)
                if (c[g] > 1)
                  printf "Duplicate Group: \"%s\" GIDs: \"%s\"\n", g, gids[g]
            }
          ' /etc/group
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.
        scored: true

      - id: 6.2.8
        description: "Ensure root path integrity (Automated)"
        audit: |
          set -euo pipefail
          ROOT_PATH="$(sudo -Hiu root env | awk -F= '$1=="PATH"{print $2; exit}')"
          [ -z "${ROOT_PATH:-}" ] && { echo "root_path_bad"; echo " - Unable to read root PATH"; exit 0; }

          issues=""

          grep -q "::"    <<<"$ROOT_PATH" && issues+=$'\n - root PATH contains an empty directory (::)'
          grep -qE ":\s*$"<<<"$ROOT_PATH" && issues+=$'\n - root PATH contains a trailing colon (:)'
          # match '.' as a discrete component (start, between colons, or end)
          grep -qE '(^|:)\.(?::|$)' <<<"$ROOT_PATH" && issues+=$'\n - root PATH contains current working directory (.)'

          IFS=: read -r -a parts <<< "$ROOT_PATH"
          for p in "${parts[@]}"; do
            # Skip empty components; already flagged via '::'
            [ -z "$p" ] && continue

            if [ ! -d "$p" ]; then
              issues+=$'\n - PATH entry is not a directory: '"$p"
              continue
            fi

            # Collect ownership and mode
            read -r mode owner <<<"$(stat -Lc '%#a %U' -- "$p" 2>/dev/null || echo "UNKNOWN UNKNOWN")"
            if [ "$owner" != "root" ]; then
              issues+=$'\n - Directory not owned by root: '"$p"$' (owner='"$owner"$')'
            fi

            if ! [[ "$mode" =~ ^0?[0-7]{3,4}$ ]]; then
              issues+=$'\n - Unable to parse mode for: '"$p"$' (mode='"$mode"$')'
            else
              # Extract last three digits
              last3="${mode: -3}"
              # Compare as numbers
              if (( 10#$last3 > 755 )); then
                issues+=$'\n - Directory permissions too permissive: '"$p"$' (mode='"$mode"$', require <= 0755)'
              fi
            fi
          done

          if [ -z "$issues" ]; then
            echo "root_path_ok"
          else
            echo "root_path_bad"
            printf "%s\n" "$issues"
          fi
        tests:
          test_items:
            - flag: "root_path_ok"
              set: true
        remediation: |
          Adjust root's PATH and directory ownership/permissions to satisfy:
            - No empty components (::) and no trailing colon (:).
            - Do not include "." as a component.
            - Every PATH directory must exist, be owned by root, and have mode <= 0755.

          Typical fixes:
            # Edit root's shell startup (e.g., /root/.bash_profile, /root/.bashrc, /etc/profile, /etc/sudoers secure_path):
            #   - Remove "." and empty/trailing components.
            #   - Ensure only needed, trusted directories are present.

            # Ensure ownership and permissions on each PATH component:
            chown root:root /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin 2>/dev/null || true
            chmod 0755      /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin 2>/dev/null || true

          Notes:
            - Root PATH often comes from multiple places: sudoers(5) secure_path, /etc/login.defs, PAM env, and shell RC files.
            - After changes, open a new root login shell (or re-load env) and re-run this audit.
        scored: true


      - id: 6.2.9
        description: "Ensure root is the only UID 0 account (Automated)"
        audit: |
          awk -F: '($3 == 0) { print $1 }' /etc/passwd
        tests:
          test_items:
            - flag: "root"
              compare:
                op: eq
                value: "root"
        remediation: |
          Remove any users other than root with UID 0 or assign them a new UID if appropriate.
        scored: true

      - id: 6.2.10
        description: "Ensure local interactive user home directories are configured (Automated)"
        audit: |
          {
            l_output="" l_output2="" l_heout2="" l_hoout2="" l_haout2=""
            l_valid_shells="^($(awk -F/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' -))$"
            unset a_uarr && a_uarr=()
            while read -r l_epu l_eph; do
            a_uarr+=("$l_epu $l_eph")
            done <<< "$(awk -F: -v pat="$l_valid_shells" '($NF ~ pat) { print $1, $(NF-1) }' /etc/passwd)"

            for entry in "${a_uarr[@]}"; do
            l_user=$(echo "$entry" | awk '{print $1}')
            l_home=$(echo "$entry" | awk '{print $2}')
            if [ -d "$l_home" ]; then
            l_mask='0027'
            l_max="$(printf '%o' $((0777 & ~$l_mask)))"
            read -r l_own l_mode <<< "$(stat -Lc '%U %a' "$l_home")"
            [ "$l_user" != "$l_own" ] && l_hoout2="$l_hoout2\n  - User: \"$l_user\" Home \"$l_home\" is owned by: \"$l_own\""
            if [ $((10#$l_mode & 10#$l_mask)) -gt 0 ]; then
            l_haout2="$l_haout2\n  - User: \"$l_user\" Home \"$l_home\" is mode: \"$l_mode\" should be mode: \"$l_max\" or more restrictive"
            fi
            else
            l_heout2="$l_heout2\n  - User: \"$l_user\" Home \"$l_home\" doesn't exist"
            fi
            done

            [ -z "$l_heout2" ] && l_output="$l_output\n   - home directories exist" || l_output2="$l_output2$l_heout2"
            [ -z "$l_hoout2" ] && l_output="$l_output\n   - own their home directory" || l_output2="$l_output2$l_hoout2"
            [ -z "$l_haout2" ] && l_output="$l_output\n   - home directories are mode: \"$l_max\" or more restrictive" || l_output2="$l_output2$l_haout2"
            [ -n "$l_output" ] && l_output="  - All local interactive users:$l_output"

            if [ -z "$l_output2" ]; then
            echo -e "\n- Audit Result:\n  ** PASS **\n - * Correctly configured * :\n$l_output"
            else
            echo -e "\n- Audit Result:\n  ** FAIL **\n - * Reasons for audit failure * :\n$l_output2"
            [ -n "$l_output" ] && echo -e "\n- * Correctly configured * :\n$l_output"
            fi
          }
        tests:
          test_items:
            - flag: "home directories exist"
              compare:
                op: has
                value: "home directories exist"
            - flag: "own their home directory"
              compare:
                op: has
                value: "own their home directory"
            - flag: "home directories are mode"
              compare:
                op: has
                value: "home directories are mode"
        remediation: |
          #!/usr/bin/env bash
          {
            l_output2=""
            l_valid_shells="^($( awk -F\/ '$NF != \"nologin\" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
            unset a_uarr && a_uarr=()
            while read -r l_epu l_eph; do
              a_uarr+=("$l_epu $l_eph")
            done <<< "$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat { print $1 \" \" $(NF-1) }' /etc/passwd)"
            for entry in "${a_uarr[@]}"; do
              l_user=$(echo "$entry" | awk '{print $1}')
              l_home=$(echo "$entry" | awk '{print $2}')
              if [ -d "$l_home" ]; then
                l_mask='0027'
                l_max="$( printf '%o' $(( 0777 & ~$l_mask)) )"
                while read -r l_own l_mode; do
                  if [ "$l_user" != "$l_own" ]; then
                    chown "$l_user" "$l_home"
                  fi
                  if [ $(( $l_mode & $l_mask )) -gt 0 ]; then
                    chmod g-w,o-rwx "$l_home"
                  fi
                done <<< "$(stat -Lc '%U %#a' "$l_home")"
              else
                echo "Home directory $l_home for user $l_user does not exist. Please create it or remove the user."
              fi
            done
          }
        scored: true

      - id: 6.2.11
        description: "Ensure local interactive user dot files access is configured (Automated)"
        audit: |
          issues=""

          # valid login shells (exclude nologin/false)
          VALID_SHELLS="$(awk '/^\// && $0 !~ /(nologin|false)$/' /etc/shells)"
          [ -z "$VALID_SHELLS" ] && { echo "dotfiles_bad"; echo " - No valid shells"; exit 0; }

          # Iterate interactive users
          awk -F: -v pat="$(echo "$VALID_SHELLS" | sed 's,/,\\\\/,g' | paste -sd'|' -)" \
            '($7 ~ pat) {print $1":"$6":"$4}' /etc/passwd |
          while IFS=: read -r user home gid; do
            [ -d "$home" ] || continue
            pg="$(getent group "$gid" | cut -d: -f1)"

            # Forbidden files
            for f in ".forward" ".rhost"; do
              if [ -e "$home/$f" ]; then
                issues="$issues\n - User: $user Home: $home forbidden file: $f"
              fi
            done

            # All dotfiles
            find "$home" -xdev -type f -name '.*' 2>/dev/null | while read -r f; do
              b="$(basename "$f")"
              # required perms: 644 by default, 600 for .bash_history and .netrc
              req=644
              [ "$b" = ".bash_history" ] || [ "$b" = ".netrc" ] && req=600

              set -- $(stat -Lc '%a %U %G' "$f")
              mode="$1" owner="$2" group="$3"
              last3=$((mode % 1000))

              if [ "$last3" -gt "$req" ]; then
                issues="$issues\n - User: $user File: $f mode $last3 > $req"
              fi
              [ "$owner" != "$user" ] && issues="$issues\n - User: $user File: $f owner $owner != $user"
              [ -n "$pg" ] && [ "$group" != "$pg" ] && issues="$issues\n - User: $user File: $f group $group != $pg"
            done
          done

          if [ -z "$issues" ]; then
            echo "dotfiles_ok"
          else
            echo "dotfiles_bad"
            printf "%b\n" "$issues"
          fi
        tests:
          test_items:
            - flag: "dotfiles_ok"
              set: true
        remediation: |
          # Investigate and delete any .forward or .rhost files
          # If .netrc is required by policy, ensure it is 600, else remove it
          # Set strict perms for dotfiles:
          #   chmod 600 ~/.bash_history ~/.netrc
          #   chmod 644 ~/.* (other dotfiles)
          # Ensure ownership is correct:
          #   chown <user>:<primary_group> ~/.*
        scored: true
