---
controls:
version: "AKS Optimized Azure Linux 3 v1.0.0"
id: 1
description: "Initial Setup"
type: "master"
groups:
  - id: 1.1
    description: "Filesystem"
    checks:
      - id: 1.1.1
        description: "Configure Filesystem Kernel Modules"
        type: "skip"
        checks:
      - id: 1.1.1.1
        description: "Ensure cramfs kernel module is not available (Automated)"
        audit: |
          # Check if cramfs module exists in the system
          if [ -n "$(find /lib/modules/*/kernel/fs -name 'cramfs*' 2>/dev/null)" ] || [ -n "$(find /usr/lib/modules/*/kernel/fs -name 'cramfs*' 2>/dev/null)" ]; then
            # Module exists, check if it's properly secured
            module_loaded=false
            module_blacklisted=false
            module_install_disabled=false

            # Check if module is currently loaded
            if lsmod | grep -q 'cramfs'; then
              module_loaded=true
            fi

            # Check if module is blacklisted
            if modprobe --showconfig 2>/dev/null | grep -q "blacklist cramfs"; then
              module_blacklisted=true
            fi

            # Check if module install is disabled
            if modprobe --showconfig 2>/dev/null | grep -Eq "install cramfs /bin/(false|true)"; then
              module_install_disabled=true
            fi

            # Check if module is properly secured (not loaded AND blacklisted AND install disabled)
            if [ "$module_loaded" = "false" ] && [ "$module_blacklisted" = "true" ] && [ "$module_install_disabled" = "true" ]; then
              echo "module_properly_secured"
            else
              echo "module_not_properly_secured"
            fi
          else
            echo "module_not_available"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "module_not_available"
              set: true
            - flag: "module_properly_secured"
              set: true
        remediation: |
          Run the following to unload and disable the cramfs kernel module:

          1. Run the following commands to unload the cramfs kernel module:
          # modprobe -r cramfs 2>/dev/null
          # rmmod cramfs 2>/dev/null

          2. Create a file ending in .conf with install cramfs /bin/false in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "install cramfs /bin/false" >> /etc/modprobe.d/cramfs.conf

          3. Create a file ending in .conf with blacklist cramfs in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "blacklist cramfs" >> /etc/modprobe.d/cramfs.conf

          Note: Some systems may include the cramfs filesystem as part of the kernel. In this case,
          if the above audit returns nothing, this is considered a passing state.
        scored: true
      - id: 1.1.1.2
        description: "Ensure freevxfs kernel module is not available (Automated)"
        audit: |
          # Check if freevxfs module exists in the system
          if [ -n "$(find /lib/modules/*/kernel/fs -name 'freevxfs*' 2>/dev/null)" ] || [ -n "$(find /usr/lib/modules/*/kernel/fs -name 'freevxfs*' 2>/dev/null)" ]; then
            # Module exists, check if it's properly secured
            module_loaded=false
            module_blacklisted=false
            module_install_disabled=false

            # Check if module is currently loaded
            if lsmod | grep -q 'freevxfs'; then
              module_loaded=true
            fi

            # Check if module is blacklisted
            if modprobe --showconfig 2>/dev/null | grep -q "blacklist freevxfs"; then
              module_blacklisted=true
            fi

            # Check if module install is disabled
            if modprobe --showconfig 2>/dev/null | grep -Eq "install freevxfs /bin/(false|true)"; then
              module_install_disabled=true
            fi

            # Check if module is properly secured (not loaded AND blacklisted AND install disabled)
            if [ "$module_loaded" = "false" ] && [ "$module_blacklisted" = "true" ] && [ "$module_install_disabled" = "true" ]; then
              echo "module_properly_secured"
            else
              echo "module_not_properly_secured"
            fi
          else
            echo "module_not_available"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "module_not_available"
              set: true
            - flag: "module_properly_secured"
              set: true
        remediation: |
          Run the following to unload and disable the freevxfs kernel module:

          1. Run the following commands to unload the freevxfs kernel module:
          # modprobe -r freevxfs 2>/dev/null
          # rmmod freevxfs 2>/dev/null

          2. Create a file ending in .conf with install freevxfs /bin/false in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "install freevxfs /bin/false" >> /etc/modprobe.d/freevxfs.conf

          3. Create a file ending in .conf with blacklist freevxfs in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "blacklist freevxfs" >> /etc/modprobe.d/freevxfs.conf
        scored: true

      - id: 1.1.1.3
        description: "Ensure hfs kernel module is not available (Automated)"
        audit: |
          # Check if hfs module exists in the system
          if [ -n "$(find /lib/modules/*/kernel/fs -name 'hfs*' 2>/dev/null)" ] || [ -n "$(find /usr/lib/modules/*/kernel/fs -name 'hfs*' 2>/dev/null)" ]; then
            # Module exists, check if it's properly secured
            module_loaded=false
            module_blacklisted=false
            module_install_disabled=false

            # Check if module is currently loaded
            if lsmod | grep -q 'hfs'; then
              module_loaded=true
            fi

            # Check if module is blacklisted
            if modprobe --showconfig 2>/dev/null | grep -q "blacklist hfs"; then
              module_blacklisted=true
            fi

            # Check if module install is disabled
            if modprobe --showconfig 2>/dev/null | grep -Eq "install hfs /bin/(false|true)"; then
              module_install_disabled=true
            fi

            # Check if module is properly secured (not loaded AND blacklisted AND install disabled)
            if [ "$module_loaded" = "false" ] && [ "$module_blacklisted" = "true" ] && [ "$module_install_disabled" = "true" ]; then
              echo "module_properly_secured"
            else
              echo "module_not_properly_secured"
            fi
          else
            echo "module_not_available"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "module_not_available"
              set: true
            - flag: "module_properly_secured"
              set: true
        remediation: |
          Run the following to unload and disable the hfs kernel module:

          1. Run the following commands to unload the hfs kernel module:
          # modprobe -r hfs 2>/dev/null
          # rmmod hfs 2>/dev/null

          2. Create a file ending in .conf with install hfs /bin/false in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "install hfs /bin/false" >> /etc/modprobe.d/hfs.conf

          3. Create a file ending in .conf with blacklist hfs in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "blacklist hfs" >> /etc/modprobe.d/hfs.conf
        scored: true

      - id: 1.1.1.4
        description: "Ensure hfsplus kernel module is not available (Automated)"
        audit: |
          # Check if hfsplus module exists in the system
          if [ -n "$(find /lib/modules/*/kernel/fs -name 'hfsplus*' 2>/dev/null)" ] || [ -n "$(find /usr/lib/modules/*/kernel/fs -name 'hfsplus*' 2>/dev/null)" ]; then
            # Module exists, check if it's properly secured
            module_loaded=false
            module_blacklisted=false
            module_install_disabled=false

            # Check if module is currently loaded
            if lsmod | grep -q 'hfsplus'; then
              module_loaded=true
            fi

            # Check if module is blacklisted
            if modprobe --showconfig 2>/dev/null | grep -q "blacklist hfsplus"; then
              module_blacklisted=true
            fi

            # Check if module install is disabled
            if modprobe --showconfig 2>/dev/null | grep -Eq "install hfsplus /bin/(false|true)"; then
              module_install_disabled=true
            fi

            # Check if module is properly secured (not loaded AND blacklisted AND install disabled)
            if [ "$module_loaded" = "false" ] && [ "$module_blacklisted" = "true" ] && [ "$module_install_disabled" = "true" ]; then
              echo "module_properly_secured"
            else
              echo "module_not_properly_secured"
            fi
          else
            echo "module_not_available"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "module_not_available"
              set: true
            - flag: "module_properly_secured"
              set: true
        remediation: |
          Run the following to unload and disable the hfsplus kernel module:

          1. Run the following commands to unload the hfsplus kernel module:
          # modprobe -r hfsplus 2>/dev/null
          # rmmod hfsplus 2>/dev/null

          2. Create a file ending in .conf with install hfsplus /bin/false in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "install hfsplus /bin/false" >> /etc/modprobe.d/hfsplus.conf

          3. Create a file ending in .conf with blacklist hfsplus in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "blacklist hfsplus" >> /etc/modprobe.d/hfsplus.conf
        scored: true

      - id: 1.1.1.5
        description: "Ensure jffs2 kernel module is not available (Automated)"
        audit: |
          # Check if jffs2 module exists in the system
          if [ -n "$(find /lib/modules/*/kernel/fs -name 'jffs2*' 2>/dev/null)" ] || [ -n "$(find /usr/lib/modules/*/kernel/fs -name 'jffs2*' 2>/dev/null)" ]; then
            # Module exists, check if it's properly secured
            module_loaded=false
            module_blacklisted=false
            module_install_disabled=false

            # Check if module is currently loaded
            if lsmod | grep -q 'jffs2'; then
              module_loaded=true
            fi

            # Check if module is blacklisted
            if modprobe --showconfig 2>/dev/null | grep -q "blacklist jffs2"; then
              module_blacklisted=true
            fi

            # Check if module install is disabled
            if modprobe --showconfig 2>/dev/null | grep -Eq "install jffs2 /bin/(false|true)"; then
              module_install_disabled=true
            fi

            # Check if module is properly secured (not loaded AND blacklisted AND install disabled)
            if [ "$module_loaded" = "false" ] && [ "$module_blacklisted" = "true" ] && [ "$module_install_disabled" = "true" ]; then
              echo "module_properly_secured"
            else
              echo "module_not_properly_secured"
            fi
          else
            echo "module_not_available"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "module_not_available"
              set: true
            - flag: "module_properly_secured"
              set: true
        remediation: |
          Run the following to unload and disable the jffs2 kernel module:

          1. Run the following commands to unload the jffs2 kernel module:
          # modprobe -r jffs2 2>/dev/null
          # rmmod jffs2 2>/dev/null

          2. Create a file ending in .conf with install jffs2 /bin/false in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "install jffs2 /bin/false" >> /etc/modprobe.d/jffs2.conf

          3. Create a file ending in .conf with blacklist jffs2 in the /etc/modprobe.d/ directory:
          # printf '%s\n' "" "blacklist jffs2" >> /etc/modprobe.d/jffs2.conf
        scored: true

      - id: 1.1.1.6
        description: "Ensure unused filesystem kernel module is not available (Manual)"
        audit: |
          MODULE="gfs2"

          if [ -n "$(find /lib/modules/*/kernel/fs -name "${MODULE}*" 2>/dev/null)" ] || [ -n "$(find /usr/lib/modules/*/kernel/fs -name "${MODULE}*" 2>/dev/null)" ]; then
            module_loaded=false
            module_blacklisted=false
            module_install_disabled=false

            if lsmod | awk '{print $1}' | grep -qx "${MODULE}"; then
              module_loaded=true
            fi

            if modprobe --showconfig 2>/dev/null | grep -Eq "^[[:space:]]*blacklist[[:space:]]+${MODULE}\b"; then
              module_blacklisted=true
            fi

            if modprobe --showconfig 2>/dev/null | grep -Eq "^[[:space:]]*install[[:space:]]+${MODULE}[[:space:]]+(/usr)?/bin/(false|true)\b"; then
              module_install_disabled=true
            fi

            if [ "$module_loaded" = "false" ] && [ "$module_blacklisted" = "true" ] && [ "$module_install_disabled" = "true" ]; then
              echo "module_properly_secured"
            else
              echo "module_not_properly_secured"
            fi
          else
            echo "module_not_available"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "module_not_available"
              set: true
            - flag: "module_properly_secured"
              set: true
        remediation: |
          Run the following to unload and disable the module:

          1) Unload the module (replace ${MODULE} with the module name):
             # modprobe -r ${MODULE} 2>/dev/null
             # rmmod ${MODULE} 2>/dev/null

          2) Disable installation:
             # printf '%s\n' "" "install ${MODULE} /bin/false" >> /etc/modprobe.d/${MODULE}.conf

          3) Denylist the module:
             # printf '%s\n' "" "blacklist ${MODULE}" >> /etc/modprobe.d/${MODULE}.conf

          Note: Some systems may build a filesystem driver into the kernel. If the audit reports
          "module_not_available", this is considered a passing state for that module.
        scored: true

      - id: 1.1.2
        description: "Configure Filesystem Partitions"
        type: "skip"
        checks:
      - id: 1.1.2.1
        description: "Configure /tmp"
        type: "skip"
        checks:
      - id: 1.1.2.1.1
        description: "Ensure /tmp is a separate partition (Automated)"
        audit: |
          if findmnt -kk /tmp > /dev/null; then
            if systemctl is-enabled tmp.mount | grep -Eq 'enabled|static|generated'; then
              echo "tmp_mounted"
            else
              echo "tmp_not_mounted"
            fi
          else
            echo "tmp_not_mounted"
          fi
        tests:
          test_items:
            - flag: "tmp_mounted"
              set: true
        remediation: |
          Run the following to configure /tmp as a separate partition:

          1. Unmask the tmp.mount unit if it exists:
          # systemctl unmask tmp.mount 2>/dev/null

          2. Edit /etc/fstab and add one of the following entries:

          Option A: Using tmpfs (recommended for AKS):
          tmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0

          Option B: Using a dedicated partition:
          <device> /tmp <fstype> defaults,nodev,nosuid,noexec 0 0

          3. Enable and mount the partition:
          # systemctl daemon-reload
          # systemctl enable tmp.mount
          # mount /tmp

          Note: For AKS environments, tmpfs is typically the preferred option.
        scored: true
      - id: 1.1.2.1.2
        description: "Ensure nodev option set on /tmp partition (Automated)"
        audit: |
          # Check if /tmp is mounted as separate partition and has nodev option
          if findmnt -nk /tmp >/dev/null 2>&1; then
            if findmnt -kn /tmp | grep -q nodev; then
              echo "nodev_configured"
            else
              echo "nodev_not_configured"
            fi
          else
            echo "tmp_not_separate_partition"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "tmp_not_separate_partition"
              set: true
            - flag: "nodev_configured"
              set: true
        remediation: |
          Run the following to ensure nodev option is set on /tmp partition:

          1. Edit /etc/fstab and ensure the nodev option is included for /tmp:

          Example entries:
          tmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0
          OR
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          2. Remount the /tmp partition:
          # mount -o remount /tmp

          Note: This check only applies if /tmp is configured as a separate partition.
        scored: true

      - id: 1.1.2.1.3
        description: "Ensure nosuid option set on /tmp partition (Automated)"
        audit: |
          # Check if /tmp is mounted as separate partition and has nosuid option
          if findmnt -nk /tmp >/dev/null 2>&1; then
            if findmnt -kn /tmp | grep -q nosuid; then
              echo "nosuid_configured"
            else
              echo "nosuid_not_configured"
            fi
          else
            echo "tmp_not_separate_partition"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "tmp_not_separate_partition"
              set: true
            - flag: "nosuid_configured"
              set: true
        remediation: |
          Run the following to ensure nosuid option is set on /tmp partition:

          1. Edit /etc/fstab and ensure the nosuid option is included for /tmp:

          Example entries:
          tmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0
          OR
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          2. Remount the /tmp partition:
          # mount -o remount /tmp

          Note: This check only applies if /tmp is configured as a separate partition.
        scored: true

      - id: 1.1.2.2
        description: "Configure /dev/shm"
        type: "skip"
        checks:
      - id: 1.1.2.2.1
        description: "Ensure /dev/shm is a separate partition (Automated)"
        audit: "findmnt -kn /dev/shm"
        tests:
          test_items:
            - flag: "/dev/shm"
              set: true
        remediation: |
          Modify `/etc/fstab` to mount `/dev/shm` as a separate `tmpfs` filesystem with appropriate options.

          Example entry in `/etc/fstab`:
          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0

          Then mount or remount the `/dev/shm` partition:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.2
        description: "Ensure nodev option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm > /dev/null; then
            echo "/dev/shm_mounted"
            if findmnt -kn /dev/shm | grep -v nodev; then
              echo "nodev_missing"
            else
              echo "nodev_ok"
            fi
          else
            echo "/dev/shm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nodev_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include the `nodev` option for `/dev/shm`. Example entry:

          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0

          Then remount the filesystem with the updated options:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.2.2.3
        description: "Ensure nosuid option set on /dev/shm partition (Automated)"
        audit: |
          if findmnt -kn /dev/shm > /dev/null; then
            echo "/dev/shm_mounted"
            if findmnt -kn /dev/shm | grep -v nosuid; then
              echo "nosuid_missing"
            else
              echo "nosuid_ok"
            fi
          else
            echo "/dev/shm_not_mounted"
          fi
        tests:
          test_items:
            - flag: "nosuid_ok"
              set: true
        remediation: |
          Edit `/etc/fstab` to include the `nosuid` option for `/dev/shm`. Example entry:
          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime  0 0
          Then remount the filesystem with:
          # mount -o remount /dev/shm
        scored: true


  - id: 1.2
    description: "Package Management"
    checks:
      - id: 1.2.1
        description: "Configure Package Repositories"
        type: "skip"
        checks:
      - id: 1.2.1.1
        description: "Ensure GPG keys are configured (Manual)"
        type: manual
        remediation: |
          Update your package manager GPG keys in accordance with site policy.
        scored: false

      - id: 1.2.1.2
        description: "Ensure gpgcheck is configured (Automated)"
        audit: |
          # Check if GPG signature checking is properly configured per CIS benchmark
          global_configured=false
          repos_configured=true

          # Check global configuration in /etc/dnf/dnf.conf for gpgcheck enabled
          if grep -Pi -- '^\h*gpgcheck\h*=\h*(1|true|yes)\b' /etc/dnf/dnf.conf 2>/dev/null; then
            global_configured=true
          fi

          # Check that gpgcheck is not disabled in any repository files
          if grep -Pris -- '^\h*gpgcheck\h*=\h*(0|[2-9]|[1-9][0-9]+|false|no)\b' /etc/yum.repos.d/ >/dev/null 2>&1; then
            repos_configured=false
          fi

          # Overall result: both global and repos must be properly configured
          if [ "$global_configured" = "true" ] && [ "$repos_configured" = "true" ]; then
            echo "gpgcheck_properly_configured"
          else
            echo "gpgcheck_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "gpgcheck_properly_configured"
              set: true
        remediation: |
          Run the following to ensure GPG signature checking is properly configured:

          1. Configure global gpgcheck in /etc/dnf/dnf.conf:
          # cp /etc/dnf/dnf.conf /etc/dnf/dnf.conf.backup
          # sed -i '/^\h*gpgcheck/d' /etc/dnf/dnf.conf
          # echo "gpgcheck=1" >> /etc/dnf/dnf.conf

          2. Remove any disabled gpgcheck settings from repository files:
          # find /etc/yum.repos.d/ -name "*.repo" -exec cp {} {}.backup \;
          # find /etc/yum.repos.d/ -name "*.repo" -exec sed -i '/^\h*gpgcheck\h*=\h*(0|[2-9]|[1-9][0-9]+|false|no)/d' {} \;

          3. Verify configuration:
          # grep -Pi -- '^\h*gpgcheck\h*=\h*(1|true|yes)\b' /etc/dnf/dnf.conf
          # grep -Pris -- '^\h*gpgcheck\h*=\h*(0|[2-9]|[1-9][0-9]+|false|no)\b' /etc/yum.repos.d/

          Note: The second command should return nothing for proper configuration.
        scored: true

      - id: 1.2.1.3
        description: "Ensure TDNF gpgcheck is globally activated (Automated)"
        audit: |
          # Check if TDNF GPG signature checking is properly configured per CIS benchmark
          global_configured=false
          repos_configured=true

          # Check global configuration in /etc/tdnf/tdnf.conf for gpgcheck=1
          if grep '^gpgcheck' /etc/tdnf/tdnf.conf 2>/dev/null | grep -q 'gpgcheck=1'; then
            global_configured=true
          fi

          # Check that there are no gpgcheck entries set to non-1 values in repository files
          # This includes 0 or any invalid (non-boolean) values
          if grep -P "^gpgcheck\h*=\h*[^1\n\r]\b" /etc/yum.repos.d/* >/dev/null 2>&1; then
            repos_configured=false
          fi

          # Overall result: both global and repos must be properly configured
          if [ "$global_configured" = "true" ] && [ "$repos_configured" = "true" ]; then
            echo "tdnf_gpgcheck_properly_configured"
          else
            echo "tdnf_gpgcheck_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "tdnf_gpgcheck_properly_configured"
              set: true
        remediation: |
          Run the following to ensure TDNF GPG signature checking is properly configured:

          1. Configure global gpgcheck in /etc/tdnf/tdnf.conf:
          # cp /etc/tdnf/tdnf.conf /etc/tdnf/tdnf.conf.backup
          # sed -i 's/^gpgcheck\s*=\s*.*/gpgcheck=1/' /etc/tdnf/tdnf.conf

          2. Configure gpgcheck for all repository files:
          # find /etc/yum.repos.d/ -name "*.repo" -exec cp {} {}.backup \;
          # find /etc/yum.repos.d/ -name "*.repo" -exec echo "Checking:" {} \; -exec sed -i 's/^gpgcheck\s*=\s*.*/gpgcheck=1/' {} \;

          3. Verify configuration:
          # grep ^gpgcheck /etc/tdnf/tdnf.conf
          # grep -P "^gpgcheck\h*=\h*[^1\n\r]\b" /etc/yum.repos.d/*

          Note: The first command should return "gpgcheck=1" and the second should return nothing.
        scored: true

      - id: 1.2.1.4
        description: "Ensure package manager repositories are configured (Manual)"
        type: manual
        remediation: |
          Configure your package manager repositories according to site policy.
        scored: false


  - id: 1.3
    description: "Configure Additional Process Hardening"
    checks:
      - id: 1.3.1
        description: "Ensure address space layout randomization is enabled (Automated)"
        audit: |
          running_ok=false
          durable_ok=false

          # 1) Runtime must be 2
          rv="$(sysctl kernel.randomize_va_space 2>/dev/null | awk -F= '{print $2}' | xargs)"
          [ "$rv" = "2" ] && running_ok=true

          # 2) Durable: inspect the effective config in load order; last match wins
          sysd="$(readlink -f /lib/systemd/systemd-sysctl 2>/dev/null || command -v systemd-sysctl 2>/dev/null || echo)"
          if [ -n "$sysd" ]; then
            # Get concatenated config in the order systemd loads it, then take the LAST match
            last_line="$("$sysd" --cat-config 2>/dev/null \
              | grep -E '^\s*kernel\.randomize_va_space\s*=' \
              | tail -n 1)"
            if [ -n "$last_line" ]; then
              dv="$(printf '%s' "$last_line" | awk -F= '{print $2}' | xargs)"
              [ "$dv" = "2" ] && durable_ok=true
            fi
          fi

          # Fallback if systemd-sysctl isn't available: check common locations in priority order and take the last match
          if [ "$durable_ok" != true ] && [ -z "$sysd" ]; then
            last_line="$(cat /usr/lib/sysctl.d/*.conf /lib/sysctl.d/*.conf /run/sysctl.d/*.conf /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null \
              | grep -E '^\s*kernel\.randomize_va_space\s*=' \
              | tail -n 1)"
            if [ -n "$last_line" ]; then
              dv="$(printf '%s' "$last_line" | awk -F= '{print $2}' | xargs)"
              [ "$dv" = "2" ] && durable_ok=true
            fi
          fi

          if [ "$running_ok" = true ] && [ "$durable_ok" = true ]; then
            echo "aslr_properly_configured"
          else
            echo "aslr_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "aslr_properly_configured"
              set: true
        remediation: |
          Run the following to ensure address space layout randomization is properly configured:

          1. Set the parameter in a sysctl configuration file:
          # printf '%s\n' "" "kernel.randomize_va_space = 2" >> /etc/sysctl.d/60-kernel_sysctl.conf

          2. Set the active kernel parameter immediately:
          # sysctl -w kernel.randomize_va_space=2

          3. Verify the configuration:
          # sysctl kernel.randomize_va_space
          # grep -Ph '^\s*kernel\.randomize_va_space' /etc/sysctl.conf /etc/sysctl.d/*.conf

          Note: The first command should return "kernel.randomize_va_space = 2" and the second should show
          the parameter set to 2 in a configuration file.
        scored: true

      - id: 1.3.2
        description: "Ensure ptrace_scope is restricted (Automated)"
        audit: |
          # Verify kernel.yama.ptrace_scope is restricted (1, 2, or 3)
          running_configured=false
          durable_configured=false

          # 1) Running configuration
          current_value=$(sysctl kernel.yama.ptrace_scope 2>/dev/null | awk -F= '{print $2}' | xargs)
          case "$current_value" in
            1|2|3) running_configured=true ;;
          esac

          # 2) Durable configuration (in sysctl files)
          # Look for kernel.yama.ptrace_scope = 1|2|3 in /etc/sysctl.conf or /etc/sysctl.d/*.conf
          if grep -Ehiq '^\s*kernel\.yama\.ptrace_scope\s*=\s*[123]\b' \
               /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null; then
            durable_configured=true
          fi

          # Result: both must be true
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "ptrace_scope_properly_configured"
          else
            echo "ptrace_scope_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "ptrace_scope_properly_configured"
              set: true
        remediation: |
          Set ptrace_scope to a restricted value (1, 2, or 3) and make it persistent:

            # printf '%s\n' "kernel.yama.ptrace_scope = 1" >> /etc/sysctl.d/60-kernel_sysctl.conf
            # sysctl -w kernel.yama.ptrace_scope=1

          If your site policy requires stricter settings, use 2 or 3 instead of 1.

          Notes:
          - If the setting appears later in the same file or a later-loaded file, it will override earlier values.
          - On Container-Optimized OS (COS) / other stateless images, /etc may be reset on reboot;
            persist via image customization or a boot-time automation that reapplies sysctl settings.
        scored: true

      - id: 1.3.3
        description: "Ensure core dump backtraces are disabled (Automated)"
        audit: |
          # Check if core dump ProcessSizeMax is properly configured per CIS benchmark
          process_size_configured=false

          # Check if ProcessSizeMax=0 is set in systemd coredump configuration
          # Use systemd-analyze to get the effective configuration
          if systemd-analyze cat-config systemd/coredump.conf 2>/dev/null | grep -Piq '^\s*ProcessSizeMax\s*=\s*0\b'; then
            process_size_configured=true
          fi

          # Also check individual config files directly as fallback
          if [ "$process_size_configured" = "false" ]; then
            # Check main config file
            if grep -Piq '^\s*ProcessSizeMax\s*=\s*0\b' /etc/systemd/coredump.conf 2>/dev/null; then
              process_size_configured=true
            fi

            # Check override config files
            if [ -d /etc/systemd/coredump.conf.d/ ]; then
              if grep -Piq '^\s*ProcessSizeMax\s*=\s*0\b' /etc/systemd/coredump.conf.d/*.conf 2>/dev/null; then
                process_size_configured=true
              fi
            fi
          fi

          # Overall result
          if [ "$process_size_configured" = "true" ]; then
            echo "core_dump_properly_configured"
          else
            echo "core_dump_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "core_dump_properly_configured"
              set: true
        remediation: |
          Run the following to ensure core dump backtraces are disabled:

          1. Create the coredump configuration directory if it doesn't exist:
          # mkdir -p /etc/systemd/coredump.conf.d/

          2. Create or edit the configuration file:
          # if grep -Psq -- '^\h*\[Coredump\]' /etc/systemd/coredump.conf.d/60-coredump.conf 2>/dev/null; then
          #   printf '%s\n' "ProcessSizeMax=0" >> /etc/systemd/coredump.conf.d/60-coredump.conf
          # else
          #   printf '%s\n' "[Coredump]" "ProcessSizeMax=0" >> /etc/systemd/coredump.conf.d/60-coredump.conf
          # fi

          3. Verify the configuration:
          # systemd-analyze cat-config systemd/coredump.conf | grep ProcessSizeMax

          Note: Setting ProcessSizeMax=0 disables core dump collection, preventing sensitive
          information from being stored in core dump files.
        scored: true

      - id: 1.3.4
        description: "Ensure core dump storage is disabled (Automated)"
        audit: |
          # Check if core dump Storage is properly configured per CIS benchmark
          storage_configured=false

          # Check if Storage=none is set in systemd coredump configuration
          # Use systemd-analyze to get the effective configuration
          if systemd-analyze cat-config systemd/coredump.conf 2>/dev/null | grep -Piq '^\s*Storage\s*=\s*none\b'; then
            storage_configured=true
          fi

          # Also check individual config files directly as fallback
          if [ "$storage_configured" = "false" ]; then
            # Check main config file
            if grep -Piq '^\s*Storage\s*=\s*none\b' /etc/systemd/coredump.conf 2>/dev/null; then
              storage_configured=true
            fi

            # Check override config files
            if [ -d /etc/systemd/coredump.conf.d/ ]; then
              if grep -Piq '^\s*Storage\s*=\s*none\b' /etc/systemd/coredump.conf.d/*.conf 2>/dev/null; then
                storage_configured=true
              fi
            fi
          fi

          # Overall result
          if [ "$storage_configured" = "true" ]; then
            echo "core_dump_storage_properly_configured"
          else
            echo "core_dump_storage_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "core_dump_storage_properly_configured"
              set: true
        remediation: |
          Run the following to ensure core dump storage is disabled:

          1. Create the coredump configuration directory if it doesn't exist:
          # mkdir -p /etc/systemd/coredump.conf.d/

          2. Create or edit the configuration file:
          # if grep -Psq -- '^\h*\[Coredump\]' /etc/systemd/coredump.conf.d/60-coredump.conf 2>/dev/null; then
          #   printf '%s\n' "Storage=none" >> /etc/systemd/coredump.conf.d/60-coredump.conf
          # else
          #   printf '%s\n' "[Coredump]" "Storage=none" >> /etc/systemd/coredump.conf.d/60-coredump.conf
          # fi

          3. Verify the configuration:
          # systemd-analyze cat-config systemd/coredump.conf | grep Storage

          Note: Setting Storage=none prevents core dumps from being stored to disk,
          providing an additional layer of protection against information disclosure.
        scored: true


  - id: 1.4
    description: "Configure Command Line Warning Banners"
    checks:
      - id: 1.4.1
        description: "Ensure local login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/issue to include a proper warning banner based on your site's policy.
          Example:

          # echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue
        scored: true

      - id: 1.4.2
        description: "Ensure remote login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue.net
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/issue.net file with the appropriate contents according to your site policy, remove any instances of \m , \r , \s , \v or references to the OS platform

          # echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue.ne
        scored: true

      - id: 1.4.3
        description: "Ensure access to /etc/motd is configured (Automated)"
        audit: |
          if [ -e /etc/motd ]; then
            perms=$(stat -Lc '%a' /etc/motd)
            owner=$(stat -Lc '%u' /etc/motd)
            group=$(stat -Lc '%g' /etc/motd)
            if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "motd_access_ok"
            else
              echo "motd_access_bad"
            fi
          else
            echo "motd_not_exist"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "motd_access_ok"
              set: true
            - flag: "motd_not_exist"
              set: true
        remediation: |
          # If /etc/motd exists, set owner and permissions
          if [ -e /etc/motd ]; then
            chown root:root $(readlink -e /etc/motd)
            chmod u-x,go-wx $(readlink -e /etc/motd)
          fi

          # Alternatively, remove /etc/motd if not required
          # rm /etc/motd
        scored: true

      - id: 1.4.4
        description: "Ensure access to /etc/issue is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue)
          owner=$(stat -Lc '%u' /etc/issue)
          group=$(stat -Lc '%g' /etc/issue)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_access_ok"
          else
            echo "issue_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue
          chown root:root $(readlink -e /etc/issue)
          chmod u-x,go-wx $(readlink -e /etc/issue)
        scored: true

      - id: 1.4.5
        description: "Ensure access to /etc/issue.net is configured (Automated)"
        audit: |
          perms=$(stat -Lc '%a' /etc/issue.net)
          owner=$(stat -Lc '%u' /etc/issue.net)
          group=$(stat -Lc '%g' /etc/issue.net)
          if [ "$perms" -le 644 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
            echo "issue_net_access_ok"
          else
            echo "issue_net_access_bad"
          fi
        tests:
          test_items:
            - flag: "issue_net_access_ok"
              set: true
        remediation: |
          # Set owner and permissions on /etc/issue.net
          chown root:root $(readlink -e /etc/issue.net)
          chmod u-x,go-wx $(readlink -e /etc/issue.net)
        scored: true

  - id: 2
    description: "Services"
  - id: 2.1
    description: "Configure Time Synchronization"
    checks:
      - id: 2.1.1
        description: "Ensure time synchronization is in use (Automated)"
        audit: "rpm -q chrony"
        tests:
          test_items:
            - flag: "package chrony is not installed"
              set: false
        remediation: |
          Run the following command to install chrony:

          # dnf install chrony
        scored: true

      - id: 2.1.2
        description: "Ensure chrony is configured (Automated)"
        audit: |
          # Check if chrony is properly configured per CIS benchmark
          server_configured=false
          options_configured=false

          # Check if remote server is configured in /etc/chrony.conf
          if grep -E "^(server|pool|refclock)" /etc/chrony.conf >/dev/null 2>&1; then
            server_configured=true
          fi

          # Check if OPTIONS includes '-u chrony' in /etc/sysconfig/chronyd
          if grep '^OPTIONS' /etc/sysconfig/chronyd 2>/dev/null | grep -q '\-u chrony'; then
            options_configured=true
          fi

          # Overall result: both server and options must be properly configured
          if [ "$server_configured" = "true" ] && [ "$options_configured" = "true" ]; then
            echo "chrony_properly_configured"
          else
            echo "chrony_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "chrony_properly_configured"
              set: true
        remediation: |
          Run the following to ensure chrony is properly configured:

          1. Configure remote server in /etc/chrony.conf:
          # cp /etc/chrony.conf /etc/chrony.conf.backup
          # Add or edit server or pool lines in /etc/chrony.conf:
          # echo "server <remote-server>" >> /etc/chrony.conf
          # echo "pool <pool-server>" >> /etc/chrony.conf

          2. Configure OPTIONS in /etc/sysconfig/chronyd:
          # cp /etc/sysconfig/chronyd /etc/sysconfig/chronyd.backup
          # sed -i 's/^OPTIONS=.*/OPTIONS="-u chrony"/' /etc/sysconfig/chronyd
          # Or if OPTIONS line doesn't exist:
          # echo 'OPTIONS="-u chrony"' >> /etc/sysconfig/chronyd

          3. Restart chronyd service:
          # systemctl restart chronyd
          # systemctl enable chronyd

          4. Verify configuration:
          # grep -E "^(server|pool|refclock)" /etc/chrony.conf
          # grep ^OPTIONS /etc/sysconfig/chronyd
        scored: true


  - id: 2.2
    description: "Configure Special Purpose Services"
    checks:
      - id: 2.2.1
        description: "Ensure xinetd is not installed (Automated)"
        audit: |
          # Check if xinetd package is installed
          if ! rpm -q xinetd >/dev/null 2>&1; then
            echo "xinetd_not_installed"
          else
            echo "xinetd_installed"
          fi
        tests:
          test_items:
            - flag: "xinetd_not_installed"
              set: true
        remediation: |
          Run the following command to remove xinetd:
          # tdnf remove xinetd
        scored: true

      - id: 2.2.2
        description: "Ensure xorg-x11-server-common is not installed (Automated)"
        audit: |
          # Check if xorg-x11-server-common package is installed
          if ! rpm -q xorg-x11-server-common >/dev/null 2>&1; then
            echo "xorg-x11-server-common_not_installed"
          else
            echo "xorg-x11-server-common_installed"
          fi
        tests:
          test_items:
            - flag: "xorg-x11-server-common_not_installed"
              set: true
        remediation: |
          Run the following command to remove xorg-x11-server-common:
          # tdnf remove xorg-x11-server-common
        scored: true

      - id: 2.2.3
        description: "Ensure avahi is not installed (Automated)"
        audit: |
          # Check if avahi package is installed
          if ! rpm -q avahi >/dev/null 2>&1; then
            echo "avahi_not_installed"
          else
            echo "avahi_installed"
          fi
        tests:
          test_items:
            - flag: "avahi_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove avahi:

          # systemctl stop avahi-daemon.socket avahi-daemon.service
          # tdnf remove avahi
        scored: true

      - id: 2.2.4
        description: "Ensure a print server is not installed (Automated)"
        audit: |
          # Check if cups package is installed
          if ! rpm -q cups >/dev/null 2>&1; then
            echo "cups_not_installed"
          else
            echo "cups_installed"
          fi
        tests:
          test_items:
            - flag: "cups_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove cups:

          # tdnf remove cups
        scored: true

      - id: 2.2.5
        description: "Ensure a dhcp server is not installed (Automated)"
        audit: |
          # Check if dhcp-server package is installed
          if ! rpm -q dhcp-server >/dev/null 2>&1; then
            echo "dhcp_not_installed"
          else
            echo "dhcp_installed"
          fi
        tests:
          test_items:
            - flag: "dhcp_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove dhcp-server:

          # tdnf remove dhcp-server
        scored: true


      - id: 2.2.6
        description: "Ensure dns server is not installed (Automated)"
        audit: |
          # Check if bind package is installed
          if ! rpm -q bind >/dev/null 2>&1; then
            echo "bind_not_installed"
          else
            echo "bind_installed"
          fi
        tests:
          test_items:
            - flag: "bind_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove bind:

          # tdnf remove bind
        scored: true


      - id: 2.2.7
        description: "Ensure FTP client is not installed (Automated)"
        audit: |
          # Check if ftp package is installed
          if ! rpm -q rpm -q ftp >/dev/null 2>&1; then
            echo "ftp_not_installed"
          else
            echo "ftp_installed"
          fi
        tests:
          test_items:
            - flag: "ftp_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove ftp:

          # tdnf remove ftp
        scored: true

      - id: 2.2.8
        description: "Ensure an ftp server is not installed (Automated)"
        audit: |
          # Check if vsftpd package is installed
          if ! rpm -q vsftpd >/dev/null 2>&1; then
            echo "vsftpd_not_installed"
          else
            echo "vsftpd_installed"
          fi
        tests:
          test_items:
            - flag: "vsftpd_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove vsftpd:

          # tdnf remove vsftpd
        scored: true

      - id: 2.2.9
        description: "Ensure a tftp server is not installed(Automated)"
        audit: |
          # Check if tftp-server package is installed
          if ! rpm -q tftp-server >/dev/null 2>&1; then
            echo "tftp-server_not_installed"
          else
            echo "tftp-server_installed"
          fi
        tests:
          test_items:
            - flag: "tftp-server_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove tftp-server:

          # tdnf remove tftp-server
        scored: true

      - id: 2.2.10
        description: "Ensure a web server is not installed (Automated)"
        audit: |
          # Check if httpd and nginx packages are installed
          httpd_installed=false
          nginx_installed=false

          if rpm -q httpd >/dev/null 2>&1; then
            httpd_installed=true
          fi

          if rpm -q nginx >/dev/null 2>&1; then
            nginx_installed=true
          fi

          # Pass if both are not installed
          if [ "$httpd_installed" = "false" ] && [ "$nginx_installed" = "false" ]; then
            echo "web_server_not_installed"
          else
            echo "web_server_installed"
          fi
        tests:
          test_items:
            - flag: "web_server_not_installed"
              set: true
        remediation: |
          Run the following commands to remove httpd and nginx:

          # tdnf remove httpd nginx
        scored: true

      - id: 2.2.11
        description: "Ensure IMAP and POP3 server is not installed (Automated)"
        audit: |
          # Check if dovecot and cyrus-imapd packages are installed
          dovecot_installed=false
          cyrus_imapd_installed=false

          if rpm -q dovecot >/dev/null 2>&1; then
            dovecot_installed=true
          fi

          if rpm -q cyrus-imapd >/dev/null 2>&1; then
            cyrus_imapd_installed=true
          fi

          # Pass if both are not installed
          if [ "$dovecot_installed" = "false" ] && [ "$cyrus_imapd_installed" = "false" ]; then
            echo "imap_pop_not_installed"
          else
            echo "imap_pop_installed"
          fi
        tests:
          test_items:
            - flag: "imap_pop_not_installed"
              set: true
        remediation: |
          Run the following commands to remove dovecot and cyrus-imapd:

          # tdnf remove dovecot cyrus-imapd
        scored: true

      - id: 2.2.12
        description: "Ensure Samba is not installed (Automated)"
        audit: |
          # Check if Samba package is installed
          if ! rpm -q samba >/dev/null 2>&1; then
            echo "samba_not_installed"
          else
            echo "samba_installed"
          fi
        tests:
          test_items:
            - flag: "samba_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove samba:

          # tdnf remove samba
        scored: true

      - id: 2.2.13
        description: "Ensure HTTP Proxy Server is not installed (Automated)"
        audit: |
          # Check if squid package is installed
          if ! rpm -q squid >/dev/null 2>&1; then
            echo "squid_not_installed"
          else
            echo "squid_installed"
          fi
        tests:
          test_items:
            - flag: "squid_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove squid:

          # tdnf remove squid
        scored: true

      - id: 2.2.14
        description: "Ensure net-snmp is not installed or the snmpd service is not enabled (Automated)"
        audit: |
          # Check if net-snmp package is installed
          if ! rpm -q net-snmp >/dev/null 2>&1; then
            echo "net-snmp_not_installed"
          else
            if systemctl is-enabled snmpd 2>/dev/null | grep -vq '^masked$'; then
              echo "snmpd_masked"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "net-snmp_not_installed"
              set: true
            - flag: "snmpd_masked"
              set: true
        remediation: |
          Run the following command to remove net-snmpd:
          # tdnf remove net-snmp
          OR
          Run the following commands to stop and mask the snmpd service:
          # systemctl stop snmpd
          # systemctl mask snmpd
        scored: true

      - id: 2.2.15
        description: "Ensure NIS server is not installed (Automated)"
        audit: |
          # Check if ypserv package is installed
          if ! rpm -q ypserv >/dev/null 2>&1; then
            echo "ypserv_not_installed"
          else
            echo "ypserv_installed"
          fi
        tests:
          test_items:
            - flag: "ypserv_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove ypserv:

          # tdnf remove ypserv
        scored: true

      - id: 2.2.16
        description: "Ensure telnet-server is not installed (Automated)"
        audit: |
          # Check if telnet-server package is installed
          if ! rpm -q telnet-server >/dev/null 2>&1; then
            echo "telnet-server_not_installed"
          else
            echo "telnet-server_installed"
          fi
        tests:
          test_items:
            - flag: "telnet-server_not_installed"
              set: true
        remediation: |
          Run the following commands to stop, and remove telnet-server:

          # tdnf remove telnet-server
        scored: true

      - id: 2.2.17
        description: "Ensure mail transfer agent is configured for local-only mode (Automated)"
        audit: |
          # Check if MTA is listening on any non-loopback address for port 25
          # Nothing should be returned if properly configured for local-only mode
          if ! ss -lntu | grep -P ':25\b' | grep -Pv '\h+(127\.0\.0\.1|\[?::1\]?):25\b' >/dev/null 2>&1; then
            echo "mta_local_only"
          else
            echo "mta_not_local_only"
          fi
        tests:
          test_items:
            - flag: "mta_local_only"
              set: true
        remediation: |
          Edit /etc/postfix/main.cf and add the following line to the RECEIVING MAIL section.
          If the line already exists, change it to look like the line below:

          inet_interfaces = loopback-only

          Run the following command to restart postfix:
          # systemctl restart postfix
        scored: true

      - id: 2.2.18
        description: "Ensure nfs-utils is not installed or the nfs-server service is masked (Automated)"
        audit: |
          if ! rpm -q nfs-utils >/dev/null 2>&1; then
            echo "nfs_utils_not_installed"
          else
            unit="nfs-server.service"
            state="$(systemctl is-enabled "$unit" 2>/dev/null)"
            if [ "$state" = "masked" ]; then
              echo "nfs_server_masked"
            else
              echo "nfs_server_not_masked:$state"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nfs_utils_not_installed"
              set: true
            - flag: "nfs_server_masked"
              set: true
        remediation: |
          Run the following command to remove nfs-utils:
          # tdnf remove nfs-utils
          OR
          If the nfs-package is required as a dependency, run the following command to stop and mask the nfs-server service:
          # systemctl --now mask nfs-server
        scored: true

      - id: 2.2.19
        description: "Ensure rsync-daemon is not installed or the rsyncd service is masked (Automated)"
        audit: |
          # Check if rsync-daemon package is installed
          if ! rpm -q rsync-daemon >/dev/null 2>&1; then
            echo "rsync-daemon_not_installed"
          else
            if systemctl is-enabled rsyncd 2>/dev/null | grep -vq '^masked$'; then
              echo "rsyncd_masked"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rsync-daemon_not_installed"
              set: true
            - flag: "rsyncd_masked"
              set: true
        remediation: |
          Run the following command to remove rsync-daemon:
          # tdnf remove rsync-daemon
          OR
          If the rsync-package is required as a dependency, run the following command to stop and mask the rsyncd service:
          # systemctl --now mask rsyncd
        scored: true


  - id: 2.3
    description: "Service Clients"
    checks:

      - id: 2.3.1
        description: "Ensure NIS Client is not installed (Automated)"
        audit: "rpm -q ypbind"
        tests:
          test_items:
            - flag: "package ypbind is not installed"
              set: true
        remediation: |
          Run the following command to remove ypbind package:

          # tdnf remove ypbind
        scored: true

      - id: 2.3.2
        description: "Ensure rsh client is not installed (Automated)"
        audit: "rpm -q rsh"
        tests:
          test_items:
            - flag: "package rsh is not installed"
              set: true
        remediation: |
          Run the following command to remove rsh package:

          # tdnf remove rsh
        scored: true

      - id: 2.3.3
        description: "Ensure talk client is not installed (Automated)"
        audit: "rpm -q talk"
        tests:
          test_items:
            - flag: "package talk is not installed"
              set: true
        remediation: |
          Run the following command to remove talk package:

          # tdnf remove talk
        scored: true

      - id: 2.3.4
        description: "Ensure telnet client is not installed (Automated)"
        audit: "rpm -q telnet"
        tests:
          test_items:
            - flag: "package telnet is not installed"
              set: true
        remediation: |
          Run the following command to remove telnet:

          # tdnf remove telnet
        scored: true

      - id: 2.3.5
        description: "Ensure LDAP client is not installed (Automated)"
        audit: "rpm -q openldap-client"
        tests:
          test_items:
            - flag: "package openldap-client is not installed"
              set: true
        remediation: |
          Run the following command to remove openldap-client package:

          # tdnf remove openldap-client
        scored: true

      - id: 2.3.6
        description: "Ensure TFTP client is not installed (Automated)"
        audit: "rpm -q tftp"
        tests:
          test_items:
            - flag: "package tftp is not installed"
              set: true
        remediation: |
          Run the following command to remove tftp package:

          # tdnf remove tftp
        scored: true


  - id: 3
    description: "Network"
  - id: 3.1
    description: "Configure Network Kernel Parameters"
    checks:
      - id: 3.1.1
        description: "Ensure packet redirect sending is disabled (Automated)"
        audit: |
          # Check running configuration for send_redirects parameters
          running_configured=true
          durable_configured=true

          # Check running configuration
          all_send_redirects=$(sysctl net.ipv4.conf.all.send_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)
          default_send_redirects=$(sysctl net.ipv4.conf.default.send_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$all_send_redirects" != "0" ] || [ "$default_send_redirects" != "0" ]; then
            running_configured=false
          fi

          # Check durable configuration in sysctl files
          # Look for net.ipv4.conf.all.send_redirects = 0 and net.ipv4.conf.default.send_redirects = 0
          if ! grep -Ph '^\s*net\.ipv4\.conf\.all\.send_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          if ! grep -Ph '^\s*net\.ipv4\.conf\.default\.send_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "send_redirects_properly_configured"
          else
            echo "send_redirects_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "send_redirects_properly_configured"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.conf.all.send_redirects = 0" "net.ipv4.conf.default.send_redirects = 0" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.conf.all.send_redirects=0
          # sysctl -w net.ipv4.conf.default.send_redirects=0
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.2
        description: "Ensure bogus icmp responses are ignored (Automated)"
        audit: |
          # Check running configuration for icmp_ignore_bogus_error_responses parameter
          running_configured=false
          durable_configured=false

          # Check running configuration
          icmp_ignore_bogus=$(sysctl net.ipv4.icmp_ignore_bogus_error_responses 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$icmp_ignore_bogus" = "1" ]; then
            running_configured=true
          fi

          # Check durable configuration in sysctl files
          # Look for net.ipv4.icmp_ignore_bogus_error_responses = 1
          if grep -Ph '^\s*net\.ipv4\.icmp_ignore_bogus_error_responses\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=true
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "icmp_ignore_bogus_properly_configured"
          else
            echo "icmp_ignore_bogus_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "icmp_ignore_bogus_properly_configured"
              set: true
        remediation: |
          Set the following parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.icmp_ignore_bogus_error_responses = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.3
        description: "Ensure broadcast icmp requests are ignored (Automated)"
        audit: |
          # Check running configuration for icmp_echo_ignore_broadcasts parameter
          running_configured=false
          durable_configured=false

          # Check running configuration
          icmp_echo_ignore_broadcasts=$(sysctl net.ipv4.icmp_echo_ignore_broadcasts 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$icmp_echo_ignore_broadcasts" = "1" ]; then
            running_configured=true
          fi

          # Check durable configuration in sysctl files
          # Look for net.ipv4.icmp_echo_ignore_broadcasts = 1
          if grep -Ph '^\s*net\.ipv4\.icmp_echo_ignore_broadcasts\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=true
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "icmp_echo_ignore_broadcasts_properly_configured"
          else
            echo "icmp_echo_ignore_broadcasts_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "icmp_echo_ignore_broadcasts_properly_configured"
              set: true
        remediation: |
          Set the following parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.icmp_echo_ignore_broadcasts = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.4
        description: "Ensure icmp redirects are not accepted (Automated)"
        audit: |
          # Check running configuration for accept_redirects parameters
          running_configured=true
          durable_configured=true

          # Check IPv4 running configuration
          ipv4_all_accept_redirects=$(sysctl net.ipv4.conf.all.accept_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)
          ipv4_default_accept_redirects=$(sysctl net.ipv4.conf.default.accept_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$ipv4_all_accept_redirects" != "0" ] || [ "$ipv4_default_accept_redirects" != "0" ]; then
            running_configured=false
          fi

          # Check IPv6 running configuration if IPv6 is enabled
          ipv6_disabled=false
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_disabled=true
          elif sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
               sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
            ipv6_disabled=true
          fi

          if [ "$ipv6_disabled" = "false" ]; then
            ipv6_all_accept_redirects=$(sysctl net.ipv6.conf.all.accept_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)
            ipv6_default_accept_redirects=$(sysctl net.ipv6.conf.default.accept_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)

            if [ "$ipv6_all_accept_redirects" != "0" ] || [ "$ipv6_default_accept_redirects" != "0" ]; then
              running_configured=false
            fi
          fi

          # Check durable configuration in sysctl files
          # IPv4 parameters
          if ! grep -Ph '^\s*net\.ipv4\.conf\.all\.accept_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          if ! grep -Ph '^\s*net\.ipv4\.conf\.default\.accept_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          # IPv6 parameters (only if IPv6 is enabled)
          if [ "$ipv6_disabled" = "false" ]; then
            if ! grep -Ph '^\s*net\.ipv6\.conf\.all\.accept_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
              durable_configured=false
            fi

            if ! grep -Ph '^\s*net\.ipv6\.conf\.default\.accept_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
              durable_configured=false
            fi
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "accept_redirects_properly_configured"
          else
            echo "accept_redirects_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "accept_redirects_properly_configured"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.conf.all.accept_redirects = 0" "net.ipv4.conf.default.accept_redirects = 0" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.conf.all.accept_redirects=0
          # sysctl -w net.ipv4.conf.default.accept_redirects=0
          # sysctl -w net.ipv4.route.flush=1

          IF IPv6 is enabled on the system:

          # printf '%s\n' "net.ipv6.conf.all.accept_redirects = 0" "net.ipv6.conf.default.accept_redirects = 0" >> /etc/sysctl.d/60-netipv6_sysctl.conf

          # sysctl -w net.ipv6.conf.all.accept_redirects=0
          # sysctl -w net.ipv6.conf.default.accept_redirects=0
          # sysctl -w net.ipv6.route.flush=1
        scored: true

      - id: 3.1.5
        description: "Ensure secure icmp redirects are not accepted (Automated)"
        audit: |
          # Check running configuration for secure_redirects parameters
          running_configured=true
          durable_configured=true

          # Check IPv4 running configuration for secure redirects
          ipv4_all_secure_redirects=$(sysctl net.ipv4.conf.all.secure_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)
          ipv4_default_secure_redirects=$(sysctl net.ipv4.conf.default.secure_redirects 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$ipv4_all_secure_redirects" != "0" ] || [ "$ipv4_default_secure_redirects" != "0" ]; then
            running_configured=false
          fi

          # Check durable configuration in sysctl files
          # IPv4 secure_redirects parameters
          if ! grep -Ph '^\s*net\.ipv4\.conf\.all\.secure_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          if ! grep -Ph '^\s*net\.ipv4\.conf\.default\.secure_redirects\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "secure_redirects_properly_configured"
          else
            echo "secure_redirects_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "secure_redirects_properly_configured"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.conf.all.secure_redirects = 0" "net.ipv4.conf.default.secure_redirects = 0" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.conf.all.secure_redirects=0
          # sysctl -w net.ipv4.conf.default.secure_redirects=0
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.6
        description: "Ensure reverse path filtering is enabled (Automated)"
        audit: |
          # Check running configuration for rp_filter parameters
          running_configured=true
          durable_configured=true

          # Check IPv4 running configuration for reverse path filtering
          ipv4_all_rp_filter=$(sysctl net.ipv4.conf.all.rp_filter 2>/dev/null | awk -F= '{print $2}' | xargs)
          ipv4_default_rp_filter=$(sysctl net.ipv4.conf.default.rp_filter 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$ipv4_all_rp_filter" != "1" ] || [ "$ipv4_default_rp_filter" != "1" ]; then
            running_configured=false
          fi

          # Check durable configuration in sysctl files
          # IPv4 rp_filter parameters
          if ! grep -Ph '^\s*net\.ipv4\.conf\.all\.rp_filter\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          if ! grep -Ph '^\s*net\.ipv4\.conf\.default\.rp_filter\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "rp_filter_properly_configured"
          else
            echo "rp_filter_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "rp_filter_properly_configured"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.conf.all.rp_filter = 1" "net.ipv4.conf.default.rp_filter = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.conf.all.rp_filter=1
          # sysctl -w net.ipv4.conf.default.rp_filter=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.7
        description: "Ensure source routed packets are not accepted (Automated)"
        audit: |
          # Check running configuration for accept_source_route parameters
          running_configured=true
          durable_configured=true

          # Check IPv4 running configuration
          ipv4_all_accept_source_route=$(sysctl net.ipv4.conf.all.accept_source_route 2>/dev/null | awk -F= '{print $2}' | xargs)
          ipv4_default_accept_source_route=$(sysctl net.ipv4.conf.default.accept_source_route 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$ipv4_all_accept_source_route" != "0" ] || [ "$ipv4_default_accept_source_route" != "0" ]; then
            running_configured=false
          fi

          # Check IPv6 running configuration if IPv6 is enabled
          ipv6_disabled=false
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_disabled=true
          elif sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
               sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
            ipv6_disabled=true
          fi

          if [ "$ipv6_disabled" = "false" ]; then
            ipv6_all_accept_source_route=$(sysctl net.ipv6.conf.all.accept_source_route 2>/dev/null | awk -F= '{print $2}' | xargs)
            ipv6_default_accept_source_route=$(sysctl net.ipv6.conf.default.accept_source_route 2>/dev/null | awk -F= '{print $2}' | xargs)

            if [ "$ipv6_all_accept_source_route" != "0" ] || [ "$ipv6_default_accept_source_route" != "0" ]; then
              running_configured=false
            fi
          fi

          # Check durable configuration in sysctl files
          # IPv4 parameters
          if ! grep -Ph '^\s*net\.ipv4\.conf\.all\.accept_source_route\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          if ! grep -Ph '^\s*net\.ipv4\.conf\.default\.accept_source_route\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          # IPv6 parameters (only if IPv6 is enabled)
          if [ "$ipv6_disabled" = "false" ]; then
            if ! grep -Ph '^\s*net\.ipv6\.conf\.all\.accept_source_route\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
              durable_configured=false
            fi

            if ! grep -Ph '^\s*net\.ipv6\.conf\.default\.accept_source_route\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
              durable_configured=false
            fi
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "accept_source_route_properly_configured"
          else
            echo "accept_source_route_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "accept_source_route_properly_configured"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.conf.all.accept_source_route = 0" "net.ipv4.conf.default.accept_source_route = 0" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.conf.all.accept_source_route=0
          # sysctl -w net.ipv4.conf.default.accept_source_route=0
          # sysctl -w net.ipv4.route.flush=1

          IF IPv6 is enabled on the system:

          # printf '%s\n' "net.ipv6.conf.all.accept_source_route = 0" "net.ipv6.conf.default.accept_source_route = 0" >> /etc/sysctl.d/60-netipv6_sysctl.conf

          # sysctl -w net.ipv6.conf.all.accept_source_route=0
          # sysctl -w net.ipv6.conf.default.accept_source_route=0
          # sysctl -w net.ipv6.route.flush=1
        scored: true

      - id: 3.1.8
        description: "Ensure suspicious packets are logged (Automated)"
        audit: |
          # Check running configuration for log_martians parameters
          running_configured=true
          durable_configured=true

          # Check IPv4 running configuration for martian packet logging
          ipv4_all_log_martians=$(sysctl net.ipv4.conf.all.log_martians 2>/dev/null | awk -F= '{print $2}' | xargs)
          ipv4_default_log_martians=$(sysctl net.ipv4.conf.default.log_martians 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$ipv4_all_log_martians" != "1" ] || [ "$ipv4_default_log_martians" != "1" ]; then
            running_configured=false
          fi

          # Check durable configuration in sysctl files
          # IPv4 log_martians parameters
          if ! grep -Ph '^\s*net\.ipv4\.conf\.all\.log_martians\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          if ! grep -Ph '^\s*net\.ipv4\.conf\.default\.log_martians\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=false
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "log_martians_properly_configured"
          else
            echo "log_martians_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "log_martians_properly_configured"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.conf.all.log_martians = 1" "net.ipv4.conf.default.log_martians = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.conf.all.log_martians=1
          # sysctl -w net.ipv4.conf.default.log_martians=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.9
        description: "Ensure tcp syn cookies is enabled (Automated)"
        audit: |
          # Check running configuration for tcp_syncookies parameter
          running_configured=false
          durable_configured=false

          # Check IPv4 running configuration for TCP SYN cookies
          ipv4_tcp_syncookies=$(sysctl net.ipv4.tcp_syncookies 2>/dev/null | awk -F= '{print $2}' | xargs)

          if [ "$ipv4_tcp_syncookies" = "1" ]; then
            running_configured=true
          fi

          # Check durable configuration in sysctl files
          # IPv4 tcp_syncookies parameter
          if grep -Ph '^\s*net\.ipv4\.tcp_syncookies\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
            durable_configured=true
          fi

          # Overall result: both running and durable must be properly configured
          if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
            echo "tcp_syncookies_properly_configured"
          else
            echo "tcp_syncookies_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "tcp_syncookies_properly_configured"
              set: true
        remediation: |
          Set the following parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv4.tcp_syncookies = 1" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv4.tcp_syncookies=1
          # sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.1.10
        description: "Ensure ipv6 router advertisements are not accepted (Automated)"
        audit: |
          # Check running configuration for accept_ra parameters
          running_configured=true
          durable_configured=true

          # Check if IPv6 is disabled
          ipv6_disabled=false
          if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable 2>/dev/null; then
            ipv6_disabled=true
          elif sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
               sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
            ipv6_disabled=true
          fi

          # If IPv6 is disabled, this check passes
          if [ "$ipv6_disabled" = "true" ]; then
            echo "ipv6_disabled_accept_ra_not_applicable"
          else
            # Check IPv6 running configuration for router advertisements
            ipv6_all_accept_ra=$(sysctl net.ipv6.conf.all.accept_ra 2>/dev/null | awk -F= '{print $2}' | xargs)
            ipv6_default_accept_ra=$(sysctl net.ipv6.conf.default.accept_ra 2>/dev/null | awk -F= '{print $2}' | xargs)

            if [ "$ipv6_all_accept_ra" != "0" ] || [ "$ipv6_default_accept_ra" != "0" ]; then
              running_configured=false
            fi

            # Check durable configuration in sysctl files
            # IPv6 accept_ra parameters
            if ! grep -Ph '^\s*net\.ipv6\.conf\.all\.accept_ra\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
              durable_configured=false
            fi

            if ! grep -Ph '^\s*net\.ipv6\.conf\.default\.accept_ra\s*=\s*0\b' /etc/sysctl.conf /etc/sysctl.d/*.conf 2>/dev/null | head -1 >/dev/null; then
              durable_configured=false
            fi

            # Overall result: both running and durable must be properly configured
            if [ "$running_configured" = "true" ] && [ "$durable_configured" = "true" ]; then
              echo "ipv6_accept_ra_properly_configured"
            else
              echo "ipv6_accept_ra_not_properly_configured"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ipv6_disabled_accept_ra_not_applicable"
              set: true
            - flag: "ipv6_accept_ra_properly_configured"
              set: true
        remediation: |
          IF IPv6 is enabled on the system:

          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

          # printf '%s\n' "net.ipv6.conf.all.accept_ra = 0" "net.ipv6.conf.default.accept_ra = 0" >> /etc/sysctl.d/60-netipv6_sysctl.conf

          Run the following script to set the active kernel parameters:

          # sysctl -w net.ipv6.conf.all.accept_ra=0
          # sysctl -w net.ipv6.conf.default.accept_ra=0
          # sysctl -w net.ipv6.route.flush=1
        scored: true


  - id: 4
    description: "Host Based Firewall"
    checks:
  - id: 4.1
    description: "Configure host based firewall packages"
    checks:
      - id: 4.1.1
        description: "Ensure iptables is installed (Automated)"
        audit: "rpm -q iptables"
        tests:
          test_items:
            - flag: "package iptables is not installed"
              set: false
        remediation: |
          Run the following command to install iptables:

          # tdnf install iptables
        scored: true

      - id: 4.1.2
        description: "Ensure nftables is not in use (Automated)"
        audit: |
          # Check if nftables package is installed
          nftables_installed=false
          nftables_service_enabled=false
          nftables_service_active=false

          if rpm -q nftables >/dev/null 2>&1; then
            nftables_installed=true

            # If installed, check if service is enabled
            if systemctl is-enabled nftables.service 2>/dev/null | grep -q '^enabled$'; then
              nftables_service_enabled=true
            fi

            # If installed, check if service is active
            if systemctl is-active nftables.service 2>/dev/null | grep -q '^active$'; then
              nftables_service_active=true
            fi
          fi

          # Pass if nftables is not installed OR if it's installed but service is not enabled and not active
          if [ "$nftables_installed" = "false" ] || ([ "$nftables_service_enabled" = "false" ] && [ "$nftables_service_active" = "false" ]); then
            echo "nftables_properly_configured"
          else
            echo "nftables_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "nftables_properly_configured"
              set: true
        remediation: |
          Run the following command to remove the NFTables package:

          # tdnf remove nftables

          OR if the NFTables package is required for a dependency:

          Run the following command to mask nftables.service:
          # systemctl mask nftables.service

          Run the following command to stop nftables.service:
          # systemctl stop nftables.service
        scored: true

      - id: 4.1.3
        description: "Ensure firewalld is not in use (Automated)"
        audit: |
          # Check if firewalld package is installed
          firewalld_installed=false
          firewalld_service_enabled=false
          firewalld_service_active=false

          if rpm -q firewalld >/dev/null 2>&1; then
            firewalld_installed=true

            # If installed, check if service is enabled
            if systemctl is-enabled firewalld.service 2>/dev/null | grep -q '^enabled$'; then
              firewalld_service_enabled=true
            fi

            # If installed, check if service is active
            if systemctl is-active firewalld.service 2>/dev/null | grep -q '^active$'; then
              firewalld_service_active=true
            fi
          fi

          # Pass if firewalld is not installed OR if it's installed but service is not enabled and not active
          if [ "$firewalld_installed" = "false" ] || ([ "$firewalld_service_enabled" = "false" ] && [ "$firewalld_service_active" = "false" ]); then
            echo "firewalld_properly_configured"
          else
            echo "firewalld_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "firewalld_properly_configured"
              set: true
        remediation: |
          Run the following command to remove the FirewallD package:

          # tdnf remove firewalld

          OR if the firewalld package is required for a dependency:

          Run the following command to mask firewalld.service:
          # systemctl mask firewalld.service

          Run the following command to stop firewalld.service:
          # systemctl stop firewalld
        scored: true

  - id: 5
    description: "Access, Authentication and Authorization"
    checks:
  - id: 5.1
    description: "Configure time-based job schedulers"
    checks:
      - id: 5.1.1
        description: "Ensure cron daemon is enabled (Automated)"
        audit: |
          if systemctl is-enabled crond 2>/dev/null | grep -q '^enabled$'; then
            echo "crond_service_enabled"
          else
            echo "crond_service_disabled"
          fi
        tests:
          test_items:
            - flag: "crond_service_enabled"
              set: true
        remediation: |
          # Enable the cron service
          # systemctl --now enable crond
        scored: true

      - id: 5.1.2
        description: "Ensure permissions on /etc/crontab are configured (Automated)"
        audit: |
          CRONTAB="/etc/crontab"

          if [ ! -f "$CRONTAB" ]; then
            echo "crontab_missing"
          else
            perms=$(stat -Lc '%a' "$CRONTAB")
            owner=$(stat -Lc '%u' "$CRONTAB")
            group=$(stat -Lc '%g' "$CRONTAB")

            if [ "$perms" -le 600 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "crontab_perms_ok"
            else
              echo "crontab_perms_bad"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "crontab_perms_ok"
              set: true
            - flag: "crontab_missing"
              set: true
        remediation: |
          # Set correct ownership and permissions on /etc/crontab
          chown root:root /etc/crontab
          chmod og-rwx /etc/crontab
        scored: true

      - id: 5.1.3
        description: "Ensure permissions on /etc/cron.hourly are configured (Automated)"
        audit: |
          CRON_HOURLY="/etc/cron.hourly"

          if [ ! -f "$CRON_HOURLY" ]; then
            echo "cron_hourly_missing"
          elif [ "$(stat -Lc %U:%G "$CRON_HOURLY" 2>/dev/null)" = "root:root" ] && \
               [ "$(stat -Lc %a "$CRON_HOURLY" 2>/dev/null)" -le 700 ] && \
               [ "$(stat -Lc %a "$CRON_HOURLY" 2>/dev/null)" -ge 0 ]; then
            echo "cron_hourly_permission_ok"
          else
            echo "cron_hourly_permission_bad"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cron_hourly_permission_ok"
              set: true
            - flag: "cron_hourly_missing"
        remediation: |
          # Set correct ownership and permissions on /etc/cron.hourly
          chown root:root /etc/cron.hourly
          chmod og-rwx /etc/cron.hourly
        scored: true

      - id: 5.1.4
        description: "Ensure permissions on /etc/cron.daily are configured (Automated)"
        audit: |
          CRON_DAILY="/etc/cron.daily"

          if [ ! -f "$CRON_DAILY" ]; then
            echo "cron_daily_missing"
          elif [ "$(stat -Lc %U:%G "$CRON_DAILY" 2>/dev/null)" = "root:root" ] && \
               [ "$(stat -Lc %a "$CRON_DAILY" 2>/dev/null)" -le 700 ]; then
            echo "cron_daily_permission_ok"
          else
            echo "cron_daily_permission_bad"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cron_daily_permission_ok"
              set: true
            - flag: "cron_daily_missing"
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.daily :

            # chown root:root /etc/cron.daily

            # chmod og-rwx /etc/cron.daily
        scored: true

      - id: 5.1.5
        description: "Ensure permissions on /etc/cron.weekly are configured (Automated)"
        audit: |
          CRON_WEEKLY="/etc/cron.weekly"

          if [ ! -f "$CRON_WEEKLY" ]; then
            echo "cron_weekly_missing"
          else
            perms=$(stat -Lc '%a' "$CRON_WEEKLY")
            owner=$(stat -Lc '%u' "$CRON_WEEKLY")
            group=$(stat -Lc '%g' "$CRON_WEEKLY")

            if [ "$perms" -eq 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "cron_weekly_permission_ok"
            else
              echo "cron_weekly_permission_bad"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cron_weekly_permission_ok"
              set: true
            - flag: "cron_weekly_missing"
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.weekly :

            # chown root:root /etc/cron.weekly

            # chmod og-rwx /etc/cron.weekly
        scored: true

      - id: 5.1.6
        description: "Ensure permissions on /etc/cron.monthly are configured (Automated)"
        audit: |
          CRON_MONTHLY="/etc/cron.monthly"

          if [ ! -f "$CRON_MONTHLY" ]; then
            echo "cron_monthly_missing"
          else
            perms=$(stat -Lc '%a' "$CRON_MONTHLY")
            owner=$(stat -Lc '%u' "$CRON_MONTHLY")
            group=$(stat -Lc '%g' "$CRON_MONTHLY")

            if [ "$perms" -eq 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "cron_monthly_permission_ok"
            else
              echo "cron_monthly_permission_bad"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cron_monthly_permission_ok"
              set: true
            - flag: "cron_monthly_missing"
        remediation: |
          Run the following commands to set ownership and permissions on /etc/cron.monthly :

            # chown root:root /etc/cron.monthly

            # chmod og-rwx /etc/cron.monthly
        scored: true

      - id: 5.1.7
        description: "Ensure permissions on /etc/cron.d are configured (Automated)"
        audit: |
          CRON_D="/etc/cron.d"

          if [ ! -f "$CRON_D" ]; then
            echo "cron_d_missing"
          else
            perms=$(stat -Lc '%a' "$CRON_D")
            owner=$(stat -Lc '%u' "$CRON_D")
            group=$(stat -Lc '%g' "$CRON_D")

            if [ "$perms" -eq 700 ] && [ "$owner" -eq 0 ] && [ "$group" -eq 0 ]; then
              echo "cron_d_permission_ok"
            else
              echo "cron_d_permission_bad"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cron_d_permission_ok"
              set: true
            - flag: "cron_d_missing"
        remediation: |

          Run the following commands to set ownership and permissions on /etc/cron.d :

            # chown root:root /etc/cron.d

            # chmod og-rwx /etc/cron.d
        scored: true

      - id: 5.1.8
        description: "Ensure cron is restricted to authorized users (Automated)"
        audit: |
          # Check if cron is installed
          if ! rpm -q cronie >/dev/null 2>&1; then
            echo "cron_not_installed"
          else
            cron_allow_ok=false
            cron_deny_ok=true

            # Check /etc/cron.allow - must exist and have proper permissions
            if [ -e /etc/cron.allow ]; then
              # Check permissions (should be 0640 or more restrictive)
              perm=$(stat -Lc %a /etc/cron.allow 2>/dev/null)
              owner=$(stat -Lc %U /etc/cron.allow 2>/dev/null)
              group=$(stat -Lc %G /etc/cron.allow 2>/dev/null)

              # Check if permissions are 0640 or more restrictive (u<=6, g<=4, o==0)
              if [[ "$perm" =~ ^[0-6][0-4]0$ ]] && [ "$owner" = "root" ] && [ "$group" = "root" ]; then
                cron_allow_ok=true
              fi
            fi

            # Check /etc/cron.deny - should not exist OR have proper permissions if it exists
            if [ -e /etc/cron.deny ]; then
              # If it exists, check permissions (should be 0640 or more restrictive)
              perm=$(stat -Lc %a /etc/cron.deny 2>/dev/null)
              owner=$(stat -Lc %U /etc/cron.deny 2>/dev/null)
              group=$(stat -Lc %G /etc/cron.deny 2>/dev/null)

              # Check if permissions are 0640 or more restrictive (u<=6, g<=4, o==0)
              if ! [[ "$perm" =~ ^[0-6][0-4]0$ ]] || [ "$owner" != "root" ] || [ "$group" != "root" ]; then
                cron_deny_ok=false
              fi
            fi

            # Pass if /etc/cron.allow exists with proper permissions AND /etc/cron.deny is properly configured
            if [ "$cron_allow_ok" = "true" ] && [ "$cron_deny_ok" = "true" ]; then
              echo "cron_access_properly_configured"
            else
              echo "cron_access_not_properly_configured"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "cron_not_installed"
              set: true
            - flag: "cron_access_properly_configured"
              set: true
        remediation: |
          Run the following script to remove /etc/cron.deny, create /etc/cron.allow, and set the file mode on /etc/cron.allow:

          #!/usr/bin/env bash
          {
             if rpm -q cronie >/dev/null; then
                [ -e /etc/cron.deny ] && rm -f /etc/cron.deny
                [ ! -e /etc/cron.allow ] && touch /etc/cron.allow
                chown root:root /etc/cron.allow
                chmod g-wx,o-rwx /etc/cron.allow
             else
                echo "cron is not installed on the system"
             fi
          }
        scored: true

      - id: 5.1.9
        description: "Ensure at is restricted to authorized users (Automated)"
        audit: |
          # Check if at is installed
          if ! rpm -q at >/dev/null 2>&1; then
            echo "at_not_installed"
          else
            at_allow_ok=false
            at_deny_ok=true

            # Check /etc/at.deny - should not exist
            if [ -e /etc/at.deny ]; then
              at_deny_ok=false
            fi

            # Check /etc/at.allow - must exist and have proper permissions
            if [ -e /etc/at.allow ]; then
              # Check permissions (should be 0600, 0400, 0200, or 0000)
              perm=$(stat -Lc %a /etc/at.allow 2>/dev/null)
              owner_group=$(stat -Lc "%u:%g" /etc/at.allow 2>/dev/null)

              # Check if permissions are restrictive (only owner can access, no group/other access)
              if [[ "$perm" =~ ^[0,2,4,6]00$ ]] && [ "$owner_group" = "0:0" ]; then
                at_allow_ok=true
              fi
            fi

            # Pass if /etc/at.deny doesn't exist AND /etc/at.allow exists with proper permissions
            if [ "$at_deny_ok" = "true" ] && [ "$at_allow_ok" = "true" ]; then
              echo "at_access_properly_configured"
            else
              echo "at_access_not_properly_configured"
            fi
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "at_not_installed"
              set: true
            - flag: "at_access_properly_configured"
              set: true
        remediation: |
          Run the following script to remove /etc/at.deny, create /etc/at.allow, and set the file mode for /etc/at.allow:

          #!/usr/bin/env bash
          {
             if rpm -q at >/dev/null; then
                [ -e /etc/at.deny ] && rm -f /etc/at.deny
                [ ! -e /etc/at.allow ] && touch /etc/at.allow
                chown root:root /etc/at.allow
                chmod u-x,go-rwx /etc/at.allow
             else
                echo "at is not installed on the system"
             fi
          }

          OR Run the following command to remove at:
          # tdnf remove at
        scored: true


  - id: 5.2
    description: "Configure SSH Server"
    checks:
      - id: 5.2.1
        description: "Ensure access to /etc/ssh/sshd_config is configured (Automated)"
        audit: |
          # Check SSH configuration files access per CIS benchmark
          perm_mask='0177'
          maxperm="$(printf '%o' $((0777 & ~$perm_mask)))"
          all_files_ok=true

          f_sshd_files_chk() {
            local l_file="$1"
            if [ -e "$l_file" ]; then
              local l_mode l_user l_group
              read -r l_mode l_user l_group < <(stat -Lc '%#a %U %G' "$l_file" 2>/dev/null)

              # Check if mode is more restrictive than 0600 (no group/other access)
              if [ $((l_mode & perm_mask)) -gt 0 ]; then
                all_files_ok=false
                return 1
              fi

              # Check if owned by root
              if [ "$l_user" != "root" ]; then
                all_files_ok=false
                return 1
              fi

              # Check if group owned by root
              if [ "$l_group" != "root" ]; then
                all_files_ok=false
                return 1
              fi
            fi
            return 0
          }

          # Check main sshd_config file
          f_sshd_files_chk "/etc/ssh/sshd_config"

          # Check .conf files in sshd_config.d directory
          if [ -d "/etc/ssh/sshd_config.d" ]; then
            while IFS= read -r -d $'\0' l_file; do
              f_sshd_files_chk "$l_file"
            done < <(find /etc/ssh/sshd_config.d -type f -name '*.conf' -print0 2>/dev/null)
          fi

          if [ "$all_files_ok" = "true" ]; then
            echo "sshd_config_access_properly_configured"
          else
            echo "sshd_config_access_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_config_access_properly_configured"
              set: true
        remediation: |
          Run the following script to set ownership and permissions on /etc/ssh/sshd_config and files ending in .conf in the /etc/ssh/sshd_config.d directory:

          #!/usr/bin/env bash
          {
             chmod u-x,og-rwx /etc/ssh/sshd_config
             chown root:root /etc/ssh/sshd_config
             while IFS= read -r -d $'\0' l_file; do
                if [ -e "$l_file" ]; then
                   chmod u-x,og-rwx "$l_file"
                   chown root:root "$l_file"
                fi
             done < <(find /etc/ssh/sshd_config.d -type f -print0 2>/dev/null)
          }

          IF other locations are listed in an Include statement, *.conf files in these locations access should also be modified.
        scored: true

      - id: 5.2.2
        description: "Ensure access to SSH private host key files is configured (Automated)"
        audit: |
          # Check SSH private host key files access per CIS benchmark
          l_ssh_group_name="$(awk -F: '($1 ~ /^(ssh_keys|_?ssh)$/) {print $1}' /etc/group)"
          all_files_ok=true

          f_file_chk() {
            local l_file="$1"
            if [ -e "$l_file" ]; then
              local l_file_mode l_file_owner l_file_group
              read -r l_file_mode l_file_owner l_file_group < <(stat -Lc '%#a %U %G' "$l_file" 2>/dev/null)

              # Determine permission mask based on group ownership
              local l_pmask
              if [ "$l_file_group" = "$l_ssh_group_name" ]; then
                l_pmask="0137"  # Allow group read for ssh_keys/_ssh group
              else
                l_pmask="0177"  # No group/other access for other groups
              fi

              # Check if mode is more restrictive than allowed
              if [ $((l_file_mode & l_pmask)) -gt 0 ]; then
                all_files_ok=false
                return 1
              fi

              # Check if owned by root
              if [ "$l_file_owner" != "root" ]; then
                all_files_ok=false
                return 1
              fi

              # Check if group owned by root or ssh_keys/_ssh
              if [[ ! "$l_file_group" =~ ^($l_ssh_group_name|root)$ ]]; then
                all_files_ok=false
                return 1
              fi
            fi
            return 0
          }

          # Find and check SSH private key files
          while IFS= read -r -d $'\0' l_file; do
            if ssh-keygen -lf "$l_file" &>/dev/null; then
              if file "$l_file" | grep -Piq -- '\bopenssh\h+([^#\n\r]+\h+)?private\h+key\b'; then
                f_file_chk "$l_file"
              fi
            fi
          done < <(find -L /etc/ssh -xdev -type f -print0 2>/dev/null)

          if [ "$all_files_ok" = "true" ]; then
            echo "ssh_private_keys_access_properly_configured"
          else
            echo "ssh_private_keys_access_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "ssh_private_keys_access_properly_configured"
              set: true
        remediation: |
          Run the following script to set mode, ownership, and group on the private SSH host key files:

          #!/usr/bin/env bash
          {
             l_ssh_group_name="$(awk -F: '($1 ~ /^(ssh_keys|_?ssh)$/) {print $1}' /etc/group)"
             f_file_access_fix() {
                local l_file="$1"
                if [ -e "$l_file" ]; then
                   local l_file_mode l_file_owner l_file_group
                   read -r l_file_mode l_file_owner l_file_group < <(stat -Lc '%#a %U %G' "$l_file" 2>/dev/null)

                   # Determine permission mask and fix permissions
                   local l_pmask
                   if [ "$l_file_group" = "$l_ssh_group_name" ]; then
                      l_pmask="0137"
                      [ $((l_file_mode & l_pmask)) -gt 0 ] && chmod u-x,g-wx,o-rwx "$l_file"
                   else
                      l_pmask="0177"
                      [ $((l_file_mode & l_pmask)) -gt 0 ] && chmod u-x,go-rwx "$l_file"
                   fi

                   # Fix ownership
                   [ "$l_file_owner" != "root" ] && chown root "$l_file"

                   # Fix group ownership
                   if [[ ! "$l_file_group" =~ ^($l_ssh_group_name|root)$ ]]; then
                      if [ -n "$l_ssh_group_name" ]; then
                         chgrp "$l_ssh_group_name" "$l_file"
                      else
                         chgrp root "$l_file"
                      fi
                   fi
                fi
             }

             while IFS= read -r -d $'\0' l_file; do
                if ssh-keygen -lf "$l_file" &>/dev/null; then
                   if file "$l_file" | grep -Piq -- '\bopenssh\h+([^#\n\r]+\h+)?private\h+key\b'; then
                      f_file_access_fix "$l_file"
                   fi
                fi
             done < <(find -L /etc/ssh -xdev -type f -print0 2>/dev/null)
          }
        scored: true

      - id: 5.2.3
        description: "Ensure access to SSH public host key files is configured (Automated)"
        audit: |
          # Check SSH public host key files access per CIS benchmark
          l_pmask="0133"
          l_maxperm="$(printf '%o' $((0777 & ~l_pmask)))"
          all_files_ok=true
          files_found=false

          f_file_chk() {
            local l_file="$1"
            if [ -e "$l_file" ]; then
              files_found=true
              local l_file_mode l_file_owner l_file_group
              read -r l_file_mode l_file_owner l_file_group < <(stat -Lc '%#a %U %G' "$l_file" 2>/dev/null)

              # Check if mode is more restrictive than 0644 (no execute for user, no write for group/other)
              if [ $((l_file_mode & l_pmask)) -gt 0 ]; then
                all_files_ok=false
                return 1
              fi

              # Check if owned by root
              if [ "$l_file_owner" != "root" ]; then
                all_files_ok=false
                return 1
              fi

              # Check if group owned by root
              if [ "$l_file_group" != "root" ]; then
                all_files_ok=false
                return 1
              fi
            fi
            return 0
          }

          # Find and check SSH public key files
          while IFS= read -r -d $'\0' l_file; do
            if ssh-keygen -lf "$l_file" &>/dev/null; then
              if file "$l_file" | grep -Piq -- '\bopenssh\h+([^#\n\r]+\h+)?public\h+key\b'; then
                f_file_chk "$l_file"
              fi
            fi
          done < <(find -L /etc/ssh -xdev -type f -print0 2>/dev/null)

          # Pass if no files found (not required) or all files are properly configured
          if [ "$files_found" = "false" ] || [ "$all_files_ok" = "true" ]; then
            echo "ssh_public_keys_access_properly_configured"
          else
            echo "ssh_public_keys_access_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "ssh_public_keys_access_properly_configured"
              set: true
        remediation: |
          Run the following script to set mode, ownership, and group on the public SSH host key files:

          #!/usr/bin/env bash
          {
             l_pmask="0133"
             l_maxperm="$(printf '%o' $((0777 & ~l_pmask)))"
             f_file_access_fix() {
                local l_file="$1"
                if [ -e "$l_file" ]; then
                   local l_file_mode l_file_owner l_file_group
                   read -r l_file_mode l_file_owner l_file_group < <(stat -Lc '%#a %U %G' "$l_file" 2>/dev/null)

                   # Fix permissions if too permissive
                   [ $((l_file_mode & l_pmask)) -gt 0 ] && chmod u-x,go-wx "$l_file"

                   # Fix ownership
                   [ "$l_file_owner" != "root" ] && chown root "$l_file"

                   # Fix group ownership
                   [ "$l_file_group" != "root" ] && chgrp root "$l_file"
                fi
             }

             while IFS= read -r -d $'\0' l_file; do
                if ssh-keygen -lf "$l_file" &>/dev/null; then
                   if file "$l_file" | grep -Piq -- '\bopenssh\h+([^#\n\r]+\h+)?public\h+key\b'; then
                      f_file_access_fix "$l_file"
                   fi
                fi
             done < <(find -L /etc/ssh -xdev -type f -print0 2>/dev/null)
          }
        scored: true

      - id: 5.2.4
        description: "Ensure sshd Ciphers are configured (Automated)"
        audit: |
          # Check for weak ciphers in SSH configuration
          weak_ciphers_found=false

          # Check if any weak ciphers are configured
          if sshd -T 2>/dev/null | grep -Pi -- '^ciphers\h+\"?([^#\n\r]+,)?((3des|blowfish|cast128|aes(128|192|256))-cbc|arcfour(128|256)?|rijndael-cbc@lysator\.liu\.se|chacha20-poly1305@openssh\.com)\b' >/dev/null; then
            weak_ciphers_found=true
          fi

          # Pass if no weak ciphers are found
          if [ "$weak_ciphers_found" = "false" ]; then
            echo "sshd_ciphers_properly_configured"
          else
            echo "sshd_ciphers_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_ciphers_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and add/modify the Ciphers line to contain a comma separated list of the site unapproved (weak) Ciphers preceded with a - above any Include entries:

          Example:
          Ciphers -3des-cbc,aes128-cbc,aes192-cbc,aes256-cbc,chacha20-poly1305@openssh.com

          IF CVE-2023-48795 has been addressed, and it meets local site policy, chacha20-poly1305@openssh.com may be removed from the list of excluded ciphers.

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.5
        description: "Ensure sshd KexAlgorithms is configured (Automated)"
        audit: |
          # Check for weak Key Exchange algorithms in SSH configuration
          weak_kex_found=false

          # Check if any weak KexAlgorithms are configured
          if sshd -T 2>/dev/null | grep -Pi -- 'kexalgorithms\h+([^#\n\r]+,)?(diffie-hellman-group1-sha1|diffie-hellman-group14-sha1|diffie-hellman-group-exchange-sha1)\b' >/dev/null; then
            weak_kex_found=true
          fi

          # Pass if no weak KexAlgorithms are found
          if [ "$weak_kex_found" = "false" ]; then
            echo "sshd_kexalgorithms_properly_configured"
          else
            echo "sshd_kexalgorithms_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_kexalgorithms_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and add/modify the KexAlgorithms line to contain a comma separated list of the site unapproved (weak) KexAlgorithms preceded with a - above any Include entries:

          Example:
          KexAlgorithms -diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.6
        description: "Ensure sshd MACs are configured (Automated)"
        audit: |
          # Check for weak MACs in SSH configuration
          weak_macs_found=false

          # Check if any weak MACs are configured
          if sshd -T 2>/dev/null | grep -Pi -- 'macs\h+([^#\n\r]+,)?(hmac-md5|hmac-md5-96|hmac-ripemd160|hmac-sha1-96|umac-64@openssh\.com|hmac-md5-etm@openssh\.com|hmac-md5-96-etm@openssh\.com|hmac-ripemd160-etm@openssh\.com|hmac-sha1-96-etm@openssh\.com|umac-64-etm@openssh\.com)\b' >/dev/null; then
            weak_macs_found=true
          fi

          # Pass if no weak MACs are found
          if [ "$weak_macs_found" = "false" ]; then
            echo "sshd_macs_properly_configured"
          else
            echo "sshd_macs_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_macs_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file and add/modify the MACs line to contain a comma separated list of the site unapproved (weak) MACs preceded with a - above any Include entries:

          Example:
          MACs -hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-sha1-96,umac-64@openssh.com,hmac-md5-etm@openssh.com,hmac-md5-96-etm@openssh.com,hmac-ripemd160-etm@openssh.com,hmac-sha1-96-etm@openssh.com,umac-64-etm@openssh.com

          IF CVE-2023-48795 has not been reviewed and addressed, the following etm MACs should be added to the exclude list:
          hmac-sha1-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.7
        description: "Ensure sshd access is configured (Automated)"
        audit: |
          # Check for SSH access control configuration
          access_controls_configured=false

          # Check if any access control directives are configured
          if sshd -T 2>/dev/null | grep -Pi -- '^\h*(allow|deny)(users|groups)\h+\H+' >/dev/null; then
            access_controls_configured=true
          fi

          # Pass if access controls are configured
          if [ "$access_controls_configured" = "true" ]; then
            echo "sshd_access_controls_configured"
          else
            echo "sshd_access_controls_not_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_access_controls_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set one or more of the parameters above any Include and Match set statements as follows:

          AllowUsers <userlist>
           - AND/OR -
          AllowGroups <grouplist>
           - AND/OR -
          DenyUsers <userlist>
           - AND/OR -
          DenyGroups <grouplist>

          Example:
          AllowUsers root admin sshuser
          AllowGroups wheel sshusers

          Note:
          - First occurrence of an option takes precedence, Match set statements withstanding
          - These options are "ANDed" together. If both AllowUsers and AllowGroups are set, connections will be limited to users that are also members of an allowed group
          - It is recommended that only one be set for clarity and ease of administration
          - It is easier to manage an allow list than a deny list

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.8
        description: "Ensure sshd Banner is configured (Automated)"
        audit: |
          # Check if SSH Banner is configured
          banner_configured=false
          banner_file_exists=false
          banner_content_ok=false

          # Check if Banner is set to a file path
          banner_file="$(sshd -T 2>/dev/null | awk '$1 == "banner" {print $2}')"
          if [ -n "$banner_file" ] && echo "$banner_file" | grep -q '^/'; then
            banner_configured=true

            # Check if banner file exists
            if [ -e "$banner_file" ]; then
              banner_file_exists=true

              # Check if banner content doesn't contain OS-specific info or escape sequences
              if ! grep -Psi -- "(\\\v|\\\r|\\\m|\\\s|\b$(grep '^ID=' /etc/os-release 2>/dev/null | cut -d= -f2 | sed -e 's/"//g')\b)" "$banner_file" >/dev/null 2>&1; then
                banner_content_ok=true
              fi
            fi
          fi

          # Pass if banner is configured, file exists, and content is appropriate
          if [ "$banner_configured" = "true" ] && [ "$banner_file_exists" = "true" ] && [ "$banner_content_ok" = "true" ]; then
            echo "sshd_banner_properly_configured"
          else
            echo "sshd_banner_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_banner_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the Banner parameter above any Include and Match entries as follows:

          Banner /etc/issue.net

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Edit the file being called by the Banner argument with the appropriate contents according to your site policy, remove any instances of \m, \r, \s, \v or references to the OS platform:

          Example:
          # printf '%s\n' "Authorized users only. All activity may be monitored and reported." > /etc/issue.net

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.9
        description: "Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured (Automated)"
        audit: |
          # Check SSH ClientAlive configuration
          interval_ok=false
          countmax_ok=false

          # Get ClientAliveInterval and ClientAliveCountMax values
          interval="$(sshd -T 2>/dev/null | awk '/^clientaliveinterval/ {print $2}')"
          countmax="$(sshd -T 2>/dev/null | awk '/^clientalivecountmax/ {print $2}')"

          # Check if ClientAliveInterval is greater than 0
          if [ -n "$interval" ] && [ "$interval" -gt 0 ] 2>/dev/null; then
            interval_ok=true
          fi

          # Check if ClientAliveCountMax is greater than 0
          if [ -n "$countmax" ] && [ "$countmax" -gt 0 ] 2>/dev/null; then
            countmax_ok=true
          fi

          # Pass if both values are greater than 0
          if [ "$interval_ok" = "true" ] && [ "$countmax_ok" = "true" ]; then
            echo "sshd_clientalive_properly_configured"
          else
            echo "sshd_clientalive_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_clientalive_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the ClientAliveInterval and ClientAliveCountMax parameters above any Include and Match entries according to site policy.

          Example:
          ClientAliveInterval 15
          ClientAliveCountMax 3

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.10
        description: "Ensure sshd HostbasedAuthentication is disabled (Automated)"
        audit: |
          # Check if HostbasedAuthentication is disabled
          hostbased_disabled=false

          # Check if HostbasedAuthentication is set to no
          if sshd -T 2>/dev/null | grep -Piq '^hostbasedauthentication\s+no$'; then
            hostbased_disabled=true
          fi

          # Pass if HostbasedAuthentication is disabled
          if [ "$hostbased_disabled" = "true" ]; then
            echo "sshd_hostbasedauth_properly_configured"
          else
            echo "sshd_hostbasedauth_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_hostbasedauth_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the HostbasedAuthentication parameter to no above any Include and Match entries as follows:

          HostbasedAuthentication no

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.11
        description: "Ensure sshd IgnoreRhosts is enabled (Automated)"
        audit: |
          # Check if IgnoreRhosts is enabled
          ignorerhosts_enabled=false

          # Check if IgnoreRhosts is set to yes
          if sshd -T 2>/dev/null | grep -Piq '^ignorerhosts\s+yes$'; then
            ignorerhosts_enabled=true
          fi

          # Pass if IgnoreRhosts is enabled
          if [ "$ignorerhosts_enabled" = "true" ]; then
            echo "sshd_ignorerhosts_properly_configured"
          else
            echo "sshd_ignorerhosts_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_ignorerhosts_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the IgnoreRhosts parameter to yes above any Include entry as follows:

          IgnoreRhosts yes

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.12
        description: "Ensure sshd LoginGraceTime is configured (Automated)"
        audit: |
          # Check SSH LoginGraceTime configuration
          logingracetime_ok=false

          # Get LoginGraceTime value
          gracetime="$(sshd -T 2>/dev/null | awk '/^logingracetime/ {print $2}')"

          # Check if LoginGraceTime is between 1 and 60 seconds
          if [ -n "$gracetime" ] && [ "$gracetime" -ge 1 ] && [ "$gracetime" -le 60 ] 2>/dev/null; then
            logingracetime_ok=true
          fi

          # Pass if LoginGraceTime is properly configured
          if [ "$logingracetime_ok" = "true" ]; then
            echo "sshd_logingracetime_properly_configured"
          else
            echo "sshd_logingracetime_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_logingracetime_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the LoginGraceTime parameter to 60 seconds or less above any Include entry as follows:

          LoginGraceTime 60

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.13
        description: "Ensure sshd LogLevel is configured (Automated)"
        audit: |
          # Check SSH LogLevel configuration
          loglevel_ok=false

          # Get LogLevel value
          loglevel="$(sshd -T 2>/dev/null | awk '/^loglevel/ {print $2}')"

          # Check if LogLevel is INFO or VERBOSE
          if [ "$loglevel" = "INFO" ] || [ "$loglevel" = "VERBOSE" ]; then
            loglevel_ok=true
          fi

          # Pass if LogLevel is properly configured
          if [ "$loglevel_ok" = "true" ]; then
            echo "sshd_loglevel_properly_configured"
          else
            echo "sshd_loglevel_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_loglevel_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the LogLevel parameter to VERBOSE or INFO above any Include and Match entries as follows:

          LogLevel VERBOSE
             - OR -
          LogLevel INFO

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.14
        description: "Ensure sshd MaxAuthTries is configured (Automated)"
        audit: |
          # Check SSH MaxAuthTries configuration
          maxauthtries_ok=false

          # Get MaxAuthTries value
          maxauthtries="$(sshd -T 2>/dev/null | awk '/^maxauthtries/ {print $2}')"

          # Check if MaxAuthTries is 4 or less
          if [ -n "$maxauthtries" ] && [ "$maxauthtries" -le 4 ] 2>/dev/null; then
            maxauthtries_ok=true
          fi

          # Pass if MaxAuthTries is properly configured
          if [ "$maxauthtries_ok" = "true" ]; then
            echo "sshd_maxauthtries_properly_configured"
          else
            echo "sshd_maxauthtries_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_maxauthtries_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the MaxAuthTries parameter to 4 or less above any Include and Match entries as follows:

          MaxAuthTries 4

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.15
        description: "Ensure sshd MaxStartups is configured (Automated)"
        audit: |
          # Check SSH MaxStartups configuration
          maxstartups_ok=true

          # Get MaxStartups value and check if it's more restrictive than 10:30:100
          maxstartups_result="$(sshd -T 2>/dev/null | awk '$1 ~ /^\s*maxstartups/{split($2, a, ":");{if(a[1] > 10 || a[2] > 30 || a[3] > 100) print $0}}')"

          # If anything is returned, the configuration is not restrictive enough
          if [ -n "$maxstartups_result" ]; then
            maxstartups_ok=false
          fi

          # Pass if MaxStartups is properly configured (10:30:100 or more restrictive)
          if [ "$maxstartups_ok" = "true" ]; then
            echo "sshd_maxstartups_properly_configured"
          else
            echo "sshd_maxstartups_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_maxstartups_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the MaxStartups parameter to 10:30:100 or more restrictive above any Include entries as follows:

          MaxStartups 10:30:100

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.16
        description: "Ensure sshd MaxSessions is configured (Automated)"
        audit: |
          # Check SSH MaxSessions configuration
          maxsessions_ok=false

          # Get MaxSessions value
          maxsessions="$(sshd -T 2>/dev/null | awk '/^maxsessions/ {print $2}')"

          # Check if MaxSessions is 10 or less
          if [ -n "$maxsessions" ] && [ "$maxsessions" -le 10 ] 2>/dev/null; then
            # Also check that no config file has MaxSessions > 10
            if ! grep -Psi -- '^\h*MaxSessions\h+\"?(1[1-9]|[2-9][0-9]|[1-9][0-9][0-9]+)\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null; then
              maxsessions_ok=true
            fi
          fi

          # Pass if MaxSessions is properly configured
          if [ "$maxsessions_ok" = "true" ]; then
            echo "sshd_maxsessions_properly_configured"
          else
            echo "sshd_maxsessions_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_maxsessions_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the MaxSessions parameter to 10 or less above any Include and Match entries as follows:

          MaxSessions 10

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.17
        description: "Ensure sshd PermitEmptyPasswords is disabled (Automated)"
        audit: |
          # Check if PermitEmptyPasswords is disabled
          permitemptypasswords_disabled=false

          # Check if PermitEmptyPasswords is set to no
          if sshd -T 2>/dev/null | grep -Piq '^permitemptypasswords\s+no$'; then
            permitemptypasswords_disabled=true
          fi

          # Pass if PermitEmptyPasswords is disabled
          if [ "$permitemptypasswords_disabled" = "true" ]; then
            echo "sshd_permitemptypasswords_properly_configured"
          else
            echo "sshd_permitemptypasswords_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_permitemptypasswords_properly_configured"
              set: true
        remediation: |
          Edit /etc/ssh/sshd_config and set the PermitEmptyPasswords parameter to no above any Include and Match entries as follows:

          PermitEmptyPasswords no

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          The SSH daemon must be restarted for the changes to take effect. To restart the SSH daemon, run the following command:
          # systemctl reload-or-restart sshd.service
        scored: true

      - id: 5.2.18
        description: "Ensure sshd PermitRootLogin is disabled (Automated)"
        audit: |
          # Check if PermitRootLogin is disabled
          permitrootlogin_disabled=false

          # Check if PermitRootLogin is set to no
          if sshd -T 2>/dev/null | grep -Piq '^permitrootlogin\s+no$'; then
            permitrootlogin_disabled=true
          fi

          # Pass if PermitRootLogin is disabled
          if [ "$permitrootlogin_disabled" = "true" ]; then
            echo "sshd_permitrootlogin_properly_configured"
          else
            echo "sshd_permitrootlogin_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_permitrootlogin_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the PermitRootLogin parameter to no above any Include and Match entries as follows:

          PermitRootLogin no

          Note: First occurrence of an option takes precedence, Match set statements withstanding. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.19
        description: "Ensure sshd PermitUserEnvironment is disabled (Automated)"
        audit: |
          # Check if PermitUserEnvironment is disabled
          permituserenvironment_disabled=false

          # Check if PermitUserEnvironment is set to no
          if sshd -T 2>/dev/null | grep -Piq '^permituserenvironment\s+no$'; then
            permituserenvironment_disabled=true
          fi

          # Pass if PermitUserEnvironment is disabled
          if [ "$permituserenvironment_disabled" = "true" ]; then
            echo "sshd_permituserenvironment_properly_configured"
          else
            echo "sshd_permituserenvironment_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_permituserenvironment_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the PermitUserEnvironment parameter to no above any Include entries as follows:

          PermitUserEnvironment no

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true

      - id: 5.2.20
        description: "Ensure sshd UsePAM is enabled (Automated)"
        audit: |
          # Check if UsePAM is enabled
          usepam_enabled=false

          # Check if UsePAM is set to yes
          if sshd -T 2>/dev/null | grep -Piq '^usepam\s+yes$'; then
            usepam_enabled=true
          fi

          # Pass if UsePAM is enabled
          if [ "$usepam_enabled" = "true" ]; then
            echo "sshd_usepam_properly_configured"
          else
            echo "sshd_usepam_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sshd_usepam_properly_configured"
              set: true
        remediation: |
          Edit the /etc/ssh/sshd_config file to set the UsePAM parameter to yes above any Include entries as follows:

          UsePAM yes

          Note: First occurrence of an option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location.

          Then restart sshd:
          # systemctl restart sshd
        scored: true


  - id: 5.3
    description: "Configure privilege escalation"
    checks:
      - id: 5.3.1
        description: "Ensure sudo is installed (Automated)"
        audit: |
          # Check if sudo is installed
          if rpm -q sudo >/dev/null 2>&1; then
            echo "sudo_installed"
          else
            echo "sudo_not_installed"
          fi
        tests:
          test_items:
            - flag: "sudo_installed"
              set: true
        remediation: |
          Run the following command to install sudo:

          # tdnf install sudo

          Note: AKS Optimized Azure Linux 2 uses tdnf as the package manager. Alternatively, you can use dnf:
          # dnf install sudo
        scored: true

      - id: 5.3.2
        description: "Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
        audit: |
          # Check for !authenticate tags in sudoers files
          no_authenticate_found=false

          # Search for any !authenticate tags in sudoers configuration
          if grep -r "^[^#].*\!authenticate" /etc/sudoers* 2>/dev/null; then
            no_authenticate_found=true
          fi

          # Pass if no !authenticate tags are found
          if [ "$no_authenticate_found" = "false" ]; then
            echo "sudo_reauthentication_properly_configured"
          else
            echo "sudo_reauthentication_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sudo_reauthentication_properly_configured"
              set: true
        remediation: |
          Configure the operating system to require users to reauthenticate for privilege escalation.

          Based on the outcome of the audit procedure, use visudo -f <PATH TO FILE> to edit the relevant sudoers file.

          Remove any occurrences of !authenticate tags in the file(s).

          Example:
          # visudo
          # visudo -f /etc/sudoers.d/filename

          Look for lines containing !authenticate and remove the !authenticate tag from those lines.
        scored: true

      - id: 5.3.3
        description: "Ensure sudo authentication timeout is configured correctly (Automated)"
        audit: |
          # Check sudo authentication timeout configuration
          timeout_ok=true

          # Check for timestamp_timeout in sudoers files
          timeout_value="$(grep -roP "timestamp_timeout=\K[0-9]*" /etc/sudoers* 2>/dev/null | head -1)"

          if [ -n "$timeout_value" ]; then
            # If timestamp_timeout is configured, check if it's 15 minutes or less
            if [ "$timeout_value" -gt 15 ] 2>/dev/null; then
              timeout_ok=false
            fi
          else
            # If no timestamp_timeout configured, check default (should be 5 minutes, which is acceptable)
            default_timeout="$(sudo -V 2>/dev/null | grep "Authentication timestamp timeout:" | grep -oP '\d+' | head -1)"
            if [ -n "$default_timeout" ] && [ "$default_timeout" -gt 15 ] 2>/dev/null; then
              timeout_ok=false
            fi
          fi

          # Pass if timeout is 15 minutes or less
          if [ "$timeout_ok" = "true" ]; then
            echo "sudo_timeout_properly_configured"
          else
            echo "sudo_timeout_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "sudo_timeout_properly_configured"
              set: true
        remediation: |
          If the currently configured timeout is larger than 15 minutes, edit the file listed in the audit section with visudo -f <PATH TO FILE> and modify the entry timestamp_timeout= to 15 minutes or less as per your site policy. The value is in minutes.

          This particular entry may appear on its own, or on the same line as env_reset. See the following two examples:

          Defaults    env_reset, timestamp_timeout=15
          Defaults    timestamp_timeout=15
          Defaults    env_reset

          Example commands:
          # visudo
          # visudo -f /etc/sudoers.d/filename

          NOTE: A value of -1 means that the timeout is disabled. Depending on the configuration of the timestamp_type, this could mean for all terminals / processes of that user and not just that one single terminal session.
        scored: true

  - id: 5.4
    description: "Configure Pluggable Authentication Modules"
    checks:
      - id: 5.4.1
        description: "Ensure password creation requirements are configured (Automated)"
        audit: |
          # Check password creation requirements configuration
          minlen_ok=false
          complexity_ok=false
          retry_ok=false

          # Check minimum password length (should be 14 or more)
          minlen_value="$(grep -Pi '^\h*minlen\b' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print $2}' | tr -d ' ')"
          if [ -n "$minlen_value" ] && [ "$minlen_value" -ge 14 ] 2>/dev/null; then
            minlen_ok=true
          fi

          # Check password complexity - either minclass=4 OR all credit settings
          minclass_value="$(grep -Pi '^\h*minclass\b' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print $2}' | tr -d ' ')"
          if [ -n "$minclass_value" ] && [ "$minclass_value" -ge 4 ] 2>/dev/null; then
            complexity_ok=true
          else
            # Check individual credit settings
            dcredit="$(grep -Pi '^\h*dcredit\b' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print $2}' | tr -d ' ')"
            ucredit="$(grep -Pi '^\h*ucredit\b' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print $2}' | tr -d ' ')"
            lcredit="$(grep -Pi '^\h*lcredit\b' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print $2}' | tr -d ' ')"
            ocredit="$(grep -Pi '^\h*ocredit\b' /etc/security/pwquality.conf 2>/dev/null | awk -F= '{print $2}' | tr -d ' ')"

            if [ "$dcredit" = "-1" ] && [ "$ucredit" = "-1" ] && [ "$lcredit" = "-1" ] && [ "$ocredit" = "-1" ]; then
              complexity_ok=true
            fi
          fi

          # Check retry setting in PAM files
          if grep -P '^\h*password\h+([^#\n\r]+\h+)?pam_pwquality\.so\h+([^#\n\r]+\h+)?(retry=[1-3])\b' /etc/pam.d/system-password /etc/pam.d/system-auth 2>/dev/null | grep -q retry; then
            retry_ok=true
          fi

          # Pass if all requirements are met
          if [ "$minlen_ok" = "true" ] && [ "$complexity_ok" = "true" ] && [ "$retry_ok" = "true" ]; then
            echo "password_requirements_properly_configured"
          else
            echo "password_requirements_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_requirements_properly_configured"
              set: true
        remediation: |
          Edit the file /etc/security/pwquality.conf and add or modify the following line for password length to conform to site policy:

          minlen = 14

          Edit the file /etc/security/pwquality.conf and add or modify the following line for password complexity to conform to site policy:

          minclass = 4
          -OR-
          dcredit = -1
          ucredit = -1
          ocredit = -1
          lcredit = -1

          Edit the /etc/pam.d/system-password and /etc/pam.d/system-auth files to include the appropriate options for pam_pwquality.so and to conform to site policy:

          password requisite pam_pwquality.so retry=3

          Note: Settings in /etc/security/pwquality.conf must use spaces around the = symbol.
        scored: true

      - id: 5.4.2
        description: "Ensure lockout for failed password attempts is configured (Automated)"
        audit: |
          preauth_ok=false
          authfail_ok=false
          account_ok=false
          if grep -P '^\h*auth\h+[^#\n\r]+\h+pam_faillock\.so\h+[^#\n\r]*preauth[^#\n\r]*deny=[1-5]\b[^#\n\r]*unlock_time=(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/pam.d/system-password /etc/pam.d/system-auth 2>/dev/null | wc -l | grep -q '^2$'; then
            preauth_ok=true
          fi
          if grep -P '^\h*auth\h+[^#\n\r]+\h+pam_faillock\.so\h+[^#\n\r]*authfail[^#\n\r]*deny=[1-5]\b[^#\n\r]*unlock_time=(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/pam.d/system-password /etc/pam.d/system-auth 2>/dev/null | wc -l | grep -q '^2$'; then
            authfail_ok=true
          fi
          if grep -P '^\h*account\h+[^#\n\r]+\h+pam_faillock\.so\b' /etc/pam.d/system-password /etc/pam.d/system-auth 2>/dev/null | wc -l | grep -q '^2$'; then
            account_ok=true
          fi
          if [ "$preauth_ok" = "true" ] && [ "$authfail_ok" = "true" ] && [ "$account_ok" = "true" ]; then
            echo "password_lockout_properly_configured"
          else
            echo "password_lockout_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_lockout_properly_configured"
              set: true
        remediation: |
          Set password lockouts and unlock times to conform to site policy. deny should be not greater than 5 and unlock_time should be 0 (never), or 900 seconds or greater.

          Edit the files /etc/pam.d/system-auth and /etc/pam.d/system-password and add the following lines:

          Add the following lines to the auth section:
          auth        required      pam_faillock.so preauth silent audit deny=5 unlock_time=900
          auth        [default=die] pam_faillock.so authfail audit deny=5 unlock_time=900

          Note: The ordering on the lines in the auth section is important. The preauth line needs to be below the line "auth required pam_env.so" and above all password validation lines. The authfail line needs to be after all password validation lines such as pam_sss.so.

          Add the following line to the account section:
          account     required      pam_faillock.so
        scored: true

      - id: 5.4.3
        description: "Ensure password hashing algorithm is SHA-512 (Automated)"
        audit: |
          sha512_system_auth=false
          sha512_system_password=false
          if grep -P '^\h*password\h+([^#\n\r]+)?\h+pam_unix\.so\h+([^#\n\r]+\h+)?sha512\b' /etc/pam.d/system-auth 2>/dev/null >/dev/null; then
            sha512_system_auth=true
          fi
          if grep -P '^\h*password\h+([^#\n\r]+)?\h+pam_unix\.so\h+([^#\n\r]+\h+)?sha512\b' /etc/pam.d/system-password 2>/dev/null >/dev/null; then
            sha512_system_password=true
          fi
          if [ "$sha512_system_auth" = "true" ] && [ "$sha512_system_password" = "true" ]; then
            echo "password_hashing_sha512_properly_configured"
          else
            echo "password_hashing_sha512_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_hashing_sha512_properly_configured"
              set: true
        remediation: |
          Edit the /etc/pam.d/system-password and /etc/pam.d/system-auth files to include sha512 option and remove the md5 option for pam_unix.so:

          password sufficient pam_unix.so sha512

          Note:
          - Any system accounts that need to be expired should be carefully done separately by the system administrator to prevent any potential problems.
          - If it is determined that the password algorithm being used is not SHA-512, once it is changed, it is recommended that all user ID's be immediately expired and forced to change their passwords on next login, in accordance with local site policies.
          - These changes only apply to accounts configured on the local system.
          - Additional module options may be set, recommendation only covers those listed here.
        scored: true

      - id: 5.4.4
        description: "Ensure password reuse is limited (Automated)"
        audit: |
          # Check if password history is configured in both PAM files
          pwhistory_system_auth=false
          pwhistory_system_password=false

          # Check for pam_pwhistory.so with remember=5 or higher in system-auth
          if grep -P '^\h*password\h+[^#\n\r]+\h+pam_pwhistory\.so\h+([^#\n\r]+\h+)?remember=([5-9]|[1-9][0-9]+)\b' /etc/pam.d/system-auth 2>/dev/null >/dev/null; then
            pwhistory_system_auth=true
          fi

          # Check for pam_pwhistory.so with remember=5 or higher in system-password
          if grep -P '^\h*password\h+[^#\n\r]+\h+pam_pwhistory\.so\h+([^#\n\r]+\h+)?remember=([5-9]|[1-9][0-9]+)\b' /etc/pam.d/system-password 2>/dev/null >/dev/null; then
            pwhistory_system_password=true
          fi

          # Pass if both files have password history configured
          if [ "$pwhistory_system_auth" = "true" ] && [ "$pwhistory_system_password" = "true" ]; then
            echo "password_reuse_properly_configured"
          else
            echo "password_reuse_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_reuse_properly_configured"
              set: true
        remediation: |
          Edit both the /etc/pam.d/system-password and /etc/pam.d/system-auth files to include the remember option and conform to site policy as shown:

          Note: Add or modify the line containing the pam_pwhistory.so after the first occurrence of password requisite:

          password    requisite      pam_pwhistory.so remember=5

          Example: (Second line is modified)
          password    requisite     pam_pwquality.so try_first_pass local_users_only authtok_type=
          password    requisite     pam_pwhistory.so use_authtok remember=5 retry=3
          password    sufficient    pam_unix.so sha512 shadow try_first_pass use_authtok
          password    required      pam_deny.so

          Note: The /etc/security/opasswd file stores the users' old passwords and can be checked to ensure that users are not recycling recent passwords. Forcing users not to reuse their past 5 passwords makes it less likely that an attacker will be able to guess the password.
        scored: true


  - id: 5.5
    description: "User Accounts and Environment"
    checks:
      - id: 5.5.1
        description: "Configure shadow password suite parameters"
        type: "skip"
        checks:
      - id: 5.5.1.1
        description: "Ensure password expiration is 365 days or less (Automated)"
        audit: |
          # Check password expiration configuration
          login_defs_ok=false
          shadow_users_ok=true

          # Check PASS_MAX_DAYS in /etc/login.defs (should be 365 or less)
          pass_max_days="$(grep -E '^\s*PASS_MAX_DAYS\s+' /etc/login.defs 2>/dev/null | awk '{print $2}')"
          if [ -n "$pass_max_days" ] && [ "$pass_max_days" -le 365 ] && [ "$pass_max_days" -gt 0 ] 2>/dev/null; then
            login_defs_ok=true
          fi

          # Check all users with passwords in /etc/shadow (field 5 should be 365 or less)
          while IFS=: read -r user pass_max_days_user rest; do
            if [ -n "$pass_max_days_user" ] && [ "$pass_max_days_user" -gt 365 ] 2>/dev/null; then
              shadow_users_ok=false
              break
            fi
          done < <(awk -F: '$2~/^[^*!xX\n\r][^\n\r]+/{print $1":"$5}' /etc/shadow 2>/dev/null)

          # Pass if both login.defs and all shadow users are configured properly
          if [ "$login_defs_ok" = "true" ] && [ "$shadow_users_ok" = "true" ]; then
            echo "password_expiration_properly_configured"
          else
            echo "password_expiration_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_expiration_properly_configured"
              set: true
        remediation: |
          Set the PASS_MAX_DAYS parameter to conform to site policy in /etc/login.defs:

          PASS_MAX_DAYS 365

          Modify user parameters for all users with a password set to match:

          # chage --maxdays 365 <user>

          Example to update all users with passwords:
          # awk -F: '$2~/^[^*!xX\n\r][^\n\r]+/{print $1}' /etc/shadow | while read user; do chage --maxdays 365 "$user"; done

          Note: The window of opportunity for an attacker to leverage compromised credentials is limited by the age of the password. Therefore, reducing the maximum age of a password also reduces an attacker's window of opportunity.
        scored: true

      - id: 5.5.1.2
        description: "Ensure minimum days between password changes is configured (Automated)"
        audit: |
          # Check minimum days between password changes configuration
          login_defs_ok=false
          shadow_users_ok=true

          # Check PASS_MIN_DAYS in /etc/login.defs (should be 1 or more)
          pass_min_days="$(grep -E '^\s*PASS_MIN_DAYS\s+' /etc/login.defs 2>/dev/null | awk '{print $2}')"
          if [ -n "$pass_min_days" ] && [ "$pass_min_days" -ge 1 ] 2>/dev/null; then
            login_defs_ok=true
          fi

          # Check all users with passwords in /etc/shadow (field 4 should be 1 or more)
          while IFS=: read -r user pass_min_days_user rest; do
            if [ -n "$pass_min_days_user" ] && [ "$pass_min_days_user" -lt 1 ] 2>/dev/null; then
              shadow_users_ok=false
              break
            fi
          done < <(awk -F: '$2~/^[^*!xX\n\r][^\n\r]+/{print $1":"$4}' /etc/shadow 2>/dev/null)

          # Pass if both login.defs and all shadow users are configured properly
          if [ "$login_defs_ok" = "true" ] && [ "$shadow_users_ok" = "true" ]; then
            echo "password_min_days_properly_configured"
          else
            echo "password_min_days_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_min_days_properly_configured"
              set: true
        remediation: |
          Set the PASS_MIN_DAYS parameter to 1 in /etc/login.defs:

          PASS_MIN_DAYS 1

          Modify user parameters for all users with a password set to match:

          # chage --mindays 1 <user>

          Example to update all users with passwords:
          # awk -F: '$2~/^[^*!xX\n\r][^\n\r]+/{print $1}' /etc/shadow | while read user; do chage --mindays 1 "$user"; done

          Note: By restricting the frequency of password changes, an administrator can prevent users from repeatedly changing their password in an attempt to circumvent password reuse controls.
        scored: true

      - id: 5.5.1.3
        description: "Ensure password expiration warning days is 7 or more (Automated)"
        audit: |
          # Check password expiration warning days configuration
          login_defs_ok=false
          shadow_users_ok=true

          # Check PASS_WARN_AGE in /etc/login.defs (should be 7 or more)
          pass_warn_age="$(grep -E '^\s*PASS_WARN_AGE\s+' /etc/login.defs 2>/dev/null | awk '{print $2}')"
          if [ -n "$pass_warn_age" ] && [ "$pass_warn_age" -ge 7 ] 2>/dev/null; then
            login_defs_ok=true
          fi

          # Check all users with passwords in /etc/shadow (field 6 should be 7 or more)
          while IFS=: read -r user pass_warn_age_user rest; do
            if [ -n "$pass_warn_age_user" ] && [ "$pass_warn_age_user" -lt 7 ] 2>/dev/null; then
              shadow_users_ok=false
              break
            fi
          done < <(awk -F: '$2~/[^*!xX\n\r][^\n\r]+/{print $1":"$6}' /etc/shadow 2>/dev/null)

          # Pass if both login.defs and all shadow users are configured properly
          if [ "$login_defs_ok" = "true" ] && [ "$shadow_users_ok" = "true" ]; then
            echo "password_warn_age_properly_configured"
          else
            echo "password_warn_age_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_warn_age_properly_configured"
              set: true
        remediation: |
          Set the PASS_WARN_AGE parameter to 7 in /etc/login.defs:

          PASS_WARN_AGE 7

          Modify user parameters for all users with a password set to match:

          # chage --warndays 7 <user>

          Example to update all users with passwords:
          # awk -F: '$2~/[^*!xX\n\r][^\n\r]+/{print $1}' /etc/shadow | while read user; do chage --warndays 7 "$user"; done

          Note: Providing an advance warning that a password will be expiring gives users time to think of a secure password. Users caught unaware may choose a simple password or write it down where it may be discovered.
        scored: true

      - id: 5.5.1.4
        description: "Ensure inactive password lock is 30 days or less (Automated)"
        audit: |
          useradd_defaults_ok=false
          shadow_users_ok=true
          inactive_default="$(useradd -D | grep INACTIVE | cut -d= -f2)"
          if [ -n "$inactive_default" ] && [ "$inactive_default" != "-1" ] && [ "$inactive_default" -le 30 ] && [ "$inactive_default" -ge 0 ] 2>/dev/null; then
            useradd_defaults_ok=true
          fi
          while IFS=: read -r user inactive_user rest; do
            if [ -z "$inactive_user" ] || [ "$inactive_user" = "-1" ] || ([ -n "$inactive_user" ] && [ "$inactive_user" -gt 30 ] 2>/dev/null); then
              shadow_users_ok=false
              break
            fi
          done < <(awk -F: '$2~/^[^*!xX\n\r][^\n\r]+/{print $1":"$7}' /etc/shadow 2>/dev/null)
          if [ "$useradd_defaults_ok" = "true" ] && [ "$shadow_users_ok" = "true" ]; then
            echo "inactive_password_lock_properly_configured"
          else
            echo "inactive_password_lock_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "inactive_password_lock_properly_configured"
              set: true
        remediation: |
          Run the following command to set the default password inactivity period to 30 days:

          # useradd -D -f 30

          Modify user parameters for all users with a password set to match:

          # chage --inactive 30 <user>

          Example to update all users with passwords:
          # awk -F: '$2~/^[^*!xX\n\r][^\n\r]+/{print $1}' /etc/shadow | while read user; do chage --inactive 30 "$user"; done

          Note: Inactive accounts pose a threat to system security since the users are not logging in to notice failed login attempts or other anomalies. User accounts that have been inactive for over 30 days after password expiration should be automatically disabled.
        scored: true

      - id: 5.5.1.5
        description: "Ensure all users last password change date is in the past (Automated)"
        audit: |
          # Check that all users' last password change date is in the past
          l_output2=""
          while read -r l_user; do
            l_change="$(chage --list $l_user | awk -F: '($1 ~ /^\s*Last\s+password\s+change/ && $2 !~ /never/){print $2}' | xargs)"
            if [[ "$(date -d "$l_change" +%s)" -gt "$(date +%s)" ]]; then
              l_output2="$l_output2\n  - User: \"$l_user\" last password change is in the future \"$l_change\""
            fi
          done < <(awk -F: '($2 ~ /^[^*!xX\n\r][^\n\r]+/){print $1}' /etc/shadow)

          if [ -z "$l_output2" ]; then
            echo "password_change_dates_properly_configured"
          else
            echo "password_change_dates_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "password_change_dates_properly_configured"
              set: true
        remediation: |
          Investigate any users with a password change date in the future and correct them. Locking the account, expiring the password, or resetting the password manually may be appropriate.

          Example commands to investigate and fix:
          # Check specific user's password change date:
          chage --list <username>

          # Reset password change date to current date:
          chage --lastday $(date +%Y-%m-%d) <username>

          # Or expire the password to force change on next login:
          passwd --expire <username>

          Note: If a user's recorded password change date is in the future then they could bypass any set password expiration.

          Options (per account):
            # Force immediate password change at next login (recommended)
            passwd -e <username>
            # or equivalently
            chage -d 0 <username>

            # If you must set the date explicitly to today
            chage -d "$(date +%Y-%m-%d)" <username>

            # If the account appears compromised or incorrect, you may lock it first
            usermod -L <username>

          After correction, re-run the audit to confirm no users are reported.
        scored: true

      - id: 5.5.2
        description: "Ensure system accounts are secured (Automated)"
        audit: |
          # Check that system accounts are properly secured
          l_output=""
          l_output2=""
          l_valid_shells="^($( awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
          a_users=()
          a_ulock=()

          # Populate array with system accounts that have a valid login shell
          while read -r l_user; do
            a_users+=("$l_user")
          done < <(awk -v pat="$l_valid_shells" -F: '($1!~/(root|sync|shutdown|halt|^\+)/ && $3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' && $(NF) ~ pat) { print $1 }' /etc/passwd)

          # Populate array with system accounts that aren't locked
          while read -r l_ulock; do
            a_ulock+=("$l_ulock")
          done < <(awk -v pat="$l_valid_shells" -F: '($1!~/(root|^\+)/ && $2!~/LK?/ && $3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' && $(NF) ~ pat) { print $1 }' /etc/passwd)

          if ! (( ${#a_users[@]} > 0 )); then
            l_output="$l_output\n  - local system accounts login is disabled"
          else
            l_output2="$l_output2\n  - There are \"$(printf '%s' "${#a_users[@]}")\" system accounts with login enabled"
          fi

          if ! (( ${#a_ulock[@]} > 0 )); then
            l_output="$l_output\n  - local system accounts are locked"
          else
            l_output2="$l_output2\n  - There are \"$(printf '%s' "${#a_ulock[@]}")\" system accounts that are not locked"
          fi

          unset a_users
          unset a_ulock

          if [ -z "$l_output2" ]; then
            echo "system_accounts_properly_secured"
          else
            echo "system_accounts_not_properly_secured"
          fi
        tests:
          test_items:
            - flag: "system_accounts_properly_secured"
              set: true
        remediation: |
          Set the shell for any accounts returned by the audit to nologin:

          # usermod -s $(which nologin) <user>

          Lock any non-root accounts returned by the audit:

          # usermod -L <user>

          The following script will automatically secure system accounts:

          #!/usr/bin/env bash
          {
             l_valid_shells="^($( awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"

             # Change system accounts that have a valid login shell to nologin shell
             while read -r l_user; do
                echo " - System account \"$l_user\" has a valid logon shell, changing shell to \"$(which nologin)\""
                usermod -s "$(which nologin)" "$l_user"
             done < <(awk -v pat="$l_valid_shells" -F: '($1!~/(root|sync|shutdown|halt|^\+)/ && $3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' && $(NF) ~ pat) { print $1 }' /etc/passwd)

             # Lock system accounts that aren't locked
             while read -r l_ulock; do
                echo " - System account \"$l_ulock\" is not locked, locking account"
                usermod -L "$l_ulock"
             done < <(awk -v pat="$l_valid_shells" -F: '($1!~/(root|^\+)/ && $2!~/LK?/ && $3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' && $(NF) ~ pat) { print $1 }' /etc/passwd)
          }

          Note: The root, sync, shutdown, and halt users are exempted from requiring a non-login shell. Root is exempt from being locked.
        scored: true

      - id: 5.5.3
        description: "Ensure default group for the root account is GID 0 (Automated)"
        audit: |
          # Check that root account's default group is GID 0
          root_gid="$(grep "^root:" /etc/passwd | cut -f4 -d:)"
          if [ "$root_gid" = "0" ]; then
            echo "root_default_group_properly_configured"
          else
            echo "root_default_group_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "root_default_group_properly_configured"
              set: true
        remediation: |
          Run the following command to set the root account default group to GID 0:

          # usermod -g 0 root

          Verify the change:
          # grep "^root:" /etc/passwd | cut -f4 -d:

          Note: Using GID 0 for the root account helps prevent root-owned files from accidentally becoming accessible to non-privileged users. The usermod command affects permissions of files that are created by the root account.

          Result:
            - New directories created by root  drwxr-x---
            - New files created by root      rw-r-----
        scored: true

      - id: 5.5.4
        description: "Ensure default user umask is 027 or more restrictive (Automated)"
        audit: |
          # Check default user umask configuration
          passing=""

          # Method 1: Check login.defs with pam_umask
          if grep -Eiq '^\s*UMASK\s+(0[0-7][2-7]7|[0-7][2-7]7)\b' /etc/login.defs && \
             grep -Eqi '^\s*USERGROUPS_ENAB\s*"?no"?\b' /etc/login.defs && \
             grep -Eq '^\s*session\s+(optional|requisite|required)\s+pam_umask\.so\b' /etc/pam.d/common-session; then
            passing=true
          fi

          # Method 2: Check profile files for umask 027 or more restrictive
          if grep -REiq '^\s*umask\s+\s*(0[0-7][2-7]7|[0-7][2-7]7|u=(r?|w?|x?)(r?|w?|x?)(r?|w?|x?),g=(r?x?|x?r?),o=)\b' /etc/profile* /etc/bashrc* 2>/dev/null; then
            passing=true
          fi

          # Check for less restrictive umask settings
          less_restrictive=""
          if grep -RPi '(^|^[^#]*)\s*umask\s+([0-7][0-7][01][0-7]\b|[0-7][0-7][0-7][0-6]\b|[0-7][01][0-7]\b|[0-7][0-7][0-6]\b|(u=[rwx]{0,3},)?(g=[rwx]{0,3},)?o=[rwx]+\b|(u=[rwx]{1,3},)?g=[^rx]{1,3}(,o=[rwx]{0,3})?\b)' /etc/login.defs /etc/profile* /etc/bashrc* 2>/dev/null; then
            less_restrictive=true
          fi

          if [ "$passing" = "true" ] && [ -z "$less_restrictive" ]; then
            echo "default_user_umask_properly_configured"
          else
            echo "default_user_umask_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "default_user_umask_properly_configured"
              set: true
        remediation: |
          Configure umask in one of the following methods:

          Method 1: Using /etc/login.defs with pam_umask (Recommended)
          Edit /etc/login.defs and set:
          UMASK 027
          USERGROUPS_ENAB no

          Edit /etc/pam.d/password-auth and /etc/pam.d/system-auth and add:
          session     optional      pam_umask.so

          Method 2: Using system-wide shell configuration
          Create /etc/profile.d/set_umask.sh with:
          umask 027

          Or add to /etc/profile or /etc/bashrc:
          umask 027

          Remove any less restrictive umask settings found by:
          # grep -RPi '(^|^[#]*)\s*umask\s+([0-7][0-7][01][0-7]\b|[0-7][0-7][0-7][0-6]\b|[0-7][01][0-7]\b|[0-7][0-7][0-6]\b|(u=[rwx]{0,3},)?(g=[rwx]{0,3},)?o=[rwx]+\b|(u=[rwx]{1,3},)?g=[^rx]{1,3}(,o=[rwx]{0,3})?\b)' /etc/login.defs /etc/profile* /etc/bashrc*

          Note: Setting a secure default umask (027) ensures newly created directories have permissions 750 (drwxr-x---) and files have permissions 640 (rw-r-----), preventing unauthorized access.
            # Set all system accounts to nologin (excluding root, halt, sync, shutdown, nfsnobody)
            awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'$(awk "/^\s*UID_MIN/{print \$2}" /etc/login.defs)') || $3==65534) {print $1}' /etc/passwd | while read user; do
              usermod -s $(command -v nologin) "$user"
            done

            # Lock all accounts already using nologin
            awk -F: '/nologin/ {print $1}' /etc/passwd | while read user; do
              usermod -L "$user"
            done
        scored: true


  - id: 6
    description: "Logging and Auditing"
    checks:
  - id: 6.1
    description: "Configure Logging"
    checks:
      - id: 6.1.1
        description: "Configure journald"
        type: "skip"
        checks:
      - id: 6.1.1.1
        description: "Configure systemd-journald service"
        type: "skip"
        checks:
      - id: 6.1.1.1.1
        description: "Ensure journald service is active (Automated)"
        audit: |
          # Verify systemd-journald is using systemd and is both enabled (static|enabled) and active
          if ! command -v systemctl >/dev/null 2>&1; then
            echo "journald_not_using_systemd"
            exit 0
          fi

          enabled_state="$(systemctl is-enabled systemd-journald.service 2>/dev/null || true)"
          active_state="$(systemctl is-active  systemd-journald.service 2>/dev/null || true)"
          masked_state="$(systemctl is-enabled systemd-journald.service 2>&1 | grep -qi masked && echo masked || echo unmasked)"

          # Accept 'static' (normal) or 'enabled' for the enablement check, require 'active' at runtime, and not masked
          if { [ "$enabled_state" = "static" ] || [ "$enabled_state" = "enabled" ]; } \
             && [ "$active_state" = "active" ] \
             && [ "$masked_state" = "unmasked" ]; then
            echo "journald_ok"
          else
            echo "journald_not_ok: enabled_state=$enabled_state active_state=$active_state masked_state=$masked_state"
          fi
        tests:
          test_items:
            - flag: "journald_ok"
              set: true
        remediation: |
          If journald is masked or inactive, unmask and start it:

            # systemctl unmask systemd-journald.service
            # systemctl start systemd-journald.service

          Notes:
          - systemd-journald normally reports "static" for is-enabled (it has no [Install] section).
            This is expected and compliant.
          - If its not 'active', investigate why (unit overrides, masking, or systemd issues).
        scored: true

      - id: 6.1.1.1.2
        description: "Ensure journald log file access is configured (Manual)"
        audit: |
          # Verify journald log file access permissions (0640 or more restrictive)

          # Determine which systemd.conf file applies
          if [ -f /etc/tmpfiles.d/systemd.conf ]; then
            file_path="/etc/tmpfiles.d/systemd.conf"
          elif [ -f /usr/lib/tmpfiles.d/systemd.conf ]; then
            file_path="/usr/lib/tmpfiles.d/systemd.conf"
          else
            echo "journald_conf_missing"
            exit 0
          fi

          # Check for permissions more permissive than 0640
          if grep -Piq '^\s*[a-z]+\s+[^\s]+\s+0*([6-7][4-7][1-7]|7[0-7][0-7])\s+' "$file_path"; then
            echo "journald_permissions_incorrect:$file_path"
          else
            echo "journald_permissions_ok:$file_path"
          fi
        tests:
          test_items:
            - flag: "journald_permissions_ok"
              set: true
        remediation: |
          If the default configuration is not appropriate for site policy, copy the default file and adjust:

            # cp /usr/lib/tmpfiles.d/systemd.conf /etc/tmpfiles.d/systemd.conf
            # chmod 0640 /etc/tmpfiles.d/systemd.conf

          Ensure permissions for journald-created log files are set to **0640 or more restrictive**.
          This protects sensitive log information from unauthorized access.

          Notes:
          - The override file `/etc/tmpfiles.d/systemd.conf` takes precedence over `/usr/lib/tmpfiles.d/systemd.conf`.
          - On Container-Optimized OS or other stateless systems, changes may not persist after reboot;
            configure this setting via image customization or startup automation.
        scored: true

      - id: 6.1.1.1.3
        description: "Ensure journald ForwardToSyslog is configured (Automated)"
        audit: |
          # Verify ForwardToSyslog in journald.conf matches the active logging method
          if systemctl is-active rsyslog.service 2>/dev/null | grep -q '^active'; then
            expected="yes"
          else
            expected="no"
          fi

          # Find current value (explicit setting or default)
          value=$(awk '/^\[Journal\]/{a=1;next}/^\[/{a=0}a' /etc/systemd/journald.conf 2>/dev/null \
                    | awk -F= '/^\s*ForwardToSyslog/{print tolower($2)}' | xargs)

          if [ -z "$value" ]; then
            # If not explicitly set, use systemd default
            value="no"
          fi

          if [ "$value" = "$expected" ]; then
            echo "journald_forwardtosyslog_ok"
          else
            echo "journald_forwardtosyslog_mismatch:value=$value expected=$expected"
          fi
        tests:
          test_items:
            - flag: "journald_forwardtosyslog_ok"
              set: true
        remediation: |
          Configure ForwardToSyslog in the [Journal] section of
          /etc/systemd/journald.conf or a drop-in file in /etc/systemd/journald.conf.d/

           If journald is the primary log collector:
              ForwardToSyslog=no
           If rsyslog is the primary log collector:
              ForwardToSyslog=yes

          Example:

            # mkdir -p /etc/systemd/journald.conf.d/
            # printf '%s\n' "[Journal]" "ForwardToSyslog=no" > /etc/systemd/journald.conf.d/60-journald.conf
            # systemctl reload-or-restart systemd-journald

          Notes:
          - no is the systemd default and is compliant when journald alone handles logs.
          - If rsyslog is enabled, yes is required so journald forwards logs.
        scored: true

      - id: 6.1.1.1.4
        description: "Ensure systemd-journal-remote service is not in use (Automated)"
        audit: |
          # Verify systemd-journal-remote service and socket are disabled and inactive

          enabled_remote=$(systemctl is-enabled systemd-journal-remote.service 2>/dev/null || echo "disabled")
          enabled_socket=$(systemctl is-enabled systemd-journal-remote.socket 2>/dev/null || echo "disabled")
          active_remote=$(systemctl is-active systemd-journal-remote.service 2>/dev/null || echo "inactive")
          active_socket=$(systemctl is-active systemd-journal-remote.socket 2>/dev/null || echo "inactive")

          if [ "$enabled_remote" != "enabled" ] && [ "$enabled_socket" != "enabled" ] \
             && [ "$active_remote" != "active" ] && [ "$active_socket" != "active" ]; then
            echo "journal_remote_not_in_use"
          else
            echo "journal_remote_in_use: enabled_remote=$enabled_remote active_remote=$active_remote enabled_socket=$enabled_socket active_socket=$active_socket"
          fi
        tests:
          test_items:
            - flag: "journal_remote_not_in_use"
              set: true
        remediation: |
          Stop and mask the remote logging components to prevent the host from acting as a log receiver:

            # systemctl stop systemd-journal-remote.service systemd-journal-remote.socket
            # systemctl mask systemd-journal-remote.service systemd-journal-remote.socket

          This ensures the system does not accept remote journal streams.
        scored: true

      - id: 6.1.1.1.5
        description: "Ensure journald Storage is configured (Automated)"
        audit: |
          # Verify that journald Storage is set to 'persistent' (to retain logs across reboots)

          journald_conf_files="/etc/systemd/journald.conf /etc/systemd/journald.conf.d/*.conf"
          configured_value=""
          found_file=""

          # Check explicit configuration
          while read -r file; do
            [ -f "$file" ] || continue
            val=$(awk '/^\[Journal\]/{a=1;next}/^\[/{a=0}a' "$file" 2>/dev/null \
                    | awk -F= '/^\s*Storage/{print tolower($2)}' | xargs)
            if [ -n "$val" ]; then
              configured_value="$val"
              found_file="$file"
            fi
          done < <(ls /etc/systemd/journald.conf /etc/systemd/journald.conf.d/*.conf 2>/dev/null)

          # If nothing found, use the default
          if [ -z "$configured_value" ]; then
            configured_value="auto"
          fi

          if [ "$configured_value" = "persistent" ]; then
            echo "journald_storage_persistent"
          else
            echo "journald_storage_not_persistent:value=$configured_value file=$found_file"
          fi
        tests:
          test_items:
            - flag: "journald_storage_persistent"
              set: true
        remediation: |
          To ensure journald stores logs persistently on disk:

            1. Create or edit a drop-in configuration file:
               # mkdir -p /etc/systemd/journald.conf.d/
               # printf '%s\n' "[Journal]" "Storage=persistent" > /etc/systemd/journald.conf.d/60-journald.conf

            2. Apply the change:
               # systemctl reload-or-restart systemd-journald

          Notes:
          - Valid Storage options: 'volatile', 'persistent', 'auto', 'none'.
            'persistent' ensures logs are retained across reboots.
          - If another file later in load order sets Storage differently,
            its value will override earlier definitions.
          - On stateless or ephemeral systems (e.g., COS, AKS optimized images),
            this setting may require custom image or boot-time configuration.
        scored: true

      - id: 6.1.1.1.6
        description: "Ensure journald Compress is configured (Automated)"
        audit: |
          conf=$(systemd-analyze cat-config systemd/journald.conf 2>/dev/null)
          val=$(awk '/^\[Journal\]/{a=1;next}/^\[/{a=0}a && /^\s*Compress/{print tolower($3)}' <<< "$conf" | tail -n1)

          if [ "$val" = "yes" ]; then
            echo "journald_compress_enabled"
          else
            echo "journald_compress_not_configured_or_disabled"
          fi
        tests:
          test_items:
            - flag: "journald_compress_enabled"
              set: true
        remediation: |
          To ensure log files are compressed by journald:

            1. Create or edit a journald configuration file:
               # mkdir -p /etc/systemd/journald.conf.d/
               # printf '%s\n' "[Journal]" "Compress=yes" > /etc/systemd/journald.conf.d/60-journald.conf

            2. Apply the configuration:
               # systemctl reload-or-restart systemd-journald

          Notes:
          - Valid values for Compress: 'yes' (default) or 'no'.
          - Setting 'Compress=yes' minimizes disk usage and prevents unexpected
            filesystem exhaustion caused by large uncompressed log files.
          - On ephemeral or read-only systems, ensure this change is persisted
            via image customization or startup automation.
        scored: true

      - id: 6.1.2
        description: "Configure rsyslog"
        type: "skip"
        checks:

      - id: 6.1.2.1
        description: "Ensure rsyslog service is enabled and active (Automated)"
        audit: |
          # Verify that the rsyslog service is enabled to start on boot and currently active

          enabled_state="$(systemctl is-enabled rsyslog.service 2>/dev/null || echo "disabled")"
          active_state="$(systemctl is-active rsyslog.service 2>/dev/null || echo "inactive")"
          masked_state="$(systemctl is-enabled rsyslog.service 2>&1 | grep -qi masked && echo masked || echo unmasked)"

          if { [ "$enabled_state" = "enabled" ] || [ "$enabled_state" = "static" ]; } \
             && [ "$active_state" = "active" ] \
             && [ "$masked_state" = "unmasked" ]; then
            echo "rsyslog_enabled_active"
          else
            echo "rsyslog_not_enabled_active: enabled_state=$enabled_state active_state=$active_state masked_state=$masked_state"
          fi
        tests:
          test_items:
            - flag: "rsyslog_enabled_active"
              set: true
        remediation: |
          If rsyslog is the chosen system logging method, ensure the service is unmasked,
          enabled, and started:

            # systemctl unmask rsyslog.service
            # systemctl enable rsyslog.service
            # systemctl start rsyslog.service

          Verify:
            # systemctl is-enabled rsyslog.service    enabled
            # systemctl is-active  rsyslog.service    active

          Notes:
          - rsyslog should run continuously to collect and forward system logs.
          - If journald alone is used for logging, this control is not applicable.
        scored: true

      - id: 6.1.2.2
        description: "Ensure rsyslog log file creation mode is configured (Automated)"
        audit: |
          # Verify that $FileCreateMode in rsyslog configuration is set to 0640 or more restrictive

          file_mode_lines=$(grep -Psi '^\s*\$FileCreateMode\s+0[0-7]{3}\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)

          if [ -z "$file_mode_lines" ]; then
            echo "rsyslog_filecreatemode_not_set"
          else
            # Extract the numeric mode (remove leading zeros for numeric comparison)
            mode_val=$(echo "$file_mode_lines" | awk '{print $2}' | tail -n1)
            # Convert to decimal for comparison
            perm=$((8#$mode_val))

            # 0640 decimal = 416, 0600 decimal = 384  both acceptable or more restrictive
            if [ "$perm" -le 416 ]; then
              echo "rsyslog_filecreatemode_ok"
            else
              echo "rsyslog_filecreatemode_too_permissive:$mode_val"
            fi
          fi
        tests:
          test_items:
            - flag: "rsyslog_filecreatemode_ok"
              set: true
        remediation: |
          Edit either **/etc/rsyslog.conf** or a dedicated configuration file in **/etc/rsyslog.d/**
          and set a file creation mode of **0640** or more restrictive:

            $FileCreateMode 0640

          Then restart rsyslog to apply:

            # systemctl restart rsyslog

          Notes:
          - Modes such as 0600 or 0640 are compliant.
          - Ensure no later-loaded configuration file overrides this setting with a less restrictive mode.
        scored: true

      - id: 6.1.2.3
        description: "Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
        audit: |
          # Verify that rsyslog is not configured as a remote log receiver

          # Search both modern and legacy rsyslog configuration syntaxes
          tcp_modload=$(grep -Psi -- '^\s*module\(load="?imtcp"?\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)
          tcp_input=$(grep -Psi -- '^\s*input\(type="?imtcp"?\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)
          legacy_modload=$(grep -Psi -- '^\s*\$ModLoad\s+imtcp\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)
          legacy_server=$(grep -Psi -- '^\s*\$InputTCPServerRun\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null)

          if [ -z "$tcp_modload$tcp_input$legacy_modload$legacy_server" ]; then
            echo "rsyslog_not_receiving_remote_logs"
          else
            echo "rsyslog_receiving_remote_logs"
            echo "$tcp_modload$tcp_input$legacy_modload$legacy_server"
          fi
        tests:
          test_items:
            - flag: "rsyslog_not_receiving_remote_logs"
              set: true
        remediation: |
          Edit **/etc/rsyslog.conf** and all files under **/etc/rsyslog.d/** to remove
          any configuration that enables rsyslog to listen for remote log messages.

          Specifically, delete or comment out any of the following lines:

            module(load="imtcp")
            input(type="imtcp" port="514")
            $ModLoad imtcp
            $InputTCPServerRun

          Then restart rsyslog:

            # systemctl restart rsyslog

          Notes:
          - These directives configure rsyslog to act as a log server.
            Client systems must not accept incoming log traffic.
        scored: true

      - id: 6.1.3
        description: "Configure Logfiles"
        type: "skip"
        checks:
      - id: 6.1.3.1
        description: "Ensure access to all log files has been configured (Automated)"
        audit: |
          # Verify that all log files under /var/log have secure ownership and permissions

          # Find files with world/group write permissions or incorrect ownership
          bad_files=$(find -L /var/log -type f \( -perm /0137 -o ! -user root -o ! -group root \) 2>/dev/null)

          if [ -z "$bad_files" ]; then
            echo "logfiles_access_ok"
          else
            echo "logfiles_access_issue"
            echo "$bad_files"
          fi
        tests:
          test_items:
            - flag: "logfiles_access_ok"
              set: true
        remediation: |
          Review the listed files and correct their permissions and ownerships.

          Recommended steps:

            # find /var/log -type f \( -perm /0137 -o ! -user root -o ! -group root \) -exec ls -l {} \;
            # chmod g-wx,o-rwx <file>
            # chown root:adm <file>

          Ensure:
            - Log files are owned by root or an authorized service account (e.g., syslog)
            - Log files are group-owned by root or adm
            - Permissions are 0640 or more restrictive

          If other services write logs elsewhere, verify those directories too.
        scored: true

      - id: 6.2
        description: "Ensure logrotate is configured (Manual)"
        type: manual
        remediation: |
          Edit /etc/logrotate.conf and /etc/logrotate.d/* to ensure logs are rotated
          according to site policy.
        scored: false


  - id: 7
    description: "System Maintenance"
    checks:
  - id: 7.1
    description: "Configure system file and directory access"
    checks:
      - id: 7.1.1
        description: "Ensure access to /etc/passwd is configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          # Set secure ownership and permissions on /etc/passwd
          chown root:root /etc/passwd
          chmod u-x,go-wx /etc/passwd   # yields 0644
        scored: true

      - id: 7.1.2
        description: "Ensure access to /etc/passwd- is configured (Automated)"
        audit: |
          # Expect: perms <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/passwd- 2>/dev/null)" || { echo "passwd_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/passwd-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "passwd_perms_ok"
          else
            echo "passwd_perms_bad"
          fi
        tests:
          test_items:
            - flag: "passwd_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/passwd-:

          chmod u-x,go-wx /etc/passwd-
          chown root:root /etc/passwd-
        scored: true


      - id: 7.1.3
        description: "Ensure access to /etc/group is configured (Automated)"
        audit: |
          mode_str="$(stat -Lc '%a' /etc/group 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group:

          chmod u-x,go-wx /etc/group
          chown root:root /etc/group
        scored: true


      - id: 7.1.4
        description: "Ensure access to /etc/group- is configured (Automated)"
        audit: |
          # Expect: group <= 0644, owner UID=0, GID=0, no suid/sgid/sticky
          mode_str="$(stat -Lc '%a' /etc/group- 2>/dev/null)" || { echo "group_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/group-)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "group_perms_ok"
          else
            echo "group_perms_bad"
          fi
        tests:
          test_items:
            - flag: "group_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group-:

          chmod u-x,go-wx /etc/group-
          chown root:root /etc/group-
        scored: true

      - id: 7.1.5
        description: "Ensure access to /etc/shadow is configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          # Correct ownership and permissions for /etc/shadow
          chown root:root /etc/shadow
          chmod 0000 /etc/shadow
        scored: true

      - id: 7.1.6
        description: "Ensure access to /etc/shadow- is configured (Automated)"
        audit: |
          # Expected: /etc/shadow owned by root:root and permissions 0000 (no suid/sgid/sticky)
          if [ -e /etc/shadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/shadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/shadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0 ]; then
              echo "shadow_perms_ok"
            else
              echo "shadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "shadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "shadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow-:

          # chown root:root /etc/shadow-
          # chmod 0000 /etc/shadow-
        scored: true

      - id: 7.1.7
        description: "Ensure access to /etc/gshadow is configured (Automated)"
        audit: |
          if [ -e /etc/gshadow ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0400 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow:

          # chown root:root /etc/gshadow
          # chmod o-wx,go-rwx /etc/gshadow
        scored: true

      - id: 7.1.8
        description: "Ensure access to /etc/gshadow- is configured (Automated)"
        audit: |
          if [ -e /etc/gshadow- ]; then
            mode_str="$(stat -Lc '%a' /etc/gshadow- 2>/dev/null)"
            uid_gid="$(stat -Lc '%u %g' /etc/gshadow- 2>/dev/null)"
            mode=$(( 8#$mode_str ))

            if [ "$uid_gid" = "0 0" ] && [ "$mode" -eq 0400 ]; then
              echo "gshadow_perms_ok"
            else
              echo "gshadow_perms_bad"
              echo "  Found mode: $mode_str uid/gid: $uid_gid"
            fi
          else
            echo "gshadow_file_missing"
          fi
        tests:
          test_items:
            - flag: "gshadow_perms_ok"
              set: true
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/gshadow-:

          # chown root:root /etc/gshadow-
          # chmod o-wx,go-rwx /etc/gshadow-
        scored: true

      - id: 7.1.9
        description: "Ensure access to /etc/shells is configured (Automated)"
        audit: |
          mode_str="$(stat -Lc '%a' /etc/shells 2>/dev/null)" || { echo "shells_perms_bad"; exit 0; }
          uid_gid="$(stat -Lc '%u %g' /etc/shells)"
          mode=$(( 8#$mode_str ))

          if [ "$uid_gid" = "0 0" ] && \
             [ $(((mode | 0644) == 0644)) -eq 1 ] && \
             [ $(((mode & 07000) == 0)) -eq 1 ]; then
            echo "shells_perms_ok"
          else
            echo "shells_perms_bad"
          fi
        tests:
          test_items:
            - flag: "shells_perms_ok"
              set: true
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/shells:

          chmod u-x,go-wx /etc/shells
          chown root:root /etc/shells
        scored: true

      - id: 7.1.10
        description: "Ensure access to /etc/security/opasswd is configured (Automated)"
        audit: |
          check_file() {
            f="$1"
            if [ -e "$f" ]; then
              mode_str="$(stat -Lc '%a' "$f" 2>/dev/null)"
              uid_gid="$(stat -Lc '%u %g' "$f" 2>/dev/null)"
              mode=$(( 8#$mode_str ))

              # mode must be <= 0600 (no group/other access) and owned by root:root
              if [ "$uid_gid" = "0 0" ] && [ $(((mode | 0600) == 0600)) -eq 1 ] && [ $(((mode & 07000) == 0)) -eq 1 ]; then
                echo "opasswd_ok_$f"
                echo "opasswd_pass_$f"
              else
                echo "opasswd_bad_$f"
              fi
            else
              echo "opasswd_missing_$f"
              echo "opasswd_pass_$f"
            fi
          }

          check_file /etc/security/opasswd
          check_file /etc/security/opasswd.old
        tests:
          test_items:
            - flag: "opasswd_pass_/etc/security/opasswd"
              set: true
            - flag: "opasswd_pass_/etc/security/opasswd.old"
              set: true
        remediation: |
          # Fix ownership and permissions for opasswd files (if present)
          [ -e "/etc/security/opasswd" ] && chown root:root /etc/security/opasswd && chmod 600 /etc/security/opasswd
          [ -e "/etc/security/opasswd.old" ] && chown root:root /etc/security/opasswd.old && chmod 600 /etc/security/opasswd.old
        scored: true

      - id: 7.1.11
        description: "Ensure world writable files and directories are secured (Automated)"
        audit: |
          # Verify that no world-writable files exist and that all world-writable directories have the sticky bit set

          # Exclude transient or system paths that may legitimately contain world-writable items
          exclude_paths=(-path "/run/user/*" -o -path "/proc/*" -o -path "*/containerd/*" \
                         -o -path "*/kubelet/pods/*" -o -path "*/kubelet/plugins/*" \
                         -o -path "/sys/*" -o -path "/snap/*")

          # 1. Find world-writable files
          ww_files=$(find / -xdev \( "${exclude_paths[@]}" \) -type f -perm -0002 2>/dev/null | head -n 20)

          # 2. Find world-writable directories missing the sticky bit
          ww_dirs=$(find / -xdev \( "${exclude_paths[@]}" \) -type d -perm -0002 ! -perm -1000 2>/dev/null | head -n 20)

          if [ -z "$ww_files$ww_dirs" ]; then
            echo "world_writable_secured"
          else
            echo "world_writable_unsecured"
            [ -n "$ww_files" ] && echo "World-writable files:" && echo "$ww_files"
            [ -n "$ww_dirs" ] && echo "World-writable directories missing sticky bit:" && echo "$ww_dirs"
          fi
        tests:
          test_items:
            - flag: "world_writable_secured"
              set: true
        remediation: |
          To secure world-writable files and directories:

            # Remove write permissions for others:
            find / -xdev -type f -perm -0002 -exec chmod o-w {} \;

            # Add the sticky bit on world-writable directories:
            find / -xdev -type d -perm -0002 ! -perm -1000 -exec chmod a+t {} \;

          Notes:
          - Review any reported files carefully before modifying permissions;
            some applications may require specific settings.
          - The sticky bit (t) prevents non-owners from deleting or renaming
            other users' files within shared directories such as /tmp.
          - On large systems this audit may take time; limit scope or use find exclusions if needed.
        scored: true

      - id: 7.1.12
        description: "Ensure no files or directories without an owner and a group exist (Automated)"
        audit: |
          # Verify that no unowned or ungrouped files/directories exist on the system

          # Exclude transient or virtual paths
          exclude_paths=(-path "/run/user/*" -o -path "/proc/*" -o -path "*/containerd/*" \
                         -o -path "*/kubelet/pods/*" -o -path "*/kubelet/plugins/*" \
                         -o -path "/sys/fs/cgroup/memory/*" -o -path "/var/*/private/*")

          unowned=$(find / -xdev \( "${exclude_paths[@]}" \) -nouser -print 2>/dev/null | head -n 20)
          ungrouped=$(find / -xdev \( "${exclude_paths[@]}" \) -nogroup -print 2>/dev/null | head -n 20)

          if [ -z "$unowned$ungrouped" ]; then
            echo "no_unowned_or_ungrouped_files"
          else
            echo "unowned_or_ungrouped_files_found"
            [ -n "$unowned" ] && echo "Unowned files or directories:" && echo "$unowned"
            [ -n "$ungrouped" ] && echo "Ungrouped files or directories:" && echo "$ungrouped"
          fi
        tests:
          test_items:
            - flag: "no_unowned_or_ungrouped_files"
              set: true
        remediation: |
          Identify and correct unowned or ungrouped files and directories:

            # find / -xdev -nouser -exec ls -l {} \;
            # find / -xdev -nogroup -exec ls -l {} \;

          Assign proper ownership or remove files as appropriate, for example:

            # chown root:root <file_or_directory>
            # rm <file_or_directory>   # if obsolete or unnecessary

          Notes:
          - Unowned or ungrouped files can appear after deleting users or groups.
          - Always review files before deletion to avoid data loss.
          - On large systems, scanning may take time; restrict search scope if necessary.
        scored: true


  - id: 7.2
    description: "Local User and Group Settings"
    checks:
      - id: 7.2.1
        description: "Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
        audit: |
          awk -F: '($2 != "x" ) { print "User: \"" $1 "\" is not set to shadowed passwords "}' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set accounts to use shadowed passwords and migrate passwords in /etc/passwd to /etc/shadow:

          # pwconv
          Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off.
        scored: true
      - id: 7.2.2
        description: "Ensure /etc/shadow password fields are not empty (Automated)"
        audit: |
          awk -F: '($2 == "" ) { print $1 " does not have a password "}' /etc/shadow
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:

          # passwd -l <username>
            Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off.
        scored: true


      - id: 7.2.3
        description: "Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
        audit: |
          # Verify that every group ID (GID) in /etc/passwd has a corresponding entry in /etc/group

          passwd_gids=$(awk -F: '{print $4}' /etc/passwd | sort -u)
          group_gids=$(awk -F: '{print $3}' /etc/group | sort -u)

          # Compare the lists; find any GIDs from passwd not present in group
          missing_gids=""
          for gid in $passwd_gids; do
            if ! grep -qE "^([^:]*:){2}$gid(:|$)" /etc/group; then
              users=$(awk -F: -v gid="$gid" '($4 == gid) {print $1}' /etc/passwd | xargs)
              missing_gids="$missing_gids\nGID $gid (users: $users)"
            fi
          done

          if [ -z "$missing_gids" ]; then
            echo "all_groups_exist"
          else
            echo "missing_groups_detected"
            echo -e "$missing_gids"
          fi
        tests:
          test_items:
            - flag: "all_groups_exist"
              set: true
        remediation: |
          Review the users and GIDs reported by the audit and correct discrepancies.

          Options include:
            - Creating the missing group(s):
                # groupadd -g <gid> <group_name>
            - Updating affected users to valid groups:
                # usermod -g <valid_group> <username>

          After corrections, re-run the audit to confirm no missing groups remain.

          Notes:
          - Every users primary group (field 4 in /etc/passwd) must exist in /etc/group.
          - Missing groups can lead to improper permission assignments.
        scored: true

      - id: 7.2.4
        description: "Ensure no duplicate UIDs exist (Automated)"
        audit: |
          #!/usr/bin/env bash
          dups="$(awk -F: '
            {
              uid=$3; user=$1
              users[uid] = (uid in users ? users[uid]" "user : user)
              count[uid]++
            }
            END {
              for (u in count)
                if (count[u] > 1)
                  printf("Duplicate UID: \"%s\" Users: \"%s\"\n", u, users[u])
            }
          ' /etc/passwd)"

          if [ -z "$dups" ]; then
            echo "uid_duplicates_ok"
          else
            echo "uid_duplicates_bad"
            printf "%s\n" "$dups"
          fi
        tests:
          test_items:
            - flag: "uid_duplicates_ok"
              set: true
        remediation: |
          Assign unique UIDs and fix ownerships where duplicates are found.

          Steps (example workflow):
            # 1) Inspect duplicates (from audit output) and pick the correct UID per user/policy.

            # 2) Change a user's UID to a unique value:
            usermod -u <NEW_UNIQUE_UID> <username>

            # 3) Update file ownerships on local filesystems for that user:
            find / -xdev -uid <OLD_UID> -exec chown <username> {} +

            # 4) If the user's primary group also needs correction, adjust as appropriate:
            # usermod -g <groupname> <username>

          Re-run the audit to confirm no duplicate UIDs remain.
        scored: true


      - id: 7.2.5
        description: "Ensure no duplicate GIDs exist (Automated)"
        audit: |
          awk -F: '
            { cnt[$3]++; names[$3] = names[$3] ? names[$3] " " $1 : $1 }
            END {
              for (gid in cnt)
                if (cnt[gid] > 1)
                  printf "Duplicate GID: \"%s\" Groups: \"%s\"\n", gid, names[gid]
            }
          ' /etc/group
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to.
        scored: true

      - id: 7.2.6
        description: "Ensure no duplicate user names exist (Automated)"
        audit: |
          awk -F: '
            { c[$1]++; uids[$1] = uids[$1] ? uids[$1] " " $3 : $3 }
            END {
              for (user in c)
                if (c[user] > 1)
                  printf "Duplicate User: \"%s\" UIDs: \"%s\"\n", user, uids[user]
            }
          ' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs.
        scored: true

      - id: 7.2.7
        description: "Ensure no duplicate group names exist (Automated)"
        audit: |
          awk -F: '
            { c[$1]++; gids[$1] = gids[$1] ? gids[$1] " " $3 : $3 }
            END {
              for (g in c)
                if (c[g] > 1)
                  printf "Duplicate Group: \"%s\" GIDs: \"%s\"\n", g, gids[g]
            }
          ' /etc/group
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.
        scored: true

      - id: 7.2.8
        description: "Ensure local interactive user home directories are configured (Automated)"
        audit: |
          # Verify that all local interactive users have properly configured home directories

          # Define acceptable shells (exclude nologin/false)
          valid_shells=$(awk -F/ '$NF != "nologin" && $NF != "false" {print $NF}' /etc/shells | paste -sd '|' -)
          mask='0027'
          max_mode=$(printf '%o' $((0777 & ~$mask)))

          fail=false

          while IFS=: read -r user _ uid gid gecos home shell; do
            # Skip system users and service accounts (uid < 1000 or shells like nologin/false)
            if [[ $uid -ge 1000 && $shell =~ ($valid_shells) ]]; then
              if [ ! -d "$home" ]; then
                echo "user_home_missing:$user:$home"
                fail=true
                continue
              fi
              owner=$(stat -Lc '%U' "$home")
              mode=$(stat -Lc '%#a' "$home")
              if [ "$owner" != "$user" ]; then
                echo "user_home_wrong_owner:$user:$home:owner=$owner"
                fail=true
              fi
              if [ $(( mode & mask )) -gt 0 ]; then
                echo "user_home_perms_incorrect:$user:$home:mode=$mode"
                fail=true
              fi
            fi
          done < /etc/passwd

          if [ "$fail" = false ]; then
            echo "user_homes_configured"
          fi
        tests:
          test_items:
            - flag: "user_homes_configured"
              set: true
        remediation: |
          For each user reported by the audit:
            - If the home directory is missing, create it and set correct ownership and permissions:
                # mkdir -p <home_dir>
                # chown <user>:<user> <home_dir>
                # chmod 0750 <home_dir>

            - If the home directory exists but is misconfigured:
                # chown <user>:<user> <home_dir>
                # chmod g-w,o-rwx <home_dir>

          Notes:
          - Interactive users are those with valid login shells and UIDs  1000.
          - Recommended permissions: **0750** or more restrictive.
          - On ephemeral or container-based systems, consider automating this at provisioning time.
        scored: true


      - id: 7.2.9
        description: "Ensure local interactive user dot files access is configured (Automated)"
        audit: |
          # Check local interactive user dot files access configuration
          a_output2=()
          a_output3=()
          l_maxsize="1000" # Maximum number of local interactive users before warning (Default 1,000)
          l_valid_shells="^($( awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
          a_user_and_home=() # Create array with local users and their home directories

          while read -r l_local_user l_local_user_home; do # Populate array with users and user home location
            [[ -n "$l_local_user" && -n "$l_local_user_home" ]] && a_user_and_home+=("$l_local_user:$l_local_user_home")
          done <<< "$(awk -v pat="$l_valid_shells" -F: '$(NF) ~ pat { print $1 " " $(NF-1) }' /etc/passwd)"

          l_asize="${#a_user_and_home[@]}" # Here if we want to look at number of users before proceeding
          [ "${#a_user_and_home[@]}" -gt "$l_maxsize" ] && printf '%s\n' "" "  ** INFO **" \
          "  - \"$l_asize\" Local interactive users found on the system" \
          "  - This may be a long running check" ""

          file_access_chk()
          {
            a_access_out=()
            l_max="$( printf '%o' $(( 0777 & ~$l_mask)) )"
            if [ $(( $l_mode & $l_mask )) -gt 0 ]; then
              a_access_out+=("  - File: \"$l_hdfile\" is mode: \"$l_mode\" and should be mode: \"$l_max\" or more restrictive")
            fi
            if [[ ! "$l_owner" =~ ($l_user) ]]; then
              a_access_out+=("  - File: \"$l_hdfile\" owned by: \"$l_owner\" and should be owned by \"${l_user//|/ or }\"")
            fi
            if [[ ! "$l_gowner" =~ ($l_group) ]]; then
              a_access_out+=("  - File: \"$l_hdfile\" group owned by: \"$l_gowner\" and should be group owned by \"${l_group//|/ or }\"")
            fi
          }

          while IFS=: read -r l_user l_home; do
            a_dot_file=(); a_netrc=(); a_netrc_warn=(); a_bhout=(); a_hdirout=()
            if [ -d "$l_home" ]; then
              l_group="$(id -gn "$l_user" | xargs)";l_group="${l_group// /|}"
              while IFS= read -r -d $'\0' l_hdfile; do
                while read -r l_mode l_owner l_gowner; do
                  case "$(basename "$l_hdfile")" in
                    .forward | .rhost )
                      a_dot_file+=("  - File: \"$l_hdfile\" exists") ;;
                    .netrc )
                      l_mask='0177'; file_access_chk
                      if [ "${#a_access_out[@]}" -gt 0 ]; then
                        a_netrc+=("${a_access_out[@]}")
                      else
                        a_netrc_warn+=("   - File: \"$l_hdfile\" exists")
                      fi ;;
                    .bash_history )
                      l_mask='0177'; file_access_chk
                      [ "${#a_access_out[@]}" -gt 0 ] && a_bhout+=("${a_access_out[@]}") ;;
                    * )
                      l_mask='0133'; file_access_chk
                      [ "${#a_access_out[@]}" -gt 0 ] && a_hdirout+=("${a_access_out[@]}") ;;
                  esac
                done < <(stat -Lc '%#a %U %G' "$l_hdfile")
              done < <(find "$l_home" -xdev -type f -name '.*' -print0)
            fi
            if [[ "${#a_dot_file[@]}" -gt 0 || "${#a_netrc[@]}" -gt 0 || "${#a_bhout[@]}" -gt 0 || "${#a_hdirout[@]}" -gt 0 ]]; then
              a_output2+=(" - User: \"$l_user\" Home Directory: \"$l_home\"" "${a_dot_file[@]}" "${a_netrc[@]}" "${a_bhout[@]}" "${a_hdirout[@]}")
            fi
            [ "${#a_netrc_warn[@]}" -gt 0 ] && a_output3+=(" - User: \"$l_user\" Home Directory: \"$l_home\"" "${a_netrc_warn[@]}")
          done <<< "$(printf '%s\n' "${a_user_and_home[@]}")"

          if [ "${#a_output2[@]}" -le 0 ]; then # If l_output2 is empty, we pass
            echo "dot_files_properly_configured"
          else
            echo "dot_files_not_properly_configured"
          fi
        tests:
          test_items:
            - flag: "dot_files_properly_configured"
              set: true
        remediation: |
          # Investigate and delete any .forward or .rhost files
          # If .netrc is required by policy, ensure it is 600, else remove it
          # Set strict perms for dotfiles:
          #   chmod 600 ~/.bash_history ~/.netrc
          #   chmod 644 ~/.* (other dotfiles)
          # Ensure ownership is correct:
          #   chown <user>:<primary_group> ~/.*
        scored: true
