---
controls:
version: 1.0.0
id: 1
description: "Initial Setup"
type: "master"
groups:
  - id: 1.1
    description: "Filesystem Configuration"
    checks:
      - id: 1.1.1
        description: "Configure Filesystem Kernel Modules"
        type: "skip"
        checks:
      - id: 1.1.1.1
        description: "Ensure mounting of squashfs filesystems is disabled (Automated)"
        audit: |
          modprobe -n -v squashfs 2>/dev/null | grep -qE 'install /bin/(true|false)' && \
          modprobe --showconfig 2>/dev/null | grep -Pq '^\h*blacklist\h+squashfs\b' && \
          ! lsmod | grep -q squashfs && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/squashfs.conf` and add the following lines:
          install squashfs /bin/false
          blacklist squashfs
          Run the following command to unload the `squashfs` module:
          # modprobe -r squashfs
        scored: true
      - id: 1.1.1.2
        description: "Ensure mounting of udf filesystems is disabled (Automated)"
        audit: |
          if modprobe -n -v udf | grep -q 'install /bin/false'; then
            echo "install_ok"
          else
            echo "install_bad"
          fi

          if modprobe --showconfig 2>/dev/null | grep -Pq '^\s*blacklist\s+udf\b'; then
            echo "blacklist_ok"
          else
            echo "blacklist_bad"
          fi

          if ! lsmod | grep -q "^udf"; then
            echo "not_loaded"
          else
            echo "loaded"
          fi
        tests:
          test_items:
            - flag: "install_ok"
              set: true
            - flag: "blacklist_ok"
              set: true
            - flag: "not_loaded"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/udf.conf` and add the following lines:
          install udf /bin/false
          blacklist udf
          Run the following command to unload the `udf` module:
          # modprobe -r udf
        scored: true

      - id: 1.1.1.3
        description: "Ensure mounting of cramfs filesystems is disabled (Automated)"
        audit: |
          out="$(modprobe -n -v cramfs 2>/dev/null)"; 
          deny="$(modprobe --showconfig 2>/dev/null | grep -P '^\s*blacklist\s+cramfs\b')"; 
          loaded="$(lsmod | grep -w cramfs || true)";

          [[ "$out" =~ "install /bin/false" || "$out" =~ "install /bin/true" ]] && 
          [[ -n "$deny" ]] && 
          [[ -z "$loaded" ]] && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/cramfs.conf` and add the following lines:
          install cramfs /bin/false
          blacklist cramfs
          Run the following command to unload the `cramfs` module:
          # modprobe -r cramfs
        scored: true

      - id: 1.1.1.4
        description: "Ensure mounting of freevxfs filesystems is disabled (Automated)"
        audit: |
          out="$(modprobe -n -v freevxfs 2>/dev/null)"; 
          deny="$(modprobe --showconfig 2>/dev/null | grep -P '^\s*blacklist\s+freevxfs\b')"; 
          loaded="$(lsmod | grep -w freevxfs || true)";

          [[ "$out" =~ "install /bin/false" || "$out" =~ "install /bin/true" ]] && 
          [[ -n "$deny" ]] && 
          [[ -z "$loaded" ]] && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/freevxfs.conf` and add the following lines:
          install freevxfs /bin/false
          blacklist freevxfs
          Run the following command to unload the `freevxfs` module:
          # modprobe -r freevxfs
        scored: true

      - id: 1.1.1.5
        description: "Ensure mounting of jffs2 filesystems is disabled (Automated)"
        audit: |
          out="$(modprobe -n -v jffs2 2>/dev/null)"; 
          deny="$(modprobe --showconfig 2>/dev/null | grep -P '^\s*blacklist\s+jffs2\b')"; 
          loaded="$(lsmod | grep -w jffs2 || true)";

          [[ "$out" =~ "install /bin/false" || "$out" =~ "install /bin/true" ]] && 
          [[ -n "$deny" ]] && 
          [[ -z "$loaded" ]] && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/jffs2.conf` and add the following lines:
          install jffs2 /bin/false
          blacklist jffs2
          Run the following command to unload the `jffs2` module:
          # modprobe -r jffs2
        scored: true

      - id: 1.1.1.6
        description: "Ensure mounting of hfs filesystems is disabled (Automated)"
        audit: |
          out="$(modprobe -n -v hfs 2>/dev/null)"
          deny="$(modprobe --showconfig 2>/dev/null | grep -P '^\s*blacklist\s+hfs\b')"
          loaded="$(lsmod | grep -w hfs || true)"

          [[ "$out" =~ "install /bin/false" || "$out" =~ "install /bin/true" ]] && 
          [[ -n "$deny" ]] && 
          [[ -z "$loaded" ]] && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/hfs.conf` and add the following lines:
          install hfs /bin/false
          blacklist hfs
          Run the following command to unload the `hfs` module:
          # modprobe -r hfs
        scored: true

      - id: 1.1.1.7
        description: "Ensure mounting of hfsplus filesystems is disabled (Automated)"
        audit: |
          out="$(modprobe -n -v hfsplus 2>/dev/null)"
          deny="$(modprobe --showconfig 2>/dev/null | grep -P '^\s*blacklist\s+hfsplus\b')"
          loaded="$(lsmod | grep -w hfsplus || true)"

          [[ "$out" =~ "install /bin/false" || "$out" =~ "install /bin/true" ]] && 
          [[ -n "$deny" ]] && 
          [[ -z "$loaded" ]] && echo "pass" || echo "fail"
        tests:
          test_items:
            - flag: "pass"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/hfsplus.conf` and add the following lines:
          install hfsplus /bin/false
          blacklist hfsplus
          Run the following command to unload the `hfsplus` module:
          # modprobe -r hfsplus
        scored: true


      - id: 1.1.2
        description: "Configure /tmp"
        type: "skip"
        checks:
      - id: 1.1.2.1
        description: "Ensure /tmp is a separate partition (Automated)"
        audit: |
          if findmnt -nk /tmp > /dev/null; then
            echo "tmp_mounted"
          else
            echo "tmp_not_mounted"
          fi

          if systemctl is-enabled tmp.mount | grep -Eq 'enabled|static|generated'; then
            echo "tmp_mount_enabled"
          else
            echo "tmp_mount_not_enabled"
          fi
        tests:
          bin_op: and
          test_items:
            - flag: "tmp_mounted"
              set: true
            - flag: "tmp_mount_enabled"
              set: true
        remediation: |
          Ensure that /tmp is mounted at boot time by doing the following:

          1. Unmask the tmp.mount unit (if applicable):
             # systemctl unmask tmp.mount

          2. Edit `/etc/fstab` to include one of the following entries:

             Option A: Using tmpfs (RAM-based):
             tmpfs	/tmp	tmpfs	defaults,rw,nosuid,nodev,noexec,relatime,size=2G	0 0

             Option B: Using a dedicated disk or volume:
             <device> /tmp <fstype> defaults,nodev,nosuid,noexec 0 0

          3. Then enable and start the mount unit if needed:
             # systemctl enable tmp.mount
             # systemctl start tmp.mount
        scored: true
      - id: 1.1.2.2
        description: "Ensure nodev option set on /tmp partition (Automated)"
        audit: "findmnt -kn /tmp | grep nodev"
        tests:
          test_items:
            - flag: "nodev"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/tmp` partition.
          Example entry in `/etc/fstab`:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/tmp` partition with the configured options:
          # mount -o remount /tmp

        scored: true

      - id: 1.1.2.3
        description: "Ensure noexec option set on /tmp partition (Automated)"
        audit: "findmnt -kn /tmp | grep noexec"
        tests:
          test_items:
            - flag: "noexec"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/tmp` partition with the configured options:
          # mount -o remount /tmp

        scored: true
      - id: 1.1.2.4
        description: "Ensure nosuid option set on /tmp partition (Automated)"
        audit: "findmnt -kn /tmp | grep nosuid"
        tests:
          test_items:
            - flag: "nosuid"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/tmp` partition with the configured options:
          # mount -o remount /tmp
        scored: true


      - id: 1.1.3
        description: "Configure /var"
        type: "skip"
        checks:
      - id: 1.1.3.1
        description: "Ensure separate partition exists for /var (Automated)"
        audit: "findmnt --kernel /var"
        tests:
          test_items:
            - flag: "/var"
              set: true
        remediation: |
          For new installations, create a custom partition layout during setup and assign a separate partition for /var.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Copy existing data from /var to the new partition.
          3. Update `/etc/fstab` to mount the new partition at /var.
          4. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.3.2
        description: "Ensure nodev option set on /var partition (Automated)"
        audit: "findmnt --kernel /var | grep nodev"
        tests:
          test_items:
            - flag: "nodev"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var` partition.

          Example entry in `/etc/fstab`:
          <device> /var <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var` partition with the configured options:
          # mount -o remount /var
        scored: true

      - id: 1.1.3.3
        description: "Ensure nosuid option set on /var partition (Automated)"
        audit: "findmnt --kernel /var | grep nosuid"
        tests:
          test_items:
            - flag: "nosuid"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var` partition.

          Example entry in `/etc/fstab`:
          <device> /var <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var` partition with the configured options:
          # mount -o remount /var
        scored: true


      - id: 1.1.4
        description: "Configure /var/tmp"
        type: "skip"
        checks:
      - id: 1.1.4.1
        description: "Ensure separate partition exists for /var/tmp (Automated)"
        audit: "findmnt --kernel /var/tmp"
        tests:
          test_items:
            - flag: "/var/tmp"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/var/tmp`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/var/tmp` content to a temporary location.
          3. Mount the new partition at `/var/tmp`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.4.2
        description: "Ensure noexec option set on /var/tmp partition (Automated)"
        audit: "findmnt --kernel /var/tmp | grep noexec"
        tests:
          test_items:
            - flag: "noexec"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/var/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/tmp` partition with the configured options:
          # mount -o remount /var/tmp
        scored: true
      - id: 1.1.4.3
        description: "Ensure nosuid option set on /var/tmp partition (Automated)"
        audit: "findmnt --kernel /var/tmp | grep nosuid"
        tests:
          test_items:
            - flag: "nosuid"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/tmp` partition with the configured options:
          # mount -o remount /var/tmp
        scored: true
      - id: 1.1.4.4
        description: "Ensure nodev option set on /var/tmp partition (Automated)"
        audit: "findmnt --kernel /var/tmp | grep nodev"
        tests:
          test_items:
            - flag: "nodev"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var/tmp` partition.

          Example entry in `/etc/fstab`:
          <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/tmp` partition with the configured options:
          # mount -o remount /var/tmp
        scored: true


      - id: 1.1.5
        description: "Configure /var/log"
        type: "skip"
        checks:
      - id: 1.1.5.1
        description: "Ensure separate partition exists for /var/log (Automated)"
        audit: "findmnt --kernel /var/log"
        tests:
          test_items:
            - flag: "/var/log"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/var/log`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/var/log` content to a temporary location.
          3. Mount the new partition at `/var/log`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true
      - id: 1.1.5.2
        description: "Ensure nodev option set on /var/log partition (Automated)"
        audit: "findmnt --kernel /var/log | grep nodev"
        tests:
          test_items:
            - flag: "nodev"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var/log` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log` partition with the configured options:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.5.3
        description: "Ensure noexec option set on /var/log partition (Automated)"
        audit: "findmnt --kernel /var/log | grep noexec"
        tests:
          test_items:
            - flag: "noexec"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/var/log` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log` partition with the configured options:
          # mount -o remount /var/log
        scored: true

      - id: 1.1.5.4
        description: "Ensure nosuid option set on /var/log partition (Automated)"
        audit: "findmnt --kernel /var/log | grep nosuid"
        tests:
          test_items:
            - flag: "nosuid"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var/log` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log` partition with the configured options:
          # mount -o remount /var/log
        scored: true


      - id: 1.1.6
        description: "Configure /var/log/audit"
        type: "skip"
        checks:
      - id: 1.1.6.1
        description: "Ensure separate partition exists for /var/log/audit (Automated)"
        audit: "findmnt --kernel /var/log/audit"
        tests:
          test_items:
            - flag: "/var/log/audit"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/var/log/audit`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/var/log/audit` content to a temporary location.
          3. Mount the new partition at `/var/log/audit`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.6.2
        description: "Ensure noexec option set on /var/log/audit partition (Automated)"
        audit: "findmnt --kernel /var/log/audit | grep noexec"
        tests:
          test_items:
            - flag: "noexec"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `noexec` option is included in the fourth field for the `/var/log/audit` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log/audit` partition with the configured options:
          # mount -o remount /var/log/audit
        scored: true

      - id: 1.1.6.3
        description: "Ensure nodev option set on /var/log/audit partition (Automated)"
        audit: "findmnt --kernel /var/log/audit | grep nodev"
        tests:
          test_items:
            - flag: "nodev"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/var/log/audit` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log/audit` partition with the configured options:
          # mount -o remount /var/log/audit
        scored: true

      - id: 1.1.6.4
        description: "Ensure nosuid option set on /var/log/audit partition (Automated)"
        audit: "findmnt --kernel /var/log/audit | grep nosuid"
        tests:
          test_items:
            - flag: "nosuid"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/var/log/audit` partition.

          Example entry in `/etc/fstab`:
          <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/var/log/audit` partition with the configured options:
          # mount -o remount /var/log/audit
        scored: true


      - id: 1.1.7
        description: "Configure /home"
        type: "skip"
        checks:
      - id: 1.1.7.1
        description: "Ensure separate partition exists for /home (Automated)"
        audit: "findmnt --kernel /home"
        tests:
          test_items:
            - flag: "/home"
              set: true
        remediation: |
          For new installations:
          - During OS installation, create a custom partition layout and assign a separate partition for `/home`.

          For existing systems:
          1. Create a new partition or logical volume.
          2. Move existing `/home` content to a temporary location.
          3. Mount the new partition at `/home`.
          4. Update `/etc/fstab` to mount the partition at boot.
          5. Reboot or remount to apply changes.
        scored: true

      - id: 1.1.7.2
        description: "Ensure nodev option set on /home partition (Automated)"
        audit: "findmnt --kernel /home | grep nodev"
        tests:
          test_items:
            - flag: "nodev"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nodev` option is included in the fourth field for the `/home` partition.

          Example entry in `/etc/fstab`:
          <device> /home <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/home` partition with the configured options:
          # mount -o remount /home
        scored: true

      - id: 1.1.7.3
        description: "Ensure nosuid option set on /home partition (Automated)"
        audit: "findmnt --kernel /home | grep nosuid"
        tests:
          test_items:
            - flag: "nosuid"
              set: true
        remediation: |
          Edit the `/etc/fstab` file and ensure that the `nosuid` option is included in the fourth field for the `/home` partition.

          Example entry in `/etc/fstab`:
          <device> /home <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

          Then remount the `/home` partition with the configured options:
          # mount -o remount /home
        scored: true


      - id: 1.1.8
        description: "Configure /dev/shm"
        type: "skip"
        checks:
      - id: 1.1.8.1
        description: "Ensure /dev/shm is a separate partition (Automated)"
        audit: "findmnt --kernel /dev/shm"
        tests:
          test_items:
            - flag: "/dev/shm"
              set: true
        remediation: |
          Modify `/etc/fstab` to mount `/dev/shm` as a separate `tmpfs` filesystem with appropriate options.

          Example entry in `/etc/fstab`:
          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0

          Then mount or remount the `/dev/shm` partition:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.8.2
        description: "Ensure nodev option set on /dev/shm partition (Automated)"
        audit: "mount | grep -E '\\s/dev/shm\\s' | grep -v nodev"
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit `/etc/fstab` to include the `nodev` option for `/dev/shm`. Example entry:

          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime,size=2G  0 0

          Then remount the filesystem with the updated options:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.8.3
        description: "Ensure noexec option set on /dev/shm partition (Automated)"
        audit: "findmnt --kernel /dev/shm | grep noexec"
        tests:
          test_items:
            - flag: "noexec"
              set: true
        remediation: |
          Edit `/etc/fstab` to include the `noexec` option for `/dev/shm`. Example entry:

          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime  0 0

          Then remount the filesystem with:
          # mount -o remount /dev/shm
        scored: true

      - id: 1.1.8.4
        description: "Ensure nosuid option set on /dev/shm partition (Automated)"
        audit: "mount | grep -E '\\s/dev/shm\\s' | grep -v nosuid"
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit `/etc/fstab` to include the `nosuid` option for `/dev/shm`. Example entry:
          tmpfs  /dev/shm  tmpfs  defaults,rw,nosuid,nodev,noexec,relatime  0 0
          Then remount the filesystem with:
          # mount -o remount /dev/shm
        scored: true


      - id: 1.1.9
        description: "Ensure usb-storage is disabled (Automated)"
        audit: "modprobe -n -v usb-storage"
        tests:
          test_items:
            - flag: "install /bin/false"
              set: true
        remediation: |
          Edit or create the file `/etc/modprobe.d/usb-storage.conf` and add the following lines:
          install usb-storage /bin/false
          blacklist usb-storage
          Then run the following command to unload the module if it is currently loaded:
          # modprobe -r usb-storage
        scored: true


  - id: 1.2
    description: "Configure Software and Patch Management"
    checks:
      - id: 1.2.1
        description: "Ensure GPG keys are configured (Manual)"
        type: manual
        remediation: |
          Update your package manager GPG keys in accordance with site policy.
        scored: false

      - id: 1.2.2
        description: "Ensure gpgcheck is globally activated (Automated)"
        audit: |
          main_check=$(grep -Pi '^\s*gpgcheck\s*=\s*(1|true)\b' /etc/dnf/dnf.conf)
          repo_override=$(grep -Prs -- '^\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|[a-zA-Z_]+)' /etc/yum.repos.d/)
          if [ -n "$main_check" ]; then
            echo "gpgcheck_main_enabled"
          else
            echo "gpgcheck_main_disabled"
          fi

          if [ -z "$repo_override" ]; then
            echo "no_repo_override"
          else
            echo "repo_override_present"
          fi
        tests:
          bin_op: and
          test_items:
            - flag: "gpgcheck_main_enabled"
              set: true
            - flag: "repo_override_present"
              set: false
        remediation: |
          1. Edit `/etc/dnf/dnf.conf` and ensure the `[main]` section includes:
             gpgcheck=1

          2. Check all `.repo` files to ensure no overrides disable GPG check:
             Run:
             # grep -Prs -- '^\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|[a-zA-Z_]+)\b' /etc/yum.repos.d/

             If any file returns a result, edit the file and change the `gpgcheck` value to:
             gpgcheck=1

             Or apply in bulk:
             # find /etc/yum.repos.d/ -name "*.repo" -exec sed -i 's/^\s*gpgcheck\s*=.*/gpgcheck=1/' {} \;

          This ensures that all RPM packages are verified before installation.
        scored: false


      - id: 1.2.3
        description: "Ensure package manager repositories are configured (Automated)"
        audit: "dnf repolist"
        tests:
          test_items:
            - flag: "repo id"
              set: true
        remediation: |
          Configure your package manager repositories according to your organization's site policy.

          1. Verify current repositories:
             # dnf repolist

          2. Inspect individual repo files:
             # cat /etc/yum.repos.d/*.repo

          Ensure only approved repositories are present and correctly configured.

          For Amazon Linux, you may need to validate:
          - Base repository (e.g., amazonlinux)
          - Security and update repositories
          - Optional livepatch or EPEL repos, as per policy
        scored: false


      - id: 1.2.4
        description: "Ensure repo_gpgcheck is globally activated (Manual)"
        type: manual
        remediation: |
          Edit /etc/dnf/dnf.conf and set repo_gpgcheck=1 in the [main] section.
          Example:
          [main]
            # repo_gpgcheck=1
            Per repository configuration
            First check that the particular repository support GPG checking on the repodata.
            Edit any failing files in /etc/yum.repos.d/* and set all instances starting with repo_gpgcheck to 1.
        scored: false

  - id: 1.3
    description: "Filesystem Integrity Checking"
    checks:
      - id: 1.3.1
        description: "Ensure AIDE is installed (Automated)"
        audit: "rpm -q aide"
        tests:
          test_items:
            - flag: "package aide is not installed"
              set: false
        remediation: |
          Install AIDE using the appropriate package manager or manual installation:
          # dnf install aide
          # apt-get install aide
          # zypper install aide
          Configure AIDE as appropriate for your environment. Consult the AIDE documentation for options.
                      Initialize AIDE:
          # aide --init
          # mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
        scored: true

      - id: 1.3.2
        description: "Ensure filesystem integrity is regularly checked (Automated)"
        audit: |
          grep -Prs '^(?:[^#]+\s+)?(/usr/s?bin/|^\s*)aide(\.wrapper)?\s(?:--?\S+\s)*(?:(?:--check|--update)|\$AIDEARGS)\b' \/etc/cron.* /etc/crontab /var/spool/cron/ || \
          (systemctl is-enabled aidecheck.service && systemctl is-enabled aidecheck.timer && systemctl is-active aidecheck.timer)
        tests:
          test_items:
            - flag: "/usr/sbin/aide --check"
              set: true
        remediation: |
          You can configure AIDE (Advanced Intrusion Detection Environment) to run regularly via cron or systemd timer.
          **Option 1: Using Cron**
          1. Open root crontab:
             # crontab -u root -e
          2. Add this line to run AIDE check daily at 5 AM:
             0 5 * * * /usr/sbin/aide --check
          -- OR --
          **Option 2: Using systemd Timer**
          1. Create the aidecheck service unit file:
             /etc/systemd/system/aidecheck.service
             [Unit]
             Description=Aide Check
             [Service]
             Type=simple
             ExecStart=/usr/sbin/aide --check
          2. Create the aidecheck timer unit file:
             /etc/systemd/system/aidecheck.timer
             [Unit]
             Description=Aide check every day at 5AM
             [Timer]
             OnCalendar=*-*-* 05:00:00
             Unit=aidecheck.service
             [Install]
             WantedBy=multi-user.target
          3. Set proper ownership and permissions:
             # chown root:root /etc/systemd/system/aidecheck.*
             # chmod 0644 /etc/systemd/system/aidecheck.*
          4. Reload systemd and enable the timer:
             # systemctl daemon-reload
             # systemctl enable aidecheck.service
             # systemctl --now enable aidecheck.timer
        scored: true

      - id: 1.3.3
        description: "Ensure cryptographic mechanisms are used to protect the integrity of audit tools (Automated)"
        audit: |
          grep -Ps -- '(\/sbin\/(audit|au)\H*\b)' /etc/aide.conf.d/*.conf /etc/aide.conf
        tests:
          test_items:
            - flag: "/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512"
              set: true
            - flag: "/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512"
              set: true
            - flag: "/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512"
              set: true
            - flag: "/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512"
              set: true
            - flag: "/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512"
              set: true
            - flag: "/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512"
              set: true
        remediation: |
          Ensure the following entries are added to either `/etc/aide.conf` or a file under `/etc/aide.conf.d/`:

          ```
          /sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512
          /sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512
          /sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512
          /sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512
          /sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512
          /sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512
          ```

          After adding the entries, update the AIDE database:
          # aide --update
          # cp /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz

        scored: true

  - id: 1.4
    description: "Secure Boot Settings"
    checks:
      - id: 1.4.1
        description: "Ensure permissions on bootloader config are configured (Automated)"
        audit: |
          find /boot -type f \( -name 'grub*' -o -name 'user.cfg' \) -exec stat -Lc '%n %a %U %G' {} \;
        tests:
          test_items:
            - flag: "/boot/grub2/grub.cfg"
              compare:
                op: bitmask
                value: "600"
            - flag: "/boot/grub2/grubenv"
              compare:
                op: bitmask
                value: "600"
            - flag: "/boot/efi/EFI/amzn/grub.cfg"
              compare:
                op: bitmask
                value: "700"
            - flag: "root"
              set: true
        remediation: |
          -- For systems using BIOS (/boot/grub2/*):
          Run the following commands to set ownership and restrict permissions:

          [ -f /boot/grub2/grub.cfg ] && chown root:root /boot/grub2/grub.cfg && chmod 600 /boot/grub2/grub.cfg
          [ -f /boot/grub2/grubenv ] && chown root:root /boot/grub2/grubenv && chmod 600 /boot/grub2/grubenv
          [ -f /boot/grub2/user.cfg ] && chown root:root /boot/grub2/user.cfg && chmod 600 /boot/grub2/user.cfg

          -- For systems using UEFI (/boot/efi/EFI/*):
          Edit `/etc/fstab` and ensure the following options are set for the EFI partition:

          Example:
          <device> /boot/efi vfat defaults,umask=0027,fmask=0077,uid=0,gid=0 0 0

          Note: Reboot may be required for these changes to take effect.
        scored: true


  - id: 1.5
    description: "Additional Process Hardening"
    checks:
      - id: 1.5.1
        description: "Ensure address space layout randomization (ASLR) is enabled (Automated)"
        audit: |
          current=$(sysctl -n kernel.randomize_va_space)
          if [ "$current" -eq 2 ]; then
            echo "runtime_ok"
          else
            echo "runtime_fail"
          fi

          grep -E '^\s*kernel\.randomize_va_space\s*=\s*2\b' /etc/sysctl.conf /etc/sysctl.d/* || echo "persistent_missing"
        tests:
          bin_op: and
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "persistent_missing"
              set: false
        remediation: |
          To enable full address space layout randomization (ASLR):

          1. Apply the runtime setting:
             # sysctl -w kernel.randomize_va_space=2

          2. Make it persistent:
             # echo "kernel.randomize_va_space = 2" > /etc/sysctl.d/60-kernel_sysctl.conf

          3. Reload settings:
             # sysctl --system
        scored: true


      - id: 1.5.2
        description: "Ensure ptrace_scope is restricted (Automated)"
        audit: |
          current=$(sysctl -n kernel.yama.ptrace_scope 2>/dev/null)
          if [ "$current" -eq 1 ]; then
            echo "runtime_ok"
          else
            echo "runtime_fail"
          fi

          grep -E '^\s*kernel\.yama\.ptrace_scope\s*=\s*1\b' /etc/sysctl.conf /etc/sysctl.d/* || echo "persistent_missing"
        tests:
          bin_op: and
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "persistent_missing"
              set: false
        remediation: |
          To restrict the use of ptrace to only child processes (for improved security):

          1. Set the runtime parameter:
             # sysctl -w kernel.yama.ptrace_scope=1

          2. Make the setting persistent:
             # echo "kernel.yama.ptrace_scope = 1" > /etc/sysctl.d/60-kernel_sysctl.conf

          3. Apply changes:
             # sysctl --system
        scored: true


      - id: 1.5.3
        description: "Ensure core dump storage is disabled (Automated)"
        audit: |
          grep -i '^\s*storage\s*=\s*none' /etc/systemd/coredump.conf
        tests:
          test_items:
            - flag: "Storage=none"
              set: true
        remediation: |
          Edit /etc/systemd/coredump.conf and edit or add the following line:
          Storage=none
        scored: true

      - id: 1.5.4
        description: "Ensure core dump backtraces are disabled (Automated)"
        audit: |
          grep -Pi '^\h*ProcessSizeMax\h*=\h*0\b' /etc/systemd/coredump.conf || echo -e "\n- Audit results:\n  ** FAIL **\n - \"ProcessSizeMax\" is: \"$(grep -i 'ProcessSizeMax' /etc/systemd/coredump.conf)\""
        tests:
          test_items:
            - flag: "ProcessSizeMax=0"
              set: true
        remediation: |
          # Edit or add the following line to disable core dumps
          sed -i '/^\s*ProcessSizeMax\s*=/d' /etc/systemd/coredump.conf
          echo "ProcessSizeMax=0" >> /etc/systemd/coredump.conf

          # Reload systemd settings (if needed)
          systemctl daemon-reexec
        scored: true


  - id: 1.6
    description: "Mandatory Access Control"
    checks:
      - id: 1.6.1
        description: "Configure SELinux"
        type: "skip"
        checks:
      - id: 1.6.1.1
        description: "Ensure SELinux is installed (Automated)"
        audit: 'rpm -q libselinux'
        tests:
          test_items:
            - flag: "package libselinux is not installed"
              set: false
        remediation: |
          Install SELinux using the appropriate package manager or manual installation:
          # dnf install libselinux
          # apt-get install libselinux1
          # zypper install libselinux1
        scored: true

      - id: 1.6.1.2
        description: "Ensure SELinux is not disabled in bootloader configuration (Automated)"
        audit: |
          grubby --info=ALL | grep -Po '(selinux|enforcing)=0\b'
        tests:
          test_items:
            - flag: "selinux=0"
              set: false
            - flag: "enforcing=0"
              set: false
        remediation: |
          # Remove any SELinux-disabling boot parameters
          grubby --update-kernel=ALL --remove-args="selinux=0 enforcing=0"

          # If legacy grub2-mkconfig was used, ensure kernelopts doesn't include disabling args
          if grep -Prsq -- '\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi; then
            grub2-mkconfig -o "$(grep -Prl -- '\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi)"
          fi
        scored: true

      - id: 1.6.1.3
        description: "Ensure SELinux policy is configure (Automated)"
        audit: |
          grep -E '^\s*SELINUXTYPE=(targeted|mls)\b' /etc/selinux/config || echo "missing_config_policy"
          sestatus | grep -E 'Loaded policy name:\s+targeted' || echo "runtime_not_targeted"
        tests:
          bin_op: and
          test_items:
            - flag: "SELINUXTYPE=targeted"
              set: true
            - flag: "runtime_not_targeted"
              set: false
        remediation: |
          1. Set the SELinux policy type in `/etc/selinux/config`:
             ```bash
             sed -i 's/^SELINUXTYPE=.*/SELINUXTYPE=targeted/' /etc/selinux/config
             ```

          2. Reboot the system or reload SELinux policy if needed.

          3. To verify:
             ```bash
             grep SELINUXTYPE /etc/selinux/config
             sestatus | grep "Loaded policy name"
             ```

          This ensures both the configured and active SELinux policy is set to "targeted".
        scored: true


      - id: 1.6.1.4
        description: "Ensure the SELinux mode is not disabled (Automated)"
        audit: |
          runtime_mode=$(getenforce)
          if [ "$runtime_mode" = "Enforcing" ] || [ "$runtime_mode" = "Permissive" ]; then
            echo "runtime_ok"
          else
            echo "runtime_fail"
          fi

          grep -Ei '^\s*SELINUX=(enforcing|permissive)' /etc/selinux/config || echo "persistent_missing"
        tests:
          bin_op: and
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "persistent_missing"
              set: false
        remediation: |
          Set SELINUX to enforcing or permissive in the config file
          # sed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config
          OR use this for permissive
          # sed -i 's/^SELINUX=.*/SELINUX=permissive/' /etc/selinux/config

          Set current SELinux mode to enforcing or permissive
          # setenforce 1
          OR use this for permissive
          # setenforce 0
        scored: true


      - id: 1.6.1.5
        description: "Ensure the SELinux mode is enforcing (Automated)"
        audit: |
          runtime_mode=$(getenforce)
          if [ "$runtime_mode" = "Enforcing" ]; then
            echo "runtime_ok"
          else
            echo "runtime_fail"
          fi

          grep -i '^SELINUX=enforcing' /etc/selinux/config || echo "persistent_missing"
        tests:
          bin_op: and
          test_items:
            - flag: "runtime_ok"
              set: true
            - flag: "SELINUX=enforcing"
              set: true
        remediation: |
          Set SELinux to enforcing in the config file
          # sed -i 's/^SELINUX=.*/SELINUX=enforcing/' /etc/selinux/config
          Set SELinux to enforcing mode immediately
          # setenforce 1
        scored: true


      - id: 1.6.1.6
        description: "Ensure no unconfined services exist (Manual)"
        type: manual
        audit: |
          ps -eZ | grep unconfined_service_t
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Investigate any unconfined processes found during the audit action. They may need to have an existing security context assigned to them or a policy built for them.
        scored: false

      - id: 1.6.1.7
        description: "Ensure SETroubleshoot is not installed (Automated)"
        audit: |
          rpm -q setroubleshoot
        tests:
          test_items:
            - flag: "package setroubleshoot is not installed"
              set: true
        remediation: |
          Run the following command to uninstall setroubleshoot:
          # dnf remove setroubleshoot
        scored: true

      - id: 1.6.1.8
        description: "Ensure the MCS Translation Service (mcstrans) is not installed (Automated)"
        audit: |
          rpm -q mcstrans
        tests:
          test_items:
            - flag: "package mcstrans is not installed"
              set: true
        remediation: |
          Run the following command to uninstall mcstrans:

          # dnf remove mcstrans
        scored: true
  - id: 1.7
    description: "Command Line Warning Banners"
    checks:
      - id: 1.7.1
        description: "Ensure message of the day is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/motd && echo "disallowed_found" || echo "no_disallowed_found"
        tests:
          test_items:
            - flag: "no_disallowed_found"
              set: true
        remediation: |
          Edit the /etc/motd file according to your organization's site policy.
          Ensure there are no escape sequences such as \m, \r, \s, or \v.
          You can manually remove them using:
            # sed -i -E 's/\\[mrsv]//g' /etc/motd
        scored: true


      - id: 1.7.2
        description: "Ensure local login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/\"//g'))" /etc/issue
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/issue to include a proper warning banner based on your site's policy.
          Example:

          # echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue
        scored: true

      - id: 1.7.3
        description: "Ensure remote login warning banner is configured properly (Automated)"
        audit: |
          grep -E -i "(\\\v|\\\r|\\\m|\\\s|$(grep '^ID=' /etc/os-release | cut -d= -f2 | sed -e 's/"//g'))" /etc/issue.net
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit the /etc/issue.net file with the appropriate contents according to your site policy, remove any instances of \m , \r , \s , \v or references to the OS platform

          # echo "Authorized uses only. All activity may be monitored and reported." > /etc/issue.ne
        scored: true

      - id: 1.7.4
        description: "Ensure permissions on /etc/motd are configured (Automated)"
        audit: |
          if stat -L /etc/motd | grep -qE 'Access:\s+\(0644/-rw-r--r--\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "motd_permissions_ok"
          else
            echo "motd_permissions_bad"
          fi
        tests:
          test_items:
            - flag: "motd_permissions_ok"
              set: true
        remediation: |
          Run the following commands to set correct ownership and permissions:

          # chown root:root /etc/motd
          # chmod 644 /etc/motd
        scored: true

      - id: 1.7.5
        description: "Ensure permissions on /etc/issue are configured (Automated)"
        audit: |
          if stat -L /etc/issue | grep -qE 'Access:\s+\(0644/-rw-r--r--\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "issue_permissions_ok"
          else
            echo "issue_permissions_bad"
          fi
        tests:
          test_items:
            - flag: "issue_permissions_ok"
              set: true
        remediation: |
          Run the following commands to set correct ownership and permissions:

          # chown root:root /etc/issue
          # chmod u-x,go-wx /etc/issue
        scored: true

      - id: 1.7.5
        description: "Ensure permissions on /etc/issue.net are configured (Automated)"
        audit: |
          if stat -L /etc/issue.net | grep -qE 'Access:\s+\(0644/-rw-r--r--\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "permissions_ok"
          else
            echo "permissions_bad"
          fi
        tests:
          test_items:
            - flag: "permissions_ok"
              set: true
        remediation: |
          Run the following commands to set correct ownership and permissions:

          # chown root:root /etc/issue.net
          # chmod u-x,go-wx /etc/issue.net
        scored: true

      - id: 1.8
        description: "Ensure updates, patches, and additional security software are installed (Manual)"
        type: manual
        audit: |
          dnf check-update
        remediation: |
          # Update all packages and reboot if needed
          dnf upgrade --releasever=<latest_version>

          # Then check if reboot is required
          dnf needs-restarting -r
        scored: false

      - id: 1.9
        description: "Ensure system-wide crypto policy is not LEGACY (Automated)"
        audit: |
          grep -E -i '^\s*LEGACY\s*(\s+#.*)?$' /etc/crypto-policies/config
        tests:
          test_items:
            - flag: "LEGACY"
              set: false
        remediation: |
          # Set the system-wide crypto policy to DEFAULT
          update-crypto-policies --set DEFAULT

          # Apply the updated crypto policy
          update-crypto-policies
        scored: true


  - id: 2
    description: "Services"
  - id: 2.1
    description: "Configure Time Synchronization"
    checks:
      - id: 2.1.1
        description: "Ensure time synchronization is in use (Automated)"
        audit: "rpm -q chrony"
        tests:
          test_items:
            - flag: "package chrony is not installed"
              set: false
        remediation: |
          Run the following command to install chrony:

          # dnf install chrony
        scored: true

      - id: 2.1.2
        description: "Ensure chrony is configured (Automated)"
        audit: |
          grep -Pr -- '^\h*(server|pool)\h+[^#\n\r]+' /etc/chrony.d/
        tests:
          bin_op: or
          test_items:
            - flag: "server"
              set: true
            - flag: "pool"
              set: true
        remediation: |
          # Add or edit server or pool lines to a .conf file under /etc/chrony.d/
          # Example:
          echo "server <remote-server>" >> /etc/chrony.d/time-sync.conf

          # Restart chronyd to apply changes
          systemctl restart chronyd
        scored: true


  - id: 2.2
    description: "Configure Special Purpose Services"
    checks:
      - id: 2.2.1
        description: "Ensure xorg-x11-server-common is not installed (Automated)"
        audit: "rpm -q xorg-x11-server-common"
        tests:
          test_items:
            - flag: "package xorg-x11-server-common is not installed"
              set: true
        remediation: |
          Run the following command to remove xorg-x11-server-common:

          # dnf remove xorg-x11-server-common
        scored: true

      - id: 2.2.2
        description: "Ensure avahi is not installed (Automated)"
        audit: "rpm -q avahi"
        tests:
          test_items:
            - flag: "package avahi is not installed"
              set: true
        remediation: |
          Run the following command to remove avahi:

          # dnf remove avahi
        scored: true

      - id: 2.2.3
        description: "Ensure a print server is not installed (Automated)"
        audit: "rpm -q cups"
        tests:
          test_items:
            - flag: "package cups is not installed"
              set: true
        remediation: |
          Run the following command to remove cups:

          # dnf remove cups
        scored: true

      - id: 2.2.4
        description: "Ensure a dhcp server is not installed (Automated)"
        audit: "rpm -q dhcp-server"
        tests:
          test_items:
            - flag: "package dhcp-server is not installed"
              set: true
        remediation: |
          Run the following command to remove dhcp:

          # dnf remove dhcp-server
        scored: true

      - id: 2.2.5
        description: "Ensure a dns server is not installed (Automated)"
        audit: "rpm -q bind"
        tests:
          test_items:
            - flag: "package bind is not installed"
              set: true
        remediation: |
          Run the following command to remove bind:

          # dnf remove bind
        scored: true

      - id: 2.2.6
        description: "Ensure a ftp server is not installed (Automated)"
        audit: "rpm -q vsftpd"
        tests:
          test_items:
            - flag: "package vsftpd is not installed"
              set: true
        remediation: |
          Run the following command to remove vsftpd:

          # dnf remove vsftpd
        scored: true

      - id: 2.2.7
        description: "Ensure a tftp server is not installed (Automated)"
        audit: "rpm -q tftp-server"
        tests:
          test_items:
            - flag: "package tftp-server is not installed"
              set: true
        remediation: |
          Run the following command to remove tftp-server:

          # dnf remove tftp-server
        scored: true

      - id: 2.2.8
        description: "Ensure a web server is not installed (Automated)"
        audit: "rpm -q httpd nginx"
        tests:
          test_items:
            - flag: "package httpd is not installed"
              set: true
            - flag: "package nginx is not installed"
              set: true
        remediation: |
          Run the following command to remove httpd and nginx:

          # dnf remove httpd nginx
        scored: true


      - id: 2.2.9
        description: "Ensure IMAP and POP3 server is not installed (Automated)"
        audit: "rpm -q dovecot cyrus-imapd"
        tests:
          test_items:
            - flag: "package dovecot is not installed"
              set: true
            - flag: "package cyrus-imapd is not installed"
              set: true
        remediation: |
          Run the following command to remove dovecot and cyrus-imapd:

          # dnf remove dovecot cyrus-imapd
        scored: true

      - id: 2.2.10
        description: "Ensure Samba is not installed (Automated)"
        audit: "rpm -q samba"
        tests:
          test_items:
            - flag: "package samba is not installed"
              set: true
        remediation: |
          Run the following command to remove samba:

          # dnf remove samba
        scored: true

      - id: 2.2.11
        description: "Ensure HTTP Proxy Server is not installed (Automated)"
        audit: "rpm -q squid"
        tests:
          test_items:
            - flag: "package squid is not installed"
              set: true
        remediation: |
          Run the following command to remove squid:

          # dnf remove squid
        scored: true

      - id: 2.2.12
        description: "Ensure net-snmp is not installed or the snmpd service is disabled (Automated)"
        audit: |
          if rpm -q net-snmp > /dev/null 2>&1; then
            echo "net-snmp_installed"
            systemctl is-enabled snmpd || echo "snmpd_not_enabled"
          else
            echo "net-snmp_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "net-snmp_not_installed"
              set: true
            - flag: "masked"
              set: true
        remediation: |
          To remove the net-snmp package:
            # dnf remove net-snmp

          If net-snmp must be present, ensure the snmpd service is disabled:
            # systemctl stop snmpd
            # systemctl mask snmpd
        scored: true


      - id: 2.2.13
        description: "Ensure telnet-server is not installed (Automated)"
        audit: "rpm -q telnet-server"
        tests:
          test_items:
            - flag: "package telnet-server is not installed"
              set: true
        remediation: |
          Run the following command to remove telnet-server:

          # dnf remove telnet-server
        scored: true

      - id: 2.2.14
        description: "Ensure dnsmasq is not installed (Automated)"
        audit: "rpm -q dnsmasq"
        tests:
          test_items:
            - flag: "package dnsmasq is not installed"
              set: true
        remediation: |
          Run the following command to remove dnsmasq:

          # dnf remove dnsmasq
        scored: true

      - id: 2.2.15
        description: "Ensure mail transfer agent is configured for local-only mode (Automated)"
        audit: |
          ss -lntu | grep -P ':25\b' | grep -Pv '\h+(127\.0\.0\.1|\[?::1\]?):25\b'
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/postfix/main.cf and add the following line to the RECEIVING MAIL section. If the line already exists, change it to look like the line below:
            inet_interfaces = loopback-only
          Run the following command to restart postfix:

            # systemctl restart postfix
        scored: true

      - id: 2.2.16
        description: "Ensure nfs-utils is not installed or the nfs-server service is masked (Automated)"
        audit: |
          if rpm -q nfs-utils > /dev/null 2>&1; then
            echo "nfs-utils_installed"
            systemctl is-enabled nfs-server || echo "nfs-server_not_enabled"
          else
            echo "nfs-utils_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nfs-utils_not_installed"
              set: true
            - flag: "masked"
              set: true
        remediation: |
          To remove the nfs-utils package:
            # dnf remove nfs-utils

          If nfs-utils is required as a dependency, ensure the nfs-server service is disabled:
            # systemctl stop nfs-server
            # systemctl mask nfs-server
        scored: true


      - id: 2.2.17
        description: "Ensure rpcbind is not installed or the rpcbind services are masked (Automated)"
        audit: |
          if rpm -q rpcbind > /dev/null 2>&1; then
            echo "rpcbind_installed"
            systemctl is-enabled rpcbind.service || echo "rpcbind_service_not_enabled"
            systemctl is-enabled rpcbind.socket || echo "rpcbind_socket_not_enabled"
          else
            echo "rpcbind_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rpcbind_not_installed"
              set: true
            - flag: "masked"
              set: true
        remediation: |
          To remove the rpcbind package:
            # dnf remove rpcbind

          If rpcbind is required as a dependency, stop and mask the services:
            # systemctl stop rpcbind.socket
            # systemctl mask rpcbind.socket

            # systemctl stop rpcbind.service
            # systemctl mask rpcbind.service
        scored: true

      - id: 2.2.18
        description: "Ensure rsync-daemon is not installed or the rsyncd service is masked (Automated)"
        audit: |
          if rpm -q rsync-daemon > /dev/null 2>&1; then
            echo "rsync_installed"
            systemctl is-enabled rsyncd || echo "rsyncd_not_enabled"
          else
            echo "rsync_not_installed"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "rsync_not_installed"
              set: true
            - flag: "masked"
              set: true
        remediation: |
          To remove the rsync-daemon package:
            # dnf remove rsync-daemon

          If rsync is required, ensure the rsyncd service is disabled:
            # systemctl stop rsyncd
            # systemctl mask rsyncd
        scored: true


  - id: 2.3
    description: "Service Clients"
    checks:
      - id: 2.3.1
        description: "Ensure telnet client is not installed (Automated)"
        audit: "rpm -q telnet"
        tests:
          test_items:
            - flag: "package telnet is not installed"
              set: true
        remediation: |
          Run the following command to remove telnet:

          # dnf remove telnet
        scored: true

      - id: 2.3.2
        description: "Ensure LDAP client is not installed (Automated)"
        audit: "rpm -q openldap-clients"
        tests:
          test_items:
            - flag: "package openldap-clients is not installed"
              set: true
        remediation: |
          Run the following command to remove openldap-clients:

          # dnf remove openldap-clients
        scored: true

      - id: 2.3.3
        description: "Ensure FTP client is not installed (Automated)"
        audit: "rpm -q ftp"
        tests:
          test_items:
            - flag: "package ftp is not installed"
              set: true
        remediation: |
          Run the following command to remove ftp:

          # dnf remove ftp
        scored: true

      - id: 2.4
        description: "Ensure nonessential services listening on the system are removed or masked (Manual)"
        type: manual
        remediation: |
          Run the following command to remove the package containing the service:

          # dnf remove <package_name>
          OR If required packages have a dependency:

          Run the following commands to stop and mask the service:

            # systemctl stop <service_name>.socket
            # systemctl stop <service_name>.service
            # systemctl mask <service_name>.socket
            # systemctl mask <service_name>.service
        scored: false


  - id: 3
    description: "Network Configuration"
  - id: 3.1
    description: "Disable unused network protocols and devices"
    checks:
      - id: 3.1.1
        description: "Ensure IPv6 status is identified (Manual)"
        type: manual
        audit: |
          grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable && echo -e "\n - IPv6 is enabled\n" || echo -e "\n - IPv6 is not enabled\n"
        remediation: |
          # If IPv6 is required:
          # Ensure IPv6 is enabled by removing any settings that disable it from /etc/sysctl.conf or GRUB
          # Otherwise, if not required:
          # Add or confirm the following lines are present to disable IPv6:
          echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.conf
          echo "net.ipv6.conf.default.disable_ipv6 = 1" >> /etc/sysctl.conf
          sysctl -p

          # Or add `ipv6.disable=1` to GRUB_CMDLINE_LINUX in /etc/default/grub and update GRUB:
          # grub2-mkconfig -o /boot/grub2/grub.cfg
        scored: false

      - id: 3.1.2
        description: "Ensure DCCP is disabled (Automated)"
        audit: |
          modprobe -n -v dccp | grep -qE 'install\s+/bin/' && echo "denylisted" || echo "not_denylisted"
          lsmod | grep -q dccp && echo "dccp_loaded" || echo "dccp_not_loaded"
        tests:
          test_items:
            - flag: "not_denylisted"
              set: false
            - flag: "dccp_not_loaded"
              set: true
        remediation: |
          Disable DCCP by creating a denylist and setting it to not load:
            # echo "install dccp /bin/false" > /etc/modprobe.d/dccp.conf
            # echo "blacklist dccp" >> /etc/modprobe.d/dccp.conf

          Unload the module if it is currently loaded:
            # modprobe -r dccp || true
        scored: true


      - id: 3.1.3
        description: "Ensure SCTP is disabled (Automated)"
        audit: |
          modprobe -n -v sctp | grep -qE 'install\s+/bin/' && echo "denylisted" || echo "not_denylisted"
          lsmod | grep -q sctp && echo "sctp_loaded" || echo "sctp_not_loaded"
        tests:
          test_items:
            - flag: "not_denylisted"
              set: false
            - flag: "sctp_not_loaded"
              set: true
        remediation: |
          Disable SCTP by blacklisting and preventing it from being loaded:
            # echo "install sctp /bin/false" > /etc/modprobe.d/sctp.conf
            # echo "blacklist sctp" >> /etc/modprobe.d/sctp.conf

          Unload the SCTP module if it is currently loaded:
            # modprobe -r sctp || true
        scored: true


      - id: 3.1.4
        description: "Ensure RDS is disabled (Automated)"
        audit: |
          modprobe -n -v rds | grep -qE 'install\s+/bin/' && echo "denylisted" || echo "not_denylisted"
          lsmod | grep -q rds && echo "rds_loaded" || echo "rds_not_loaded"
        tests:
          test_items:
            - flag: "not_denylisted"
              set: false
            - flag: "rds_not_loaded"
              set: true
        remediation: |
          Disable RDS by blacklisting and preventing it from being loaded:
            # echo "install rds /bin/false" > /etc/modprobe.d/rds.conf
            # echo "blacklist rds" >> /etc/modprobe.d/rds.conf

          Unload the RDS module if it is currently loaded:
            # modprobe -r rds || true
        scored: true


      - id: 3.1.5
        description: "Ensure TIPC is disabled (Automated)"
        audit: |
          modprobe -n -v tipc | grep -qE 'install\s+/bin/' && echo "denylisted" || echo "not_denylisted"
          lsmod | grep -q tipc && echo "tipc_loaded" || echo "tipc_not_loaded"
        tests:
          test_items:
            - flag: "not_denylisted"
              set: false
            - flag: "tipc_not_loaded"
              set: true
        remediation: |
          Disable TIPC by blacklisting and preventing it from being loaded:
            # echo "install tipc /bin/false" > /etc/modprobe.d/tipc.conf
            # echo "blacklist tipc" >> /etc/modprobe.d/tipc.conf

          Unload the TIPC module if it is currently loaded:
            # modprobe -r tipc || true
        scored: true


  - id: 3.2
    description: "Configure Network Parameters (Host Only)"
    checks:
      - id: 3.2.1
        description: "Ensure IP forwarding is disabled (Automated)"
        audit: |
          echo "Runtime IPv4 Forwarding:"
          sysctl net.ipv4.ip_forward | awk -F'=' '{print $2}' | xargs

          echo "Persistent IPv4 Forwarding Setting:"
          grep -Er '^\s*net\.ipv4\.ip_forward\s*=\s*0' /etc/sysctl.conf /etc/sysctl.d/*.conf || echo "missing_ipv4_persistent"

          echo "IPv6 Runtime Forwarding:"
          if [ "$(cat /sys/module/ipv6/parameters/disable 2>/dev/null)" = "0" ]; then
            sysctl net.ipv6.conf.all.forwarding | awk -F'=' '{print $2}' | xargs
          else
            echo "IPv6 disabled - N/A"
          fi
        tests:
          bin_op: and
          test_items:
            - flag: "0"
              compare:
                op: eq
                value: "0"
            - flag: "missing_ipv4_persistent"
              set: false
        remediation: |
          Set the following parameter in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

            net.ipv4.ip_forward = 0

          Example:
            # printf "\nnet.ipv4.ip_forward = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Apply the change immediately:
            # sysctl -w net.ipv4.ip_forward=0
            # sysctl -w net.ipv4.route.flush=1

          If IPv6 is enabled on the system, also set:

            net.ipv6.conf.all.forwarding = 0

          Example:
            # printf "\nnet.ipv6.conf.all.forwarding = 0\n" >> /etc/sysctl.d/60-netipv6_sysctl.conf

          Apply the IPv6 change:
            # sysctl -w net.ipv6.conf.all.forwarding=0
            # sysctl -w net.ipv6.route.flush=1
        scored: true


      - id: 3.2.2
        description: "Ensure packet redirect sending is disabled (Automated)"
        audit: |
          echo "Runtime Checks:"
          sysctl net.ipv4.conf.all.send_redirects | awk -F'=' '{print $2}' | xargs
          sysctl net.ipv4.conf.default.send_redirects | awk -F'=' '{print $2}' | xargs

          echo "Persistent Config Checks:"
          grep -Er '^\s*net\.ipv4\.conf\.all\.send_redirects\s*=\s*0' /etc/sysctl.conf /etc/sysctl.d/*.conf || echo "missing_all_persistent"
          grep -Er '^\s*net\.ipv4\.conf\.default\.send_redirects\s*=\s*0' /etc/sysctl.conf /etc/sysctl.d/*.conf || echo "missing_default_persistent"
        tests:
          bin_op: and
          test_items:
            - flag: "0"
              compare:
                op: eq
                value: "0"
            - flag: "missing_all_persistent"
              set: false
            - flag: "missing_default_persistent"
              set: false
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

            net.ipv4.conf.all.send_redirects = 0
            net.ipv4.conf.default.send_redirects = 0

          Example:
            # printf "\nnet.ipv4.conf.all.send_redirects = 0\nnet.ipv4.conf.default.send_redirects = 0\n" >> /etc/sysctl.d/60-netipv4_sysctl.conf

          Apply the changes immediately:
            # sysctl -w net.ipv4.conf.all.send_redirects=0
            # sysctl -w net.ipv4.conf.default.send_redirects=0
            # sysctl -w net.ipv4.route.flush=1
        scored: true


  - id: 3.3
    description: "Configure Network Parameters (Host and Router)"
    checks:
      - id: 3.3.1
        description: "Ensure source routed packets are not accepted (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.conf.all.accept_source_route)" = "0" ] && \
          [ "$(sysctl -n net.ipv4.conf.default.accept_source_route)" = "0" ] && \
          { [ "$(cat /sys/module/ipv6/parameters/disable 2>/dev/null)" != "1" ] && \
          [ "$(sysctl -n net.ipv6.conf.all.accept_source_route)" = "0" ] && \
          [ "$(sysctl -n net.ipv6.conf.default.accept_source_route)" = "0" ] || \
          [ "$(cat /sys/module/ipv6/parameters/disable 2>/dev/null)" = "1" ]; }; then
          echo "all_routed_packet_not_accepted"
          else
          echo "source_routed_packet_accepted"
          fi
        tests:
          test_items:
            - flag: "all_routed_packet_not_accepted"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

            net.ipv4.conf.all.accept_source_route = 0
            net.ipv4.conf.default.accept_source_route = 0
            net.ipv6.conf.all.accept_source_route = 0
            net.ipv6.conf.default.accept_source_route = 0

          Example:
            # printf "
            net.ipv4.conf.all.accept_source_route = 0
            net.ipv4.conf.default.accept_source_route = 0
            net.ipv6.conf.all.accept_source_route = 0
            net.ipv6.conf.default.accept_source_route = 0
            " >> /etc/sysctl.d/60-source-route.conf

          Apply changes immediately:
            # sysctl -w net.ipv4.conf.all.accept_source_route=0
            # sysctl -w net.ipv4.conf.default.accept_source_route=0
            # sysctl -w net.ipv6.conf.all.accept_source_route=0
            # sysctl -w net.ipv6.conf.default.accept_source_route=0
            # sysctl -w net.ipv4.route.flush=1
            # sysctl -w net.ipv6.route.flush=1
        scored: true


      - id: 3.3.2
        description: "Ensure ICMP redirects are not accepted (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.conf.all.accept_redirects)" = "0" ] && \
             [ "$(sysctl -n net.ipv4.conf.default.accept_redirects)" = "0" ] && \
             { [ "$(cat /sys/module/ipv6/parameters/disable 2>/dev/null)" != "1" ] && \
               [ "$(sysctl -n net.ipv6.conf.all.accept_redirects)" = "0" ] && \
               [ "$(sysctl -n net.ipv6.conf.default.accept_redirects)" = "0" ] || \
               [ "$(cat /sys/module/ipv6/parameters/disable 2>/dev/null)" = "1" ]; }; then
            echo "icmp_redirects_not_accepted"
          else
            echo "icmp_redirects_accepted"
          fi
        tests:
          test_items:
            - flag: "icmp_redirects_not_accepted"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

            net.ipv4.conf.all.accept_redirects = 0
            net.ipv4.conf.default.accept_redirects = 0
            net.ipv6.conf.all.accept_redirects = 0
            net.ipv6.conf.default.accept_redirects = 0

          Example:
            # printf "
            net.ipv4.conf.all.accept_redirects = 0
            net.ipv4.conf.default.accept_redirects = 0
            net.ipv6.conf.all.accept_redirects = 0
            net.ipv6.conf.default.accept_redirects = 0
            " >> /etc/sysctl.d/60-icmp-redirects.conf

          Apply changes immediately:
            # sysctl -w net.ipv4.conf.all.accept_redirects=0
            # sysctl -w net.ipv4.conf.default.accept_redirects=0
            # sysctl -w net.ipv6.conf.all.accept_redirects=0
            # sysctl -w net.ipv6.conf.default.accept_redirects=0
            # sysctl -w net.ip
        scored: true

      - id: 3.3.3
        description: "Ensure secure ICMP redirects are not accepted (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.conf.all.secure_redirects)" = "0" ] && \
             [ "$(sysctl -n net.ipv4.conf.default.secure_redirects)" = "0" ]; then
            echo "secure_icmp_redirects_not_accepted"
          else
            echo "secure_icmp_redirects_accepted"
          fi
        tests:
          test_items:
            - flag: "secure_icmp_redirects_not_accepted"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

            net.ipv4.conf.all.secure_redirects = 0
            net.ipv4.conf.default.secure_redirects = 0

          Example:
            # printf "
            net.ipv4.conf.all.secure_redirects = 0
            net.ipv4.conf.default.secure_redirects = 0
            " >> /etc/sysctl.d/60-secure-icmp-redirects.conf

          Apply changes immediately:
            # sysctl -w net.ipv4.conf.all.secure_redirects=0
            # sysctl -w net.ipv4.conf.default.secure_redirects=0
            # sysctl -w net.ipv4.route.flush=1
        scored: true


      - id: 3.3.4
        description: "Ensure suspicious packets are logged (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.conf.all.log_martians)" = "1" ] && \
             [ "$(sysctl -n net.ipv4.conf.default.log_martians)" = "1" ]; then
            echo "log_martians_enabled"
          else
            echo "log_martians_disabled"
          fi
        tests:
          test_items:
            - flag: "log_martians_enabled"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/ ending in .conf:

            net.ipv4.conf.all.log_martians = 1
            net.ipv4.conf.default.log_martians = 1

          Example:
            # printf "
            net.ipv4.conf.all.log_martians = 1
            net.ipv4.conf.default.log_martians = 1
            " >> /etc/sysctl.d/60-log-martians.conf

          Apply changes immediately:
            # sysctl -w net.ipv4.conf.all.log_martians=1
            # sysctl -w net.ipv4.conf.default.log_martians=1
            # sysctl -w net.ipv4.route.flush=1
        scored: true


      - id: 3.3.5
        description: "Ensure broadcast ICMP requests are ignored (Automated)"
        audit: |
          sysctl net.ipv4.icmp_echo_ignore_broadcasts | awk -F'=' '{print $2}' | xargs
        tests:
          test_items:
            - flag: "1"
              compare:
                op: eq
                value: "1"
        remediation: |
          Set net.ipv4.icmp_echo_ignore_broadcasts to 1 in /etc/sysctl.conf or a file in /etc/sysctl.d/*.conf, then apply using:
            sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1
        scored: true

      - id: 3.3.6
        description: "Ensure bogus ICMP responses are ignored (Automated)"
        audit: |
          sysctl net.ipv4.icmp_ignore_bogus_error_responses | awk -F'=' '{print $2}' | xargs
        tests:
          test_items:
            - flag: "1"
              compare:
                op: eq
                value: "1"
        remediation: |
          Set net.ipv4.icmp_ignore_bogus_error_responses to 1 in /etc/sysctl.conf or a file in /etc/sysctl.d/*.conf, then apply using:
            sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1
            sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.7
        description: "Ensure Reverse Path Filtering is enabled (Automated)"
        audit: |
          if [ "$(sysctl -n net.ipv4.conf.all.rp_filter)" = "1" ] && \
             [ "$(sysctl -n net.ipv4.conf.default.rp_filter)" = "1" ]; then
            echo "rp_filter_enabled"
          else
            echo "rp_filter_disabled"
          fi
        tests:
          test_items:
            - flag: "rp_filter_enabled"
              set: true
        remediation: |
          Set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/*.conf:

            net.ipv4.conf.all.rp_filter = 1
            net.ipv4.conf.default.rp_filter = 1

          Example:
            # printf "
            net.ipv4.conf.all.rp_filter = 1
            net.ipv4.conf.default.rp_filter = 1
            " >> /etc/sysctl.d/60-rp-filter.conf

          Apply the changes immediately:
            # sysctl -w net.ipv4.conf.all.rp_filter=1
            # sysctl -w net.ipv4.conf.default.rp_filter=1
            # sysctl -w net.ipv4.route.flush=1
        scored: true


      - id: 3.3.8
        description: "Ensure TCP SYN Cookies is enabled (Automated)"
        audit: |
          sysctl net.ipv4.tcp_syncookies | awk -F'=' '{print $2}' | xargs
        tests:
          test_items:
            - flag: "1"
              compare:
                op: eq
                value: "1"
        remediation: |
          Set net.ipv4.tcp_syncookies to 1 in /etc/sysctl.conf or a file in /etc/sysctl.d/*.conf and apply it:
            sysctl -w net.ipv4.tcp_syncookies=1
            sysctl -w net.ipv4.route.flush=1
        scored: true

      - id: 3.3.9
        description: "Ensure IPv6 router advertisements are not accepted (Automated)"
        audit: |
          if [ "$(cat /sys/module/ipv6/parameters/disable 2>/dev/null)" = "1" ]; then
            echo "ipv6_disabled"
          elif [ "$(sysctl -n net.ipv6.conf.all.accept_ra)" = "0" ] && \
               [ "$(sysctl -n net.ipv6.conf.default.accept_ra)" = "0" ]; then
            echo "ipv6_accept_ra_disabled"
          else
            echo "ipv6_accept_ra_enabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "ipv6_accept_ra_disabled"
              set: true
            - flag: "ipv6_disabled"
              set: true
        remediation: |
          If IPv6 is enabled on your system, set the following parameters in /etc/sysctl.conf or a file in /etc/sysctl.d/*.conf:

            net.ipv6.conf.all.accept_ra = 0
            net.ipv6.conf.default.accept_ra = 0

          Example:
            # printf "
            net.ipv6.conf.all.accept_ra = 0
            net.ipv6.conf.default.accept_ra = 0
            " >> /etc/sysctl.d/60-ipv6-accept-ra.conf

          Apply the changes immediately:
            # sysctl -w net.ipv6.conf.all.accept_ra=0
            # sysctl -w net.ipv6.conf.default.accept_ra=0
            # sysctl -w net.ipv6.route.flush=1
        scored: true


  - id: 3.4
    description: "Configure Host Based Firewall"
    checks:
      - id: 3.4.1
        description: "Configure a firewall utility"
        type: "skip"
        checks:
      - id: 3.4.1.1
        description: "Ensure nftables is installed (Automated)"
        audit: "rpm -q nftables"
        tests:
          test_items:
            - flag: "package nftables is not installed"
              set: false
        remediation: |
          Run the following command to install nftables

          # dnf install nftables
        scored: true

      - id: 3.4.1.2
        description: "Ensure a single firewall configuration utility is in use (Automated)"
        audit: |
          rpm -q firewalld > /dev/null 2>&1 && fwd_status="$(systemctl is-enabled firewalld):$(systemctl is-active firewalld)" || fwd_status="not_installed"
          rpm -q nftables > /dev/null 2>&1 && nft_status="$(systemctl is-enabled nftables):$(systemctl is-active nftables)" || nft_status="not_installed"
          echo "FirewallD: $fwd_status"
          echo "NFTables: $nft_status"
        tests:
          bin_op: or
          test_items:
            - flag: "enabled:active:disabled:inactive"
              compare:
                op: eq
                value: "enabled:active:disabled:inactive"
            - flag: "disabled:inactive:enabled:active"
              compare:
                op: eq
                value: "disabled:inactive:enabled:active"
            - flag: "enabled:active:masked:inactive"
              compare:
                op: eq
                value: "enabled:active:masked:inactive"
            - flag: "masked:inactive:enabled:active"
              compare:
                op: eq
                value: "masked:inactive:enabled:active"
            - flag: ":enabled:active"
              compare:
                op: eq
                value: ":enabled:active"
        remediation: |
          - If both FirewallD and nftables are enabled and active:
              Run one of the following to disable one:
              systemctl stop nftables && systemctl --now mask nftables
              OR
              systemctl stop firewalld && systemctl --now mask firewalld
          - If neither is installed:
              dnf -q install nftables && systemctl enable --now nftables
        scored: true

      - id: 3.4.2
        description: "Configure firewall rules"
        type: "skip"
        checks:
      - id: 3.4.2.1
        description: "Ensure firewalld default zone is set (Automated)"
        audit: |
          if systemctl is-enabled firewalld.service | grep -q 'enabled'; then
            firewall-cmd --get-default-zone
          else
            echo "FirewallD is not enabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "FirewallD is not enabled"
              compare:
                op: has
                value: "FirewallD is not enabled"
            - flag: "public"
              compare:
                op: has
                value: "public"
        remediation: |
          Run the following command to set the default zone (adjust as per local policy):

          firewall-cmd --set-default-zone=public

          This change will apply immediately. Ensure this aligns with your organization's zone policy.
        scored: true

      - id: 3.4.2.2
        description: "Ensure at least one nftables table exists (Automated)"
        audit: |
          nft list tables
        tests:
          test_items:
            - flag: "table"
              compare:
                op: has
                value: "table"
        remediation: |
          Run the following command to create an nftables table if none exist:

          nft create table inet filter

          This creates a default table named 'filter' with the 'inet' family.
        scored: true

      - id: 3.4.2.3
        description: "Ensure nftables base chains exist (Automated)"
        audit: |
          nft list ruleset | grep 'hook input'
          nft list ruleset | grep 'hook forward'
          nft list ruleset | grep 'hook output'
        tests:
          test_items:
            - flag: "hook input"
              compare:
                op: has
                value: "hook input"
            - flag: "hook forward"
              compare:
                op: has
                value: "hook forward"
            - flag: "hook output"
              compare:
                op: has
                value: "hook output"
        remediation: |
          Create base chains with the appropriate hooks using the following commands:

          nft create chain inet filter input { type filter hook input priority 0 \; }
          nft create chain inet filter forward { type filter hook forward priority 0 \; }
          nft create chain inet filter output { type filter hook output priority 0 \; }

          ⚠️ Warning: If setting a default policy to `drop`, ensure SSH is allowed before applying to avoid loss of connectivity.
        scored: true

      - id: 3.4.2.4
        description: "Ensure host based firewall loopback traffic is configured (Automated)"
        audit: |
          nft list ruleset | awk '/hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -P -- '\H+\h+"lo"\h+accept'
          nft list ruleset | awk '/filter_IN_public_deny|hook\s+input\s+/,/\}\s*(#.*)?$/' | grep -P -- 'ip\h+saddr\h+127\.0\.0\.0\/8.*drop'
          if grep -Pq -- '^\h*0\h*$' /sys/module/ipv6/parameters/disable; then
            nft list ruleset | awk '/filter_IN_public_deny|hook input/,/}/' | grep -P -- 'ip6\h+saddr\h+::1.*drop'
          fi
        tests:
          test_items:
            - flag: 'lo accept'
              compare:
                op: has
                value: 'lo accept'
            - flag: '127.0.0.0/8 drop'
              compare:
                op: has
                value: '127.0.0.0/8 drop'
            - flag: '::1 drop'
              compare:
                op: has
                value: '::1 drop'
        remediation: |
          If using nftables:
          - Accept traffic from loopback interface:
            nft add rule inet filter input iif lo accept
          - Drop traffic to loopback not coming from loopback (IPv4):
            nft add rule inet filter input ip saddr 127.0.0.0/8 counter drop
          - Drop traffic to loopback not coming from loopback (IPv6):
            nft add rule inet filter input ip6 saddr ::1 counter drop

          If using firewalld:
          - firewall-cmd --permanent --zone=trusted --add-interface=lo
          - firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address="127.0.0.1" destination not address="127.0.0.1" drop'
          - firewall-cmd --permanent --add-rich-rule='rule family=ipv6 source address="::1" destination not address="::1" drop'
          - firewall-cmd --reload

          ⚠️ Make sure only one firewall utility (firewalld or nftables) is active to avoid conflicts.
        scored: true

      - id: 3.4.2.5
        description: "Ensure firewalld drops unnecessary services and ports (Manual)"
        type: manual
        audit: |
          systemctl is-enabled firewalld.service | grep -q 'enabled' && \
          firewall-cmd --list-all --zone="$(firewall-cmd --get-active-zones | awk 'NR==1{print $1}')" | \
          grep -P -- '^\h*(services:|ports:)'
        remediation: |
          # Remove unnecessary services
          firewall-cmd --remove-service=<service>

          # Example:
          firewall-cmd --remove-service=cockpit

          # Remove unnecessary ports
          firewall-cmd --remove-port=<port-number>/<protocol>

          # Example:
          firewall-cmd --remove-port=25/tcp

          # Make changes persistent
          firewall-cmd --runtime-to-permanent
        scored: false

      - id: 3.4.2.6
        description: "Ensure nftables established connections are configured (Manual)"
        type: manual
        audit: |
          systemctl is-enabled nftables.service | grep -q 'enabled' && \
          nft list ruleset | awk '/hook input/,/}/' | grep 'ct state'
        remediation: |
          # Allow established TCP connections
          nft add rule inet filter input ip protocol tcp ct state established accept

          # Allow established UDP connections
          nft add rule inet filter input ip protocol udp ct state established accept

          # Allow established ICMP connections
          nft add rule inet filter input ip protocol icmp ct state established accept
        scored: false

      - id: 3.4.2.7
        description: "Ensure nftables default deny firewall policy (Automated)"
        audit: |
          if systemctl --quiet is-enabled nftables.service; then
            input_policy=$(nft list ruleset | grep -E 'hook input' | grep -v 'policy drop')
            forward_policy=$(nft list ruleset | grep -E 'hook forward' | grep -v 'policy drop')
            if [ -z "$input_policy" ] && [ -z "$forward_policy" ]; then
              echo "nftables_policy_drop_set"
            else
              echo "nftables_policy_drop_missing"
            fi
          else
            echo "nftables_not_enabled"
          fi
        tests:
          bin_op: or
          test_items:
            - flag: "nftables_policy_drop_set"
              set: true
            - flag: "nftables_not_enabled"
              set: true
        remediation: |
          If `nftables` is in use on your system, ensure all base chains have a default drop policy.

          Run the following commands to set the default policy:

            # nft chain inet filter input { policy drop \; }
            # nft chain inet filter forward { policy drop \; }

          If `nftables` is not in use, this rule does not apply.
        scored: true

  - id: 4
    description: "Access, Authentication and Authorization"
    checks:
  - id: 4.1
    description: "Configure time-based job schedulers"
    checks:
      - id: 4.1.1
        description: "Ensure cron daemon is installed and enabled (Automated)"
        audit: |
          if rpm -q cronie > /dev/null 2>&1; then
            echo "cronie_installed"
          else
            echo "cronie_missing"
          fi

          if systemctl is-enabled crond 2>/dev/null | grep -q enabled; then
            echo "crond_enabled"
          else
            echo "crond_not_enabled"
          fi
        tests:
          bin_op: and
          test_items:
            - flag: "cronie_installed"
              set: true
            - flag: "crond_enabled"
              set: true
        remediation: |
          -- IF -- Cron is used to execute batch jobs on the system:

          Run the following commands to install and enable the cron service:

            # dnf install -y cronie
            # systemctl enable --now crond
        scored: true

      - id: 4.1.2
        description: "Ensure permissions on /etc/crontab are configured (Automated)"
        audit: |
          if stat -L /etc/crontab | grep -qE 'Access:\s+\(0600/-rw-------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "crontab_permission_ok"
          else
          echo "crontab_permissions_bad"
          fi
        tests:
          test_items:
            - flag: "crontab_permission_ok"
              set: true
        remediation: |
          - IF -- Cron is being used to execute batch jobs on the system

          Run the following commands to set ownership and permissions on /etc/crontab:
          # chown root:root /etc/crontab
          # chmod og-rwx /etc/crontab
        scored: true

      - id: 4.1.3
        description: "Ensure permissions on /etc/cron.hourly are configured (Automated)"
        audit: |
          if stat -L /etc/cron.hourly | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_hourly_permission_ok"
          else
          echo "cron_hourly_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_hourly_permission_ok"
              set: true
        remediation: |
          - IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.hourly :

            # chown root:root /etc/cron.hourly

            # chmod og-rwx /etc/cron.hourly
        scored: true

      - id: 4.1.4
        description: "Ensure permissions on /etc/cron.daily are configured (Automated)"
        audit: |
          if stat -L /etc/cron.daily | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_daily_permission_ok"
          else
          echo "cron_daily_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_daily_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.daily :

            # chown root:root /etc/cron.daily

            # chmod og-rwx /etc/cron.daily
        scored: true

      - id: 4.1.5
        description: "Ensure permissions on /etc/cron.weekly are configured (Automated)"
        audit: |
          if stat -L /etc/cron.weekly | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_weekly_permission_ok"
          else
          echo "cron_weekly_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_weekly_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.weekly :

            # chown root:root /etc/cron.weekly

            # chmod og-rwx /etc/cron.weekly
        scored: true

      - id: 4.1.6
        description: "Ensure permissions on /etc/cron.monthly are configured (Automated)"
        audit: |
          if stat -L /etc/cron.monthly | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_monthly_permission_ok"
          else
          echo "cron_monthly_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_monthly_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.monthly :

            # chown root:root /etc/cron.monthly

            # chmod og-rwx /etc/cron.monthly
        scored: true

      - id: 4.1.7
        description: "Ensure permissions on /etc/cron.d are configured (Automated)"
        audit: |
          if stat -L /etc/cron.d | grep -qE 'Access:\s+\(0700/drwx------\)\s+Uid:\s+\(\s*0/\s*root\)\s+Gid:\s+\(\s*0/\s*root\)'; then
            echo "cron_d_permission_ok"
          else
          echo "cron_d_permission_bad"
          fi
        tests:
          test_items:
            - flag: "cron_d_permission_ok"
              set: true
        remediation: |
          -- IF -- Cron is being used to execute batch jobs on the system:

          Run the following commands to set ownership and permissions on /etc/cron.d :

            # chown root:root /etc/cron.d

            # chmod og-rwx /etc/cron.d
        scored: true

      - id: 4.1.8
        description: "Ensure cron is restricted to authorized users (Automated)"
        audit: |
          bash -c '[ -e /etc/cron.allow ] && [ "$(stat -c "%a" /etc/cron.allow)" = "600" ] && [ "$(stat -c "%u:%g" /etc/cron.allow)" = "0:0" ] && [ ! -e /etc/cron.deny ] && echo "Pass" || echo "Fail"'
        tests:
          test_items:
            - flag: "Pass"
              set: true
              compare:
                op: eq
                value: "Pass"

        remediation: |
          if rpm -q cronie >/dev/null; then
            [ -e /etc/cron.deny ] && rm -f /etc/cron.deny
            [ ! -e /etc/cron.allow ] && touch /etc/cron.allow
            chown root:root /etc/cron.allow
            chmod 600 /etc/cron.allow
          fi
        scored: true

      - id: 4.1.9
        description: "Ensure at is restricted to authorized users (Automated)"
        audit: |
          bash -c '[ -e /etc/at.allow ] && [ "$(stat -c "%a" /etc/at.allow)" = "600" ] && [ "$(stat -c "%u:%g" /etc/at.allow)" = "0:0" ] && [ ! -e /etc/at.deny ] && echo "Pass" || echo "Fail"'
        tests:
          test_items:
            - flag: "Pass"
              set: true
              compare:
                op: eq
                value: "Pass"

        remediation: |
          if rpm -q at >/dev/null; then
            [ -e /etc/at.deny ] && rm -f /etc/at.deny
            [ ! -e /etc/at.allow ] && touch /etc/at.allow
            chown root:root /etc/at.allow
            chmod 600 /etc/at.allow
          fi
        scored: true

  - id: 4.2
    description: "Configure SSH Server"
    checks:
      - id: 4.2.1
        description: "Ensure permissions on /etc/ssh/sshd_config are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/ssh/sshd_config
        tests:
          test_items:
            - flag: "600"
              set: true
            - flag: "0/root 0/root"
              set: true

        remediation: |
          Run the following commands to set ownership and permissions on /etc/ssh/sshd_config:

          # chown root:root /etc/ssh/sshd_config
          # chmod u-x,go-rwx /etc/ssh/sshd_config
        scored: true
      - id: 4.2.2
        description: "Ensure permissions on SSH private host key files are configured (Automated)"
        audit: |
          find /etc/ssh -xdev -type f -name "ssh_host_*_key" -exec stat -c "%n %a %U %G" {} \; | while read file perm user group; do
            if [ "$perm" != "600" ] || [ "$user" != "root" ] || ([ "$group" != "root" ] && [ "$group" != "ssh_keys" ]); then
              echo "FAIL: $file has incorrect permissions or ownership"
            fi
          done
        tests:
          test_items:
            - flag: "FAIL"
              set: false
        remediation: |
          find /etc/ssh -xdev -type f -name "ssh_host_*_key" | while read file; do
            chmod 600 "$file"
            chown root:root "$file"
          done
        scored: true

      - id: 4.2.3
        description: "Ensure permissions on SSH public host key files are configured (Automated)"
        audit: |
          bash -c 'found_fail=0; find /etc/ssh -xdev -type f -exec stat -c "%n %a %U %G" {} + 2>/dev/null | while read -r file mode user group; do
          if file "$file" | grep -Pq "OpenSSH.*public key"; then
          if [ "$mode" -gt 644 ] || [ "$user" != "root" ] || [ "$group" != "root" ]; then
          echo "FAIL: $file mode=$mode owner=$user group=$group"
          found_fail=1
          fi
          fi
          done; [ "$found_fail" -eq 0 ] && echo "PASS"'

        tests:
          test_items:
            - flag: "PASS"
              set: true
              compare:
                op: eq
                value: "PASS"
        remediation: |
          bash -c '{
            l_pmask=0133
            l_maxperm=$(printf "%o" $(( 0777 & ~$l_pmask )))
            find -L /etc/ssh -xdev -type f -exec stat -Lc "%n %#a %U %G" {} + | while read -r l_file l_mode l_owner l_group; do
              if file "$l_file" | grep -Pq ":\\h+OpenSSH\\h+(\\H+\\h+)?public\\h+key\\b"; then
                chmod u-x,go-wx "$l_file"
                chown root "$l_file"
                chgrp root "$l_file"
              fi
            done
          }'
        scored: true

      - id: 4.2.4
        description: "Ensure SSH access is limited (Automated)"
        audit: |
          sshd_config_output=$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(hostname -I | awk '{print $1}')" 2>/dev/null | grep -Pi "^\s*(allow|deny)(users|groups)\s+\S+")
          file_config_output=$(grep -Pi "^\s*(allow|deny)(users|groups)\s+\S+" /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)
          if [ -n "$sshd_config_output" ] || [ -n "$file_config_output" ]; then echo "PASS"; else echo "FAIL"; fi
        tests:
          test_items:
            - flag: "FAIL"
              set: false
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set one or more of the parameters as follows:

            AllowUsers <userlist>
            -OR-

            AllowGroups <grouplist>
            -OR-

            DenyUsers <userlist>
            -OR-

            DenyGroups <grouplist>
        scored: true

      - id: 4.2.5
        description: "Ensure SSH LogLevel is appropriate (Automated)"
        audit: |
          # Check runtime config
          sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep loglevel
        tests:
          test_items:
            - flag: "loglevel"
              compare:
                op: eq
                value: "INFO"

        remediation: |
          Edit or create a file ending in *.conf in /etc/ssh/sshd_config.d/ or edit /etc/ssh/sshd_config directly and set:

            LogLevel VERBOSE
            OR
            LogLevel INFO

          To comment out incorrect LogLevel settings:
            # grep -Pi '^\s*LogLevel\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null | grep -Evi '(VERBOSE|INFO)' | \
              while IFS=: read -r file _; do sed -i '/^\s*LogLevel\s\+/s/^/# /' "$file"; done

          Then reload SSH daemon:
            # systemctl reload sshd
        scored: true


      - id: 4.2.6
        description: "Ensure SSH PAM is enabled (Automated)"
        audit: |
          if sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i usepam | grep -iq 'yes'; then
           runtime="runtime_pam_ok"
          else
           runtime="runtime_pam_bad"
          fi

          usepam_lines="$(grep -Pi '^\s*UsePAM\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$usepam_lines" ]; then
            echo "$usepam_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*UsePAM\s+yes' && static="static_pam_bad" || static="static_pam_ok"
          else
            static="static_pam_ok"
          fi

          echo "runtime=$runtime static=$static"
        tests:
          test_items:
            - flag: "runtime_pam_ok"
              set: true
        remediation: |
          Edit or create a file in /etc/ssh/sshd_config.d/*.conf or in /etc/ssh/sshd_config and add the following:

            UsePAM yes

          Then comment out any incorrect UsePAM values:

            # grep -Pi '^\s*UsePAM\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null | grep -Evi 'yes' | \
              while IFS=: read -r file _; do sed -i '/^\s*UsePAM\s\+/s/^/# /' "$file"; done

          Finally, reload the SSH daemon:

            # systemctl reload sshd
        scored: true


      - id: 4.2.7
        description: "Ensure SSH root login is disabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^permitrootlogin' | awk '{print $2}')"

          if [ "$runtime_status" = "no" ]; then
            runtime="root_login_disabled"
          else
            runtime="root_login_enabled"
          fi

          config_lines="$(grep -Pi '^\s*PermitRootLogin\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*PermitRootLogin\s+no' && static="root_login_enabled" || static="root_login_disabled"
          else
            static="root_login_disabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:root_login_disabled"
              set: true
            - flag: "static:root_login_disabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the PermitRootLogin parameter as follows:

            PermitRootLogin no

          Then, comment out any PermitRootLogin lines not set to "no":

          # grep -Pi '^\h*PermitRootLogin\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri "/^\s*PermitRootLogin\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          Finally, reload the SSH service:

          # systemctl reload sshd
        scored: true


      - id: 4.2.8
        description: "Ensure SSH HostbasedAuthentication is disabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^hostbasedauthentication' | awk '{print $2}')"

          if [ "$runtime_status" = "no" ]; then
            runtime="hostbasedauth_disabled"
          else
            runtime="hostbasedauth_enabled"
          fi

          config_lines="$(grep -Pi '^\s*HostbasedAuthentication\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*HostbasedAuthentication\s+no' && static="hostbasedauth_enabled" || static="hostbasedauth_disabled"
          else
            static="hostbasedauth_disabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:hostbasedauth_disabled"
              set: true
            - flag: "static:hostbasedauth_disabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the following parameter:

            HostbasedAuthentication no

          Then comment out any `HostbasedAuthentication` lines that are set to anything other than "no":

          # grep -Pi '^\h*HostbasedAuthentication\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri "/^\s*HostbasedAuthentication\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          After making changes, reload SSH:

          # systemctl reload sshd
        scored: true


      - id: 4.2.9
        description: "Ensure SSH PermitEmptyPasswords is disabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^permitemptypasswords' | awk '{print $2}')"

          if [ "$runtime_status" = "no" ]; then
            runtime="permitempty_disabled"
          else
            runtime="permitempty_enabled"
          fi

          config_lines="$(grep -Pi '^\s*PermitEmptyPasswords\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*PermitEmptyPasswords\s+no' && static="permitempty_enabled" || static="permitempty_disabled"
          else
            static="permitempty_disabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:permitempty_disabled"
              set: true
            - flag: "static:permitempty_disabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the following:

            PermitEmptyPasswords no

          Then, comment out any lines that set `PermitEmptyPasswords` to anything **other than** `no` using the command:

          # grep -Pi '^\h*PermitEmptyPasswords\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri "/^\s*PermitEmptyPasswords\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          After editing, reload SSH to apply changes:

          # systemctl reload sshd
        scored: true


      - id: 4.2.10
        description: "Ensure SSH PermitUserEnvironment is disabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^permituserenvironment' | awk '{print $2}')"

          if [ "$runtime_status" = "no" ]; then
            runtime="userenv_disabled"
          else
            runtime="userenv_enabled"
          fi

          config_lines="$(grep -Pi '^\s*PermitUserEnvironment\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*PermitUserEnvironment\s+no' && static="userenv_enabled" || static="userenv_disabled"
          else
            static="userenv_disabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:userenv_disabled"
              set: true
            - flag: "static:userenv_disabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the following:

            PermitUserEnvironment no

          Then comment out any lines setting it to other values using:

          # grep -Pi '^\h*PermitUserEnvironment\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri "/^\s*PermitUserEnvironment\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          Finally, reload the SSH daemon:

          # systemctl reload sshd
        scored: true


      - id: 4.2.11
        description: "Ensure SSH IgnoreRhosts is enabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^ignorerhosts' | awk '{print $2}')"

          if [ "$runtime_status" = "yes" ]; then
            runtime="ignorerhosts_enabled"
          else
            runtime="ignorerhosts_disabled"
          fi

          config_lines="$(grep -Pi '^\s*IgnoreRhosts\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*IgnoreRhosts\s+yes' && static="ignorerhosts_disabled" || static="ignorerhosts_enabled"
          else
            static="ignorerhosts_enabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:ignorerhosts_enabled"
              set: true
            - flag: "static:ignorerhosts_enabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set:

            IgnoreRhosts yes

          Then comment out any entries with values other than `yes`:

          # grep -Pi '^\h*IgnoreRhosts\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'yes' | while read -r l_out; do sed -ri "/^\s*IgnoreRhosts\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          Finally, reload the SSH daemon:

          # systemctl reload sshd
        scored: true


      - id: 4.2.12
        description: "Ensure SSH X11 forwarding is disabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^x11forwarding' | awk '{print $2}')"

          if [ "$runtime_status" = "no" ]; then
            runtime="x11_forwarding_disabled"
          else
            runtime="x11_forwarding_enabled"
          fi

          config_lines="$(grep -Pi '^\s*X11Forwarding\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*X11Forwarding\s+no' && static="x11_forwarding_enabled" || static="x11_forwarding_disabled"
          else
            static="x11_forwarding_disabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:x11_forwarding_disabled"
              set: true
            - flag: "static:x11_forwarding_disabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the following:

            X11Forwarding no

          Then comment out any entries with values other than `no`:

          # grep -Pi '^\h*X11Forwarding\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri "/^\s*X11Forwarding\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          Finally, reload the SSH daemon:

          # systemctl reload sshd
        scored: true


      - id: 4.2.13
        description: "Ensure SSH AllowTcpForwarding is disabled (Automated)"
        audit: |
          runtime_status="$(sshd -T -C user=root -C host=\"$(hostname)\" -C addr=\"$(getent hosts $(hostname) | awk '{print $1}')\" | grep -i '^allowtcpforwarding' | awk '{print $2}')"

          if [ "$runtime_status" = "no" ]; then
            runtime="tcp_forwarding_disabled"
          else
            runtime="tcp_forwarding_enabled"
          fi

          config_lines="$(grep -Pi '^\s*AllowTcpForwarding\s+' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -n "$config_lines" ]; then
            echo "$config_lines" | awk -F: '{print $2}' | grep -Eviq '^\s*AllowTcpForwarding\s+no' && static="tcp_forwarding_enabled" || static="tcp_forwarding_disabled"
          else
            static="tcp_forwarding_disabled"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:tcp_forwarding_disabled"
              set: true
            - flag: "static:tcp_forwarding_disabled"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the following:

            AllowTcpForwarding no

          Then comment out any entries with values other than `no`:

          # grep -Pi '^\h*AllowTcpForwarding\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | grep -Evi 'no' | while read -r l_out; do sed -ri "/^\s*AllowTcpForwarding\s+/s/^/# /" "$(awk -F: '{print $1}' <<< $l_out)"; done

          Finally, reload the SSH daemon:

          # systemctl reload sshd
        scored: true


      - id: 4.2.14
        description: "Ensure system-wide crypto policy is not over-ridden (Automated)"
        audit: |
          grep -i '^\s*CRYPTO_POLICY=' /etc/sysconfig/sshd /etc/ssh/sshd_config.d/*.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following commands:

          # sed -ri "s/^\s*(CRYPTO_POLICY\s*=.*)$/# \1/" /etc/sysconfig/sshd /etc/ssh/sshd_config.d/*.conf

          # systemctl reload sshd
        scored: true

      - id: 4.2.15
        description: "Ensure SSH warning banner is configured (Automated)"
        audit: |
          sshd -T -C user=root -C host="$(hostname)" -C addr="$(grep $(hostname) /etc/hosts | awk '{print $1}')" | grep banner
        tests:
          test_items:
            - flag: "banner"
              compare:
                op: eq
                value: "/etc/issue.net"
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set the Banner parameter as follows:

          Banner /etc/issue.net
        scored: true

      - id: 4.2.16
        description: "Ensure SSH MaxAuthTries is set to 4 or less (Automated)"
        audit: |
          # Check runtime value
          runtime_value="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i '^maxauthtries' | awk '{print $2}')"
          if [ -n "$runtime_value" ] && [ "$runtime_value" -le 4 ]; then
            runtime="maxauthtries_ok"
          else
            runtime="maxauthtries_bad"
          fi

          # Check static config files
          static_bad="$(grep -Pi '^\h*maxauthtries\h+([5-9]|[1-9][0-9]+)' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"
          if [ -z "$static_bad" ]; then
            static="maxauthtries_ok"
          else
            static="maxauthtries_bad"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:maxauthtries_ok"
              set: true
            - flag: "static:maxauthtries_ok"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the /etc/ssh/sshd_config.d/ directory or the /etc/ssh/sshd_config file and set:

            MaxAuthTries 4

          Then comment out any MaxAuthTries entries with values greater than 4:

            # grep -Pi '^\h*maxauthtries\h+([5-9]|[1-9][0-9]+)' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | \
              while read -r l_out; do sed -ri "/^\s*maxauthtries\s+([5-9]|[1-9][0-9]+)/s/^/# /" "$(awk -F: '{print $1}' <<< "$l_out")"; done

          Restart the SSH service after applying changes:

            # systemctl reload sshd
        scored: true


      - id: 4.2.17
        description: "Ensure SSH MaxStartups is configured (Automated)"
        audit: |
          # Get runtime value
          runtime_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i '^maxstartups' | awk '{print $2}')"

          # Check runtime policy
          if [ "$runtime_val" = "10:30:60" ]; then
            runtime="maxstartups_ok"
          else
            runtime="maxstartups_bad"
          fi

          # Check static config files for excessive values
          static_bad="$(grep -Ei '^\s*maxstartups\s+(((1[1-9]|[1-9][0-9][0-9]+):([0-9]+):([0-9]+))|(([0-9]+):(3[1-9]|[4-9][0-9]|[1-9][0-9][0-9]+):([0-9]+))|(([0-9]+):([0-9]+):(6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+)))' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -z "$static_bad" ]; then
            static="maxstartups_ok"
          else
            static="maxstartups_bad"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:maxstartups_ok"
              set: true
            - flag: "static:maxstartups_ok"
              set: true
        remediation: |
          Edit or create a configuration file in `/etc/ssh/sshd_config.d/` or `/etc/ssh/sshd_config` and set:

            MaxStartups 10:30:60

          Then comment out any `MaxStartups` entries exceeding the recommended values:

            # grep -Pi '^\s*maxstartups\s+(((1[1-9]|[1-9][0-9][0-9]+):([0-9]+):([0-9]+))|(([0-9]+):(3[1-9]|[4-9][0-9]|[1-9][0-9][0-9]+):([0-9]+))|(([0-9]+):([0-9]+):(6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+)))' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | \
              while read -r l_out; do sed -ri "/^\s*MaxStartups\s+/s/^/# /" "$(awk -F: '{print $1}' <<< "$l_out")"; done

          After applying changes, reload SSH:

            # systemctl reload sshd
        scored: true


      - id: 4.2.18
        description: "Ensure SSH MaxSessions is set to 10 or less (Automated)"
        audit: |
          # Get runtime MaxSessions value
          runtime_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i '^maxsessions' | awk '{print $2}')"

          # Check if runtime is compliant
          if [ "$runtime_val" -le 10 ] 2>/dev/null; then
            runtime="maxsessions_ok"
          else
            runtime="maxsessions_bad"
          fi

          # Check static configuration for any value > 10
          static_bad="$(grep -Ei '^\s*MaxSessions\s+(1[1-9]|[2-9][0-9]|[1-9][0-9][0-9]+)' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -z "$static_bad" ]; then
            static="maxsessions_ok"
          else
            static="maxsessions_bad"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:maxsessions_ok"
              set: true
            - flag: "static:maxsessions_ok"
              set: true
        remediation: |
          Edit or create a configuration file in `/etc/ssh/sshd_config.d/` or `/etc/ssh/sshd_config` and set:

            MaxSessions 10

          Then comment out any `MaxSessions` entries exceeding the recommended value:

            # grep -Pi '^\s*MaxSessions\s+(1[1-9]|[2-9][0-9]|[1-9][0-9][0-9]+)' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | \
              while read -r l_out; do sed -ri "/^\s*MaxSessions\s+/s/^/# /" "$(awk -F: '{print $1}' <<< "$l_out")"; done

          After applying changes, reload SSH:

            # systemctl reload sshd
        scored: true

      - id: 4.2.19
        description: "Ensure SSH LoginGraceTime is set to one minute or less (Automated)"
        audit: |
          # Get runtime LoginGraceTime value (in seconds)
          runtime_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i '^logingracetime' | awk '{print $2}')"

          # Convert m to seconds if needed
          if [[ "$runtime_val" == *m ]]; then
            runtime_val=$((60 * ${runtime_val%m}))
          fi

          # Check runtime threshold
          if [ "$runtime_val" -le 60 ] 2>/dev/null; then
            runtime="gracetime_ok"
          else
            runtime="gracetime_bad"
          fi

          # Check static configuration for invalid values
          static_bad="$(grep -Ei '^\s*LoginGraceTime\s+(0|6[1-9]|[7-9][0-9]|[1-9][0-9]{2,}|[^1]m)' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf 2>/dev/null)"

          if [ -z "$static_bad" ]; then
            static="gracetime_ok"
          else
            static="gracetime_bad"
          fi

          echo "runtime:$runtime"
          echo "static:$static"
        tests:
          test_items:
            - flag: "runtime:gracetime_ok"
              set: true
            - flag: "static:gracetime_ok"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the `/etc/ssh/sshd_config.d/` directory or `/etc/ssh/sshd_config` and set:

            LoginGraceTime 60
            # or
            LoginGraceTime 1m

          Then comment out any entries that configure LoginGraceTime to `0`, a value greater than `60`, or any non-`1m` values:

            # grep -Pi '^\s*LoginGraceTime\s+(0|6[1-9]|[7-9][0-9]|[1-9][0-9][0-9]+|[^1]m)' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | \
              while read -r l_out; do sed -ri "/^\s*LoginGraceTime\s+/s/^/# /" "$(awk -F: '{print $1}' <<< "$l_out")"; done

          Reload SSH after configuration changes:

            # systemctl reload sshd
        scored: true


      - id: 4.2.20
        description: "Ensure SSH Idle Timeout Interval is configured (Automated)"
        audit: |
          clientaliveinterval_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i '^clientaliveinterval' | awk '{print $2}')"
          clientalivecountmax_val="$(sshd -T -C user=root -C host="$(hostname)" -C addr="$(getent hosts "$(hostname)" | awk '{print $1}')" | grep -i '^clientalivecountmax' | awk '{print $2}')"

          if [ "$clientaliveinterval_val" -gt 0 ] 2>/dev/null; then
            interval_ok="true"
          else
            interval_ok="false"
          fi

          if [ "$clientalivecountmax_val" -gt 0 ] 2>/dev/null; then
            countmax_ok="true"
          else
            countmax_ok="false"
          fi

          echo "interval:$interval_ok"
          echo "countmax:$countmax_ok"
        tests:
          test_items:
            - flag: "interval:true"
              set: true
            - flag: "countmax:true"
              set: true
        remediation: |
          Edit or create a file ending in *.conf in the `/etc/ssh/sshd_config.d/` directory or the `/etc/ssh/sshd_config` file and set both parameters as per policy.

          Example recommended setting:

            ClientAliveInterval 15
            ClientAliveCountMax 3

          Then comment out any occurrence of:

            ClientAliveCountMax 0

          using:

            # grep -Pi '^\h*ClientAliveCountMax\h+0\b' /etc/ssh/sshd_config /etc/ssh/sshd_config.d/*.conf | \
              while read -r l_out; do sed -ri "/^\s*ClientAliveCountMax\s+0/s/^/# /" "$(awk -F: '{print $1}' <<< "$l_out")"; done

          Reload SSH to apply changes:

            # systemctl reload sshd
        scored: true


  - id: 4.3
    description: "Configure privilege escalation"
    checks:
      - id: 4.3.1
        description: "Ensure sudo is installed (Automated)"
        audit: "rpm -q sudo"
        tests:
          test_items:
            - flag: "package sudo is not installed"
              set: false
        remediation: |
          Run the following command to install sudo

          # dnf install sudo
        scored: true
      - id: 4.3.2
        description: "Ensure sudo commands use pty (Automated)"
        audit: |
          grep -rPi '^\h*Defaults\h+([^#\n\r]+,)?use_pty(,\h*\h+\h*)*\h*(#.*)?$' /etc/sudoers*
        tests:
          test_items:
            - flag: "use_pty"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f <PATH_TO_FILE> and add the following line:

          Defaults use_pty
          Note:

          sudo will read each file in /etc/sudoers.d, skipping file names that end in ~ or contain a . character to avoid causing problems with package manager or editor temporary/backup files.
          Files are parsed in sorted lexical order. That is, /etc/sudoers.d/01_first will be parsed before /etc/sudoers.d/10_second.
          Be aware that because the sorting is lexical, not numeric, /etc/sudoers.d/1_whoops would be loaded after /etc/sudoers.d/10_second.
          Using a consistent number of leading zeroes in the file names can be used to avoid such problems.
        scored: true

      - id: 4.3.3
        description: "Ensure sudo log file exists (Automated)"
        audit: |
          grep -rPsi "^\h*Defaults\h+([^#]+,\h*)?logfile\h*=\h*(\"|\')?\H+(\"|\')?(,\h*\H+\h*)*\h*(#.*)?$" /etc/sudoers*
        tests:
          test_items:
            - flag: "logfile"
              set: true
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with visudo -f <PATH_TO_FILE> and add the following line:

          Defaults logfile="/var/log/sudo.log"

          Note:

          sudo will read each file in /etc/sudoers.d, skipping file names that end in ~ or contain a . character to avoid causing problems with package manager or editor temporary/backup files.
          Files are parsed in sorted lexical order. That is, /etc/sudoers.d/01_first will be parsed before /etc/sudoers.d/10_second.
          Be aware that because the sorting is lexical, not numeric, /etc/sudoers.d/1_whoops would be loaded after /etc/sudoers.d/10_second.
          Using a consistent number of leading zeroes in the file names can be used to avoid such problems.
        scored: true

      - id: 4.3.4
        description: "Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
        audit: |
          grep -r "^[^#].*\!authenticate" /etc/sudoers /etc/sudoers.d 2>/dev/null
        tests:
          test_items:
            - flag: "!authenticate"
              set: false
        remediation: |
          Edit the file /etc/sudoers with visudo or a file in /etc/sudoers.d/ with:

          visudo -f <PATH_TO_FILE>

          Remove any line that includes the `!authenticate` tag to ensure users must re-authenticate for privilege escalation.

          Example of what to **remove**:

            %admin ALL=(ALL) NOPASSWD: ALL, !authenticate

          Note:

          Improper editing of sudoers files can lock you out of sudo access. Always use visudo to validate syntax.
        scored: true

      - id: 4.3.5
        description: "Ensure sudo authentication timeout is configured correctly (Automated)"
        audit: |
          timeout=$(grep -roP "timestamp_timeout=\K-?[0-9]+" /etc/sudoers* 2>/dev/null | head -n 1)

          if [ -z "$timeout" ]; then
            timeout=$(sudo -V | grep -i "Authentication timestamp timeout:" | awk -F ':' '{print $2}' | awk '{print int($1)}')
          fi

          if [ -z "$timeout" ]; then
            echo "timestamp timeout: not set"
          elif [ "$timeout" -le 15 ] && [ "$timeout" -ge 0 ]; then
            echo "timestamp timeout: ok"
          else
            echo "timestamp timeout: bad"
          fi
        tests:
          test_items:
            - flag: "timestamp timeout: ok"
              set: true
        remediation: |
          Edit the file /etc/sudoers or a file in /etc/sudoers.d/ using visudo:

            visudo -f /etc/sudoers
            OR
            visudo -f /etc/sudoers.d/<filename>

          Set the timeout value to 15 minutes or less using one of the following:

            Defaults    timestamp_timeout=15
            OR
            Defaults    env_reset, timestamp_timeout=15

          Note:
          - A value of `-1` disables the timeout and is **non-compliant**.
          - Always use `visudo` to avoid syntax errors that may lock you out.
        scored: true


      - id: 4.3.6
        description: "Ensure access to the su command is restricted (Automated)"
        audit: |
          if grep -Pi '^\s*auth\s+(required|requisite)\s+pam_wheel\.so.*use_uid.*group=\w+' /etc/pam.d/su; then
            group_name=$(grep -Pi '^\s*auth\s+(required|requisite)\s+pam_wheel\.so.*group=\w+' /etc/pam.d/su | sed -n 's/.*group=\(\w\+\).*/\1/p')
            echo "pam_wheel_configured"
            echo "group_name=$group_name"
            if ! grep -qP "^$group_name:.*:[^:]+:[^:]" /etc/group; then
              echo "group_has_no_users"
            fi
          fi
        tests:
          test_items:
            - flag: "pam_wheel_configured"
              set: true
            - flag: "group_has_no_users"
              set: true
        remediation: |
          1. Create a dedicated empty group (e.g., `sugroup`) to control access to the `su` command:
             groupadd sugroup

          2. Edit `/etc/pam.d/su` and ensure the following line is present and **not commented**:
             auth required pam_wheel.so use_uid group=sugroup

          3. Verify the group has no members:
             grep '^sugroup:' /etc/group
             # Should return: sugroup:x:<GID>:

          This restricts `su` access to members of an intentionally empty group, enforcing sudo usage instead.
        scored: true


  - id: 4.4
    description: "Configure authselect"
    checks:
      - id: 4.4.1
        description: "Ensure custom authselect profile is used (Manual)"
        type: manual
        remediation: |
          Run the following command to install authselect if needed

          # dnf install authselect
          Run the following command to create a custom authselect profile:

          # authselect create-profile <custom-profile name> <options>
          Example:

          # authselect create-profile custom-profile -b sssd --symlink-meta
          Run the following command to select a custom authselect profile:

          # authselect select custom/<CUSTOM PROFILE NAME> {with-<OPTIONS>}
          Example:

            # authselect select custom/custom-profile with-sudo with-faillock without-nullok
        scored: false

      - id: 4.4.2
        description: "Ensure authselect includes with-faillock (Automated)"
        audit: |
          authselect current | grep -q 'with-faillock' && \
          grep -q 'pam_faillock.so' /etc/pam.d/system-auth && \
          grep -q 'pam_faillock.so' /etc/pam.d/password-auth
        tests:
          test_items:
            - flag: "with-faillock"
              set: true
        remediation: |
          Run the following commands to enable the 'with-faillock' feature in the current authselect profile:

            authselect enable-feature with-faillock
            authselect apply-changes

          Then verify the following lines exist in both /etc/pam.d/system-auth and /etc/pam.d/password-auth:

            auth        required      pam_faillock.so preauth silent
            auth        required      pam_faillock.so authfail
            account     required      pam_faillock.so

          Note: These entries help prevent brute-force password attacks by locking accounts after a set number of failed login attempts.
        scored: true

  - id: 4.5
    description: "Configure PAM"
    checks:
      - id: 4.5.1
        description: "Ensure password creation requirements are configured (Automated)"
        audit: |
          retry_check=$(grep -E '^\s*password\s+requisite\s+pam_pwquality\.so.*retry=3\b' /etc/pam.d/system-auth /etc/pam.d/password-auth)
          minlen_check=$(grep -E '^minlen\s*=\s*(1[4-9]|[2-9][0-9]+)' /etc/security/pwquality.conf)
          minclass_check=$(grep -E '^minclass\s*=\s*[4-9]' /etc/security/pwquality.conf)
          credits_check=$(grep -q '^dcredit\s*=\s*-1' /etc/security/pwquality.conf && \
          grep -q '^ucredit\s*=\s*-1' /etc/security/pwquality.conf && \
          grep -q '^ocredit\s*=\s*-1' /etc/security/pwquality.conf && \
          grep -q '^lcredit\s*=\s*-1' /etc/security/pwquality.conf)

          if [ -n "$retry_check" ]; then echo "retry=3"; fi
          if [ -n "$minlen_check" ]; then echo "minlen_ok"; fi
          if [ -n "$minclass_check" ] || $credits_check; then echo "complexity_ok"; fi
        tests:
          test_items:
            - flag: "retry=3"
              set: true
            - flag: "minlen_ok"
              set: true
            - flag: "complexity_ok"
              set: true
        remediation: |
          Edit `/etc/security/pwquality.conf` to include or update the following lines:

            minlen = 14
            minclass = 4

          OR instead of minclass, add the following for character type enforcement:

            dcredit = -1
            ucredit = -1
            ocredit = -1
            lcredit = -1

          Then ensure `/etc/pam.d/system-auth` and `/etc/pam.d/password-auth` contain:

            password requisite pam_pwquality.so try_first_pass local_users_only enforce_for_root retry=3

          If you are using `authselect`, run the following to apply the changes:

            authselect apply-changes
        scored: true

      - id: 4.5.2
        description: "Ensure lockout for failed password attempts is configured (Automated)"
        audit: |
          if grep -Pq '^\s*deny\s*=\s*([1-5])\b' /etc/security/faillock.conf && \
          grep -Pq '^\s*unlock_time\s*=\s*(0|9[0-9]{2,}|[1-9][0-9]{3,})\b' /etc/security/faillock.conf; then
            echo "lockout_policy_set"
          else
          echo "lockout_policy_missing"
          fi
        tests:
          test_items:
            - flag: "lockout_policy_set"
              set: true
        remediation: |
          Edit the file /etc/security/faillock.conf and ensure the following lines are present and configured correctly:

          deny = 5
          unlock_time = 900

          - `deny` must be set to a value greater than 0 and no greater than 5.
          - `unlock_time` must be set to either 0 (never) or 900 seconds or more.

          These settings mitigate brute force login attacks and help prevent unauthorized access.
        scored: true

      - id: 4.5.3
        description: "Ensure password reuse is limited (Automated)"
        audit: |
          pam_file="/etc/pam.d/system-auth"
          if grep -Pq '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so.*\bremember=([5-9]|[1-9][0-9]+)\b' "$pam_file" && \
          grep -Pq '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so.*\bremember=([5-9]|[1-9][0-9]+)\b' "$pam_file"; then
          echo "remember_enforced"
          else
          echo "remember_not_set"
          fi
        tests:
          test_items:
            - flag: "remember_enforced"
              set: true
        remediation: |
          Edit the file /etc/authselect/custom/system-auth (or the applicable PAM profile in use) and ensure the following line(s) include `remember=5` or greater:

          Example entries:
          password     requisite     pam_pwhistory.so try_first_pass use_authtok remember=5
          password     sufficient    pam_unix.so sha512 shadow try_first_pass use_authtok remember=5

          If using `authselect`, you can apply the changes using:

          # authselect apply-changes

          Alternatively, use the script below:

          ```
          #!/usr/bin/env bash

          file="/etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/system-auth"

          if ! grep -Pq -- '^\h*password\h+(requisite|required|sufficient)\h+pam_pwhistory\.so\h+.*remember=([5-9]|[1-9][0-9]+)\b' "$file"; then
            sed -ri '/^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so/ s/$/ remember=5/' "$file"
          fi

          if ! grep -Pq -- '^\h*password\h+(requisite|required|sufficient)\h+pam_unix\.so\h+.*remember=([5-9]|[1-9][0-9]+)\b' "$file"; then
            sed -ri '/^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so/ s/$/ remember=5/' "$file"
          fi

          authselect apply-changes
          ```

          This ensures users cannot reuse their last 5 passwords on the system.
        scored: true

      - id: 4.5.4
        description: "Ensure password hashing algorithm is SHA-512 (Automated)"
        audit: |
          result=0

          if grep -Ei '^\s*crypt_style\s*=\s*sha512\b' /etc/libuser.conf >/dev/null; then
            echo "crypt_style_ok"
          else
            echo "crypt_style_missing"
            result=1
          fi

          if grep -Ei '^\s*ENCRYPT_METHOD\s+SHA512\b' /etc/login.defs >/dev/null; then
            echo "encrypt_method_ok"
          else
            echo "encrypt_method_missing"
            result=1
          fi

          if grep -Piw -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so.*\bsha512\b' /etc/pam.d/system-auth >/dev/null; then
            echo "system_auth_ok"
          else
            echo "system_auth_missing"
            result=1
          fi

          if grep -Piw -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so.*\bsha512\b' /etc/pam.d/password-auth >/dev/null; then
            echo "password_auth_ok"
          else
            echo "password_auth_missing"
            result=1
          fi

          if [ "$result" -eq 0 ]; then
            echo "PASS"
          else
            echo "FAIL"
          fi
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. Edit `/etc/libuser.conf` and ensure:
             crypt_style = sha512

          2. Edit `/etc/login.defs` and ensure:
             ENCRYPT_METHOD SHA512

          3. Update PAM config files to use SHA512 hashing algorithm:
             ```
             #!/usr/bin/env bash

             for fn in system-auth password-auth; do
               file="/etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$fn"
               if ! grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so.*\bsha512\b' "$file"; then
                 if grep -Pq -- '^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so.*\b(md5|blowfish|bigcrypt|sha256|yescrypt)\b' "$file"; then
                   sed -ri 's/\b(md5|blowfish|bigcrypt|sha256|yescrypt)\b/sha512/' "$file"
                 else
                   sed -ri 's/^(\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+)(.*)$/\1sha512 \3/' "$file"
                 fi
               fi
             done

             authselect apply-changes
             ```

          4. Password algorithm changes only apply to **new passwords**. It is strongly recommended to force all users to reset their password:
             ```
             chage --expiredate 0 <username>
             ```
        scored: true


  - id: 4.6
    description: "User Accounts and Environment"
    checks:
      - id: 4.6.1
        description: "Set Shadow Password Suite Parameters"
        type: "skip"
        checks:
      - id: 4.6.1.1
        description: "Ensure password expiration is 365 days or less (Automated)"
        audit: |
          grep -Eq '^\s*PASS_MAX_DAYS\s+(3[0-5][0-9]|36[0-5]|[1-2][0-9]{2}|[1-9][0-9]?|[1-9])\b' /etc/login.defs && ! awk -F: '($2 !~ /^[!*]/ && $5 > 365) { exit 1 }' /etc/shadow && echo "PASS" || echo "FAIL"
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. Set system-wide password max age in `/etc/login.defs`:
             ```
             PASS_MAX_DAYS 365
             ```

          2. Apply to all users with existing passwords:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $5 > 365) { print $1 }' /etc/shadow); do
               chage --maxdays 365 "$user"
             done
             ```
        scored: true

      - id: 4.6.1.2
        description: "Ensure minimum days between password changes is configured (Automated)"
        audit: |
          grep -Eq '^\s*PASS_MIN_DAYS\s+([1-9][0-9]*)\b' /etc/login.defs && ! awk -F: '($2 !~ /^[!*]/ && $4 < 1) { exit 1 }' /etc/shadow && echo "PASS" || echo "FAIL"
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. Set system-wide minimum password age in `/etc/login.defs`:
             ```
             PASS_MIN_DAYS 1
             ```

          2. Apply to all users with existing passwords not meeting the policy:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $4 < 1) { print $1 }' /etc/shadow); do
               chage --mindays 1 "$user"
             done
             ```
        scored: true

      - id: 4.6.1.3
        description: "Ensure password expiration warning days is 7 or more (Automated)"
        audit: |
          grep -Eq '^\s*PASS_WARN_AGE\s+(7|[8-9]|[1-9][0-9]+)\b' /etc/login.defs && ! awk -F: '($2 !~ /^[!*]/ && $6 < 7) { exit 1 }' /etc/shadow && echo "PASS" || echo "FAIL"
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. Set global warning age in `/etc/login.defs`:
             ```
             PASS_WARN_AGE 7
             ```

          2. Fix user-specific values:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && $6 < 7) { print $1 }' /etc/shadow); do
               chage --warndays 7 "$user"
             done
             ```
        scored: true

      - id: 4.6.1.4
        description: "Ensure inactive password lock is 30 days or less (Automated)"
        audit: |
          useradd -D | grep -Eq '^INACTIVE=([0-9]|[1-2][0-9]|30)$' && ! awk -F: '($2 !~ /^[!*]/ && ($7 == "" || $7 ~ /^-1$|^3[1-9]$|^[4-9][0-9]+$|^[1-9][0-9]{2,}$/)) { exit 1 }' /etc/shadow && echo "PASS" || echo "FAIL"
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. Set default inactive days to 30:
             ```
             useradd -D -f 30
             ```

          2. Set inactive days for existing users:
             ```
             for user in $(awk -F: '($2 !~ /^[!*]/ && ($7 == "" || $7 ~ /^-1$|^3[1-9]$|^[4-9][0-9]+$|^[1-9][0-9]{2,}$/)) { print $1 }' /etc/shadow); do
               chage --inactive 30 "$user"
             done
             ```
        scored: true

      - id: 4.6.1.5
        description: "Ensure all users last password change date is in the past (Automated)"
        audit: |
          awk -F: '/^[^:]+:[^!*]/{print $1}' /etc/shadow | while read -r usr; \
          do change=$(date -d "$(chage --list $usr | grep '^Last password change' | cut -d: -f2 | grep -v 'never$')" +%s); \
            if [[ "$change" -gt "$(date +%s)" ]]; then \
          echo "User: \"$usr\" last password change was \"$(chage --list $usr | grep '^Last password change' | cut -d: -f2)\""; fi; done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          investigate any users with a password change date in the future and correct them. Locking the account, expiring the password, or resetting the password manually may be appropriate.
        scored: true

      - id: 4.6.2
        description: "Ensure system accounts are secured (Automated)"
        audit: |
          result=0
          awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3 < '"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $7 !~ /(\/usr)?\/sbin\/nologin$/) { print "FAIL: System account with login shell ->", $1; result=1 }' /etc/passwd
          awk -F: '/nologin/ {print $1}' /etc/passwd | xargs -I '{}' passwd -S '{}' 2>/dev/null | awk '($2 != "L" && $2 != "LK") { print "FAIL: nologin shell but account not locked ->", $1; result=1 }'
          system_accounts=$(awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3 < '"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $7 !~ /(\/usr)?\/sbin\/nologin$/)' /etc/passwd)
          unlocked_nologin=$(awk -F: '/nologin/ {print $1}' /etc/passwd | xargs -I '{}' passwd -S '{}' 2>/dev/null | awk '($2 != "L" && $2 != "LK") { print $1 }')

          if [ -z "$system_accounts" ] && [ -z "$unlocked_nologin" ]; then
            echo "PASS"
          else
            echo "FAIL"
          fi
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. Ensure system accounts have the `nologin` shell:
             ```bash
             awk -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3 < $(awk "/^\\s*UID_MIN/{print \$2}" /etc/login.defs) || $3 == 65534)) { print $1 }' /etc/passwd | while read user; do
               usermod -s $(command -v nologin) "$user"
             done
             ```

          2. Lock all users who already have nologin shell:
             ```bash
             awk -F: '/nologin/ {print $1}' /etc/passwd | while read user; do
               usermod -L "$user"
             done
             ```

          3. You may exclude essential service accounts based on application context.

        scored: true


      - id: 4.6.3
        description: "Ensure default user shell timeout is 900 seconds or less (Automated)"
        audit: |
          find /etc/profile /etc/bashrc /etc/profile.d/ -type f -name "*.sh" -exec grep -EH '^\s*TMOUT=' {} \; | while read -r line; do
            file=$(echo "$line" | cut -d: -f1)
            value=$(echo "$line" | grep -oP 'TMOUT=\K[0-9]+')
            if [ "$value" -gt 900 ] || [ "$value" -eq 0 ]; then
              echo "Invalid TMOUT=$value in $file"
            fi
          done

          find /etc/profile /etc/bashrc /etc/profile.d/ -type f -name "*.sh" -exec grep -LE '^\s*readonly\s+TMOUT' {} \;
          find /etc/profile /etc/bashrc /etc/profile.d/ -type f -name "*.sh" -exec grep -LE '^\s*export\s+TMOUT' {} \;
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Review /etc/profile, /etc/bashrc, and all *.sh files in /etc/profile.d/.
          Ensure that TMOUT is set to a value between 1 and 900, and is declared as readonly and exported.

          Example configuration (preferred in a file under /etc/profile.d/secure_timeout.sh):

          TMOUT=900
          readonly TMOUT
          export TMOUT
        scored: true


      - id: 4.6.4
        description: "Ensure default group for the root account is GID 0 (Automated)"
        audit: |
          grep "^root:" /etc/passwd | cut -f4 -d:
        tests:
          test_items:
            - flag: "0"
              compare:
                op: eq
                value: "0"
        remediation: |
          Run the following command to set the root account default group to GID 0 :

          # usermod -g 0 root
        scored: true

      - id: 4.6.5
        description: "Ensure default user umask is 027 or more restrictive (Automated)"
        audit: |
          {
            result=0

            # Check /etc/login.defs
            grep -Eq '^\s*UMASK\s+027\b' /etc/login.defs || { echo "FAIL: UMASK not set to 027 in /etc/login.defs"; result=1; }
            grep -Eq '^\s*USERGROUPS_ENAB\s+no\b' /etc/login.defs || { echo "FAIL: USERGROUPS_ENAB not set to no"; result=1; }

            # Check PAM umask setting
            grep -Eq '^\s*session\s+(optional|required|requisite)\s+pam_umask\.so\b' /etc/pam.d/system-auth /etc/pam.d/password-auth || { echo "FAIL: pam_umask.so missing in PAM configs"; result=1; }

            # Check profile scripts for weak umask (e.g. 002, 022)
            grep -RPi '(^|^[^#]*)\s*umask\s+(000|00[0-6]|01[0-6]|02[0-6]|0[1-2]|2[0-6]|\s*002|\s*022)' /etc/profile* /etc/bashrc* /etc/profile.d/*.sh > /dev/null && { echo "FAIL: Weak umask found in profile scripts"; result=1; }

            # If all checks passed
            if [ "$result" -eq 0 ]; then
              echo "PASS"
            else
              echo "FAIL"
            fi
          }
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          1. **Set default UMASK** in `/etc/login.defs`:
             ```
             UMASK 027
             USERGROUPS_ENAB no
             ```

          2. **Add pam_umask.so to PAM config** (if not already present):
             ```
             session optional pam_umask.so
             ```
             Add this line to:
             - `/etc/pam.d/system-auth`
             - `/etc/pam.d/password-auth`

          3. **Set a secure umask in global shell profile** (optional):
             Create `/etc/profile.d/set_umask.sh` with:
             ```bash
             umask 027
             ```

          4. **Remove or update any less restrictive `umask` settings** (e.g. `002`, `022`) in:
             - `/etc/login.defs`
             - `/etc/profile*`
             - `/etc/bashrc*`
             - `/etc/profile.d/*.sh`
        scored: true

      - id: 4.6.6
        description: "Ensure root password is set (Automated)"
        audit: "passwd -S root"
        tests:
          test_items:
            - flag: "Password set"
              set: true
        remediation: |
          Set the root password with:

          # passwd root
        scored: true

  - id: 5
    description: "Logging and Auditing"
    checks:
  - id: 5.1
    description: "Configure Logging"
    checks:
      - id: 5.1.1
        description: "Configure rsyslog"
        type: "skip"
        checks:
      - id: 5.1.1.1
        description: "Ensure rsyslog is installed (Manual)"
        type: manual
        audit: "rpm -q rsyslog"
        remediation: |
          Install the rsyslog package if it is not already installed:

          # dnf install rsyslog
        scored: false

      - id: 5.1.1.2
        description: "Ensure rsyslog service is enabled (Manual)"
        type: manual
        audit: "systemctl is-enabled rsyslog"
        remediation: |
          Run the following command to enable rsyslog:

          # systemctl --now enable rsyslog
        scored: false

      - id: 5.1.1.3
        description: "Ensure journald is configured to send logs to rsyslog (Manual)"
        type: manual
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:

            ForwardToSyslog=yes
          Restart the service:

            # systemctl restart rsyslog
        scored: false

      - id: 5.1.1.4
        description: "Ensure rsyslog default file permissions are configured (Automated)"
        audit: |
          grep -Ps "^\s*\$FileCreateMode\s+0[0,2,4,6][0,2,4]0\b" /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null
        tests:
          test_items:
            - flag: "0640"
              set: true
        remediation: |
          Edit either /etc/rsyslog.conf or a dedicated .conf file in /etc/rsyslog.d/ and set $FileCreateMode to 0640 or more restrictive:

            $FileCreateMode 0640
          Restart the service:

          # systemctl restart rsyslog
        scored: true

      - id: 5.1.1.5
        description: "Ensure logging is configured (Manual)"
        type: manual
        audit: "ls -l /var/log/"
        remediation: |
          Edit the following lines in the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files as appropriate for your environment.

          Run the following command to reload the rsyslogd configuration:

          # systemctl restart rsyslog
        scored: false

      - id: 5.1.1.6
        description: "Ensure rsyslog is configured to send logs to a remote log host (Manual)"
        type: manual
        audit: |
          grep -E '^\s*([^#]+\s+)?action\(([^#]+\s+)?\btarget=\"?[^#"]+\"?\b' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        remediation: |
          Edit the /etc/rsyslog.conf and /etc/rsyslog.d/*.conf files and add the following line (where loghost.example.com is the name of your central log host). The target directive may either be a fully qualified domain name or an IP address.

            *.* action(type="omfwd" target="192.168.2.100" port="514" protocol="tcp"
            action.resumeRetryCount="100"
            queue.type="LinkedList" queue.size="1000")
          Run the following command to reload the rsyslogd configuration:

          # systemctl restart rsyslog

        scored: false

      - id: 5.1.1.7
        description: "Ensure rsyslog is not configured to receive logs from a remote client (Automated)"
        audit: |
          grep -Ps -- '^\h*module\(load="imtcp"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -Ps -- '^\h*input\(type="imtcp" port="514"\)' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -s '^\s*\$ModLoad imtcp' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
          grep -s '^\s*\$InputTCPServerRun' /etc/rsyslog.conf /etc/rsyslog.d/*.conf
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Edit /etc/rsyslog.conf and all /etc/rsyslog.d/*.conf files to remove any configuration lines that enable receiving logs from remote clients:

          Remove any of the following lines if present:
            - module(load="imtcp")
            - input(type="imtcp" port="514")
            - $ModLoad imtcp
            - $InputTCPServerRun

          After making changes, restart the rsyslog service:
            systemctl restart rsyslog
        scored: true

      - id: 5.1.2
        description: "Configure journald"
        type: "skip"
        checks:
      - id: 5.1.2.1
        description: "Ensure journald is configured to send logs to a remote log host"
        type: "skip"
        checks:
      - id: 5.1.2.1.1
        description: "Ensure systemd-journal-remote is installed (Manual)"
        type: manual
        audit: "rpm -q systemd-journal-remote"
        remediation: |
          Run the following command to install systemd-journal-remote:

          # dnf install systemd-journal-remote
        scored: false

      - id: 5.1.2.1.2
        description: "Ensure systemd-journal-remote is configured (Manual)"
        type: manual
        audit: |
          grep -P "^ *URL=|^ *ServerKeyFile=|^ *ServerCertificateFile=|^ *TrustedCertificateFile=" /etc/systemd/journal-upload.conf
        remediation: |
          Edit the /etc/systemd/journal-upload.conf file and ensure the following lines are set per your environment:

              URL=192.168.50.42
              ServerKeyFile=/etc/ssl/private/journal-upload.pem
              ServerCertificateFile=/etc/ssl/certs/journal-upload.pem
              TrustedCertificateFile=/etc/ssl/ca/trusted.pem
            Restart the service:

            # systemctl restart systemd-journal-upload
        scored: false

      - id: 5.1.2.1.3
        description: "Ensure systemd-journal-remote is enabled (Manual)"
        type: manual
        audit: "systemctl is-enabled systemd-journal-upload.service"
        remediation: |
          Run the following command to enable systemd-journal-remote:

          # systemctl --now enable systemd-journal-upload.service
        scored: false

      - id: 5.1.2.1.4
        description: "Ensure journald is not configured to receive logs from a remote client (Automated)"
        audit: |
          systemctl is-enabled systemd-journal-remote.socket
        tests:
          test_items:
            - flag: "masked"
              set: true
        remediation: |
          Run the following command to disable systemd-journal-remote.socket:

          # systemctl --now mask systemd-journal-remote.socket
        scored: true
      - id: 5.1.2.2
        description: "Ensure journald service is enabled (Automated)"
        audit: "systemctl is-enabled systemd-journald.service"
        tests:
          test_items:
            - flag: "static"
              set: true
        remediation: |
          By default the systemd-journald service does not have an [Install] section and thus cannot be enabled / disabled. It is meant to be referenced as Requires or Wants by other unit files. As such, if the status of systemd-journald is not static, investigate why.
        scored: true

      - id: 5.1.2.3
        description: "Ensure journald is configured to compress large log files (Automated)"
        audit: |
          grep -E ^\s*Compress /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "yes"
              set: true
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:

          Compress=yes
          Restart the service:

          # systemctl restart systemd-journald.service
        scored: true

      - id: 5.1.2.4
        description: "Ensure journald is configured to write logfiles to persistent disk (Automated)"
        audit: |
          grep -E ^\s*Storage /etc/systemd/journald.conf
        tests:
          test_items:
            - flag: "persistent"
              set: true
        remediation: |
          Edit the /etc/systemd/journald.conf file and add the following line:

            Storage=persistent
          Restart the service:

            # systemctl restart systemd-journald.service
        scored: true

      - id: 5.1.2.5
        description: "Ensure journald is not configured to send logs to rsyslog (Manual)"
        type: manual
        audit: |
          grep ^\s*ForwardToSyslog /etc/systemd/journald.conf
        remediation: |
          Edit the /etc/systemd/journald.conf file and ensure that ForwardToSyslog=yes is removed.

          Restart the service:

          # systemctl restart systemd-journald.service
        scored: false

      - id: 5.1.2.6
        description: "Ensure journald log rotation is configured per site policy (Manual)"
        type: manual
        remediation: |
          Review /etc/systemd/journald.conf and verify logs are rotated according to site policy. The settings should be carefully understood as there are specific edge cases and prioritization of parameters.
          The specific parameters for log rotation are:
            SystemMaxUse=
            SystemKeepFree=
            RuntimeMaxUse=
            RuntimeKeepFree=
            MaxFileSec=
        scored: false

      - id: 5.1.2.7
        description: "Ensure journald default file permissions configured (Manual)"
        type: manual
        remediation: |
          If the default configuration is not appropriate for the site specific requirements, copy /usr/lib/tmpfiles.d/systemd.conf to /etc/tmpfiles.d/systemd.conf and modify as required. Requirements is either 0640 or site policy if that is less restrictive.
        scored: false

      - id: 5.1.3
        description: "Ensure all logfiles have appropriate permissions and ownership (Automated)"
        audit: |
          find /var/log -type f -exec stat --format '%n %U %G %a' {} \; | while read -r file owner group perms; do
          if [[ "$perms" =~ ^[0-7]{3}$ ]]; then
          if [[ "$perms" -gt 640 ]] || [[ "$owner" != "root" && "$owner" != "syslog" ]] || [[ "$group" != "adm" && "$group" != "root" ]]; then
          echo "⚠️  $file has insecure permission or ownership => $perms $owner:$group"
          fi
          fi
          done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the remediation script provided in the benchmark to fix incorrect permissions and ownerships.
          Ensure critical log files under /var/log have:
            - Secure file permissions (e.g., 640 or more restrictive)
            - Owned by root or relevant system users
            - Belonging to adm, root, or appropriate system group

          You may also need to update log service configuration for logs stored outside /var/log.
        scored: true

  - id: 5.2
    description: "Configure System Accounting (auditd)"
    checks:
      - id: 5.2.1
        description: "Ensure auditing is enabled"
        type: "skip"
        checks:
      - id: 5.2.1.1
        description: "Ensure auditd is installed (Automated)"
        audit: "rpm -q audit"
        tests:
          test_items:
            - flag: "package audit is not installed"
              set: false
        remediation: |
            Install the audit package if it is not already installed:

            # dnf install audit
        scored: true

      - id: 5.2.1.2
        description: "Ensure auditing for processes that start prior to auditd is enabled (Automated)"
        audit: |
          grubby --info=ALL | grep -Po '\baudit=1\b'
        tests:
          test_items:
            - flag: "audit=1"
              set: true
        remediation: |
          Run the following command to update the grub2 configuration with audit=1:

          # grubby --update-kernel ALL --args 'audit=1'
        scored: true

      - id: 5.2.1.3
        description: "Ensure audit_backlog_limit is sufficient (Automated)"
        audit: |
          grubby --info=ALL | grep -Po '\baudit_backlog_limit=\K\d+' | awk '{ if ($1 >= 8192) { print "PASS" } else { print "FAIL" } }'
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          Run the following command to add audit_backlog_limit=<BACKLOG SIZE> to GRUB_CMDLINE_LINUX:

          # grubby --update-kernel ALL --args 'audit_backlog_limit=<BACKLOG SIZE>'
          Example:

            # grubby --update-kernel ALL --args 'audit_backlog_limit=8192'
        scored: true

      - id: 5.2.1.4
        description: "Ensure auditd service is enabled (Automated)"
        audit: |
          systemctl is-enabled auditd
        tests:
          test_items:
            - flag: "enabled"
              set: true
        remediation: |
          Run the following command to enable auditd:

          # systemctl --now enable auditd
        scored: true

      - id: 5.2.2
        description: "Configure Data Retention"
        type: "skip"
        checks:
      - id: 5.2.2.1
        description: "Ensure audit log storage size is configured (Automated)"
        audit: |
          grep -P '^\s*max_log_file\s*=\s*\d+' /etc/audit/auditd.conf
        tests:
          test_items:
            - flag: "max_log_file"
              compare:
                op: gt
                value: 0
        remediation: |
          Edit the file `/etc/audit/auditd.conf` and set the `max_log_file` parameter
          according to your site's policy. The value is specified in megabytes (MB).

          Example:
          max_log_file = 100

          After modifying the file, restart the audit daemon:

          systemctl restart auditd
        scored: true

      - id: 5.2.2.2
        description: "Ensure audit logs are not automatically deleted (Automated)"
        audit: |
          grep max_log_file_action /etc/audit/auditd.conf
        tests:
          test_items:
            - flag: "keep_logs"
              set: true
        remediation: |
          Set the following parameter in /etc/audit/auditd.conf:

          max_log_file_action = keep_logs
        scored: true

      - id: 5.2.2.3
        description: "Ensure system is disabled when audit logs are full (Automated)"
        audit: |
          result=0

          space_left=$(grep -E '^\s*space_left_action\s*=\s*email\b' /etc/audit/auditd.conf)
          mail_acct=$(grep -E '^\s*action_mail_acct\s*=\s*root\b' /etc/audit/auditd.conf)
          admin_action=$(grep -E '^\s*admin_space_left_action\s*=\s*(halt|single)\b' /etc/audit/auditd.conf)

          [ -z "$space_left" ] && echo "FAIL: space_left_action is not set to email" && result=1
          [ -z "$mail_acct" ] && echo "FAIL: action_mail_acct is not set to root" && result=1
          [ -z "$admin_action" ] && echo "FAIL: admin_space_left_action is not set to halt or single" && result=1

          [ "$result" -eq 0 ] && echo "PASS" || echo "FAIL"
        tests:
          test_items:
            - flag: "PASS"
              set: true
        remediation: |
          Edit `/etc/audit/auditd.conf` and set the following parameters:

          ```
          space_left_action = email
          action_mail_acct = root
          admin_space_left_action = halt
          ```

          Or use `single` instead of `halt` if required:
          ```
          admin_space_left_action = single
          ```

          After changes, restart the auditd service:
          ```
          systemctl restart auditd
          ```
        scored: true


      - id: 5.2.3
        description: "Configure auditd rules"
        type: "skip"
        checks:
      - id: 5.2.3.1
        description: "Ensure changes to system administration scope (sudoers) is collected (Automated)"
        audit: |
          awk '/^ *-w/ \
          && /\/etc\/sudoers/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules

          awk '/^ *-w/ \
          && /\/etc\/sudoers.d/ \
          && / +-p *wa/ \
          && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
        tests:
          test_items:
            - flag: "-w /etc/sudoers -p wa -k scope"
              compare:
                op: has
                value: "scope"
        remediation: |
          echo "[+] Adding sudoers scope monitoring rules..."
          printf "
          -w /etc/sudoers -p wa -k scope
          -w /etc/sudoers.d -p wa -k scope
          " >> /etc/audit/rules.d/50-scope.rules

              echo "[ ✓ ] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to fully enforce the new audit rules."
          fi
        scored: true


      - id: 5.2.3.2
        description: "Ensure actions as another user are always logged (Automated)"
        audit: |
          awk '/^ *-a *always,exit/ \
          && / -F *arch=b(32|64)/ \
          && (/ -F *auid!=unset/ || / -F *auid!=-1/ || / -F *auid!=4294967295/) \
          && (/ -C *euid!=uid/ || / -C *uid!=euid/) \
          && / -S *execve/ \
          && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
        tests:
          test_items:
            - flag: "-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation"
              compare:
                op: has
                value: "user_emulation"
        remediation: |
          echo "[+] Adding user emulation audit rule..."
          printf "
          -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
          " >> /etc/audit/rules.d/50-user_emulation.rules

              echo "[ ✓ ] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to fully enforce the new audit rules."
          fi
        scored: true


      - id: 5.2.3.3
        description: "Ensure events that modify the sudo log file are collected (Automated)"
        audit: |
          SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//' -e 's/,.*//' -e 's/\"//g')

          if [ -n "$SUDO_LOG_FILE" ]; then
            awk "/^ *-w/ && /$SUDO_LOG_FILE/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules
          else
            echo "ERROR: Could not determine sudo log file from sudoers config."
          fi
        tests:
          test_items:
            - flag: "-w /var/log/sudo.log -p wa -k sudo_log_file"
              compare:
                op: has
                value: "/var/log/sudo.log"
        remediation: |
          echo "[+] Adding sudo log audit rule..."
          SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//' -e 's/,.*//' -e 's/\"//g')

          if [ -n "$SUDO_LOG_FILE" ]; then
            echo "-w $SUDO_LOG_FILE -p wa -k sudo_log_file" >> /etc/audit/rules.d/50-sudo.rules
          else
            echo "ERROR: SUDO_LOG_FILE not found, skipping rule addition."
          fi

          echo "[✓] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
            echo "Reboot required to apply sudo log audit rules completely."
          fi
        scored: true

      - id: 5.2.3.4
        description: "Ensure events that modify date and time information are collected (Automated)"
        audit: |
          awk '/^ *-a *always,exit/ \
            &&/ -F *arch=b(32|64)/ \
            &&/ -S/ \
            &&(/adjtimex/ || /settimeofday/ || /clock_settime/ ) \
            &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules

          awk '/^ *-w/ && /\/etc\/localtime/ && / +-p *wa/ && (/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
        tests:
          test_items:
            - flag: "-S adjtimex,settimeofday,clock_settime"
              compare:
                op: has
                value: "settimeofday"
            - flag: "-w /etc/localtime -p wa -k time-change"
              compare:
                op: has
                value: "/etc/localtime"
        remediation: |
          echo "[+] Writing audit rules for time-change events..."
          cat << 'EOF' > /etc/audit/rules.d/50-time-change.rules
          -a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
          -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change
          -w /etc/localtime -p wa -k time-change
          EOF

          echo "[✓] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to apply time-change audit rules completely."
          fi
        scored: true


      - id: 5.2.3.5
        description: "Ensure events that modify the system's network environment are collected (Automated)"
        audit: |
          awk '/^ *-a *always,exit/ \
            &&/ -F *arch=b(32|64)/ \
            &&/ -S/ \
            &&(/sethostname/ || /setdomainname/) \
            &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules

          awk '/^ *-w/ \
            &&(/\/etc\/issue/ \
              ||/\/etc\/issue.net/ \
              ||/\/etc\/hosts/ \
              ||/\/etc\/sysconfig\/network/) \
            &&/ +-p *wa/ \
            &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules
        tests:
          test_items:
            - flag: "-S sethostname,setdomainname"
              set: true
            - flag: "-w /etc/hosts -p wa -k system-locale"
              compare:
                op: has
                value: "/etc/hosts"
        remediation: |
          echo "[+] Writing audit rules for system-locale (network-related changes)..."
          cat << 'EOF' > /etc/audit/rules.d/50-system_local.rules
          -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
          -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
          -w /etc/issue -p wa -k system-locale
          -w /etc/issue.net -p wa -k system-locale
          -w /etc/hosts -p wa -k system-locale
          -w /etc/sysconfig/network -p wa -k system-locale
          -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
          EOF

          echo "[✓] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
          echo "Reboot required to apply system-locale audit rules completely."
          fi
        scored: true


      - id: 5.2.3.6
        description: "Ensure use of privileged commands are collected (Automated)"
        audit: |
          for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ {print $2}' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
            for PRIVILEGED in $(find "${PARTITION}" -xdev -perm /6000 -type f); do
              grep -qr "${PRIVILEGED}" /etc/audit/rules.d \
              && echo "OK: '${PRIVILEGED}' found in audit rules." \
              || echo "Warning: '${PRIVILEGED}' not found in audit rules."
            done
          done
        tests:
          test_items:
            - flag: "OK:"
              set: true
        remediation: |
          echo "[+] Adding privileged command audit rules..."
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          AUDIT_RULE_FILE="/etc/audit/rules.d/50-privileged.rules"
          NEW_DATA=()
          for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid" | awk '{print $1}'); do
            readarray -t DATA < <(find "${PARTITION}" -xdev -perm /6000 -type f | awk -v UID_MIN=${UID_MIN} '{print "-a always,exit -F path=" $1 " -F perm=x -F auid>="UID_MIN" -F auid!=unset -k privileged"}')
            for ENTRY in "${DATA[@]}"; do
              NEW_DATA+=("${ENTRY}")
            done
          done
          readarray -t OLD_DATA < "${AUDIT_RULE_FILE}" 2>/dev/null || OLD_DATA=()
          COMBINED_DATA=( "${OLD_DATA[@]}" "${NEW_DATA[@]}" )
          printf '%s\n' "${COMBINED_DATA[@]}" | sort -u > "${AUDIT_RULE_FILE}"

          echo "[✓] Reloading audit rules..."
          augenrules --load

          echo "[?] Reboot check..."
          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then
            echo "Reboot required to fully apply privileged command audit rules."
          fi
        scored: true


      - id: 5.2.3.7
        description: "Ensure unsuccessful file access attempts are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "${UID_MIN}" ]; then
            awk "/^ *-a *always,exit/ \
              &&/ -F *arch=b[2346]{2}/ \
              &&(/ -F *auid!=unset/ || / -F *auid!=-1/ || / -F *auid!=4294967295/) \
              &&/ -F *auid>=${UID_MIN}/ \
              &&(/ -F *exit=-EACCES/ || / -F *exit=-EPERM/) \
              &&/ -S/ \
              &&/creat|open|openat|truncate|ftruncate/ \
              &&(/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)" /etc/audit/rules.d/*.rules | grep -q "access" \
              && echo "unsuccessful_file_access_rules_present" \
              || echo "unsuccessful_file_access_rules_missing"
          else
            echo "UID_MIN_not_found"
          fi
        tests:
          test_items:
            - flag: "unsuccessful_file_access_rules_present"
              set: true
        remediation: |
          Set audit rules for unsuccessful file access attempts:
          Run:

            UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
            if [ -n "${UID_MIN}" ]; then
              printf "
              -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
              -a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=${UID_MIN} -F auid!=unset -k access
              -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access
              -a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM  -F auid>=${UID_MIN} -F auid!=unset -k access
              " >> /etc/audit/rules.d/50-access.rules
            fi

          Reload the audit rules:
            # augenrules --load

          Check if reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.8
        description: "Ensure events that modify user/group information are collected (Automated)"
        audit: |
          if awk '/^ *-w/ \
            &&(/\/etc\/group/ || /\/etc\/passwd/ || /\/etc\/gshadow/ || /\/etc\/shadow/ || /\/etc\/security\/opasswd/) \
            &&/ +-p *wa/ \
            &&(/ key= *[!-~]* *$/ || / -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules | grep -q "identity"; then
              echo "identity_rules_present"
          else
              echo "identity_rules_missing"
          fi
        tests:
          test_items:
            - flag: "identity_rules_present"
              set: true
        remediation: |
          Add the following lines to /etc/audit/rules.d/50-identity.rules:

            -w /etc/group -p wa -k identity
            -w /etc/passwd -p wa -k identity
            -w /etc/gshadow -p wa -k identity
            -w /etc/shadow -p wa -k identity
            -w /etc/security/opasswd -p wa -k identity

          Then reload audit rules:
            # augenrules --load

          Optionally, verify if a reboot is needed:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.9
        description: "Ensure discretionary access control permission modification events are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "$UID_MIN" ]; then
            awk "/^-a always,exit/ \
              && /-F arch=b(32|64)/ \
              && /-F auid>=$UID_MIN/ \
              && (/auid!=unset/ || /auid!=-1/ || /auid!=4294967295/) \
              && /-S/ \
              && (/chmod/ || /fchmod/ || /fchmodat/ || /chown/ || /fchown/ || /fchownat/ || /lchown/ || /setxattr/ || /lsetxattr/ || /fsetxattr/ || /removexattr/ || /lremovexattr/ || /fremovexattr/) \
              && (/ key= *[!-~]*$/ || / -k *[!-~]*$/)" /etc/audit/rules.d/*.rules | grep -q "perm_mod" && echo "perm_mod_rules_present" || echo "perm_mod_rules_missing"
          else
            echo "UID_MIN not set in /etc/login.defs"
          fi
        tests:
          test_items:
            - flag: "perm_mod_rules_present"
              set: true
        remediation: |
          Add the following lines to a file like /etc/audit/rules.d/50-perm_mod.rules:

            -a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b32 -S chown,fchown,lchown,fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod
            -a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod

          Then reload the audit rules:
            # augenrules --load

          Optionally check if a reboot is needed:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.10
        description: "Ensure successful file system mounts are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "$UID_MIN" ]; then
            RULES=$(awk "/^-a always,exit/ && /-F arch=b(32|64)/ && /-S mount/ && /-F auid>=$UID_MIN/ && (/auid!=unset/ || /auid!=-1/ || /auid!=4294967295/) && /-k mounts/" /etc/audit/rules.d/*.rules || true)
            if echo "$RULES" | grep -q "mount"; then
              echo "mount_audit_rules_present"
            else
              echo "mount_audit_rules_missing"
            fi
          else
            echo "UID_MIN not set in /etc/login.defs"
          fi
        tests:
          test_items:
            - flag: "mount_audit_rules_present"
              set: true
        remediation: |
          Add the following lines to a rules file, such as /etc/audit/rules.d/50-mounts.rules:

            -a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=unset -k mounts
            -a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=unset -k mounts

          Then reload the audit rules:
            # augenrules --load

          Optionally check if a reboot is needed:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.11
        description: "Ensure session initiation information is collected (Automated)"
        audit: |
          RULE1=$(grep -P -- "^-w\s+/var/run/utmp\s+-p\s+wa\s+-k\s+session" /etc/audit/rules.d/*.rules || true)
          RULE2=$(grep -P -- "^-w\s+/var/log/wtmp\s+-p\s+wa\s+-k\s+session" /etc/audit/rules.d/*.rules || true)
          RULE3=$(grep -P -- "^-w\s+/var/log/btmp\s+-p\s+wa\s+-k\s+session" /etc/audit/rules.d/*.rules || true)

          if [ -n "$RULE1" ] && [ -n "$RULE2" ] && [ -n "$RULE3" ]; then
            echo "session_audit_rules_present"
          else
            echo "session_audit_rules_missing"
          fi
        tests:
          test_items:
            - flag: "session_audit_rules_present"
              set: true
        remediation: |
          Create or edit the audit rules file `/etc/audit/rules.d/50-session.rules` and add the following lines:
            -w /var/run/utmp -p wa -k session
            -w /var/log/wtmp -p wa -k session
            -w /var/log/btmp -p wa -k session

          Then load the rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.12
        description: "Ensure login and logout events are collected (Automated)"
        audit: |
          RULE1=$(grep -P -- "^-w\s+/var/log/lastlog\s+-p\s+wa\s+-k\s+logins" /etc/audit/rules.d/*.rules || true)
          RULE2=$(grep -P -- "^-w\s+/var/run/faillock\s+-p\s+wa\s+-k\s+logins" /etc/audit/rules.d/*.rules || true)

          if [ -n "$RULE1" ] && [ -n "$RULE2" ]; then
            echo "login_logout_audit_rules_present"
          else
            echo "login_logout_audit_rules_missing"
          fi
        tests:
          test_items:
            - flag: "login_logout_audit_rules_present"
              set: true
        remediation: |
          Create or edit the audit rules file `/etc/audit/rules.d/50-login.rules` and add the following lines:
            -w /var/log/lastlog -p wa -k logins
            -w /var/run/faillock -p wa -k logins

          Then load the rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.13
        description: "Ensure file deletion events by users are collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
          if [ -n "$UID_MIN" ]; then
            RULE_B64=$(grep -P -- "^-a always,exit\s+-F arch=b64\s+-S (rename|unlink|unlinkat|renameat)\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-F key=delete" /etc/audit/rules.d/*.rules || true)
            RULE_B32=$(grep -P -- "^-a always,exit\s+-F arch=b32\s+-S (rename|unlink|unlinkat|renameat)\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-F key=delete" /etc/audit/rules.d/*.rules || true)

            if [ -n "$RULE_B64" ] && [ -n "$RULE_B32" ]; then
              echo "file_deletion_audit_rules_present"
            else
              echo "file_deletion_audit_rules_missing"
            fi
          else
            echo "ERROR: UID_MIN is unset"
          fi
        tests:
          test_items:
            - flag: "file_deletion_audit_rules_present"
              set: true
        remediation: |
          Determine the minimum user ID for regular users:
            # UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)

          Create or edit `/etc/audit/rules.d/50-delete.rules` and add the following lines:
            -a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=$UID_MIN -F auid!=unset -F key=delete
            -a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=$UID_MIN -F auid!=unset -F key=delete

          Then reload the audit rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.14
        description: "Ensure events that modify the system's Mandatory Access Controls are collected (Automated)"
        audit: |
          ETC_SELINUX=$(grep -P -- '^\s*-w\s+/etc/selinux\s+-p\s+wa\s+(-k\s+MAC-policy|key=MAC-policy)' /etc/audit/rules.d/*.rules || true)
          SHARE_SELINUX=$(grep -P -- '^\s*-w\s+/usr/share/selinux\s+-p\s+wa\s+(-k\s+MAC-policy|key=MAC-policy)' /etc/audit/rules.d/*.rules || true)

          if [ -n "$ETC_SELINUX" ] && [ -n "$SHARE_SELINUX" ]; then
            echo "selinux_mac_policy_audit_rules_present"
          else
            echo "mac_policy_audit_rules_missing"
          fi
        tests:
          test_items:
            - flag: "selinux_mac_policy_audit_rules_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-MAC-policy.rules` and add the following lines:

            -w /etc/selinux -p wa -k MAC-policy
            -w /usr/share/selinux -p wa -k MAC-policy

          Then reload the audit rules:
            # augenrules --load

          Optionally, check if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.15
        description: "Ensure successful and unsuccessful attempts to use the chcon command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/chcon\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k perm_chng" /etc/audit/rules.d/*.rules; then
              echo "chcon_audit_rule_present"
            else
              echo "chcon_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "chcon_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-perm_chng.rules` and add the following line:

            -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.16
        description: "Ensure successful and unsuccessful attempts to use the setfacl command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/setfacl\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k perm_chng" /etc/audit/rules.d/*.rules; then
              echo "setfacl_audit_rule_present"
            else
              echo "setfacl_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "setfacl_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-perm_chng.rules` and add the following line:

            -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.17
        description: "Ensure successful and unsuccessful attempts to use the chacl command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/chacl\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k perm_chng" /etc/audit/rules.d/*.rules; then
              echo "chacl_audit_rule_present"
            else
              echo "chacl_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "chacl_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-perm_chng.rules` and add the following line:

            -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true


      - id: 5.2.3.18
        description: "Ensure successful and unsuccessful attempts to use the usermod command are recorded (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/sbin/usermod\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k usermod" /etc/audit/rules.d/*.rules; then
              echo "usermod_audit_rule_present"
            else
              echo "usermod_audit_rule_missing"
            fi
          else
            echo "uid_min_unset"
          fi
        tests:
          test_items:
            - flag: "usermod_audit_rule_present"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-usermod.rules` and add the following line:

            -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -k usermod

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true

      - id: 5.2.3.19
        description: "Ensure kernel module loading, unloading and modification is collected (Automated)"
        audit: |
          UID_MIN=$(awk '/^\s*UID_MIN/ {print $2}' /etc/login.defs)

          if grep -Pq -- '^-a always,exit\s+-F arch=b64\s+-S (init_module|finit_module|delete_module|create_module|query_module)\s+-F auid>=[0-9]+\s+-F auid!=unset\s+-k kernel_modules' /etc/audit/rules.d/*.rules; then
            echo "kernel_module_syscalls_collected"
          else
            echo "kernel_module_syscalls_missing"
          fi

          if [ -n "$UID_MIN" ]; then
            if grep -Pq -- "^-a always,exit\s+-F path=/usr/bin/kmod\s+-F perm=x\s+-F auid>=$UID_MIN\s+-F auid!=unset\s+-k kernel_modules" /etc/audit/rules.d/*.rules; then
              echo "kmod_exec_audited"
            else
              echo "kmod_exec_audit_missing"
            fi
          else
            echo "uid_min_unset"
          fi

          BAD_LINKS=$(ls -l /usr/sbin/{lsmod,rmmod,insmod,modinfo,modprobe,depmod} 2>/dev/null | grep -v "-> ../bin/kmod" || true)
          if [[ -z "$BAD_LINKS" ]]; then
            echo "kmod_symlinks_valid"
          else
            echo "kmod_symlinks_invalid"
          fi
        tests:
          test_items:
            - flag: "kernel_module_syscalls_collected"
              set: true
            - flag: "kmod_exec_audited"
              set: true
            - flag: "kmod_symlinks_valid"
              set: true
        remediation: |
          Create or edit the file `/etc/audit/rules.d/50-kernel_modules.rules` and add the following:

            -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=1000 -F auid!=unset -k kernel_modules
            -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -k kernel_modules

          Then reload the audit rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi

          Ensure all symlinks point correctly:
            All of /usr/sbin/lsmod, rmmod, insmod, modinfo, modprobe, and depmod should symlink to ../bin/kmod

            # ls -l /usr/sbin/{lsmod,rmmod,insmod,modinfo,modprobe,depmod}
        scored: true


      - id: 5.2.3.20
        description: "Ensure the audit configuration is immutable (Automated)"
        audit: |
          if grep -Ph -- '^\h*-e\h+2\b' /etc/audit/rules.d/*.rules | grep -q -- '-e 2'; then
            echo "audit_config_immutable"
          else
            echo "immutable_setting_missing"
          fi
        tests:
          test_items:
            - flag: "audit_config_immutable"
              set: true
        remediation: |
          Edit or create the file /etc/audit/rules.d/99-finalize.rules and add the line:
            -e 2

          Then reload the rules:
            # augenrules --load

          Optionally, verify if a reboot is required:
            # if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then printf "Reboot required to load rules\n"; fi
        scored: true


      - id: 5.2.3.21
        description: "Ensure the running and on disk configuration is the same (Manual)"
        type: manual
        audit: |
          gaugenrules --check
        remediation: |
          If the rules are not aligned across all three () areas, run the following command to merge and load all rules:

          # augenrules --load
          Check if reboot is required.

          if [[ $(auditctl -s | grep "enabled") =~ "2" ]]; then echo "Reboot required to load rules"; fi
        scored: true

      - id: 5.2.4
        description: "Configure auditd file access"
        type: "skip"
        checks:
      - id: 5.2.4.1
        description: "Ensure audit log files are mode 0640 or less permissive (Automated)"
        audit: |
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            find "$log_dir" -type f \
            \( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \) \
          -exec echo "bad_perms_found: {}" \;
          fi
        tests:
          test_items:
            - flag: bad_perms_found
              set: false
        remediation: |
          Run the following command to fix permissions of audit log files:

          ```sh
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            find "$log_dir" -type f \
              \( ! -perm 600 -a ! -perm 0400 -a ! -perm 0200 -a ! -perm 0000 -a ! -perm 0640 -a ! -perm 0440 -a ! -perm 0040 \) \
              -exec chmod u-x,g-wx,o-rwx {} +
          fi
          ```

          This ensures audit log files are readable and/or writable only by authorized users/groups.
        scored: true

      - id: 5.2.4.2
        description: "Ensure only authorized users own audit log files (Automated)"
        audit: |
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            find "$log_dir" -type f ! -user root -exec echo "bad_owner_found: {}" \;
          fi
        tests:
          test_items:
            - flag: bad_owner_found
              set: false
        remediation: |
          Run the following command to configure the audit log files to be owned by the root user:

          [ -f /etc/audit/auditd.conf ] && find "$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))" -type f ! -user root -exec chown root {} +
        scored: true

      - id: 5.2.4.3
        description: "Ensure only authorized groups are assigned ownership of audit log files (Automated)"
        audit: |
          grep -Piw -- '^\h*log_group\h*=\h*(adm|root)\b' /etc/audit/auditd.conf || echo "invalid_log_group_found"
          if [ -f /etc/audit/auditd.conf ]; then
            log_dir=$(dirname $(awk -F "=" '/^\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))
            stat -c "%n %G" "$log_dir"/* | grep -Pv '^\h*\H+\h+(adm|root)\b' && echo "bad_group_owner_found"
          fi
        tests:
          test_items:
            - flag: invalid_log_group_found
              set: false
            - flag: bad_group_owner_found
              set: false
        remediation: |
          1. Update audit log files group ownership:
             find $(dirname $(awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf | xargs)) -type f \( ! -group adm -a ! -group root \) -exec chgrp adm {} +

          2. Update audit log directory group:
             chgrp adm /var/log/audit/

          3. Set the correct group in audit config:
             sed -ri 's/^\s*#?\s*log_group\s*=\s*\S+(\s*#.*)?.*$/log_group = adm\1/' /etc/audit/auditd.conf

          4. Restart auditd to apply:
             systemctl restart auditd
        scored: true

      - id: 5.2.4.4
        description: "Ensure the audit log directory is 0750 or more restrictive (Automated)"
        audit: |
          if [ -f /etc/audit/auditd.conf ]; then
            audit_dir=$(dirname $(awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf | xargs))
            stat -Lc "%n %a" "$audit_dir" | grep -Pv -- '^\h*\H+\h+([0,5,7][0,5]0)' && echo "audit_dir_perm_weak"
          fi
        tests:
          test_items:
            - flag: audit_dir_perm_weak
              set: false
        remediation: |
          Run the following command to fix directory permissions:

            chmod g-w,o-rwx "$(dirname $( awk -F"=" '/^\s*log_file\s*=\s*/ {print $2}' /etc/audit/auditd.conf))"

          This ensures the audit directory is set to 0750 or stricter to prevent unauthorized access.
        scored: true

      - id: 5.2.4.5
        description: "Ensure audit configuration files are 640 or more restrictive (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) \
          -exec stat -Lc "%n %a" {} + | \
          grep -Pv -- '^\h*\H+\h*([0,2,4,6][0,4]0)\h*$' && echo "audit_config_perms_weak"
        tests:
          test_items:
            - flag: audit_config_perms_weak
              set: false
        remediation: |
          Run the following command to correct the file permissions:

            find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) -exec chmod u-x,g-wx,o-rwx {} +

          This ensures all audit configuration files are set to **0640 or stricter**, protecting audit rules from unauthorized access or tampering.
        scored: true


      - id: 5.2.4.6
        description: "Ensure audit configuration files are owned by root (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root && echo "audit_config_not_owned_by_root"
        tests:
          test_items:
            - flag: audit_config_not_owned_by_root
              set: false
        remediation: |
          Run the following command to change the ownership of audit configuration files to the root user:

            find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -user root -exec chown root {} +

          This ensures audit configurations are protected from unauthorized modification.
        scored: true


      - id: 5.2.4.7
        description: "Ensure audit configuration files belong to group root (Automated)"
        audit: |
          find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root && echo "audit_config_wrong_group"
        tests:
          test_items:
            - flag: audit_config_wrong_group
              set: false
        remediation: |
          Run the following command to change the group ownership of audit configuration files to root:

            find /etc/audit/ -type f \( -name '*.conf' -o -name '*.rules' \) ! -group root -exec chgrp root {} +

          This ensures only authorized groups can modify critical audit configurations.
        scored: true

      - id: 5.2.4.8
        description: "Ensure audit tools are 755 or more restrictive (Automated)"
        audit: |
          stat -c "%n %a" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules 2>/dev/null | \
          grep -Pv -- '^\h*\H+\h+([0-7][0,1,4,5][0,1,4,5])\h*$' && echo "audit_tools_bad_perms"
        tests:
          test_items:
            - flag: audit_tools_bad_perms
              set: false
        remediation: |
          Run the following command to correct the permissions of audit tools:

            chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules

          This ensures only authorized users can modify or execute audit utilities.
        scored: true

      - id: 5.2.4.9
        description: "Ensure audit tools are owned by root (Automated)"
        audit: |
          audit_tools=(/sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules)
          incorrect_ownership_found=false

          for tool in "${audit_tools[@]}"; do
            if [ -e "$tool" ]; then
              owner=$(stat -c '%U' "$tool")
              if [ "$owner" != "root" ]; then
                echo "$tool is not owned by root"
                incorrect_ownership_found=true
              fi
            else
              echo "$tool not found"
            fi
          done

          if ! $incorrect_ownership_found; then
            echo "audit_tools_owned_by_root"
          fi
        tests:
          test_items:
            - flag: "audit_tools_owned_by_root"
              compare:
                op: has
                value: "audit_tools_owned_by_root"
        remediation: |
          Run the following command to ensure audit tools are owned by root:
          # chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
        scored: true


      - id: 5.2.4.10
        description: "Ensure audit tools belong to group root (Automated)"
        audit: |
          stat -c "%n %a %U %G" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules 2>/dev/null | \
          grep -Pv -- '^\h*\H+\h+([0-7][0,1,4,5][0,1,4,5])\h+root\h+root\h*$' && echo "audit_tools_wrong_group"
        tests:
          test_items:
            - flag: audit_tools_wrong_group
              set: false
        remediation: |
          Run the following commands to correct group and permissions of audit tools:

            chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules
            chown root:root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules

          This ensures audit tools are owned and grouped under root with restrictive access.
        scored: true

      - id: 5.3
        description: "Ensure logrotate is configured (Manual)"
        type: manual
        remediation: |
          Edit /etc/logrotate.conf and /etc/logrotate.d/* to ensure logs are rotated according to site policy.
        scored: false

  - id: 6
    description: "System Maintenance"
    checks:
  - id: 6.1
    description: "System File Permissions"
    checks:
      - id: 6.1.1
        description: "Ensure permissions on /etc/passwd are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/passwd
        tests:
          test_items:
            - flag: "/etc/passwd"
              compare:
                op: bitmask
                value: "644"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/passwd:

          # chmod u-x,go-wx /etc/passwd
          # chown root:root /etc/passwd
        scored: true

      - id: 6.1.2
        description: "Ensure permissions on /etc/passwd are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/passwd
        tests:
          test_items:
            - flag: "/etc/passwd"
              compare:
                op: bitmask
                value: "644"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/passwd:

          # chmod u-x,go-wx /etc/passwd
          # chown root:root /etc/passwd
        scored: true

      - id: 6.1.3
        description: "Ensure permissions on /etc/passwd- are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/passwd-
        tests:
          test_items:
            - flag: "/etc/passwd-"
              compare:
                op: bitmask
                value: "644"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/passwd-:

          # chmod u-x,go-wx /etc/passwd-
          # chown root:root /etc/passwd-
        scored: true

      - id: 6.1.4
        description: "Ensure permissions on /etc/group are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/group
        tests:
          test_items:
            - flag: "/etc/group"
              compare:
                op: bitmask
                value: "644"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group:

          # chmod u-x,go-wx /etc/group
          # chown root:root /etc/group
        scored: true

      - id: 6.1.5
        description: "Ensure permissions on /etc/group- are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/group-
        tests:
          test_items:
            - flag: "/etc/group-"
              compare:
                op: bitmask
                value: "644"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to remove excess permissions, set owner, and set group on /etc/group-:

          # chmod u-x,go-wx /etc/group-
          # chown root:root /etc/group-
        scored: true

      - id: 6.1.6
        description: "Ensure permissions on /etc/shadow are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/shadow
        tests:
          test_items:
            - flag: "/etc/shadow"
              compare:
                op: bitmask
                value: "000"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow:

          # chown root:root /etc/shadow
          # chmod 0000 /etc/shadow
        scored: true

      - id: 6.1.7
        description: "Ensure permissions on /etc/shadow- are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/shadow-
        tests:
          test_items:
            - flag: "/etc/shadow-"
              compare:
                op: bitmask
                value: "000"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow-:

          # chown root:root /etc/shadow-
          # chmod 0000 /etc/shadow-
        scored: true

      - id: 6.1.8
        description: "Ensure permissions on /etc/gshadow are configured (Automated)"
        audit: |
          stat -Lc "%n %a %u/%U %g/%G" /etc/gshadow
        tests:
          test_items:
            - flag: "/etc/gshadow"
              compare:
                op: bitmask
                value: "000"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to set mode, owner, and group on /etc/shadow-:

          # chown root:root /etc/gshadow
          # chmod 0000 /etc/gshadow
        scored: true

      - id: 6.1.9
        description: "Ensure permissions on /etc/gshadow- are configured (Automated)"
        audit: |
          if [ -e /etc/gshadow- ]; then
            stat -Lc "%n %a %u/%U %g/%G" /etc/gshadow-
          else
            echo "/etc/gshadow- file does not exist"
          fi
        tests:
          test_items:
            - flag: "/etc/gshadow-"
              compare:
                op: bitmask
                value: "000"
            - flag: "0/root 0/root"
              compare:
                op: has
                value: "0/root 0/root"
        remediation: |
          Run the following commands to set the correct permissions, owner, and group on /etc/gshadow-:

            # chown root:root /etc/gshadow-
            # chmod 0000 /etc/gshadow-
        scored: true


      - id: 6.1.10
        description: "Audit system file permissions (Manual)"
        type: manual
        remediation: |
          Correct any discrepancies found and rerun the audit until output is clean or risk is mitigated or accepted.
        scored: false

      - id: 6.1.11
        description: "Ensure world writable files and directories are secured (Automated)"
        audit: |
          world_files=$(find / -xdev -type f -perm -0002 \
            ! -path "/proc/*" ! -path "/sys/*" ! -path "/dev/*" \
            ! -path "/run/user/*" ! -path "/var/lib/containerd/*" \
            ! -path "/var/lib/kubelet/pods/*" 2>/dev/null)

          if [ -z "$world_files" ]; then
            echo "no_world_writable_files: true"
          else
            echo "no_world_writable_files: false"
            echo "$world_files"
          fi

          world_dirs=$(find / -xdev -type d -perm -0002 \
            ! -path "/proc/*" ! -path "/sys/*" ! -path "/dev/*" \
            ! -path "/run/user/*" ! -path "/var/lib/containerd/*" \
            ! -path "/var/lib/kubelet/pods/*" \
            -exec stat -c "%n %A" {} + 2>/dev/null | awk '$2 !~ /t/')

          if [ -z "$world_dirs" ]; then
            echo "no_non_sticky_dirs: true"
          else
            echo "no_non_sticky_dirs: false"
            echo "$world_dirs"
          fi
        tests:
          test_items:
            - flag: "no_world_writable_files"
              compare:
                op: eq
                value: true
            - flag: "no_non_sticky_dirs"
              compare:
                op: eq
                value: true
        remediation: |
          # Fix world-writable files
          find / -xdev -type f -perm -0002 \
            ! -path "/proc/*" ! -path "/sys/*" ! -path "/dev/*" \
            -exec chmod o-w {} + 2>/dev/null

          # Fix world-writable dirs missing sticky bit
          find / -xdev -type d -perm -0002 \
            ! -path "/proc/*" ! -path "/sys/*" ! -path "/dev/*" \
            -exec stat -c "%n %A" {} + 2>/dev/null | awk '$2 !~ /t/ {print $1}' | xargs -r chmod +t
        scored: true

      - id: 6.1.12
        description: "Ensure no unowned or ungrouped files or directories exist (Automated)"
        audit: |
          unowned_files=$(find / -xdev \( -nouser -o -nogroup \) \
            ! -path "/proc/*" \
            ! -path "/sys/*" \
            ! -path "/dev/*" \
            ! -path "/run/user/*" \
            ! -path "/var/lib/containerd/*" \
            ! -path "/var/lib/kubelet/pods/*" 2>/dev/null)

          has_nouser=false
          has_nogroup=false

          for file in $unowned_files; do
            user=$(stat -c %U "$file" 2>/dev/null)
            group=$(stat -c %G "$file" 2>/dev/null)

            if [ "$user" = "UNKNOWN" ]; then
              has_nouser=true
            fi

            if [ "$group" = "UNKNOWN" ]; then
              has_nogroup=true
            fi
          done

          if [ "$has_nouser" = false ]; then
            echo "no_unowned_files: true"
          else
            echo "no_unowned_files: false"
          fi

          if [ "$has_nogroup" = false ]; then
            echo "no_ungrouped_files: true"
          else
            echo "no_ungrouped_files: false"
          fi
        tests:
          test_items:
            - flag: "no_unowned_files"
              compare:
                op: eq
                value: true
            - flag: "no_ungrouped_files"
              compare:
                op: eq
                value: true
        remediation: |
          # Fix unowned files
          find / -xdev -nouser -exec chown root {} + 2>/dev/null

          # Fix ungrouped files
          find / -xdev -nogroup -exec chgrp root {} + 2>/dev/null
        scored: true


      - id: 6.1.13
        description: "Ensure SUID and SGID files are reviewed (Automated)"
        audit: |
          suid_files=$(find / -xdev -type f -perm -4000 \
            ! -path "/proc/*" \
            ! -path "/sys/*" \
            ! -path "/dev/*" \
            ! -path "/run/user/*" \
            ! -path "/var/lib/containerd/*" \
            ! -path "/var/lib/kubelet/pods/*" 2>/dev/null)

          sgid_files=$(find / -xdev -type f -perm -2000 \
            ! -path "/proc/*" \
            ! -path "/sys/*" \
            ! -path "/dev/*" \
            ! -path "/run/user/*" \
            ! -path "/var/lib/containerd/*" \
            ! -path "/var/lib/kubelet/pods/*" 2>/dev/null)

          if [ -z "$suid_files" ]; then
            echo "no_suid_files: true"
          else
            echo "no_suid_files: false"
            echo "suid_files:"
            echo "$suid_files"
          fi

          if [ -z "$sgid_files" ]; then
            echo "no_sgid_files: true"
          else
            echo "no_sgid_files: false"
            echo "sgid_files:"
            echo "$sgid_files"
          fi
        tests:
          test_items:
            - flag: "no_suid_files"
              compare:
                op: eq
                value: true
            - flag: "no_sgid_files"
              compare:
                op: eq
                value: true
        remediation: |
          # Review the listed SUID and SGID files.
          # Confirm they are legitimate by checking their source package (e.g., rpm -V or debsums)
          # Remove or correct any suspicious binaries:

          # Example:
          # chmod u-s /path/to/unexpected-suid-file
          # chmod g-s /path/to/unexpected-sgid-file

          # Or restore from trusted packages.
        scored: true

  - id: 6.2
    description: "Local User and Group Settings"
    checks:
      - id: 6.2.1
        description: "Ensure accounts in /etc/passwd use shadowed passwords (Automated)"
        audit: |
          awk -F: '($2 != "x" ) { print $1 " is not set to shadowed passwords "}' /etc/passwd
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Run the following command to set accounts to use shadowed passwords:

          # sed -e 's/^\([a-zA-Z0-9_]*\):[^:]*:/\1:x:/' -i /etc/passwd
            Investigate to determine if the account is logged in and what it is being used for, to determine if it needs to be forced off.
        scored: true
      - id: 6.2.2
        description: "Ensure /etc/shadow password fields are not empty (Automated)"
        audit: |
          awk -F: '($2 == "" ) { print $1 " does not have a password "}' /etc/shadow
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          If any accounts in the /etc/shadow file do not have a password, run the following command to lock the account until it can be determined why it does not have a password:

          # passwd -l <username>
            Also, check to see if the account is logged in and investigate what it is being used for to determine if it needs to be forced off.
        scored: true


      - id: 6.2.3
        description: "Ensure all groups in /etc/passwd exist in /etc/group (Automated)"
        audit: |
          for i in $(cut -s -d: -f4 /etc/passwd | sort -u ); do
            grep -q -P "^.*?:[^:]*:$i:" /etc/group
            if [ $? -ne 0 ]; then
              echo "Group $i is referenced by /etc/passwd but does not exist in /etc/group"
            fi
          done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Analyze the output of the Audit step above and perform the appropriate action to correct any discrepancies found.
        scored: true

      - id: 6.2.4
        description: "Ensure no duplicate UIDs exist (Automated)"
        audit: |
          cut -f3 -d":" /etc/passwd | sort -n | uniq -c | while read x ; do
            [ -z "$x" ] && break
            set - $x
            if [ $1 -gt 1 ]; then
            users=$(awk -F: '($3 == n) { print $1 }' n=$2 /etc/passwd | xargs)
            echo "Duplicate UID ($2): $users"
            fi
          done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique UIDs and review all files owned by the shared UIDs to determine which UID they are supposed to belong to.
        scored: true

      - id: 6.2.5
        description: "Ensure no duplicate GIDs exist (Automated)"
        audit: |
          cut -d: -f3 /etc/group | sort | uniq -d | while read x ; do
            echo "Duplicate GID ($x) in /etc/group"
          done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique GIDs and review all files owned by the shared GID to determine which group they are supposed to belong to.
        scored: true

      - id: 6.2.6
        description: "Ensure no duplicate user names exist (Automated)"
        audit: |
          cut -d: -f1 /etc/passwd | sort | uniq -d | while read -r x; do
            echo "Duplicate login name $x in /etc/passwd"
          done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique user names for the users. File ownerships will automatically reflect the change as long as the users have unique UIDs.
        scored: true

      - id: 6.2.7
        description: "Ensure no duplicate group names exist (Automated)"
        audit: |
          cut -d: -f1 /etc/group | sort | uniq -d | while read -r x; do
            echo "Duplicate group name $x in /etc/group"
          done
        tests:
          test_items:
            - flag: ""
              compare:
                op: eq
                value: ""
        remediation: |
          Based on the results of the audit script, establish unique names for the user groups. File group ownerships will automatically reflect the change as long as the groups have unique GIDs.
        scored: true

      - id: 6.2.8
        description: "Ensure root PATH Integrity (Automated)"
        audit: |
          RPCV="$(sudo -Hiu root env | grep '^PATH' | cut -d= -f2)"
          path_safe=true

          echo "$RPCV" | grep -q "::" && echo "path_has_empty_entry: true" && path_safe=false
          echo "$RPCV" | grep -q ":$" && echo "path_has_trailing_colon: true" && path_safe=false

          for x in $(echo "$RPCV" | tr ":" " "); do
            if [ "$x" = "." ]; then
              echo "path_contains_dot: true"
              path_safe=false
              continue
            fi

            if [ -d "$x" ]; then
              owner=$(stat -Lc '%U' "$x")
              perms=$(stat -Lc '%A' "$x")
              group_write=$(echo "$perms" | cut -c6)
              other_write=$(echo "$perms" | cut -c9)

              [ "$owner" != "root" ] && echo "non_root_owned_dir: $x" && path_safe=false
              [ "$group_write" != "-" ] && echo "group_writable_dir: $x" && path_safe=false
              [ "$other_write" != "-" ] && echo "world_writable_dir: $x" && path_safe=false
            else
              echo "path_not_directory: $x"
              path_safe=false
            fi
          done

          $path_safe && echo "root_path_integrity: pass"
        tests:
          test_items:
            - flag: "root_path_integrity"
              set: true
        remediation: |
          Correct the root PATH variable in /etc/environment, /etc/profile, /root/.bash_profile, or other shell init files.
          - Remove empty (::) or trailing (:) entries.
          - Avoid including '.' in PATH.
          - Ensure all directories in PATH:
            - Exist
            - Are owned by root
            - Are not group- or world-writable

          Example:
          # chmod go-w /path/to/dir
          # chown root:root /path/to/dir
        scored: true

      - id: 6.2.9
        description: "Ensure root is the only UID 0 account (Automated)"
        audit: |
          awk -F: '($3 == 0) { print $1 }' /etc/passwd
        tests:
          test_items:
            - flag: "root"
              compare:
                op: eq
                value: "root"
        remediation: |
          Remove any users other than root with UID 0 or assign them a new UID if appropriate.
        scored: true

      - id: 6.2.10
        description: "Ensure local interactive user home directories are configured (Automated)"
        audit: |
          {
            l_output="" l_output2="" l_heout2="" l_hoout2="" l_haout2=""
            l_valid_shells="^($(awk -F/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' -))$"
            unset a_uarr && a_uarr=()
            while read -r l_epu l_eph; do
            a_uarr+=("$l_epu $l_eph")
            done <<< "$(awk -F: -v pat="$l_valid_shells" '($NF ~ pat) { print $1, $(NF-1) }' /etc/passwd)"

            for entry in "${a_uarr[@]}"; do
            l_user=$(echo "$entry" | awk '{print $1}')
            l_home=$(echo "$entry" | awk '{print $2}')
            if [ -d "$l_home" ]; then
            l_mask='0027'
            l_max="$(printf '%o' $((0777 & ~$l_mask)))"
            read -r l_own l_mode <<< "$(stat -Lc '%U %a' "$l_home")"
            [ "$l_user" != "$l_own" ] && l_hoout2="$l_hoout2\n  - User: \"$l_user\" Home \"$l_home\" is owned by: \"$l_own\""
            if [ $((10#$l_mode & 10#$l_mask)) -gt 0 ]; then
            l_haout2="$l_haout2\n  - User: \"$l_user\" Home \"$l_home\" is mode: \"$l_mode\" should be mode: \"$l_max\" or more restrictive"
            fi
            else
            l_heout2="$l_heout2\n  - User: \"$l_user\" Home \"$l_home\" doesn't exist"
            fi
            done

            [ -z "$l_heout2" ] && l_output="$l_output\n   - home directories exist" || l_output2="$l_output2$l_heout2"
            [ -z "$l_hoout2" ] && l_output="$l_output\n   - own their home directory" || l_output2="$l_output2$l_hoout2"
            [ -z "$l_haout2" ] && l_output="$l_output\n   - home directories are mode: \"$l_max\" or more restrictive" || l_output2="$l_output2$l_haout2"
            [ -n "$l_output" ] && l_output="  - All local interactive users:$l_output"

            if [ -z "$l_output2" ]; then
            echo -e "\n- Audit Result:\n  ** PASS **\n - * Correctly configured * :\n$l_output"
            else
            echo -e "\n- Audit Result:\n  ** FAIL **\n - * Reasons for audit failure * :\n$l_output2"
            [ -n "$l_output" ] && echo -e "\n- * Correctly configured * :\n$l_output"
            fi
          }
        tests:
          test_items:
            - flag: "home directories exist"
              compare:
                op: has
                value: "home directories exist"
            - flag: "own their home directory"
              compare:
                op: has
                value: "own their home directory"
            - flag: "home directories are mode"
              compare:
                op: has
                value: "home directories are mode"
        remediation: |
          #!/usr/bin/env bash
          {
            l_output2=""
            l_valid_shells="^($( awk -F\/ '$NF != \"nologin\" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
            unset a_uarr && a_uarr=()
            while read -r l_epu l_eph; do
              a_uarr+=("$l_epu $l_eph")
            done <<< "$(awk -v pat=\"$l_valid_shells\" -F: '$(NF) ~ pat { print $1 \" \" $(NF-1) }' /etc/passwd)"
            for entry in "${a_uarr[@]}"; do
              l_user=$(echo "$entry" | awk '{print $1}')
              l_home=$(echo "$entry" | awk '{print $2}')
              if [ -d "$l_home" ]; then
                l_mask='0027'
                l_max="$( printf '%o' $(( 0777 & ~$l_mask)) )"
                while read -r l_own l_mode; do
                  if [ "$l_user" != "$l_own" ]; then
                    chown "$l_user" "$l_home"
                  fi
                  if [ $(( $l_mode & $l_mask )) -gt 0 ]; then
                    chmod g-w,o-rwx "$l_home"
                  fi
                done <<< "$(stat -Lc '%U %#a' "$l_home")"
              else
                echo "Home directory $l_home for user $l_user does not exist. Please create it or remove the user."
              fi
            done
          }
        scored: true

      - id: 6.2.11
        description: "Ensure local interactive user dot files access is configured (Automated)"
        audit: |
          {
            l_output="" l_output2="" l_output3="" l_output4=""
            l_bf="" l_df="" l_nf="" l_hf=""

            # Build valid shell regex pattern excluding nologin
            l_valid_shells="^($(awk -F/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\/,g;p}' | paste -s -d '|' -))$"

            unset a_uarr
            a_uarr=()

            while read -r l_epu l_eph; do
            [[ -n "$l_epu" && -n "$l_eph" ]] && a_uarr+=("$l_epu $l_eph")
            done <<< "$(awk -v pat="$l_valid_shells" -F: '($NF ~ pat) { print $1 " " $(NF-1) }' /etc/passwd)"

            file_access_chk() {
            l_facout2=""
            l_max=$(printf '%o' $((0777 & ~$l_mask)))
            if [ $((l_mode & l_mask)) -gt 0 ]; then
            l_facout2="$l_facout2\n  - File: \"$l_hdfile\" is mode: \"$l_mode\" and should be mode: \"$l_max\" or more restrictive"
            fi
            if [[ ! "$l_owner" =~ ($l_user) ]]; then
            l_facout2="$l_facout2\n  - File: \"$l_hdfile\" owned by: \"$l_owner\" and should be owned by \"${l_user//|/ or }\""
            fi
            if [[ ! "$l_gowner" =~ ($l_group) ]]; then
            l_facout2="$l_facout2\n  - File: \"$l_hdfile\" group owned by: \"$l_gowner\" and should be group owned by \"${l_group//|/ or }\""
            fi
          }

          while read -r l_user l_home; do
            l_fe="" l_nout2="" l_nout3="" l_dfout2="" l_hdout2="" l_bhout2=""
            if [ -d "$l_home" ]; then
            l_group=$(id -gn "$l_user" | xargs)
            l_group="${l_group// /|}"
            while IFS= read -r -d $'\0' l_hdfile; do
            while read -r l_mode l_owner l_gowner; do
            case "$(basename "$l_hdfile")" in
            .forward | .rhost )
            l_fe="Y" && l_bf="Y"
            l_dfout2="$l_dfout2\n  - File: \"$l_hdfile\" exists"
            ;;
            .netrc )
            l_mask='0177'
            file_access_chk
            if [ -n "$l_facout2" ]; then
            l_fe="Y" && l_nf="Y"
            l_nout2="$l_facout2"
            else
            l_nout3="   - File: \"$l_hdfile\" exists"
            fi
            ;;
            .bash_history )
            l_mask='0177'
            file_access_chk
            if [ -n "$l_facout2" ]; then
            l_fe="Y" && l_hf="Y"
            l_bhout2="$l_facout2"
            fi
            ;;
            * )
            l_mask='0133'
            file_access_chk
            if [ -n "$l_facout2" ]; then
            l_fe="Y" && l_df="Y"
            l_hdout2="$l_facout2"
            fi
            ;;
            esac
            done <<< "$(stat -Lc '%#a %U %G' "$l_hdfile")"
            done < <(find "$l_home" -xdev -type f -name '.*' -print0)
            fi
            if [ "$l_fe" = "Y" ]; then
            l_output2="$l_output2\n - User: \"$l_user\" Home Directory: \"$l_home\""
            [ -n "$l_dfout2" ] && l_output2="$l_output2$l_dfout2"
            [ -n "$l_nout2" ] && l_output2="$l_output2$l_nout2"
            [ -n "$l_bhout2" ] && l_output2="$l_output2$l_bhout2"
            [ -n "$l_hdout2" ] && l_output2="$l_output2$l_hdout2"
            fi
            [ -n "$l_nout3" ] && l_output3="$l_output3\n  - User: \"$l_user\" Home Directory: \"$l_home\"\n$l_nout3"
            done <<< "$(printf '%s\n' "${a_uarr[@]}")"

            [ -n "$l_output3" ] && l_output3=" - ** Warning **\n - \".netrc\" files should be removed unless deemed necessary\n   and in accordance with local site policy:$l_output3"
            [ -z "$l_bf" ] && l_output="$l_output\n   - \".forward\" or \".rhost\" files"
            [ -z "$l_nf" ] && l_output="$l_output\n   - \".netrc\" files with incorrect access configured"
            [ -z "$l_hf" ] && l_output="$l_output\n   - \".bash_history\" files with incorrect access configured"
            [ -z "$l_df" ] && l_output="$l_output\n   - \"dot\" files with incorrect access configured"
            [ -n "$l_output" ] && l_output="  - No local interactive users home directories contain:$l_output"

            if [ -z "$l_output2" ]; then
            echo -e "\n- Audit Result:\n  ** PASS **\n - * Correctly configured * :\n$l_output\n"
            echo -e "$l_output3\n"
            else
            echo -e "\n- Audit Result:\n  ** FAIL **\n - * Reasons for audit failure * :\n$l_output2\n"
            echo -e "$l_output3\n"
            [ -n "$l_output" ] && echo -e "- * Correctly configured * :\n$l_output\n"
            fi
          }
        tests:
          test_items:
            - flag: ".forward"
              compare:
                op: nothave
                value: "exists"
            - flag: ".netrc"
              compare:
                op: nothave
                value: "incorrect access"
            - flag: ".bash_history"
              compare:
                op: nothave
                value: "incorrect access"
        remediation: "Manual remediation steps should be applied per-user based on audit findings."
        scored: true
